<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【译】Boost Smooth Scrolling with iOS 10 Pre-Fetching API</title>
      <link href="/2023/08/30/Boost%20Smooth%20Scrolling%20with%20iOS%2010%20Pre-Fetching%20API/"/>
      <url>/2023/08/30/Boost%20Smooth%20Scrolling%20with%20iOS%2010%20Pre-Fetching%20API/</url>
      
        <content type="html"><![CDATA[<img src="/2023/08/30/Boost%20Smooth%20Scrolling%20with%20iOS%2010%20Pre-Fetching%20API/prefetch.png" class="&#x3D;"><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="https://jackwchen2015.github.io/2023/08/29/Smooth%20Scrolling%20in%20UITableView%20and%20UICollectionView/#more">之前</a>的一篇文章中，我们探讨了在iOS手机应用中实现流畅滚动的一些常见策略。应用这些策略的主要目标是避免起伏滚动(choppy scrolling)，这是一个对用户体验产生负面影响的常见问题。为了帮助开发者完成这样的任务，苹果在<code>iOS10</code>中对<code>UICollectionView</code>做了一些非常有用的改变。但是在回顾这个新引入的功能之前，让我们先看看是什么促使了对它们的需求。</p><h2 id="是什么导致滚动出现起伏"><a href="#是什么导致滚动出现起伏" class="headerlink" title="是什么导致滚动出现起伏?"></a>是什么导致滚动出现起伏?</h2><p>你是否曾经接触过或开发过偶尔出现起伏不平的应用?如果答案是肯定的，那么你就会知道当你尝试快速滚动时，应用程序的内容似乎是断断续续的(stutter)，这是多么令人失望。你可能会问自己，是什么引发了这种起伏不定的滚动行为，以及随之而来的糟糕的用户体验。</p><p><strong>简短的回答是:该应用正在掉帧。但这到底是什么意思呢?</strong></p><p>为了确保持续流畅的滚动，应用程序需要能够稳定地显示<code>60 FPS</code>(帧每秒)。或者，换句话说，应用程序需要每秒刷新60次内容。这意味着每一帧大约有<code>16ms</code>的渲染时间(<code>1000ms/60frames ~ 16ms/frame</code>)。在不幸的情况下，显示一帧的时间超过了规定的时间，没有显示下一帧的数据，这被认为是应用程序“丢失了一帧”。这个不幸的场景如下图所示。蓝色标记表示绘图操作，其粗细(thickness)表示完成渲染所需的时间。正如我们所看到的，在第二帧中，我们有一些渲染事件花费的时间超过了分配的时间(约16ms)，因此，第三帧被丢弃了。</p><img src="/2023/08/30/Boost%20Smooth%20Scrolling%20with%20iOS%2010%20Pre-Fetching%20API/dropframe.png" class="&#x3D;" title="Dropped Frame"><p>我们可以从刷新操作所花费的<code>CPU时间</code>的角度来可视化相同的场景。在下面的图表中，峰值对应于当应用程序花费超过预期的<code>16毫秒</code>来刷新当前内容时出现的丢弃帧。</p><img src="/2023/08/30/Boost%20Smooth%20Scrolling%20with%20iOS%2010%20Pre-Fetching%20API/displayRefreshes.png" class="&#x3D;" title="Display Refreshes"><p>为了获得良好的用户体验，刷新时间必须始终低于允许的最大值<code>~16ms</code>。理想情况下，当我们想要创造一个很棒的用户体验时(and not just a good one)，每次刷新时间应该是:</p><ul><li>始终远低于允许的最大时间(~16ms)。 </li><li>尽可能低，以节省CPU时间，这些时间可以用于其他任务。</li></ul><p>丢帧最常见的原因是从主线程为cell加载昂贵的数据模型。此场景的典型示例如下:</p><ul><li>从URL加载图像。 </li><li>从数据库或CoreData访问items。</li></ul><p>在<code>iOS10</code>中，苹果对单元格的加载和显示方式进行了一些优化。让我们来看看<code>iOS10</code>的改进，以及它们是如何让开发者更容易地创建流畅的滚动用户体验的。</p><h2 id="iOS9中的Cell生命周期"><a href="#iOS9中的Cell生命周期" class="headerlink" title="iOS9中的Cell生命周期"></a>iOS9中的Cell生命周期</h2><p><code>UICollectionViewCell</code>的生命周期可以可视化如下:</p><img src="/2023/08/30/Boost%20Smooth%20Scrolling%20with%20iOS%2010%20Pre-Fetching%20API/celllifecycle.png" class="&#x3D;" title="iOS9 cell lifecycle"><p>集合视图和它的单元格之间的主要交互是:</p><ul><li>集合视图正在请求将要显示的单元格的内容——单元格即将进入可见区域:<code>collectionView(_:cellForItemAt:)</code>。 </li><li>集合视图请求显示单元格——单元格刚刚进入可见区域:<code>collectionView(_:willDisplay:forItemAt:)</code>。 </li><li>收集视图正在删除单元格-单元格在可见区域之外:<code>collectionView(didenddisplay:forItemAt:)</code>。</li></ul><h2 id="iOS10中的Cell生命周期"><a href="#iOS10中的Cell生命周期" class="headerlink" title="iOS10中的Cell生命周期"></a>iOS10中的Cell生命周期</h2><p>在<code>iOS10</code>中，cell的生命周期与<code>iOS9</code>基本相同。然而，有一些显著的区别。 </p><p>第一个区别是操作系统调用<code>collectionView(_:cellForItemAt:)</code>比以前早得多。这意味着两件事: </p><ul><li>加载单元格的繁重工作可以在需要显示单元格之前完成。 </li><li>单元格可能最终根本不显示(因为它可能从未被带入可见区域)。</li></ul><p>第二个不同之处在于，当一个cell离开可见区域时会发生什么。在<code>iOS10</code>中，像往常一样调用<code>collectionView(didenddisplay:forItemAt:)</code>，但单元格不会立即回收。操作系统会保留它一段时间以防用户反转滚动方向;如果发生这种情况，单元格仍然可用，并且可以再次显示(将调用<code>collectionView(_:willDisplay:forItemAt:)</code>)，而不必重新加载其内容。</p><img src="/2023/08/30/Boost%20Smooth%20Scrolling%20with%20iOS%2010%20Pre-Fetching%20API/iOS10lifecycle.png" class="&#x3D;" title="iOS10 cell lifecycle changes"><p>将此与<code>iOS9</code>上的情况进行比较。您将注意到，对于这个特定的用例，不再需要重新加载单元格(<code>collectionView(_:cellForItemAt:)</code>)。这种优化允许我们在用户快速滚动和改变滚动方向时更快地渲染单元格。</p><p><code>iOS9</code>和<code>iOS10</code>之间的第三个重要区别是为多列布局的collection views加载单元格的方式。</p><img src="/2023/08/30/Boost%20Smooth%20Scrolling%20with%20iOS%2010%20Pre-Fetching%20API/iOS9MultiColumn.png" class="&#x3D;" title="iOS9"><img src="/2023/08/30/Boost%20Smooth%20Scrolling%20with%20iOS%2010%20Pre-Fetching%20API/iOS10MultiColumn.png" class="&#x3D;" title="iOS10"><p>在<code>iOS10</code>中，关于进入可见区域的每个单元格都是分开(separately)加载的(<code>collectionView(_:cellForItemAt:)</code>)。正如我们在审查(examining)cell生命周期时所看到的，这比实际需要显示每个cell的时间要早得多。这为优化打开了大门，因为操作系统将能够处理不同的请求，将它们与单元格的加载解耦(interleaving)。</p><p>当一行单元格(a row of cells)进入可见区域时，这些单元格将作为单个批处理(a single batch)显示(同时对整行调用<code>collectionView(_:willDisplay:forItemAt:)</code>)，因为此操作在CPU周期方面不是很昂贵(至少与加载单元格内容相比)。</p><p>加载多列布局的差异是<code>iOS10</code>最重要的<code>UICollectionView</code>优化的核心:预抓取(Pre-Fetching)。让我们更详细地探讨一下。</p><h2 id="预抓取API"><a href="#预抓取API" class="headerlink" title="预抓取API"></a>预抓取API</h2><p>在发布<code>iOS10</code>时，苹果将预抓取吹捧(touted)为一种自适应技术(Adaptive Technology)。这意味着<code>pre - fetching</code>将尝试利用用户与应用交互的方式来执行一些优化，以提高滚动性能。例如，这项新技术将寻找空闲时间(当用户缓慢滚动或根本不滚动时)来加载(Pre-Fetch)新的单元格。根据用户滚动模式(scrolling patterns)的不同，<code>Pre-Fetching</code>执行这种优化的机会可能更多(或更少)。</p><p>在查看可用的API之前，让我们看一下使用该技术的一些最佳实践。为了充分利用预抓取，设置单元格内容的主体(bulk)必须在<code>collectionView(_:cellForItemAt:)</code>中执行。在<code>collectionView(_:willDisplay:forItemAt:)</code>和<code>collectionView(didenddisplay:forItemAt:)</code>中执行的操作应该保持最小化，并且必须是非cpu密集型的(non-CPU intensive)。更好的是，如果我们可以对这些生命周期事件根本不执行任何操作，那将是最优的!另外，请记住，即使为单元格调用了<code>collectionView(_:cellForItemAt:)</code>，仍然有可能永远不会显示该单元格。</p><p>一些非常好的消息是，在<code>iOS10</code>上编译的应用程序默认启用预抓取。但是，可以通过将<code>UICollectionView</code>的<code>isPrefetchingEnabled</code>属性设置为<code>false</code>来关闭此功能。同样重要的是要注意，预取与单元格生命周期一起工作。这意味着我们为实现集合视图而编写的代码不需要修改——要充分利用预抓取功能，唯一需要做的就是实现预抓取<code>API</code>。</p><h2 id="预取API和UICollectionView"><a href="#预取API和UICollectionView" class="headerlink" title="预取API和UICollectionView"></a>预取API和UICollectionView</h2><p><code>UICollectionView</code>的预取<code>API</code>是在<code>uicollectionviewdatasourcepre</code>抓取协议中定义的。<code>API</code>定义了以下两个方法。</p><p><code>collectionView(_:prefetchItemsAt:) </code>(required) -该方法允许启动(initiate)<code>[IndexPath]</code>参数指定的单元格所需的数据的异步加载。异步加载既可以通过<code>Grand Central Dispatch</code>执行，也可以通过<code>OperationQueue</code>执行。在实现这些方法时，最重要的是编写代码，将数据加载的负担从主队列转移到后台队列。这样做的目的是减少主队列的工作负载，使其能够将大部分时间用于执行显示刷新等关键任务。</p><p><code>collectionView(_:cancelPrefetchingForItemsAt:)</code>(optional)-该方法通知(communicates)不再需要<code>[IndexPath]</code>参数指定的单元格的数据。实现这个方法允许我们根据需要取消挂起的数据加载，这是通过取消不必要的工作(通常是因为用户改变了滚动方向)来节省CPU时间的好方法。</p><p>如前所述，预取是一种自适应技术(Adaptive Technology)。因此，上述方法是基于用户与应用程序交互的方式触发的。这样做的一个后果是，可能不会对集合视图中的每个单元格都调用<code>collectionView(_:prefetchItemsAt:)</code>方法。这意味着，当通过<code>collectionView(_:cellForItemAt:)</code>加载单元格时，应用程序应该能够处理以下所有场景: </p><ul><li>数据已经预取完成，准备好了可以显示(The data has been pre-fetched and is ready to be displayed)。 </li><li>正在提取数据，未准备好显示数据(The data is currently being fetched and is not ready to be displayed)。 </li><li>数据还没被请求(The data has not been requested yet)。</li></ul><h2 id="预取API和UITableView"><a href="#预取API和UITableView" class="headerlink" title="预取API和UITableView"></a>预取API和UITableView</h2><p><code>iOS10</code>还为<code>UITableView</code>引入了<code>Pre-Fetching</code>功能。我们为<code>UICollectionView</code>演示的所有主要概念都以类似的方式应用于<code>UITableView</code>。<code>UITableView</code>的预取API在<code>UITableViewPrefetchingDataSource</code>协议中定义。<code>API</code>定义了以下两个方法。 </p><p><code>tableView(_:prefetchRowsAt:)</code> (required) -这个方法允许启动异步加载<code>[IndexPath]</code>参数指定的单元格所需的数据。 </p><p><code>tableView(_:cancelPrefetchingForRowsAt:)</code> (optional) -此方法通知不再需要<code>[IndexPath]</code>参数指定的单元格数据。 </p><p>为每个<code>UICollectionView</code>预取API方法提出的建议同样适用于每个<code>UITableView</code>预取API方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我已经更新了<code>UITableView</code>和<code>UICollectionView</code>的代码样本，以支持<code>iOS10</code>上的预抓取。你可以在<a href="https://github.com/andrea-prearo/SwiftExamples/tree/master/SmoothScrolling/Client">这里</a>找到。 </p><p>在这篇文章中，我们回顾了<code>iOS10</code>在提升<code>UICollectionView</code>和<code>UITableView</code>平滑滚动方面的改进。特别是，我们看到，通过实现特定的预取API，可以充分利用所有新的操作系统优化，并在与移动应用程序交互时提供最佳的用户体验。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://medium.com/capital-one-tech/boost-smooth-scrolling-with-ios-10-pre-fetching-api-818c25cd9c5d">Boost Smooth Scrolling with iOS 10 Pre-Fetching API</a></li><li><a href="">有道翻译</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【译】Smooth Scrolling in UITableView and UICollectionView</title>
      <link href="/2023/08/29/Smooth%20Scrolling%20in%20UITableView%20and%20UICollectionView/"/>
      <url>/2023/08/29/Smooth%20Scrolling%20in%20UITableView%20and%20UICollectionView/</url>
      
        <content type="html"><![CDATA[<img src="/2023/08/29/Smooth%20Scrolling%20in%20UITableView%20and%20UICollectionView/tableviewPreView.gif" class="&#x3D;"><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正如大多数iOS开发者所知，显示数据集是构建移动应用程序的一个相当常见的任务。苹果的SDK提供了两个组件来帮助完成这样的任务，而不必从头开始实现所有内容:一个表视图(<code>UITableView</code>)和一个集合视图(<code>UICollectionView</code>)。</p><p>表视图和集合视图都被设计为支持显示可滚动的数据集。然而，当显示大量数据时，实现完美的平滑滚动可能会非常棘手。这并不理想，因为它会对用户体验产生负面影响。</p><p>作为<code>Capital One Mobile</code>应用iOS开发团队的一员，我有机会尝试表格视图和集合视图;这篇文章反映了我个人在显示大量可滚动数据方面的经验。在本文中，我们将回顾优化上述SDK组件性能的最重要技巧。这一步对于实现流畅的滚动体验至关重要。请注意，下面的大多数要点都适用于<code>UITableView</code>和<code>UICollectionView</code>，因为它们共享了大量的“底层”行为。有几点是<code>UICollectionView</code>特有的，因为这个视图把额外的布局细节放在了开发人员的肩上。</p><p>让我们从快速概述上述组件开始。<br><code>UITableView</code>被优化为将视图显示为行序列。由于布局是预定义的，SDK组件负责大部分布局，并提供主要关注于显示单元格内容的委托。<br>另一方面，<code>UICollectionView</code>提供了最大的灵活性，因为布局是完全可定制的。然而，集合视图的灵活性是以必须考虑如何执行布局的额外细节为代价的。</p><h2 id="UITableView和UICollectionView的共同技巧"><a href="#UITableView和UICollectionView的共同技巧" class="headerlink" title="UITableView和UICollectionView的共同技巧"></a>UITableView和UICollectionView的共同技巧</h2><blockquote><p>我将使用UITableView作为我的代码片段。但同样的概念也适用于UICollectionView。</p></blockquote><h3 id="Cells渲染是一项关键任务"><a href="#Cells渲染是一项关键任务" class="headerlink" title="Cells渲染是一项关键任务"></a>Cells渲染是一项关键任务</h3><p><code>UITableView</code>和<code>UITableViewCell</code>之间的主要交互可以用以下事件来描述:</p><ul><li>表视图正在请求需要显示的单元格(<code>tableView(_:cellForRowAt:)</code>)。 </li><li>表视图即将显示单元格(<code>tableView(_:willDisplay:forRowAt:)</code>)。 </li><li>单元格已经从表视图中移除(<code>tableView(_: didenddisplay:forRowAt:)</code>)。</li></ul><p>对于上述所有事件，表视图将传递正在进行交互的index(row)。这是<code>UITableViewCell</code>生命周期的可视化:</p><img src="/2023/08/29/Smooth%20Scrolling%20in%20UITableView%20and%20UICollectionView/tableviewcell.png" class="&#x3D;"><p>首先，<code>tableView(_:cellForRowAt:)</code>方法应该尽可能快。每次需要显示单元格时调用此方法。它执行得越快，表视图的滚动就会越平滑。 </p><p>有一些事情我们可以做，以确保我们渲染cell尽可能快。下面是渲染单元格的基本代码，摘自苹果的文档:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">tableView</span>(<span class="keyword">_</span> <span class="params">tableView</span>: <span class="type">UITableView</span>, <span class="params">cellForRowAt</span> <span class="params">indexPath</span>: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="comment">// Table view cells are reused and should be dequeued using a cell identifier.</span></span><br><span class="line">    <span class="keyword">let</span> cell <span class="operator">=</span> tableView.dequeueReusableCell(withIdentifier: <span class="string">&quot;reuseIdentifier&quot;</span>, for: indexPath)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Configure the cell ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取即将被重用的单元格实例(<code>dequeueReusableCell(withIdentifier:for:)</code>)之后，我们需要通过为其属性分配所需的值来配置它。让我们看一下如何使代码快速执行。</p><h3 id="为单元格定义视图模型"><a href="#为单元格定义视图模型" class="headerlink" title="为单元格定义视图模型"></a>为单元格定义视图模型</h3><p>一种方法是让我们需要展示的所有属性都随时可用然后把它们分配给相应的单元格。为了实现这一点，我们可以利用<code>MVVM</code>模式。假设我们需要在表视图中显示一组用户。我们可以将用户模型定义为:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Role</span>: <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Unknown</span> <span class="operator">=</span> <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">User</span> <span class="operator">=</span> <span class="string">&quot;User&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Owner</span> <span class="operator">=</span> <span class="string">&quot;Owner&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Admin</span> <span class="operator">=</span> <span class="string">&quot;Admin&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">get</span>(<span class="params">from</span>: <span class="type">String</span>) -&gt; <span class="type">Role</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> from <span class="operator">==</span> <span class="type">User</span>.rawValue &#123;</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">User</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> from <span class="operator">==</span> <span class="type">Owner</span>.rawValue &#123;</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Owner</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> from <span class="operator">==</span> <span class="type">Admin</span>.rawValue &#123;</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Admin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> .<span class="type">Unknown</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> avatarUrl: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> username: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> role: <span class="type">Role</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">avatarUrl</span>: <span class="type">String</span>, <span class="params">username</span>: <span class="type">String</span>, <span class="params">role</span>: <span class="type">Role</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.avatarUrl <span class="operator">=</span> avatarUrl</span><br><span class="line">        <span class="keyword">self</span>.username <span class="operator">=</span> username</span><br><span class="line">        <span class="keyword">self</span>.role <span class="operator">=</span> role</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为用户定义视图模型很简单:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UserViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> avatarUrl: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> username: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> role: <span class="type">Role</span></span><br><span class="line">    <span class="keyword">let</span> roleText: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">user</span>: <span class="type">User</span>) &#123;</span><br><span class="line">        <span class="comment">// Avatar</span></span><br><span class="line">        avatarUrl <span class="operator">=</span> user.avatarUrl</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Username</span></span><br><span class="line">        username <span class="operator">=</span> user.username</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Role</span></span><br><span class="line">        role <span class="operator">=</span> user.role</span><br><span class="line">        roleText <span class="operator">=</span> user.role.rawValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步获取数据和缓存视图模型"><a href="#异步获取数据和缓存视图模型" class="headerlink" title="异步获取数据和缓存视图模型"></a>异步获取数据和缓存视图模型</h3><p>现在我们已经定义了模型和视图模型，让我们让它们工作吧!我们将通过web服务为用户获取数据。当然，我们希望实现最好的用户体验。因此，我们将关注以下方面:</p><ul><li>在获取数据时避免阻塞主线程。 </li><li>在检索数据后立即更新表视图。</li></ul><p>这意味着我们将异步获取数据。我们将通过一个特定的控制器来执行这个任务，以便将获取逻辑与模型和视图模型分开，如下所示:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserViewModelController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> viewModels: [<span class="type">UserViewModel</span>?] <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">retrieveUsers</span>(<span class="keyword">_</span> <span class="params">completionBlock</span>: <span class="keyword">@escaping</span> (<span class="keyword">_</span> success: <span class="type">Bool</span>, <span class="keyword">_</span> error: <span class="type">NSError</span>?) -&gt; ()) &#123;</span><br><span class="line">        <span class="keyword">let</span> urlString <span class="operator">=</span> <span class="operator">...</span> <span class="comment">// Users Web Service URL</span></span><br><span class="line">        <span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>.shared</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: urlString) <span class="keyword">else</span> &#123;</span><br><span class="line">            completionBlock(<span class="literal">false</span>, <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> task <span class="operator">=</span> session.dataTask(with: url) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> strongSelf <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> data <span class="operator">=</span> data <span class="keyword">else</span> &#123;</span><br><span class="line">                completionBlock(<span class="literal">false</span>, error <span class="keyword">as</span> <span class="type">NSError</span>?)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> error <span class="operator">=</span> <span class="operator">...</span> <span class="comment">// Define a NSError for failed parsing</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> jsonData <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">JSONSerialization</span>.jsonObject(with: data, options: .allowFragments) <span class="keyword">as?</span> [[<span class="type">String</span>: <span class="type">AnyObject</span>]] &#123;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> jsonData <span class="operator">=</span> jsonData <span class="keyword">else</span> &#123;</span><br><span class="line">                    completionBlock(<span class="literal">false</span>,  error)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> users <span class="operator">=</span> [<span class="type">User</span>?]()</span><br><span class="line">                <span class="keyword">for</span> json <span class="keyword">in</span> jsonData &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> user <span class="operator">=</span> <span class="type">UserViewModelController</span>.parse(json) &#123;</span><br><span class="line">                        users.append(user)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                strongSelf.viewModels <span class="operator">=</span> <span class="type">UserViewModelController</span>.initViewModels(users)</span><br><span class="line">                completionBlock(<span class="literal">true</span>, <span class="literal">nil</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                completionBlock(<span class="literal">false</span>, error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        task.resume()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> viewModelsCount: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> viewModels.count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">viewModel</span>(<span class="params">at</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">UserViewModel</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> index <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> index <span class="operator">&lt;</span> viewModelsCount <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> viewModels[index]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">extension</span> <span class="title class_">UserViewModelController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">parse</span>(<span class="keyword">_</span> <span class="params">json</span>: [<span class="params">String</span>: <span class="type">AnyObject</span>]) -&gt; <span class="type">User</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> avatarUrl <span class="operator">=</span> json[<span class="string">&quot;avatar&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span> <span class="operator">??</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">let</span> username <span class="operator">=</span> json[<span class="string">&quot;username&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span> <span class="operator">??</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">let</span> role <span class="operator">=</span> json[<span class="string">&quot;role&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span> <span class="operator">??</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">User</span>(avatarUrl: avatarUrl, username: username, role: <span class="type">Role</span>.get(from: role))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">initViewModels</span>(<span class="keyword">_</span> <span class="params">users</span>: [<span class="type">User</span>?]) -&gt; [<span class="type">UserViewModel</span>?] &#123;</span><br><span class="line">        <span class="keyword">return</span> users.map &#123; user <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> user <span class="operator">=</span> user &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="type">UserViewModel</span>(user: user)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以检索数据并异步更新表视图，如下面的代码片段所示:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewController</span>: <span class="title class_">UITableViewController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">let</span> userViewModelController <span class="operator">=</span> <span class="type">UserViewModelController</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        userViewModelController.retrieveUsers &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (success, error) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> strongSelf <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="operator">!</span>success &#123;</span><br><span class="line">                <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                    <span class="keyword">let</span> title <span class="operator">=</span> <span class="string">&quot;Error&quot;</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">                        strongSelf.showError(title, message: error.localizedDescription)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        strongSelf.showError(title, message: <span class="type">NSLocalizedString</span>(<span class="string">&quot;Can&#x27;t retrieve contacts.&quot;</span>, comment: <span class="string">&quot;The message displayed when contacts can’t be retrieved.&quot;</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                    strongSelf.tableView.reloadData()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="operator">...</span>]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用上面的代码片段以几种不同的方式获取用户数据: </p><ul><li>只有在第一次加载表视图时，通过将其放置在<code>viewDidLoad()</code>中。 </li><li>每次显示表视图时，通过将其放置在<code>viewWillAppear(_:)</code>中。 </li><li>根据用户需求(例如通过下拉刷新)，将其放置在负责刷新数据的方法调用中。</li></ul><p>选择取决于后端数据更改的频率。如果数据大部分是静态的或不经常更改，则第一种选择更好。否则，我们应该选择第二种。</p><h3 id="异步加载图像并缓存它们"><a href="#异步加载图像并缓存它们" class="headerlink" title="异步加载图像并缓存它们"></a>异步加载图像并缓存它们</h3><p>为单元格加载图像是很常见的。由于我们试图获得最佳的滚动性能，我们绝对不想阻塞主线程来获取图像。避免这种情况的一个简单方法是通过在<code>URLSession</code>周围创建一个简单的包装器来异步加载图像:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">UIImageView</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">downloadImageFromUrl</span>(<span class="keyword">_</span> <span class="params">url</span>: <span class="type">String</span>, <span class="params">defaultImage</span>: <span class="type">UIImage</span>? <span class="operator">=</span> <span class="type">UIImageView</span>.defaultAvatarImage()) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: url) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="type">URLSession</span>.shared.dataTask(with: url, completionHandler: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (data, response, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> httpURLResponse <span class="operator">=</span> response <span class="keyword">as?</span> <span class="type">NSHTTPURLResponse</span> <span class="keyword">where</span> httpURLResponse.statusCode <span class="operator">==</span> <span class="number">200</span>,</span><br><span class="line">                <span class="keyword">let</span> mimeType <span class="operator">=</span> response<span class="operator">?</span>.mimeType, mimeType.hasPrefix(<span class="string">&quot;image&quot;</span>),</span><br><span class="line">                <span class="keyword">let</span> data <span class="operator">=</span> data <span class="keyword">where</span> error <span class="operator">==</span> <span class="literal">nil</span>,</span><br><span class="line">                <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">UIImage</span>(data: data)</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).resume()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这让我们可以使用后台线程获取每个图像，然后在所需数据可用时更新UI。我们可以通过缓存图像进一步提高性能。 </p><p>如果我们不想——或者负担不起——自己编写自定义的异步图像下载和缓存，我们可以利用像<code>SDWebImage</code>或<code>AlamofireImage</code>这样的库。这些库提供了我们正在寻找的开箱即用的功能。</p><h3 id="自定义单元格"><a href="#自定义单元格" class="headerlink" title="自定义单元格"></a>自定义单元格</h3><p>为了充分利用缓存的视图模型，我们可以自定义用户单元格的子类(从<code>UITableViewCell</code>表视图和从<code>UICollectionViewCell</code>集合视图)。基本的方法是为需要显示的模型的每个属性创建一个出口，并从视图模型中初始化它:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserCell</span>: <span class="title class_">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> avatar: <span class="type">UIImageView</span>!</span><br><span class="line">    <span class="keyword">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> username: <span class="type">UILabel</span>!</span><br><span class="line">    <span class="keyword">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> role: <span class="type">UILabel</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">configure</span>(<span class="keyword">_</span> <span class="params">viewModel</span>: <span class="type">UserViewModel</span>) &#123;</span><br><span class="line">        avatar.downloadImageFromUrl(viewModel.avatarUrl)</span><br><span class="line">        username.text <span class="operator">=</span> viewModel.username</span><br><span class="line">        role.text <span class="operator">=</span> viewModel.roleText</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用不透明图层，避免渐变"><a href="#使用不透明图层，避免渐变" class="headerlink" title="使用不透明图层，避免渐变"></a>使用不透明图层，避免渐变</h3><p>由于使用透明层或应用渐变需要大量的计算，如果可能的话，我们应该避免使用它们来提高滚动性能。特别是，我们应该避免改变<code>alpha</code>值，最好使用标准的RGB颜色(避免<code>uiccolor .clear</code>)用于单元格和它包含的任何图像: </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserCell</span>: <span class="title class_">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> avatar: <span class="type">UIImageView</span>!</span><br><span class="line">    <span class="keyword">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> username: <span class="type">UILabel</span>!</span><br><span class="line">    <span class="keyword">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> role: <span class="type">UILabel</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">configure</span>(<span class="keyword">_</span> <span class="params">viewModel</span>: <span class="type">UserViewModel</span>) &#123;</span><br><span class="line">        setOpaqueBackground()</span><br><span class="line">        </span><br><span class="line">        [<span class="operator">...</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">extension</span> <span class="title class_">UserCell</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> defaultBackgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.groupTableViewBackgroundColor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setOpaqueBackground</span>() &#123;</span><br><span class="line">        alpha <span class="operator">=</span> <span class="number">1.0</span></span><br><span class="line">        backgroundColor <span class="operator">=</span> <span class="type">UserCell</span>.defaultBackgroundColor</span><br><span class="line">        avatar.alpha <span class="operator">=</span> <span class="number">1.0</span></span><br><span class="line">        avatar.backgroundColor <span class="operator">=</span> <span class="type">UserCell</span>.defaultBackgroundColor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="把一切放在一起-优化cell渲染"><a href="#把一切放在一起-优化cell渲染" class="headerlink" title="把一切放在一起:优化cell渲染"></a>把一切放在一起:优化cell渲染</h3><p>在这一点上，在渲染单元格的时候配置它应该很容易，而且非常快，因为:</p><ul><li>我们正在使用缓存的视图模型数据。 </li><li>我们正在异步获取图像。</li></ul><p>下面是更新后的代码:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">tableView</span>(<span class="keyword">_</span> <span class="params">tableView</span>: <span class="type">UITableView</span>, <span class="params">cellForRowAt</span> <span class="params">indexPath</span>: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cell <span class="operator">=</span> tableView.dequeueReusableCell(withIdentifier: <span class="string">&quot;UserCell&quot;</span>, for: indexPath) <span class="keyword">as!</span> <span class="type">UserCell</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> viewModel <span class="operator">=</span> userViewModelController.viewModel(at: (indexPath <span class="keyword">as</span> <span class="type">NSIndexPath</span>).row) &#123;</span><br><span class="line">        cell.configure(viewModel)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UITableView的特别技巧"><a href="#UITableView的特别技巧" class="headerlink" title="UITableView的特别技巧"></a>UITableView的特别技巧</h2><h3 id="对可变高度的单元格使用自调整大小-Self-Sizing-的单元格"><a href="#对可变高度的单元格使用自调整大小-Self-Sizing-的单元格" class="headerlink" title="对可变高度的单元格使用自调整大小(Self-Sizing)的单元格"></a>对可变高度的单元格使用自调整大小(Self-Sizing)的单元格</h3><p>如果我们想要在表格视图中显示的单元格具有可变高度，我们可以使用<code>self sizable cells</code>。基本上，我们应该创建适当的Auto Layout约束，以确保具有可变高度的UI组件能够正确拉伸。然后我们只需要初始化<code>estimatedRowHeight</code>和<code>rowHeight</code>属性:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">   [<span class="operator">...</span>]</span><br><span class="line">   tableView.estimatedRowHeight <span class="operator">=</span> <span class="operator">...</span> <span class="comment">// Estimated default row height</span></span><br><span class="line">   tableView.rowHeight <span class="operator">=</span> <span class="type">UITableViewAutomaticDimension</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主意：在不幸的情况下，我们不能使用<code>self-sizing cells</code>(例如，如果支持iOS7仍然是必需的)，我们必须实现<code>tableView(_:heightForRowAt:)</code>来计算每个单元格的高度。但是，仍然可以通过以下方式提高滚动性能:</p><ul><li>一次预先计算所有的行高。 </li><li>当<code>tableView(_:heightForRowAt:)</code>被调用时返回缓存的值。</li></ul><h2 id="UICollectionView的特别技巧"><a href="#UICollectionView的特别技巧" class="headerlink" title="UICollectionView的特别技巧"></a>UICollectionView的特别技巧</h2><p>通过实现适当的<code>UICollectionViewFlowLayoutDelegate</code>协议方法，我们可以轻松地定制大部分集合视图。</p><h3 id="计算单元格大小"><a href="#计算单元格大小" class="headerlink" title="计算单元格大小"></a>计算单元格大小</h3><p>我们可以通过实现<code>collectionView(_:layout:sizeForItemAt:)</code>来定制集合视图的单元格大小:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span>(collectionView:layout:sizeForItemAtIndexPath:)</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">collectionView</span>(<span class="keyword">_</span> <span class="params">collectionView</span>: <span class="type">UICollectionView</span>, <span class="params">layout</span> <span class="params">collectionViewLayout</span>: <span class="type">UICollectionViewLayout</span>, <span class="params">sizeForItemAt</span> <span class="params">indexPath</span>: <span class="type">IndexPath</span>) -&gt; <span class="type">CGSize</span></span><br><span class="line">    <span class="comment">// Calculate the appropriate cell size</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGSize</span>(width: <span class="operator">...</span>, height: <span class="operator">...</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理Size-Classes和Orientation的改变"><a href="#处理Size-Classes和Orientation的改变" class="headerlink" title="处理Size Classes和Orientation的改变"></a>处理Size Classes和Orientation的改变</h3><p>我们应该确保在以下情况下正确刷新集合视图布局:</p><ul><li>转换到不同的Size Class。 </li><li>旋转设备。</li></ul><p>这可以通过实现<code>viewWillTransition(to:with:)</code>来实现:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewWillTransition</span>(<span class="params">to</span> <span class="params">size</span>: <span class="type">CGSize</span>, <span class="params">with</span> <span class="params">coordinator</span>: <span class="type">UIViewControllerTransitionCoordinator</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewWillTransition(to: size, with: coordinator)</span><br><span class="line">    collectionView<span class="operator">?</span>.collectionViewLayout.invalidateLayout()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态调整单元格布局"><a href="#动态调整单元格布局" class="headerlink" title="动态调整单元格布局"></a>动态调整单元格布局</h3><p>如果我们需要动态调整单元格布局，我们应该通过在我们的自定义集合视图单元格(它是<code>UICollectionViewCell</code>的子类)中重写<code>apply(_:)</code>来处理这个问题:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="keyword">_</span> <span class="params">layoutAttributes</span>: <span class="type">UICollectionViewLayoutAttributes</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>.apply(layoutAttributes)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Customize the cell layout</span></span><br><span class="line">    [<span class="operator">...</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，在这个方法中执行的常见任务之一是通过编程设置其<code>preferredmaxlayoutidth</code>属性来调整多行<code>UILabel</code>的最大宽度:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="keyword">_</span> <span class="params">layoutAttributes</span>: <span class="type">UICollectionViewLayoutAttributes</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>.apply(layoutAttributes)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Customize the cell layout</span></span><br><span class="line">    <span class="keyword">let</span> width <span class="operator">=</span> layoutAttributes.frame.width</span><br><span class="line">    username.preferredMaxLayoutWidth <span class="operator">=</span> width <span class="operator">-</span> <span class="number">16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你可以在<a href="https://github.com/andrea-prearo/SwiftExamples/tree/master/SmoothScrolling/Client">这里</a>找到一个关于<code>uitableview</code>和<code>UICollectionView</code>建议技巧的小示例。 </p><p>在这篇文章中，我们研究了一些常见的技巧来实现<code>UITableView</code>和<code>UICollectionView</code>的平滑滚动。我们还介绍了一些适用于每种特定集合类型的特定技巧。根据特定的UI需求，可能有更好或不同的方法来优化集合类型。然而，这篇文章中描述的基本原则仍然适用。与往常一样，找出哪种优化最有效的最佳方法是分析你的应用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://medium.com/capital-one-developers/smooth-scrolling-in-uitableview-and-uicollectionview-a012045d77f">Smooth Scrolling in UITableView and UICollectionView</a></li><li><a href="">有道翻译</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>查理芒格的原则</title>
      <link href="/2023/06/11/%E8%8A%92%E6%A0%BC%E7%9A%84%E5%8E%9F%E5%88%99/"/>
      <url>/2023/06/11/%E8%8A%92%E6%A0%BC%E7%9A%84%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>小破站有个颜值很高的小姐姐（无处安放的小A），一个不错的读书圈栏目(小A的读书圈)，很合我的口味，所以这里是对她这系列读书分享视频的笔记</p><blockquote><p>学会独立思考 告别从众</p></blockquote><blockquote><p>投资本质上是考验一个人对社会以及自我认知的清晰程度，同时对心态进行不断磨练的过程</p></blockquote><span id="more"></span><h2 id="让问题简单化"><a href="#让问题简单化" class="headerlink" title="让问题简单化"></a>让问题简单化</h2><p>价值投资的核心就是要我们认清自己的能力边界，避免做那些拿不准或者可能导致犯错的决定</p><p><strong>格雷厄姆</strong>把价值投资体系故意设计成了在熊市的表现好于市场，而牛市要逊于市场，通过放弃牛市里一些好机会，从而在下跌时获得更好的回报，主动降低收益其实是为了控制风险，永远不去赚最后一枚硬币，能帮你免去不少麻烦</p><p>价值投资者追求的是绝对收益 而不是一个短期能拿出去招摇的战绩，为了长期获得好于大盘的回报 就要懂得接受短期业绩逊于大盘的过程，同时不去碰自己看不懂的东西</p><p>成功的价值投资者 只会等那些能轻松赚钱的机会才出手，因为市场不是完全有效的，它会时不时出现非理性恐慌，给出错误定价，这就是我们捡漏，获得超额回报的好机会。</p><p>先锋集团创始人约翰*博格也说过投资者得到的回报都是市场少收取的费用，所以他才发明了指数基金</p><h2 id="黄金适合投资吗？-告别从众的愚蠢"><a href="#黄金适合投资吗？-告别从众的愚蠢" class="headerlink" title="黄金适合投资吗？  告别从众的愚蠢"></a>黄金适合投资吗？  告别从众的愚蠢</h2><p>经济学家凯恩斯将投机形容成预测市场心理的活动，也就是说投机者只需要揣摩其他参与者在想些什么 预判他们的预判</p><p>有些人认为黄金能够保值避险 是不错的投资工具 但芒格说这玩意儿没法产生现金流，也就没有内在价值，只能当做投机而不是投资</p><p>就算一家公司看起来非常有前景 也要等到股票价格低于价值的时候才值得购买，这就叫安全边际</p><h2 id="定期摸鱼，效率更高-重视常识的作用"><a href="#定期摸鱼，效率更高-重视常识的作用" class="headerlink" title="定期摸鱼，效率更高     重视常识的作用"></a>定期摸鱼，效率更高     重视常识的作用</h2><p>学而不思则惘 死而不学则怠</p><p>保留精力应付复杂的事情</p><h2 id="为什么聪明人也总被骗-走出直观判断的误区"><a href="#为什么聪明人也总被骗-走出直观判断的误区" class="headerlink" title="为什么聪明人也总被骗    走出直观判断的误区"></a>为什么聪明人也总被骗    走出直观判断的误区</h2><p>偏见是源于人类大脑自然状态下的非数学性，当它用粗略的直观判断来处理概率时，经常会被误导做出一些糟糕的决定</p><p>对于一些概率非常小 然而一旦发生就会损失惨重的危险 必须重点防范 绝对不能大意</p><h3 id="认知偏差第一种-回避疑虑的倾向"><a href="#认知偏差第一种-回避疑虑的倾向" class="headerlink" title="认知偏差第一种 回避疑虑的倾向"></a>认知偏差第一种 回避疑虑的倾向</h3><p>或者换个更通俗的说法叫做轻信，心理学研究者认为人们很容易就会相信别人说的话，因为这样不仅能减少大脑负担，让我们处理更多事，而且对人际关系也有好处，不容易得罪人</p><h3 id="认知偏差的第二种-从众的倾向"><a href="#认知偏差的第二种-从众的倾向" class="headerlink" title="认知偏差的第二种 从众的倾向"></a>认知偏差的第二种 从众的倾向</h3><h3 id="认知偏差的第三种-回避痛苦的倾向"><a href="#认知偏差的第三种-回避痛苦的倾向" class="headerlink" title="认知偏差的第三种 回避痛苦的倾向"></a>认知偏差的第三种 回避痛苦的倾向</h3><h3 id="认知偏差的第四种-回馈的倾向-你怎么对我我怎么对你"><a href="#认知偏差的第四种-回馈的倾向-你怎么对我我怎么对你" class="headerlink" title="认知偏差的第四种 回馈的倾向     你怎么对我我怎么对你"></a>认知偏差的第四种 回馈的倾向     你怎么对我我怎么对你</h3><h3 id="认知偏差的第五种-热爱或憎恨的倾向-先站队再找理由-情人眼里出西施"><a href="#认知偏差的第五种-热爱或憎恨的倾向-先站队再找理由-情人眼里出西施" class="headerlink" title="认知偏差的第五种 热爱或憎恨的倾向   先站队再找理由 情人眼里出西施"></a>认知偏差的第五种 热爱或憎恨的倾向   先站队再找理由 情人眼里出西施</h3><h2 id="哪些性格可以让我们受益终身-把眼光放长远"><a href="#哪些性格可以让我们受益终身-把眼光放长远" class="headerlink" title="哪些性格可以让我们受益终身    把眼光放长远"></a>哪些性格可以让我们受益终身    把眼光放长远</h2><p>耐心</p><p>能力和性情</p><p>激情和学习</p><p>寻找益友</p><h2 id="公司价值怎么确定-抓住变化的本质"><a href="#公司价值怎么确定-抓住变化的本质" class="headerlink" title="公司价值怎么确定    抓住变化的本质"></a>公司价值怎么确定    抓住变化的本质</h2><p>企业的内在价值 就是它在剩余存续期内 可取现金的折现值 简单说就是要看它在未来还能赚多少钱，以及这些钱放在今天值多少</p><p>ROIC</p><h2 id="什么样的公司好赚钱-珍惜声誉和诚信"><a href="#什么样的公司好赚钱-珍惜声誉和诚信" class="headerlink" title="什么样的公司好赚钱  珍惜声誉和诚信"></a>什么样的公司好赚钱  珍惜声誉和诚信</h2><p>判断一个公司有没有议价权就看它有没有护城河</p>]]></content>
      
      
      <categories>
          
          <category> 韭菜的救赎 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2023/05/23/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/05/23/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>前几天的一个算法题面试，手写代码，发现n多年没写的冒泡排序，两层循环的意义忘记了，加深下记忆。核心是响铃两个数进行比较，循环的次数的意义需要重点关注下。</p><span id="more"></span><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序算法的运作如下：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortBuble</span><span class="params">(<span class="type">int</span> ary[],<span class="type">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length<span class="number">-1</span>;++i)   <span class="comment">//n个数需要比较n-1次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;length<span class="number">-1</span>-i; ++j) &#123; <span class="comment">//i表示已经排完的个数</span></span><br><span class="line">        <span class="keyword">if</span>(ary[j]&gt;ary[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="type">int</span> temp = ary[j];</span><br><span class="line">            ary[j] = ary[j+<span class="number">1</span>];</span><br><span class="line">            ary[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ary[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">45</span>,<span class="number">66</span>,<span class="number">33</span>,<span class="number">88</span>,<span class="number">22</span>,<span class="number">13</span>,<span class="number">99</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(ary)/<span class="built_in">sizeof</span>(ary[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;length : %d\n&quot;</span>,length);</span><br><span class="line">    <span class="built_in">sortBuble</span>(ary,length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ary[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>触摸事件与手势识别</title>
      <link href="/2023/05/20/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/"/>
      <url>/2023/05/20/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>需要给一个tableview添加一个tap手势识别，同时不影响tableview的滑动，应该如何实现？</p><p>设置 tap.cancelTouchsInView &#x3D; NO;</p><span id="more"></span><h2 id="Gesture-Recognizer"><a href="#Gesture-Recognizer" class="headerlink" title="Gesture Recognizer"></a>Gesture Recognizer</h2><p>Gesture Recognizer是iOS3.2引入的，用来识别手势、简化定制视图事件处理的对象。基类为<code>UIGestureRecognizer</code>，这是一个抽象基类，定义了实现底层手势识别行为的编程接口。</p><ul><li>6个具体的手势识别类</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITapGestureRecognizer</span>:用来识别点击手势,包括单击，双击，甚至三击等。</span><br><span class="line"><span class="built_in">UIPinchGestureRecognizer</span>:用来识别手指捏合手势。</span><br><span class="line"><span class="built_in">UIPanGestureRecognizer</span>:用来识别拖动手势。</span><br><span class="line"><span class="built_in">UISwipeGestureRecognizer</span>:用来识别Swipe手势。</span><br><span class="line"><span class="built_in">UIRotationGestureRecognizer</span>:用来识别旋转手势。</span><br><span class="line"><span class="built_in">UILongPressGestureRecognizer</span>:用来识别长按手势。</span><br><span class="line"><span class="built_in">UIScreenEdgePanGestureRecognizer</span>:(iOS <span class="number">7</span> 新加入的手势识别器苹果官方给的唯一的一个属性是edges)</span><br></pre></td></tr></table></figure><p><code>UIScreenEdgePanGestureRecognizer</code>跟pan(平移)手势差不多，需要从边缘进行拖动，在控制器转换的时候是有用的，看文档的话我们会发现 <code>UIScreenEdgePanGestureRecognizer</code>是 <code>UIPanGestureRecognizer</code>的子类，理解会更方便一点。</p><h3 id="手势识别流程"><a href="#手势识别流程" class="headerlink" title="手势识别流程"></a>手势识别流程</h3><p>为了识别手势，需要将Gesture Recoginzers关联到其检测触摸事件的view上，可以使用UIView的addGestureRecognizer:方法将手势识别绑定到视图上。Gesture Recognizers在触摸事件处理流程中，处于观察者的角色，其不是view层级结构的一部分，所以也不参与responder chain。</p><p>触摸事件传递的过程：在将触摸事件发送给hit-test view之前，系统会先将事件发送到hit-test上绑定的gesture recoginzers上或 hit-test view视图(superview)上绑定的Gesture Recognizers上。其流程图如下图所示:</p><img src="/2023/05/20/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/gesture01.png" class="&#x3D;"><p>注:图中view与Gesture Recognizer的关系是,Gesture Recognizer关联在view或view的superview(可能多级)上</p><h2 id="Gesture-Recoginzers与事件分发路径的关系"><a href="#Gesture-Recoginzers与事件分发路径的关系" class="headerlink" title="Gesture Recoginzers与事件分发路径的关系"></a>Gesture Recoginzers与事件分发路径的关系</h2><p>Gesture Recognizers可能会延迟将触摸事件发送到hit-test view上，默认情况下，当Gesture Recognizer识别到手势后，会向hit-test view发送cancel消息，来取消之前发给hit-test view的事件。</p><ul><li>控制这个流程的是UIGestureRecognizer的三个属性</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cancelTouchsInView （<span class="keyword">default</span> <span class="literal">YES</span>）</span><br><span class="line">delayTouchesBegin （<span class="keyword">default</span> <span class="literal">NO</span>）</span><br><span class="line">delayTouchesEnded （<span class="keyword">default</span> <span class="literal">YES</span>）</span><br></pre></td></tr></table></figure><p><code>cancelsTouchesInView</code>为YES,表示当Gesture Recognizers识别到手势后，会向hit-test view发送 <code>touchesCancelled:withEvent:</code>消息来取消hit-test view对此触摸序列的处理,这样只有Gesture Recognizers能响应此触摸序列，hit-test view不再响应。</p><p>如果为NO,则不发送<code>touchesCancelled:withEvent:</code>消息给hit-test view,这样会使Gesture Recognizers和hit-test view同时响应触摸序列。</p><p><code>delaysTouchesBegan</code>为NO，表示触摸序列开始时，而手势识别器还未识别出此手势时，touch事件会同时发向hit-test view,这样在手势识别器还未识别出此手势，hit-test view同时也可以收到同样的触摸事件。</p><p>如果为YES,则在手势识别器在识别手势的过程中，不会有任何触摸事件发送给hit-test view,如果手势识别器最终识别到了手势，则也不会发送任何消息(包括<code>touchesCancelled:withEvent:</code>)给hit-test view;如果手势识别最终没有识别到手势，则所有的触摸事件在发给hit-test view处理。关于这个特性，可参考UIScrollView的<code>delaysContentTouches</code>属性。这样属性也谨慎使用，使用不当会导致UI无响应。</p><p><code>delaysTouchesEnded</code>,在文档上的解释是，当手势识别器在识别手势时，对于<code>UITouchPhaseEnded</code>阶段的touch会延迟发送给hit-test view,在手势识别成功后,发送给hit-test view cancel消息，手势识别失败时，发送原来的end消息。</p><h2 id="多个Gesture-Recoginzer之间的关系"><a href="#多个Gesture-Recoginzer之间的关系" class="headerlink" title="多个Gesture Recoginzer之间的关系"></a>多个Gesture Recoginzer之间的关系</h2><p>在一个view上可以绑定多个Gesture Recognizer,在默认情况下，触摸序列中的触摸事件会以<strong>不确定的次序</strong>在各个gesture recognizer中传递，直到事件最终发送给hit-test view（如果中间没被Gesture Recognizer识别出并截获的话）。多个Gesture Recognizer之间的关系也可以根据需要定制，主要有下面几种行为</p><h3 id="使其中一个gesture-recognizer失败的情况下，另一个gesture-recognizer才能分析事件。"><a href="#使其中一个gesture-recognizer失败的情况下，另一个gesture-recognizer才能分析事件。" class="headerlink" title="使其中一个gesture recognizer失败的情况下，另一个gesture recognizer才能分析事件。"></a>使其中一个gesture recognizer失败的情况下，另一个gesture recognizer才能分析事件。</h3><p>以同时识别单击操作和双击操作为例，两个gesture recognizers分别用来识别单击和双击，分别为singleTapGesture和doubleTapGesture。在默认情况下,当用户进行单击操作时，singleTapGesture会识别出一个单击操作，doubleTapGesture也会识别出一个双击动作，但我们的意图是，这仅仅是一个双击操作。在这种情况下我们可以使用UIGestureRecognizer的requireGestureRecognizerToFail:方法来使singleTapGesture在doubleTapGesture识别识别的时候才分析事件，如果doubleTapGesture识别出双击事件，则singleTapGesture不会有任何动作。</p><p><code>[singleTapGesture requireGestureRecognizerToFail:doubleTapGesture];</code><br>需要注意的是，在这种情况下,如果用户进行单击操作，需要一段延时(即doubleTapGesture识别失败)，singleTapGesture才会识别出单击动作，进行单击处理，这段时间很多，对实际使用几乎没有影响。</p><h3 id="精确控制gesture-recognizer是否响应某个事件或事件序列"><a href="#精确控制gesture-recognizer是否响应某个事件或事件序列" class="headerlink" title="精确控制gesture recognizer是否响应某个事件或事件序列."></a>精确控制gesture recognizer是否响应某个事件或事件序列.</h3><p>在<code>UIGestureRecognizerDelegate</code>协议中有两个可选方法可以控制gesture recognizer是否需要识别某些事件</p><p><code>gestureRecognizerShouldBegin:</code><br>此方法在gesture recognizer视图转出UIGestureRecognizerStatePossible状态时调用，如果返回NO,则转换到UIGestureRecognizerStateFailed;如果返回YES,则继续识别触摸序列.(默认情况下为YES)<br><code>gestureRecognizer:shouldReceiveTouch:</code><br>此方法在window对象在有触摸事件发生时，调用gesture recognizer的touchesBegan:withEvent:方法之前调用，如果返回NO,则gesture recognizer不会看到此触摸事件。(默认情况下为YES).<br>另外，在UIGestureRecognizer类中也有两个可以重写的方法来完成与Delegate方法中相同的功能</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)canPreventGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)preventedGestureRecognizer;</span><br><span class="line">- (<span class="type">BOOL</span>)canBePreventedByGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)preventingGestureRecognizer;</span><br></pre></td></tr></table></figure><h3 id="允许多个手势识别器共同识别"><a href="#允许多个手势识别器共同识别" class="headerlink" title="允许多个手势识别器共同识别"></a>允许多个手势识别器共同识别</h3><p>默认情况下，两个gesture recognizers不会同时识别它们的手势,但是你可以实现<code>UIGestureRecognizerDelegate</code>协议中的<br><code>gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:</code>方法对其进行控制。这个方法在这两个gesture recognizers中的任意一个将block另一个的触摸事件时调用，如果返回YES,则两个gesture recognizers可同时识别，如果返回NO，则并不保证两个gesture recognizers必不能同时识别，因为另外一个gesture recognizer的此方法可能返回YES。也就是说两个gesture recognizers的delegate方法只要任意一个返回YES，则这两个就可以同时识别；只有两个都返回NO的时候，才是互斥的。默认情况下是返回NO。</p><p>有这样一个例子，如果要侦测在window上的所有触摸事件，可以将gesture recognizer关联到window上，默认情况下如果手势被window识别，则子视图中的gesture recognizer就失效了，而我们在window上的gesture recognizer的目的只是监控所有事件，但并不处理这些事件，具体事件的处理还需要子视图中的各个gesture recognizer去处理，这样我们可以实现window上绑定gesture recognizer的delegate方法，使<code>gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:</code>返回YES即可。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UIScrollView的类似行为"><a href="#UIScrollView的类似行为" class="headerlink" title="UIScrollView的类似行为"></a>UIScrollView的类似行为</h2><p>scroll view没有滚动栏，当在scroll view上有触摸行为时其要识别出触摸行为的目的是scroll view本身还是其内容子视图。定制scrollview如何处理这种情况，看查看UIScrollView类的下列属性和方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">touchesShouldBegin:withEvent:inContentView:</span><br><span class="line">touchesShouldCancelInContentView:</span><br><span class="line">canCancelContentTouches</span><br><span class="line">delaysContentTouches</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/junhuawang/p/6133974.html">触摸事件与手势识别</a><br><a href="https://mp.weixin.qq.com/s/5ZV0eUljDYY36qaq0KzrUA">关于TapGesture、UIResponder 链和 target-action 事件的相互影响的机理和应用</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> UI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【译】Creating Custom Presentations</title>
      <link href="/2023/04/04/%5B%E8%AF%91%5DCreating%20Custom%20Presentations/"/>
      <url>/2023/04/04/%5B%E8%AF%91%5DCreating%20Custom%20Presentations/</url>
      
        <content type="html"><![CDATA[<p>UIKit将你的视图控制器的content从content is presented 并在屏幕上显示的方式中分离出来。Presented视图控制器由底层presentation控制器对象管理，该对象管理用于显示视图控制器的视图的视觉样式。presentation控制器可以做以下事情: </p><ul><li>设置presented视图控制器的大小。 </li><li>添加自定义视图以更改显示内容的( the presented content)视觉外观。 </li><li>为任何自定义视图提供过渡动画。 </li><li>当应用程序的环境发生变化时，调整演示的视觉外观。</li></ul><p>UIKit为标准的表示样式提供了presentation控制器。当你设置一个视图控制器的表示样式为<code>UIModalPresentationCustom</code>并提供一个适当的转换委托时，UIKit会使用你的自定义表示控制器。</p><span id="more"></span><h3 id="The-Custom-Presentation-Process"><a href="#The-Custom-Presentation-Process" class="headerlink" title="The Custom Presentation Process"></a>The Custom Presentation Process</h3><p>当你present一个presentation风格为<code>UIModalPresentationCustom</code>的视图控制器时，UIKit会寻找一个自定义的presentation控制器来管理presentation过程。随着presentation的进行，UIKit调用presentation控制器的方法，让它有机会设置任何自定义视图并将它们动画到相应的位置。 </p><p>presentation控制器与任何动画对象(animator objects)一起工作来实现整体转换。animator对象将视图控制器的内容(contents)动画到屏幕上，而presentation控制器处理其他一切。通常，你的presentation控制器动画它自己的视图，但你也可以重写presentation控制器的<code>presenttedview</code>方法，让animator对象动画所有或部分视图。</p><p>在presentation过程中，UIKit:</p><ol><li><p>调用转换委托的<code>presentationcontrollerforpresenttedviewcontroller:presentingViewController:sourceViewController:</code>方法来检索(retrieve)您的自定义presentation控制器 </p></li><li><p>向过渡委托请求动画器和交互动画器对象(如果有的话) </p></li><li><p>调用表示控制器的<code>presentationTransitionWillBegin</code>方法</p><blockquote><p>这个方法的实现应该将任何自定义视图添加到视图层次结构中，并为这些视图配置动画。 </p></blockquote></li><li><p>从presentation控制器获取<code>presenttedview</code> </p><blockquote><p>此方法返回的视图由动画器对象动画到相应位置。通常，这个方法返回presented视图控制器的根视图。您的presentation控制器可以根据需要用自定义背景视图替换该视图。如果你指定了一个不同的视图，你必须将presented视图控制器的根视图嵌入到你的视图层次结构中。 </p></blockquote></li><li><p>执行过渡动画 </p><blockquote><p>过渡动画包括由animator对象创建的主要动画，以及您配置为与主要动画一起运行的任何动画。有关过渡动画的信息，请参见过渡动画序列。<br> 在动画过程中，UIKit调用你的表示控制器的containerViewWillLayoutSubviews和containerViewDidLayoutSubviews方法，这样你就可以根据需要调整你的自定义视图的布局。 </p></blockquote></li><li><p>在转换动画完成时调用presentationTransitionDidEnd:方法</p></li></ol><p>在dismissal期间，UIKit:</p><ol><li><p>从当前可见的视图控制器获取自定义presentation控制器 </p></li><li><p>向过渡委托请求动画器和交互动画器对象(如果有的话) </p></li><li><p>调用表示控制器的<code>dissaltransitionwillbegin</code>方法 </p><blockquote><p>这个方法的实现应该将任何自定义视图添加到视图层次结构中，并为这些视图配置动画。 </p></blockquote></li><li><p>从表示控制器获取已经  <code>presentedView</code> </p></li><li><p>执行过渡动画 </p><blockquote><p>过渡动画包括由animator对象创建的主要动画，以及您配置为与主要动画一起运行的任何动画。有关过渡动画的信息，请参见过渡动画序列。<br>在动画过程中，UIKit调用你的表示控制器的containerViewWillLayoutSubviews和containerViewDidLayoutSubviews方法，这样你就可以删除任何自定义约束。 </p></blockquote></li><li><p>当过渡动画结束时调用dissaltransitiondidend:方法</p></li></ol><p>在presentation过程中，你的表示控制器的<code>frameofpresenttedviewincontainerview</code>和<code>presenttedview</code>方法可能会被调用几次，所以你的实现应该很快返回。同样，你的<code>presenttedview</code>方法的实现不应该尝试设置视图层次结构。在调用方法时，视图层次结构应该已经配置好了。</p><h3 id="Creating-a-Custom-Presentation-Controller"><a href="#Creating-a-Custom-Presentation-Controller" class="headerlink" title="Creating a Custom Presentation Controller"></a>Creating a Custom Presentation Controller</h3><p>要实现自定义的presentation风格，子类<code>UIPresentationController</code>并添加代码来创建presentation的视图和动画。在创建自定义presentation控制器时，考虑以下问题: </p><ul><li><p>您想添加哪些视图? </p></li><li><p>你想如何在屏幕上动画任何其他视图? </p></li><li><p>呈现的视图控制器应该是多大? </p></li><li><p>在水平规则类和水平紧凑类之间，表示应该如何适应? </p></li><li><p>当呈现结束时，呈现视图控制器的视图应该被移除吗?</p></li></ul><p>所有这些决策都需要重写<code>UIPresentationController</code>类的不同方法。</p><h4 id="Setting-the-Frame-of-the-Presented-View-Controller"><a href="#Setting-the-Frame-of-the-Presented-View-Controller" class="headerlink" title="Setting the Frame of the Presented View Controller"></a>Setting the Frame of the Presented View Controller</h4><p>您可以修改当前视图控制器(presented view controlle)的框架矩形(frame rectangle )，使其只填充可用空间的一部分。默认情况下，presented view controller的大小完全填满容器视图的frame。要改变frame rectangle，重写presentation控制器的<code>frameofpresenttedviewincontainerview</code>方法。清单11-1显示了一个例子，其中frame被更改为只覆盖容器视图的右半部分。在这种情况下，presentation控制器使用背景变暗(dimming)视图来覆盖容器的另一半。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Listing 11-1 Changing the frame of a presented view controller</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)frameOfPresentedViewInContainerView &#123;</span><br><span class="line">    <span class="built_in">CGRect</span> presentedViewFrame = <span class="built_in">CGRectZero</span>;</span><br><span class="line">    <span class="built_in">CGRect</span> containerBounds = [[<span class="keyword">self</span> containerView] bounds];</span><br><span class="line"> </span><br><span class="line">    presentedViewFrame.size = <span class="built_in">CGSizeMake</span>(floorf(containerBounds.size.width / <span class="number">2.0</span>),</span><br><span class="line">                                         containerBounds.size.height);</span><br><span class="line">    presentedViewFrame.origin.x = containerBounds.size.width -</span><br><span class="line">                                    presentedViewFrame.size.width;</span><br><span class="line">    <span class="keyword">return</span> presentedViewFrame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Managing-and-Animating-Custom-Views"><a href="#Managing-and-Animating-Custom-Views" class="headerlink" title="Managing and Animating Custom Views"></a>Managing and Animating Custom Views</h4><p>自定义presentations通常包括向presented的内容添加自定义视图。使用自定义视图来实现纯视觉装饰(adornments)，或者使用它们来向表示添加实际(practical)行为。例如，背景视图可能包含手势识别器来跟踪presented内容范围之外的特定操作。 </p><p>presentation控制器负责创建和管理与其presentation相关联的所有自定义视图。通常，在初始化表示控制器期间创建自定义视图。清单11-2显示了创建自己的变暗视图的自定义视图控制器的初始化方法。该方法创建视图并执行一些最小配置。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 11-2 Initializing the presentation controller</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPresentedViewController:(<span class="built_in">UIViewController</span> *)presentedViewController</span><br><span class="line">                    presentingViewController:(<span class="built_in">UIViewController</span> *)presentingViewController &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> initWithPresentedViewController:presentedViewController</span><br><span class="line">                         presentingViewController:presentingViewController];</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// Create the dimming view and set its initial appearance.</span></span><br><span class="line">        <span class="keyword">self</span>.dimmingView = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">        [<span class="keyword">self</span>.dimmingView setBackgroundColor:[<span class="built_in">UIColor</span> colorWithWhite:<span class="number">0.0</span> alpha:<span class="number">0.4</span>]];</span><br><span class="line">        [<span class="keyword">self</span>.dimmingView setAlpha:<span class="number">0.0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>presentationTransitionWillBegin</code>方法将自定义视图动画到屏幕上。在这种方法中，配置您的自定义视图并将它们添加到容器视图，如清单11-3所示。使用presented视图控制器或presenting视图控制器的转换协调器来创建任何动画。不要在此方法中修改presented视图控制器的视图。动画器对象负责将presented视图控制器动画到你从<code>frameofpresenttedviewincontainerview</code>方法返回的frame rectangle中。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listing 11-3 Animating the dimming view onto the screen</span></span><br><span class="line">- (<span class="type">void</span>)presentationTransitionWillBegin &#123;</span><br><span class="line">    <span class="comment">// Get critical information about the presentation.</span></span><br><span class="line">    <span class="built_in">UIView</span>* containerView = [<span class="keyword">self</span> containerView];</span><br><span class="line">    <span class="built_in">UIViewController</span>* presentedViewController = [<span class="keyword">self</span> presentedViewController];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Set the dimming view to the size of the container&#x27;s</span></span><br><span class="line">    <span class="comment">// bounds, and make it transparent initially.</span></span><br><span class="line">    [[<span class="keyword">self</span> dimmingView] setFrame:[containerView bounds]];</span><br><span class="line">    [[<span class="keyword">self</span> dimmingView] setAlpha:<span class="number">0.0</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Insert the dimming view below everything else.</span></span><br><span class="line">    [containerView insertSubview:[<span class="keyword">self</span> dimmingView] atIndex:<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Set up the animations for fading in the dimming view.</span></span><br><span class="line">    <span class="keyword">if</span>([presentedViewController transitionCoordinator]) &#123;</span><br><span class="line">        [[presentedViewController transitionCoordinator]</span><br><span class="line">               animateAlongsideTransition:^(<span class="type">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinatorContext</span>&gt;</span><br><span class="line">                                            context) &#123;</span><br><span class="line">            <span class="comment">// Fade in the dimming view.</span></span><br><span class="line">            [[<span class="keyword">self</span> dimmingView] setAlpha:<span class="number">1.0</span>];</span><br><span class="line">        &#125; completion:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        [[<span class="keyword">self</span> dimmingView] setAlpha:<span class="number">1.0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在presentation结束时，使用<code>presentationTransitionDidEnd:</code>方法来处理由于取消presentation而引起的任何清理。交互式动画对象如果没有满足阈值(threshold)条件，可能会取消转换。当这种情况发生时，UIKit调用<code>presentationTransitionDidEnd:</code>方法，值为<code>NO</code>。当取消发生时，删除您在presentation开始时添加的任何自定义视图，并将任何其他视图返回到它们之前的配置，如清单11-4所示。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Listing 11-4 Handling a cancelled presentation</span></span><br><span class="line">- (<span class="type">void</span>)presentationTransitionDidEnd:(<span class="type">BOOL</span>)completed &#123;</span><br><span class="line">    <span class="comment">// If the presentation was canceled, remove the dimming view.</span></span><br><span class="line">    <span class="keyword">if</span> (!completed)</span><br><span class="line">        [<span class="keyword">self</span>.dimmingView removeFromSuperview];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当视图控制器dismissed时，使用<code>dismissalTransitionDidEnd:</code>方法从视图层次结构中移除你的自定义视图。如果你想动画视图的消失，在<code>dismissalTransitionDidEnd:</code>方法中设置这些动画。清单11-5显示了在前面的示例中删除暗光视图( dimming view)的两种方法的实现。总是检查<code>disdissaltransitiondidend:</code>方法的参数，看看dismissal是成功的还是被取消了</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Listing 11-5 Dismissing the presentation’s views</span></span><br><span class="line">- (<span class="type">void</span>)dismissalTransitionWillBegin &#123;</span><br><span class="line">    <span class="comment">// Fade the dimming view back out.</span></span><br><span class="line">    <span class="keyword">if</span>([[<span class="keyword">self</span> presentedViewController] transitionCoordinator]) &#123;</span><br><span class="line">        [[[<span class="keyword">self</span> presentedViewController] transitionCoordinator]</span><br><span class="line">           animateAlongsideTransition:^(<span class="type">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinatorContext</span>&gt;</span><br><span class="line">                                        context) &#123;</span><br><span class="line">            [[<span class="keyword">self</span> dimmingView] setAlpha:<span class="number">0.0</span>];</span><br><span class="line">        &#125; completion:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        [[<span class="keyword">self</span> dimmingView] setAlpha:<span class="number">0.0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="type">void</span>)dismissalTransitionDidEnd:(<span class="type">BOOL</span>)completed &#123;</span><br><span class="line">    <span class="comment">// If the dismissal was successful, remove the dimming view.</span></span><br><span class="line">    <span class="keyword">if</span> (completed)</span><br><span class="line">        [<span class="keyword">self</span>.dimmingView removeFromSuperview];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vending-Your-Presentation-Controller-to-UIKit"><a href="#Vending-Your-Presentation-Controller-to-UIKit" class="headerlink" title="Vending Your Presentation Controller to UIKit"></a>Vending Your Presentation Controller to UIKit</h3><p>当presenting一个视图控制器时，执行以下操作来使用你的自定义presentation控制器显示它: </p><ul><li><p>设置presented视图控制器的<code>modalPresentationStyle</code>属性为<code>UIModalPresentationCustom</code>。 </p></li><li><p>给presented视图控制器的<code>transitioningDelegate</code>属性分配一个转换委托。 </p></li><li><p>实现转换委托的<code>presentationcontrollerforpresenttedviewcontroller:presentingViewController:sourceViewController:</code>方法。</p></li></ul><p>UIKit调用你的转换委托的<code>presentationcontrollerforpresenttedviewcontroller:presentingViewController:sourceViewController:</code>方法当它需要你的表示控制器时。这个方法的实现应该像清单11-6中那样简单。只需创建您的表示控制器，配置它并返回它。如果你从这个方法中返回nil, UIKit会使用全屏显示样式来显示视图控制器。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Listing 11-6 Creating a custom presentation controller</span></span><br><span class="line">- (<span class="built_in">UIPresentationController</span> *)presentationControllerForPresentedViewController:</span><br><span class="line">                                 (<span class="built_in">UIViewController</span> *)presented</span><br><span class="line">        presentingViewController:(<span class="built_in">UIViewController</span> *)presenting</span><br><span class="line">            sourceViewController:(<span class="built_in">UIViewController</span> *)source &#123;</span><br><span class="line"> </span><br><span class="line">    MyPresentationController* myPresentation = [[MyPresentationController]</span><br><span class="line">       initWithPresentedViewController:presented presentingViewController:presenting];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> myPresentation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/DefiningCustomPresentations.html#//apple_ref/doc/uid/TP40007457-CH25-SW1">Creating Custom Presentations</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【译】Presenting a View Controller</title>
      <link href="/2023/03/31/Presenting%20a%20View%20Controller/"/>
      <url>/2023/03/31/Presenting%20a%20View%20Controller/</url>
      
        <content type="html"><![CDATA[<p>添加一个视图弹窗到当前窗口，是选择view还是Controller实现？</p><span id="more"></span><p>有两种方法在屏幕上显示一个视图控制器:将它嵌入到容器视图控制器中或present它。容器视图控制器提供了应用程序的主要导航，但present视图控制器也是一个重要的导航工具。你使用直接表示来在当前视图控制器的顶部显示一个新的视图控制器。通常，当你想要实现模态交互时，你会present视图控制器，但你也可以将它们用于其他目的。</p><p>对presenting视图控制器的支持被内置到<code>UIViewController</code>类中，并且对所有视图控制器对象可用。你可以从任何其他视图控制器present任何视图控制器，尽管UIKit可能会将请求重新路由(reroute)到不同的视图控制器。Presenting一个视图控制器会在原始视图控制器(称为presenting视图控制器)和要显示的新视图控制器(称为presented视图控制器)之间创建一个关系。这个关系构成了视图控制器层次结构(hierarchy)的一部分，并一直存在，直到presented视图控制器被解散(dismissed)。</p><h2 id="The-Presentation-and-Transition-Process"><a href="#The-Presentation-and-Transition-Process" class="headerlink" title="The Presentation and Transition Process"></a>The Presentation and Transition Process</h2><p>Presenting一个视图控制器是将新内容动画到屏幕上的一种快速而简单的方法。UIKit内建的表示机制(machinery)允许你使用内置或自定义动画来显示一个新的视图控制器。内置的presentations和动画只需要很少的代码，因为UIKit处理了所有的工作。您还可以创建自定义的presentations和动画，只需一点点额外的努力，并将它们与任何视图控制器一起使用。 </p><p>你可以通过编程或使用segue来初始化视图控制器的presentation。如果你在设计时就知道应用的导航，segue是最简单的方式来启动presentations。对于更动态的交互，或者在没有专门的控件来启动segue的情况下，使用UIViewController的方法来present你的视图控制器。</p><h2 id="Presentation-Styles"><a href="#Presentation-Styles" class="headerlink" title="Presentation Styles"></a>Presentation Styles</h2><p>视图控制器的presentation style决定了它在屏幕上的外观。UIKit定义了许多标准的表示样式，每种样式都有特定的外观和意图。您还可以定义自己的自定义表示样式。在设计你的应用程序时，选择对你想要做的事情最有意义的表现风格，并为你想要表现的视图控制器的modalPresentationStyle属性分配适当的常数。</p><h3 id="Full-Screen-Presentation-Styles"><a href="#Full-Screen-Presentation-Styles" class="headerlink" title="Full-Screen Presentation Styles"></a>Full-Screen Presentation Styles</h3><p>全屏显示样式覆盖了整个屏幕，阻止了与底层内容的交互。在水平规则环境中(horizontally regular environment)，只有一种全屏样式完全覆盖底层内容。其余的包含调光视图(dimming views)或透明度(transparency)，以允许底层视图控制器的部分通过显示。在水平紧凑的环境中(horizontally compact environment)，全屏演示自动适应UIModalPresentationFullScreen样式并覆盖所有底层内容。 </p><p>图8-1演示了在水平规则环境中使用UIModalPresentationFullScreen、UIModalPresentationPageSheet和UIModalPresentationFormSheet样式的演示的外观。在图中，左上角的绿色视图控制器呈现右上方的蓝色视图控制器，每种呈现风格的结果如下所示。对于某些表示样式，UIKit会在两个视图控制器的内容之间插入一个调光视图( dimming view)。 </p><p>Figure 8-1 The full screen presentation styles</p><img src="/2023/03/31/Presenting%20a%20View%20Controller/VCPG_PresentationStyles%20_fig_8-1_2x.png" class="&#x3D;"><blockquote><p>当使用UIModalPresentationFullScreen样式呈现一个视图控制器时，UIKit通常在转换动画完成后删除底层视图控制器的视图。你可以通过指定UIModalPresentationOverFullScreen样式来阻止这些视图的移除。当呈现的视图控制器有透明区域，可以显示底层内容时，可以使用这种样式。</p></blockquote><p>当使用一种全屏显示样式时，发起显示的视图控制器必须自己覆盖整个屏幕。如果presenting视图控制器没有覆盖屏幕，UIKit会沿着视图控制器层次结构向上走，直到找到一个覆盖屏幕的。如果UIKit找不到一个填充屏幕的中间视图控制器，它就会使用窗口的根视图控制器。</p><h3 id="The-Popover-Style"><a href="#The-Popover-Style" class="headerlink" title="The Popover Style"></a>The Popover Style</h3><p>UIModalPresentationPopover样式在弹窗视图(popover view.)中显示视图控制器。Popovers对于显示与焦点或选定对象相关的附加信息或项列表非常有用。在水平规则环境中，弹窗视图只覆盖屏幕的一部分，如图8-2所示。在水平紧凑的环境中，弹窗默认情况下适应UIModalPresentationOverFullScreen表示样式。在弹出窗口视图外点击会自动解除弹出窗口。</p><p>Figure 8-2 The popover presentation style</p><img src="/2023/03/31/Presenting%20a%20View%20Controller/VCPG_popover-style_2x.png" class="&#x3D;"><p>因为弹窗适应于水平紧凑环境中的全屏显示，所以通常需要修改弹窗代码来处理这种适应。在全屏模式下，你需要一种方法来dismiss弹出窗口。您可以通过添加一个按钮，将弹出窗口嵌入到dismissible的容器视图控制器中，或更改自适应行为本身来实现这一点。 </p><p>有关如何配置弹出窗口表示的技巧，请参见在弹出窗口中呈现视图控制器。</p><h3 id="The-Current-Context-Styles"><a href="#The-Current-Context-Styles" class="headerlink" title="The Current Context Styles"></a>The Current Context Styles</h3><p><code>UIModalPresentationCurrentContext</code>样式覆盖了你的界面中一个特定的视图控制器。当使用上下文样式时，你通过设置它的<code>definesPresentationContext</code>属性为YES来指定你想覆盖哪个视图控制器。图8-3展示了一个当前的上下文表示，它只覆盖了分屏视图控制器的一个子视图控制器。</p><p>Figure 8-3 The current context presentation style</p><img src="/2023/03/31/Presenting%20a%20View%20Controller/VCPG_CurrentContextStyles_2x.png" class="&#x3D;"><blockquote><p>当使用UIModalPresentationFullScreen样式呈现一个视图控制器时，UIKit通常在转换动画完成后删除底层视图控制器的视图。你可以通过指定UIModalPresentationOverCurrentContext样式来阻止这些视图的删除。当呈现的视图控制器有透明区域，可以显示底层内容时，可以使用这种样式。</p></blockquote><p>定义presentation上下文的视图控制器还可以定义在表示期间使用的转换动画。通常，UIKit使用所呈现的视图控制器的<code>modalTransitionStyle</code>属性中的值在屏幕上动画视图控制器。如果表示上下文视图控制器将它的<code>providesPresentationContextTransitionStyle</code>设置为YES, UIKit使用该视图控制器的modalTransitionStyle属性中的值。 </p><p>当转换到水平紧凑环境时，当前上下文样式适应<code>UIModalPresentationFullScreen</code>样式。要改变这种行为，请使用自适应表示委托来指定不同的表示样式或视图控制器。</p><h3 id="Custom-Presentation-Styles"><a href="#Custom-Presentation-Styles" class="headerlink" title="Custom Presentation Styles"></a>Custom Presentation Styles</h3><p><code>UIModalPresentationCustom</code>样式让你使用你定义的自定义样式来呈现一个视图控制器。创建自定义样式包括子类化<code>UIPresentationController</code>，并使用它的方法将任何自定义视图动画到屏幕上，并设置presented view controller的大小和位置。presentation控制器还处理任何由于presented视图控制器的特征（traits）的变化而发生的适应性。 </p><p>有关如何定义自定义表示控制器的信息，请参见创建自定义表示。</p><h2 id="Presenting-Versus-Showing-a-View-Controller"><a href="#Presenting-Versus-Showing-a-View-Controller" class="headerlink" title="Presenting Versus Showing a View Controller"></a>Presenting Versus Showing a View Controller</h2><p>UIViewController类提供了两种方式来显示一个视图控制器: </p><ol><li><p><code>showViewController:sender:</code>和<code>showDetailViewController:sender:</code>方法提供了最适应性和最灵活的方式来显示视图控制器。这些方法让presenting视图控制器决定如何最好地处理presentation。例如，容器视图控制器可能将视图控制器合并(incorporate)为子视图控制器，而不是modal地呈现它。默认行为以模态方式呈现视图控制器。 </p></li><li><p><code>presentViewController:animated:completion:</code>方法总是以模态方式显示视图控制器。调用此方法的视图控制器可能最终(ultimately)不会处理presentation，但presentation始终是模态的。此方法适用于水平紧凑环境的presentation样式。</p></li></ol><p>方法<code>showViewController:sender:</code>和<code>showDetailViewController:sender:</code>是发起展示(initiate presentations)的首选方式。视图控制器可以调用它们，而不需要知道视图控制器层次结构的其他部分或者当前视图控制器在那个层次结构中的位置。这些方法也使得在应用程序的不同部分重用视图控制器变得更容易，而无需编写条件代码路径。</p><h3 id="Showing-View-Controllers"><a href="#Showing-View-Controllers" class="headerlink" title="Showing View Controllers"></a>Showing View Controllers</h3><p>当使用showViewController:sender:和showDetailViewController:sender:方法时，在屏幕上获取一个新的视图控制器的过程很简单: </p><ol><li><p>创建你想要呈现的视图控制器对象。当创建视图控制器时，你有责任用它执行任务所需的任何数据来初始化它。 </p></li><li><p>将新视图控制器的modalPresentationStyle属性设置为首选的表示样式。这种风格可能不会在最终的演示中使用。 </p></li><li><p>将视图控制器的modalTransitionStyle属性设置为所需的过渡动画样式。这种风格可能不会在最终的动画中使用。 </p></li><li><p>调用当前视图控制器的showViewController:sender:和showDetailViewController:sender:方法。</p></li></ol><p>UIKit将对showViewController:sender:和showDetailViewController:sender:方法的调用转发给相应的呈现视图控制器。然后视图控制器可以决定如何最好地执行表示，并可以根据需要更改表示和转换样式。例如，一个导航控制器可能会把视图控制器推到它的导航堆栈上。 </p><p>有关显示视图控制器和模态显示视图控制器之间的区别的信息，请参见显示与显示视图控制器。</p><h3 id="Presenting-View-Controllers-Modally"><a href="#Presenting-View-Controllers-Modally" class="headerlink" title="Presenting View Controllers Modally"></a>Presenting View Controllers Modally</h3><p>当直接呈现一个视图控制器时，你告诉UIKit你希望新的视图控制器如何显示，以及它应该如何在屏幕上动画。 </p><ol><li><p>创建你想要呈现的视图控制器对象。<br> 当创建视图控制器时，你有责任用它执行任务所需的任何数据来初始化它。 </p></li><li><p>将新视图控制器的modalPresentationStyle属性设置为所需的表示样式。 </p></li><li><p>将视图控制器的modalTransitionStyle属性设置为所需的动画样式。 </p></li><li><p>调用当前视图控制器的presentViewController:animated:completion:方法。</p></li></ol><p>调用<code>presentViewController:animated:completion:</code>方法的视图控制器可能不是真正执行模式显示的那个。呈现风格决定了视图控制器如何被呈现，包括呈现视图控制器所需的特征。例如，<strong>全屏显示必须由全屏视图控制器发起</strong>。如果当前呈现的视图控制器不合适，UIKit会遍历视图控制器层次结构，直到找到一个合适的。模态呈现完成后，UIKit会更新受影响的视图控制器的presentingViewController和presenttedviewcontroller属性。 </p><p>清单8-1演示了如何以编程方式表示视图控制器。当用户添加一个新食谱时，应用程序会通过一个导航控制器提示用户关于食谱的基本信息。选择一个导航控制器，这样就有一个标准的位置来放置“取消和完成”按钮。使用导航控制器还可以使将来更容易扩展新的食谱界面。你所要做的就是把新的视图控制器推到导航堆栈上。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Listing 8-1 Presenting a view controller programmatically  </span></span><br><span class="line">- (<span class="type">void</span>)add:(<span class="type">id</span>)sender &#123;</span><br><span class="line">   <span class="comment">// Create the root view controller for the navigation controller</span></span><br><span class="line">   <span class="comment">// The new view controller configures a Cancel and Done button for the</span></span><br><span class="line">   <span class="comment">// navigation bar.</span></span><br><span class="line">   RecipeAddViewController *addController = [[RecipeAddViewController alloc] init];</span><br><span class="line"> </span><br><span class="line">   addController.modalPresentationStyle = <span class="built_in">UIModalPresentationFullScreen</span>;</span><br><span class="line">   addController.transitionStyle = <span class="built_in">UIModalTransitionStyleCoverVertical</span>;</span><br><span class="line">   [<span class="keyword">self</span> presentViewController:addController animated:<span class="literal">YES</span> completion: <span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Presenting-a-View-Controller-in-a-Popover"><a href="#Presenting-a-View-Controller-in-a-Popover" class="headerlink" title="Presenting a View Controller in a Popover"></a>Presenting a View Controller in a Popover</h3><p>弹出窗口需要额外的配置才能显示它们。在将模态表示样式设置为UIModalPresentationPopover之后，配置以下与弹出窗口相关的属性: </p><ul><li><p>设置你的视图控制器的preferredContentSize属性为所需的大小。 </p></li><li><p>使用相关的UIPopoverPresentationController对象设置弹出窗口锚点，该对象可以从视图控制器的popoverPresentationController属性中访问。只需要设置以下其中一个: </p><ul><li><p>将barButtonItem属性设置为一个栏按钮项。 </p></li><li><p>将sourceView和sourceRect属性设置为一个视图中的特定区域。</p></li></ul></li></ul><p>你可以使用<code>UIPopoverPresentationController</code>对象根据需要对弹出窗口的外观进行其他调整。弹窗表示控制器还支持一个委托对象，您可以使用该对象在表示过程中响应更改。例如，当弹出窗口在屏幕上出现、消失或重新定位时，可以使用委托进行响应。有关该对象的更多信息，请参见<a href="https://developer.apple.com/documentation/uikit/uipopoverpresentationcontroller?language=objc">UIPopoverPresentationController</a>类参考。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/PresentingaViewController.html#//apple_ref/doc/uid/TP40007457-CH14-SW13">View Controller Programming Guide for iOS</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift 闭包</title>
      <link href="/2023/03/27/Swift%20%E9%97%AD%E5%8C%85/"/>
      <url>/2023/03/27/Swift%20%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>闭包表达式语法有如下的一般形式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; <span class="keyword">return</span> type <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包表达式参数 可以是 in-out 参数，但不能设定默认值。元组也可以作为参数和返回值。</p><span id="more"></span><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">backward</span>(<span class="keyword">_</span> <span class="params">s1</span>: <span class="type">String</span>, <span class="keyword">_</span> <span class="params">s2</span>: <span class="type">String</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reversedNames <span class="operator">=</span> names.sorted(by: backward)</span><br><span class="line"><span class="comment">// reversedNames 为 [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]</span></span><br><span class="line"></span><br><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="根据上下文推断类型"><a href="#根据上下文推断类型" class="headerlink" title="根据上下文推断类型"></a>根据上下文推断类型</h3><p>因为所有的类型都可以被正确推断，<strong>返回箭头（-&gt;）</strong>和<strong>围绕在参数周围的括号</strong>也可以被省略：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2 &#125; )</span><br></pre></td></tr></table></figure><h3 id="单表达式闭包的隐式返回"><a href="#单表达式闭包的隐式返回" class="headerlink" title="单表达式闭包的隐式返回"></a>单表达式闭包的隐式返回</h3><p>单行表达式闭包可以通过<strong>省略 return 关键字</strong>来隐式返回单行表达式的结果</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> s1 <span class="operator">&gt;</span> s2 &#125; )</span><br></pre></td></tr></table></figure><h3 id="参数名称缩写"><a href="#参数名称缩写" class="headerlink" title="参数名称缩写"></a>参数名称缩写</h3><p>Swift 自动为内联闭包提供了参数名称缩写功能，你可以直接通过 $0，$1，$2 来顺序调用闭包的参数，以此类推。</p><p>如果你在闭包表达式中使用参数名称缩写，你可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。闭包接受的参数的数量取决于所使用的缩写参数的最大编号。<strong>in 关键字也同样可以被省略</strong>，因为此时闭包表达式完全由闭包函数体构成：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125; )</span><br></pre></td></tr></table></figure><h3 id="运算符方法"><a href="#运算符方法" class="headerlink" title="运算符方法"></a>运算符方法</h3><p>Swift 的 String 类型定义了关于大于号（&gt;）的字符串实现，其作为一个函数接受两个 String 类型的参数并返回 Bool 类型的值。而这正好与 sorted(by:) 方法的参数需要的函数类型相符合。因此，你可以简单地传递一个大于号，Swift 可以自动推断找到系统自带的那个字符串函数的实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: <span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure><h3 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h3><p>将一个很长的闭包表达式作为最后一个参数传递给函数，将这个闭包替换成为尾随闭包的形式很有用。尾随闭包是一个书写在函数圆括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，你<strong>不用写出它的参数标签</strong>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionThatTakesAClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是不使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure(closure: &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted() &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure><p>如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至<strong>可以把 () 省略掉</strong>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift和OC的区别</title>
      <link href="/2023/03/08/Swift%E5%92%8COC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
      <url>/2023/03/08/Swift%E5%92%8COC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift和OC的区别？"><a href="#Swift和OC的区别？" class="headerlink" title="Swift和OC的区别？"></a>Swift和OC的区别？</h2><p>swift是静态语言，有类型推断，OC是动态语言。<br>swift支持静态派发（效率高）、动态派发（函数表派发、消息派发）方式，OC支持动态派发（消息派发）方式。<br>swift的协议不仅可以被类实现，也可以被struct和enum实现<br>swift有元组类型、支持运算符重载</p><span id="more"></span><h2 id="swift的派发机制"><a href="#swift的派发机制" class="headerlink" title="swift的派发机制"></a>swift的派发机制</h2><p>函数的派发机制：静态派发（直接派发）、函数表派发、消息派发</p><h3 id="swift派发机制总结："><a href="#swift派发机制总结：" class="headerlink" title="swift派发机制总结："></a>swift派发机制总结：</h3><ol><li>swift中所有值类型：struct、enum使用直接派发。</li><li>swift中协议的extensions(类似于OC的分类)使用直接派发，初始声明函数使用函数表派发</li><li>swift中class中extensions使用直接派发，初始化声明函数使用函数表派发，dynamic修饰的函数使用消息派发。</li><li>swift中NSObject的子类用@nonobjc或final修饰的函数使用直接派发，初始声明函数使用函数表派发，dynamic修饰的extensions使用消息派发</li><li>swift中函数派发查看方式：可将swift代码转换为SIL（中间码）</li></ol><p><code>swiftc -emit-silgen -O example.swift</code></p><h3 id="swift显示指定派发方式？"><a href="#swift显示指定派发方式？" class="headerlink" title="swift显示指定派发方式？"></a>swift显示指定派发方式？</h3><ol><li>添加final关键字的函数使用直接派发</li><li>添加static关键字函数使用直接派发</li><li>添加@inline关键字的函数告诉编译器可以使用直接派发</li><li>添加dynamic关键字函数使用消息派发</li><li>添加@objc关键字的函数使用消息派发</li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift面试高级</title>
      <link href="/2023/03/07/%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
      <url>/2023/03/07/%E9%AB%98%E7%BA%A7%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="一个-Sequence-的索引是不是一定从-0-开始？"><a href="#一个-Sequence-的索引是不是一定从-0-开始？" class="headerlink" title="一个 Sequence 的索引是不是一定从 0 开始？"></a>一个 Sequence 的索引是不是一定从 0 开始？</h2><p>不一定, 两个 for in 并不能保证都是从 0 开始, 且输出结果一致, 官方文档如下：</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Repeated Access　　</span><br><span class="line">The Sequence protocol makes no requirement on conforming types regarding</span><br><span class="line">whether they will be destructively consumed by iteration. As a</span><br><span class="line">consequence, don’t assume that multiple for-in loops on a sequence</span><br><span class="line">will either resume iteration or restart from the beginning:</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span>系统方法调用</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;start----&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> numbers <span class="operator">=</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> numbersIterator <span class="operator">=</span> numbers.makeIterator()</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> num <span class="operator">=</span> numbersIterator.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;midle----&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> num <span class="operator">=</span> numbersIterator.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;end----&quot;</span>)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">start<span class="operator">----</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">midle<span class="operator">----</span></span><br><span class="line">end<span class="operator">----</span></span><br></pre></td></tr></table></figure><h2 id="数组都实现了哪些协议"><a href="#数组都实现了哪些协议" class="headerlink" title="数组都实现了哪些协议"></a>数组都实现了哪些协议</h2><p>MutableCollection, 实现了可修改的数组, 如 a[1] &#x3D; 2<br>ExpressibleByArrayLiteral, 实现了数组可以从[1, 2, 3] 这种字面值初始化的能力</p><h2 id="编译选项-whole-module-optmization-优化了什么"><a href="#编译选项-whole-module-optmization-优化了什么" class="headerlink" title="编译选项 whole module optmization 优化了什么"></a>编译选项 whole module optmization 优化了什么</h2><p>编译器可以跨文件优化编译代码, 不局限于一个文件</p><h2 id="下面代码中-mutating-的作用是什么"><a href="#下面代码中-mutating-的作用是什么" class="headerlink" title="下面代码中 mutating 的作用是什么"></a>下面代码中 mutating 的作用是什么</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">mutating</span> <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> store</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让不可变对象无法访问 name 属性</p><h2 id="为什么数组索引越界会崩溃，而字典用下标取值时-key-没有对应值的话返回的是-nil-不会崩溃"><a href="#为什么数组索引越界会崩溃，而字典用下标取值时-key-没有对应值的话返回的是-nil-不会崩溃" class="headerlink" title="为什么数组索引越界会崩溃，而字典用下标取值时 key 没有对应值的话返回的是 nil 不会崩溃"></a>为什么数组索引越界会崩溃，而字典用下标取值时 key 没有对应值的话返回的是 nil 不会崩溃</h2><p>数组的对象的储蓄地址是连续的，如果越界了，那取到的地址不一定可用，所以报错。字典的key并没有对应确定的内存地址,所以是安全的.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Array</span>&lt;<span class="title class_">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Element</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dictionary</span>&lt;<span class="title class_">Key</span>: <span class="title class_">Hashable</span>, <span class="title class_">Value</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">key</span>: <span class="type">Key</span>) -&gt; <span class="type">Value</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lazy-懒加载的实现"><a href="#lazy-懒加载的实现" class="headerlink" title="lazy 懒加载的实现"></a>lazy 懒加载的实现</h2><p>lazy懒加载,oc中实利用get方法实现, swift利用闭包实现.比如</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">var</span> navLeftButton <span class="operator">=</span> &#123; () -&gt; <span class="type">UIButton</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> btn <span class="operator">=</span> <span class="type">UIButton</span>(type: .custom)</span><br><span class="line">        btn.frame <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">50</span>, height: <span class="number">30</span>)</span><br><span class="line">        btn.setImage(<span class="type">UIImage</span>(named:<span class="string">&quot;back&quot;</span>), for: .normal)</span><br><span class="line">        btn.addTarget(<span class="keyword">self</span>, action: <span class="keyword">#selector</span>(<span class="keyword">self</span>.back), for: .touchUpInside)</span><br><span class="line">        <span class="keyword">return</span> btn</span><br><span class="line">    &#125;()</span><br></pre></td></tr></table></figure><h2 id="Swift中的常量和OC中的常量有啥区别？"><a href="#Swift中的常量和OC中的常量有啥区别？" class="headerlink" title="Swift中的常量和OC中的常量有啥区别？"></a>Swift中的常量和OC中的常量有啥区别？</h2><p>OC中的常量（const）是编译期决定的，Swift中的常量（let）是运行时确定的</p><h2 id="map-与-flatmap-的区别"><a href="#map-与-flatmap-的区别" class="headerlink" title="map 与 flatmap 的区别"></a>map 与 flatmap 的区别</h2><p>map不能将元素映射成可选类型，flatmap可以</p><h2 id="如何自定义模式匹配"><a href="#如何自定义模式匹配" class="headerlink" title="如何自定义模式匹配"></a>如何自定义模式匹配</h2><p><a href="https://swift.gg/2016/04/28/pattern-matching-3/"> 自定义的模式匹配和语法糖</a></p><h2 id="计算属性-和-存储属性"><a href="#计算属性-和-存储属性" class="headerlink" title="计算属性 和 存储属性"></a>计算属性 和 存储属性</h2><p>计算属性可以用于类、结构体和枚举，而存储属性只能用于类和结构体。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/504681687">2022新Swift 面试题</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift高阶函数 Map,Flatmap,Filter,Reduce的用法</title>
      <link href="/2023/03/07/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%20Map,Flatmap,Filter,Reduce%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2023/03/07/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%20Map,Flatmap,Filter,Reduce%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="高阶函数-Map-Flatmap-Filter-Reduce的用法"><a href="#高阶函数-Map-Flatmap-Filter-Reduce的用法" class="headerlink" title="高阶函数 Map,Flatmap,Filter,Reduce的用法"></a>高阶函数 Map,Flatmap,Filter,Reduce的用法</h2><span id="more"></span><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>map:map方法作用是把数组[T]通过闭包函数把每一个数组中的元素变成U类型的值，最后组成数组[U]。</p><p>定义如下：</p><p><code>func map(transform: (T) -&gt; U) -&gt; [U]</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">map</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt;(<span class="params">xs</span>: [<span class="type">T</span>], <span class="params">f</span>: <span class="type">T</span> -&gt; <span class="type">U</span>) -&gt; [<span class="type">U</span>]</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">var</span> result: [<span class="type">U</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> xs </span><br><span class="line">    &#123;</span><br><span class="line">        result.append(f(x)) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将示例数组，每个数字都加10，获得一个新的数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map函数里面可以直接使用函数作为参数,这里采用函数的方式。</span></span><br><span class="line"><span class="keyword">let</span> numberArray <span class="operator">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">fmap</span>(<span class="params">a</span> : <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result <span class="operator">=</span> numberArray.map(fmap)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用闭包的方式</span></span><br><span class="line"><span class="keyword">var</span> result <span class="operator">=</span> numberArray.map(&#123;(<span class="variable">$0</span>) <span class="operator">+</span> <span class="number">10</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>map不只是可以用来做简单的数值运算，还可以处理一些其他复杂操作，如：在数字后拼接字符串，返回新的数组</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resultArray <span class="operator">=</span> numberArray.map(&#123;<span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>)</span>只&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(resultArray)</span><br></pre></td></tr></table></figure><h3 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h3><p>flatMap 更加强大，可以传入N个处理方法，将处理后得到数据，组合到同一个数组中</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resultArray <span class="operator">=</span> numberArray.flatMap(&#123;[<span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>)</span>个&quot;</span>,<span class="string">&quot;<span class="subst">\(<span class="variable">$0</span> )</span>只&quot;</span>]&#125;)</span><br><span class="line"><span class="built_in">print</span>(resultArray)</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"></span><br><span class="line">[<span class="string">&quot;1个&quot;</span>, <span class="string">&quot;1只&quot;</span>, <span class="string">&quot;2个&quot;</span>, <span class="string">&quot;2只&quot;</span>, <span class="string">&quot;3个&quot;</span>, <span class="string">&quot;3只&quot;</span>, <span class="string">&quot;4个&quot;</span>, <span class="string">&quot;4只&quot;</span>, <span class="string">&quot;5个&quot;</span>, <span class="string">&quot;5只&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>filter就是筛选的功能，参数是一个用来判断是否筛除的筛选闭包，根据闭包函数返回的Bool值来过滤值。为True则加入到结果数组中。定义如下：<br><code>func filter(includeElement: (T) -&gt; Bool) -&gt; [T]</code></p><p>找出数组中大于2的数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filteredArray : [<span class="type">Int</span>] <span class="operator">=</span> []</span><br><span class="line">filteredArray <span class="operator">=</span> numberArray.filter(&#123;<span class="variable">$0</span> <span class="operator">&gt;</span> <span class="number">2</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(filteredArray)</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>reduce的作用给定一个类型为U的初始值，把数组[T]中每一个元素传入到combine的闭包函数里面，通过计算得到最终类型为U的结果值。</p><p>定义如下：</p><p><code>func reduce(initial: U, combine: (U, T) -&gt; U) -&gt; U</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">reduce</span>&lt;<span class="type">A</span>, <span class="type">R</span>&gt;(<span class="params">arr</span>: [<span class="type">A</span>], <span class="keyword">_</span> <span class="params">initialValue</span>: <span class="type">R</span>, <span class="params">combine</span>: (<span class="type">R</span>, <span class="type">A</span>) -&gt; <span class="type">R</span>) -&gt; <span class="type">R</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="operator">=</span> initialValue</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr</span><br><span class="line">    &#123;</span><br><span class="line">        result <span class="operator">=</span> combine(result, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> input <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum <span class="operator">=</span> reduce(input, <span class="number">0</span>)&#123; x, y <span class="keyword">in</span> x <span class="operator">+</span> y &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>计算数组中所有数字的和，积</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">sum <span class="operator">=</span> numberArray.reduce(<span class="number">0</span>, combine: &#123;<span class="variable">$0</span> <span class="operator">+</span> <span class="variable">$1</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(sum)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift面试基础题</title>
      <link href="/2023/03/06/Swift%20%E5%9F%BA%E7%A1%80%E9%A2%98/"/>
      <url>/2023/03/06/Swift%20%E5%9F%BA%E7%A1%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="Struct和Class的区别"><a href="#Struct和Class的区别" class="headerlink" title="Struct和Class的区别"></a>Struct和Class的区别</h3><ol><li>Struct不支持继承、Class支持继承</li><li>Struct是值类型，Class是引用类型</li><li>Struct无法修改自身属性值，函数需要添加mutating关键字</li><li>Struct初始化方法是基于属性的</li><li>Struct不需要deinit方法，因为值类型不关心引用计数，Class需要deinit方法。</li></ol><p>结构体不可以继承</p><span id="more"></span><h3 id="Swift值类型的写时复制"><a href="#Swift值类型的写时复制" class="headerlink" title="Swift值类型的写时复制"></a>Swift值类型的写时复制</h3><ul><li><p>只有当一个结构体发生了写入行为时才会有复制行为。</p></li><li><p>在结构体内部用一个引用类型来存储实际的数据，在不进行写入操作的普通传递过程中，都是将内部的reference的应用计数+1，在进行写入操作时，对内部的reference做一次copy操作用来存储新的数据，防止和之前的reference产生意外的数据共享。</p></li><li><p>swift中提供该<code>[isKnownUniquelyReferenced]</code>函数，他能检查一个类的实例是不是唯一的引用，如果是，我们就不需要对结构体实例进行复制，如果不是，说明对象被不同的结构体共享，这时对它进行更改就需要进行复制。</p></li></ul><h3 id="defer的用法"><a href="#defer的用法" class="headerlink" title="defer的用法"></a>defer的用法</h3><p>使用defer代码块来表示在函数返回前，函数中最后执行的代码。无论函数是否会抛出错误，这段代码都将执行。</p><p>defer 语句块中的代码, 会在当前作用域结束前调用。每当一个作用域结束就进行该作用域defer执行。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">doSomethingFile</span>&#123;</span><br><span class="line"> openDirectory()</span><br><span class="line"> <span class="keyword">defer</span>&#123;</span><br><span class="line">    closeDirectory()</span><br><span class="line"> &#125;</span><br><span class="line"> openFile()</span><br><span class="line"> <span class="keyword">defer</span>&#123;</span><br><span class="line">    closeFile()</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// do other things</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="static和class的区别"><a href="#static和class的区别" class="headerlink" title="static和class的区别"></a>static和class的区别</h3><p>在Swift中static和class都表示“类型范围作用域”的关键字。<br>在所有类型中（class、static、enum）中，我们可以使用static来描述类型作用域。<code>class是专门用于修饰class类型的</code>。</p><h4 id="static可以修饰属性和方法"><a href="#static可以修饰属性和方法" class="headerlink" title="static可以修饰属性和方法"></a>static可以修饰属性和方法</h4><ul><li>所修饰的属性和方法不能够被重写。 </li><li>static修饰的类方法和属性包含了final关键字的特性，重写会报错</li></ul><h4 id="class修饰方法和计算属性"><a href="#class修饰方法和计算属性" class="headerlink" title="class修饰方法和计算属性"></a>class修饰方法和计算属性</h4><ul><li>我们同样可以使用class修饰方法和计算属性，但是不能够修饰存储属性。</li><li>类方法和计算属性是可以被重写的，可以使用class关键字也可以是static</li></ul><h3 id="mutating关键字的使用？"><a href="#mutating关键字的使用？" class="headerlink" title="mutating关键字的使用？"></a>mutating关键字的使用？</h3><p>类是引用类型，而结构和枚举是值类型。默认情况下，不能在其实例方法中修改值类型的属性。为了修改值类型的属性，必须在实例方法中使用mutating关键字。使用此关键字，您的方法将能够更改属性的值，并在方法实现结束时将其写回到原始结构</p><h3 id="闭包是引用类型吗？"><a href="#闭包是引用类型吗？" class="headerlink" title="闭包是引用类型吗？"></a>闭包是引用类型吗？</h3><p>闭包是引用类型。如果一个闭包被分配给一个变量，这个变量复制给另一个变量，那么他们引用的是同一个闭包，他们的捕捉列表也会被复制。</p><p>闭包和函数是引用类型，将函数或闭包赋值给一个常量还是变量，实际上都是将常量或变量的值设置为对应函数或闭包的引用。</p><h3 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h3><p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">request</span>(<span class="params">result</span>:<span class="keyword">@escaping</span>((<span class="type">String</span>)-&gt;()))&#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(wallDeadline: <span class="type">DispatchWallTime</span>.now() <span class="operator">+</span> <span class="number">10</span>) &#123;</span><br><span class="line">        result(<span class="string">&quot;数据结果&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逃逸闭包的生命周期是长于函数的。</p><p>逃逸闭包的生命周期：</p><ol><li>闭包作为参数传递给函数；</li><li>退出函数；</li><li>闭包被调用，闭包生命周期结束。</li></ol><p>非逃逸闭包, 永远不会离开一个函数的局部作用域的闭包就是非逃逸闭包。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">player</span>(<span class="params">complete</span>:(<span class="type">Bool</span>)-&gt;())&#123;</span><br><span class="line">    complete(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非逃逸闭包的生命周期：</p><ol><li>闭包作为参数传给函数；</li><li>函数中运行改闭包；</li><li>退出函数。</li></ol><h3 id="为什么要分逃逸闭包和非逃逸闭包"><a href="#为什么要分逃逸闭包和非逃逸闭包" class="headerlink" title="为什么要分逃逸闭包和非逃逸闭包"></a>为什么要分逃逸闭包和非逃逸闭包</h3><p>为了管理内存，闭包会强引用它捕获的所有对象，比如你在闭包中访问了当前控制器的属性、函数，编译器会要求你在闭包中显示 self 的引用，这样闭包会持有当前对象，容易导致循环引用。<br>而对于非逃逸闭包：</p><p>非逃逸闭包不会产生循环引用，它会在函数作用域内释放，编译器可以保证在函数结束时闭包会释放它捕获的所有对象。<br>使用非逃逸闭包可以使编译器应用更多强有力的性能优化，例如，当明确了一个闭包的生命周期的话，就可以省去一些保留（retain）和释放（release）的调用。<br>非逃逸闭包它的上下文的内存可以保存在栈上而不是堆上。</p><h3 id="String-与-NSString-区别？"><a href="#String-与-NSString-区别？" class="headerlink" title="String 与 NSString 区别？"></a>String 与 NSString 区别？</h3><p>根本区别： String 是结构体， NSString 是类</p><h3 id="怎么获取一个-String-的长度？"><a href="#怎么获取一个-String-的长度？" class="headerlink" title="怎么获取一个 String 的长度？"></a>怎么获取一个 String 的长度？</h3><p>Objc 中读取 NSString 长度使用的是 .length，length返回的是基于 UTF-16 的长度<br>在 Swift 中读取 String 的长度，通常使用的是 count，而 count 本身返回的是 characters.count，只是 Unicode 字符个数。这两者的区别在纯文本中看不出来，但是包含 Emoji 的时候就十分明显了</p><p>举个例子：“😆😆😆😆😆😆”，用 Objc 的 length 读取返回的是12，而用 Swift 的 count 读取返回的是6，这在做一些富文本插入操作时，得到的结果绝不会是你想要的。</p><p>Swift 有专门的 utf16.count 来对应 NSString 的 .length，在使用的时候只需要 string.utf16.count就可以得到与 Objc 中 length 相同的结果</p><p><a href="https://cloud.tencent.com/developer/article/2073711">Swift中的空字符串</a>  </p><h3 id="如何截取-String-的某段字符串"><a href="#如何截取-String-的某段字符串" class="headerlink" title="如何截取 String 的某段字符串"></a>如何截取 String 的某段字符串</h3><p>需要使用 String.Index 来确定要截取的范围,<code>substring:to , substring:from,  substring:with.</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> simpleString <span class="operator">=</span> <span class="string">&quot;Hello, world&quot;</span></span><br><span class="line">simpleString.substring(to: simpleString.index(simpleString.startIndex, offsetBy: <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line">simpleString.substring(from: simpleString.index(simpleString.endIndex, offsetBy: <span class="operator">-</span><span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line">simpleString.substring(with: simpleString.index(simpleString.startIndex, offsetBy: <span class="number">5</span>) <span class="operator">..&lt;</span> simpleString.index(simpleString.endIndex, offsetBy: <span class="operator">-</span><span class="number">5</span>))</span><br><span class="line"><span class="comment">// ,</span></span><br></pre></td></tr></table></figure><h3 id="throws-和-rethrows-的用法与作用"><a href="#throws-和-rethrows-的用法与作用" class="headerlink" title="throws 和 rethrows 的用法与作用"></a>throws 和 rethrows 的用法与作用</h3><p>throws 用在函数上, 表示这个函数会抛出错误.<br>有两种情况会抛出错误,<br> 一种是直接使用 throw 抛出,<br> 另一种是调用其他抛出异常的函数时, 直接使用 try xx 没有处理异常.<br>如</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">DivideError</span>: <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">EqualZeroError</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">divide</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Double</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Double</span>) <span class="keyword">throws</span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> b <span class="operator">!=</span> <span class="type">Double</span>(<span class="number">0</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//1. 方法内部直接抛出</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="type">DivideError</span>.<span class="type">EqualZeroError</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">/</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">split</span>(<span class="params">pieces</span>: <span class="type">Int</span>) <span class="keyword">throws</span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="comment">//2. Try 调用的内部方法抛出 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> divide(<span class="number">1</span>, <span class="type">Double</span>(pieces))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rethrows 与 throws 类似, 不过只适用于参数中有函数, 且函数会抛出异常的情况, rethrows 可以用 throws 替换, 反过来不行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">processNumber</span>(<span class="params">a</span>: <span class="type">Double</span>, <span class="params">b</span>: <span class="type">Double</span>, <span class="params">functionC</span>: (<span class="type">Double</span>, <span class="type">Double</span>) <span class="keyword">throws</span> -&gt; <span class="type">Double</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> functionC(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="try-try-try-的区别"><a href="#try-try-try-的区别" class="headerlink" title="try try? try! 的区别"></a>try try? try! 的区别</h3><p>这两个都用于处理可抛出异常的函数, 使用这两个关键字可以不用写 do catch</p><ul><li>try 出现异常处理异常</li><li>try? 不处理异常,返回一个可选值类型,出现异常返回nil</li><li>try! 不让异常继续传播,一旦出现异常程序停止,类似NSAssert()</li></ul><h3 id="associatedtype的作用："><a href="#associatedtype的作用：" class="headerlink" title="associatedtype的作用："></a>associatedtype的作用：</h3><p>简单来说就是 protocol 使用的泛型</p><h3 id="什么时候使用-final？"><a href="#什么时候使用-final？" class="headerlink" title="什么时候使用 final？"></a>什么时候使用 final？</h3><p>final关键字可以用在class ，func和var前面进行修饰，表示不允许对内容进行继承或者重写操作。 给一段代码加上final 就意味着你告诉编译器这段代码不会再被修改。</p><h3 id="public-和-open-的区别"><a href="#public-和-open-的区别" class="headerlink" title="public 和 open 的区别"></a>public 和 open 的区别</h3><p>这两个都用于在模块中声明需要对外界暴露的函数, 区别在于, public 修饰的类, 在模块外无法继承,<br> 而 open 则可以任意继承, 公开度来说, public &lt; open</p><h3 id="声明一个只有一个参数没有返回值闭包的别名"><a href="#声明一个只有一个参数没有返回值闭包的别名" class="headerlink" title="声明一个只有一个参数没有返回值闭包的别名"></a>声明一个只有一个参数没有返回值闭包的别名</h3><p>没有返回值也就是返回值为 Void</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">SomeClosuerType</span> <span class="operator">=</span> (<span class="type">String</span>) -&gt; (<span class="type">Void</span>)</span><br><span class="line"><span class="keyword">let</span> someClosuer: <span class="type">SomeClosuerType</span> <span class="operator">=</span> &#123; (name: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello,&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line">someClosuer(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"><span class="comment">// hello, world</span></span><br></pre></td></tr></table></figure><h3 id="Self-的使用场景"><a href="#Self-的使用场景" class="headerlink" title="Self 的使用场景"></a>Self 的使用场景</h3><p>Self 通常在协议中使用, 用来表示实现者或者实现者的子类类型.</p><p>如, 定义一个复制的协议</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">CopyProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">copy</span>() -&gt; <span class="keyword">Self</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是结构体去实现, 要将Self 换为具体的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeStruct</span>: <span class="title class_">CopyProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">copySelf</span>() -&gt; <span class="type">SomeStruct</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">SomeStruct</span>(value: <span class="keyword">self</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是类去实现, 则有点复杂, 需要有一个 required 初始化方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeCopyableClass</span>: <span class="title class_">CopyProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">copySelf</span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(of: <span class="keyword">self</span>).<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type-of-vs-self"><a href="#type-of-vs-self" class="headerlink" title="type(of:) vs .self"></a>type(of:) vs .self</h3><p>通过 type(of:) 和 .self都可以获得元类型的值。那么这两种方式的区别是什么呢？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> instanceMetaType: <span class="type">String</span>.<span class="keyword">Type</span> <span class="operator">=</span> <span class="built_in">type</span>(of: <span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> staicMetaType: <span class="type">String</span>.<span class="keyword">Type</span> <span class="operator">=</span> <span class="type">String</span>.<span class="keyword">self</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myNum: <span class="keyword">Any</span> <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line"><span class="built_in">type</span>(of: myNum) <span class="comment">// Int.type</span></span><br></pre></td></tr></table></figure><p>self 取到的是静态的元类型，声明的时候是什么类型就是什么类型。type(of:) 取的是运行时候的元类型，也就是这个实例 的类型。</p><h3 id="dynamic-的作用"><a href="#dynamic-的作用" class="headerlink" title="dynamic 的作用"></a>dynamic 的作用</h3><p>由于 swift 是一个静态语言, 所以没有 Objective-C 中的消息发送这些动态机制, dynamic 的作用就是让 swift 代码也能有 Objective-C 中的动态机制, 常用的地方就是 KVO 了, 如果要监控一个属性, 则必须要标记为 dynamic</p><h3 id="什么时候使用-objc"><a href="#什么时候使用-objc" class="headerlink" title="什么时候使用 @objc"></a>什么时候使用 @objc</h3><p>@objc 用途是为了在 Objective-C 和 Swift 混编的时候, 能够正常调用 Swift 代码. 可以用于修饰类, 协议, 方法, 属性。<br>常用的地方是在定义 delegate 协议中, 会将协议中的部分方法声明为可选方法, 需要用到@objc</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">protocol</span> <span class="title class_">OptionalProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">optional</span> <span class="keyword">func</span> <span class="title function_">optionalFunc</span>()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">normalFunc</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OptionProtocolClass</span>: <span class="title class_">OptionalProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">normalFunc</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> someOptionalDelegate: <span class="type">OptionalProtocol</span> <span class="operator">=</span> <span class="type">OptionProtocolClass</span>()</span><br><span class="line">someOptionalDelegate.optionalFunc<span class="operator">?</span>()</span><br></pre></td></tr></table></figure><h3 id="Optional（可选型）-是用什么实现的"><a href="#Optional（可选型）-是用什么实现的" class="headerlink" title="Optional（可选型） 是用什么实现的"></a>Optional（可选型） 是用什么实现的</h3><p>Optional 是一个泛型枚举<br>大致定义如下:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Optional</span>&lt;<span class="title class_">Wrapped</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">case</span> none</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">some</span>(<span class="type">Wrapped</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用 let someValue: Int? &#x3D; nil 之外, 还可以使用let optional1: Optional<Int> &#x3D; nil 来定义</p><h3 id="下面的代码会不会崩溃，说出原因"><a href="#下面的代码会不会崩溃，说出原因" class="headerlink" title="下面的代码会不会崩溃，说出原因"></a>下面的代码会不会崩溃，说出原因</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutableArray <span class="operator">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> mutableArray &#123;</span><br><span class="line">     mutableArray.removeLast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不会, 原理不清楚, 就算是把 removeLast(), 换成 removeAll() ,这个循环也会执行count次, 估计是在一开始, for in 就对 mutableArray 进行了一次值捕获,<br>而 Array 是一个值类型 , removeLast() 并不能修改捕获的值。</p><h3 id="给集合中元素是字符串的类型增加一个扩展方法，应该怎么声明"><a href="#给集合中元素是字符串的类型增加一个扩展方法，应该怎么声明" class="headerlink" title="给集合中元素是字符串的类型增加一个扩展方法，应该怎么声明"></a>给集合中元素是字符串的类型增加一个扩展方法，应该怎么声明</h3><p>使用 where 子句, 限制 Element 为 String</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span> <span class="title class_">where</span> <span class="title class_">Element</span> == <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isStringElement:<span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>].isStringElement</span><br><span class="line"><span class="comment">//[1, 2].isStringElement// error</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/7006186681296486437">Swift 基础题</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>define</title>
      <link href="/2023/02/01/define%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/02/01/define%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>define命令是C语言中的一个宏定义命令，它用来将一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本</p><span id="more"></span><h2 id="有参宏定义"><a href="#有参宏定义" class="headerlink" title="有参宏定义"></a>有参宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名(形参数表) 字符串</span></span><br></pre></td></tr></table></figure><p>在使用时调用带参宏调用的一般形式为：宏名(实参表)；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> add(x, y) (x + y)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1 plus 1 is &quot;</span> &lt;&lt; add(<span class="number">1</span>, <span class="number">1.5</span>) &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    <span class="comment">//输出“1 plus 1 is 2.5.”</span></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个“函数”定义了加法，但是该“函数”没有类型检查，有点类似模板，但没有模板安全，可以看做一个简单的模板。</p><h2 id="宏定义中的特殊操作符"><a href="#宏定义中的特殊操作符" class="headerlink" title="宏定义中的特殊操作符"></a>宏定义中的特殊操作符</h2><p>define 中的特殊操作符有<code>#，##和… and __VA_ARGS__</code></p><p>1）#<br>假如希望在字符串中包含宏参数，ANSI C允许这样作，在类函数宏的替换部分，#符号用作一个预处理运算符，它可以把语言符号转化程字符串。例如，如果x是一个宏参量，那么#x可以把参数名转化成相应的字符串。该过程称为字符串化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PSQR(x) printf(<span class="string">&quot;the square of&quot;</span> #x <span class="string">&quot;is %d.\n&quot;</span>,(x)*(x))</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> y =<span class="number">4</span>;</span><br><span class="line">    PSQR(y);</span><br><span class="line">    <span class="comment">//输出：the square of y is 16.</span></span><br><span class="line">    PSQR(<span class="number">2</span>+<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//输出：the square of 2+4 is 36.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）##</p><p><code>##</code>运算符可以用于类函数宏的替换部分。另外，##还可以用于类对象宏的替换部分。这个运算符把两个语言符号组合成单个语言符号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XNAME(n) x##n</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXN(n) printf(<span class="string">&quot;x&quot;</span>#n<span class="string">&quot; = %d\n&quot;</span>,x##n)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">XNAME</span><span class="params">(<span class="number">1</span>)</span>=<span class="number">12</span>;<span class="comment">//int x1=12;</span></span><br><span class="line">    PXN(<span class="number">1</span>);<span class="comment">//printf(&quot;x1 = %d\n&quot;, x1);</span></span><br><span class="line">    <span class="comment">//输出：x1=12</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> YLLoadRequest(REQUEST_METHOD, REQUEST_ID)                                               \</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">__weak typeof(self) weakSelf = self;\</span></span><br><span class="line"><span class="meta">REQUEST_ID = [[YLAPIProxy sharedInstance] load##REQUEST_METHOD##WithParams:finalAPIParams useJSON:self.isRequestUsingJSON host:self.host path:self.child.path apiVersion:self.child.apiVersion success:^(YLResponseModel *response) &#123;\</span></span><br><span class="line"><span class="meta">    __strong typeof(weakSelf) strongSelf = weakSelf;\</span></span><br><span class="line"><span class="meta">    [strongSelf dataDidLoad:response];\</span></span><br><span class="line"><span class="meta">&#125; fail:^(YLResponseError *<span class="keyword">error</span>) &#123;\</span></span><br><span class="line"><span class="meta">    __strong typeof(weakSelf) strongSelf = weakSelf;\</span></span><br><span class="line"><span class="meta">    [strongSelf dataLoadFailed:<span class="keyword">error</span>];\</span></span><br><span class="line"><span class="meta">&#125;];\</span></span><br><span class="line"><span class="meta">self.requestIdMap[@(REQUEST_ID)]= @(REQUEST_ID);\</span></span><br><span class="line"><span class="meta">&#125;\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"></span><br><span class="line">YLLoadRequest(GET, requestId);</span><br><span class="line"></span><br><span class="line">YLLoadRequest(POST, requestId);</span><br></pre></td></tr></table></figure><p>（3）可变参数宏 …和__VA_ARGS__</p><p><code>__VA_ARGS__</code> 是一个可变参数的宏，很少人知道这个宏，这个可变参数的宏是新的C99规范中新增的，目前似乎只有gcc支持（VC6.0的编译器不支持）。<br>实现思想就是宏定义中参数列表的最后一个参数为省略号（也就是三个点）。这样预定义宏<code>__VA_ARGS__</code>就可以被用在替换部分中，替换省略号所代表的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PR(...) printf(__VA_ARGS__)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> wt=<span class="number">1</span>,sp=<span class="number">2</span>;</span><br><span class="line">    PR(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="comment">//输出：hello</span></span><br><span class="line">    PR(<span class="string">&quot;weight = %d, shipping = %d&quot;</span>,wt,sp);</span><br><span class="line">    <span class="comment">//输出：weight = 1, shipping = 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//YYThreadSafeArray</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT(...) self = super.init; \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (!self) return nil; \</span></span><br><span class="line"><span class="meta">__VA_ARGS__; \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (!_arr) return nil; \</span></span><br><span class="line"><span class="meta">_lock = dispatch_semaphore_create(1); \</span></span><br><span class="line"><span class="meta">return self;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK(...) dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER); \</span></span><br><span class="line"><span class="meta">__VA_ARGS__; \</span></span><br><span class="line"><span class="meta">dispatch_semaphore_signal(_lock);</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u012611878/article/details/52534622">c&#x2F;c++中define用法详解及代码示例</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Objective-C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ObjC和Swift混编</title>
      <link href="/2023/01/17/ObjC%E5%92%8CSwift%E6%B7%B7%E7%BC%96/"/>
      <url>/2023/01/17/ObjC%E5%92%8CSwift%E6%B7%B7%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<p>概述</p><p>随着Xcode 11、Swift 5.0的发布，Swift目前已经实现了ABI稳定及模块稳定，并且<code>Swift runtime</code>和标准库已经植入系统中，而且苹果新出文档都用Swift，Sample Code也是Swift，可以看出Swift是苹果扶持与研发的重点方向。</p><p>对于新App来说，可以直接用纯Swift进行开发，而对于老App来说，绝大部分以前都是用OC开发的，因此Swift&#x2F;OC混编是一个必然面临的问题。</p><span id="more"></span><h2 id="ObjC和Swift混编"><a href="#ObjC和Swift混编" class="headerlink" title="ObjC和Swift混编"></a>ObjC和Swift混编</h2><p><code>OC/Swift </code>调用 <code>Swift</code>，最终通过 <code>Swift Module</code> 进行，而 <code>Swift</code> 调用 <code>OC</code> 时，则是通过 <code>Clang Module</code>，当然也可以通过 <code>Clang Module</code> 进行 OC 对 OC 的调用。</p><h2 id="同一工程内的混编"><a href="#同一工程内的混编" class="headerlink" title="同一工程内的混编"></a>同一工程内的混编</h2><h3 id="宿主工程利用桥接文件-Bridging-Header-h-进行混编"><a href="#宿主工程利用桥接文件-Bridging-Header-h-进行混编" class="headerlink" title="宿主工程利用桥接文件(Bridging-Header.h)进行混编"></a>宿主工程利用桥接文件(Bridging-Header.h)进行混编</h3><ul><li><p>Swift访问Obje-C<br>只需要在桥接文件中(<code>Bridging-Header.h</code>)导入需要暴露给Swift模块的Objective-C类，即可在Swift中访问相应Objective-C的类和方法</p></li><li><p>Objective-C访问Swift<br>在Objective-C类中导入<code>ProductName-Swift.h</code>，即可访问Swift中暴露给Objective-C的类和方法</p></li></ul><h3 id="利用cocoapods包管理工具，进行二-x2F-三方库混编"><a href="#利用cocoapods包管理工具，进行二-x2F-三方库混编" class="headerlink" title="利用cocoapods包管理工具，进行二&#x2F;三方库混编"></a>利用cocoapods包管理工具，进行二&#x2F;三方库混编</h3><ul><li><p>Swift访问Obj-C<br>用Swift Module系统，需要用到的Objective-C类用<code>import xxx</code>进行引用，即可在Swift中访问相应的Objective-c的类和方法</p></li><li><p>Objective-C访问Swift<br>在Objective-c类中导入<code>ProductName-Swift.h</code>，即可访问Swift中暴露给Objective-C的类和方法</p></li></ul><h2 id="Module系统"><a href="#Module系统" class="headerlink" title="Module系统"></a>Module系统</h2><h3 id="LLVM-Module系统"><a href="#LLVM-Module系统" class="headerlink" title="LLVM Module系统"></a>LLVM Module系统</h3><p>苹果在 2012 年 11 月提出 <code>LLVM</code> 的 <code>Module</code> 系统，简单讲就是用树形的结构化的描述来取代以往 <code>#include</code> ，例如传统的<code>#include</code> 现在变成 <code>import std.io</code></p><p>意义：</p><ul><li>语义上完整描述了一个框架的作用</li><li>提高编译时的可扩展性，同一模块只需编译或导入一次，避免了头文件的多次引用、解析</li><li>减少碎片化，每个模块只处理一次，环境的变化不会导致不一致</li></ul><h3 id="modulemap文件"><a href="#modulemap文件" class="headerlink" title="modulemap文件"></a>modulemap文件</h3><p><code>modulemap</code>文件就是对一个框架，一个库的所有文件的结构化描述。默认文件名是<code>module.modulemap</code></p><h3 id="Swift-Module"><a href="#Swift-Module" class="headerlink" title="Swift Module"></a>Swift Module</h3><p>SwiftModule 可以将 Swift 解析后生成对应的 modulemap 和 umbrella.h 文件，SwiftModule 增加对编译器版本的依赖，编译产物与编译器 和 Swift 版本有关。如果想要实现 Swift 和 Objective-C 的互相访问，需要 Objective-C 库，以及对应的 umbrella.h 和 modulemap 支持。其中动态库 framework 是 Xcode 支持配置并生成 header，静态库 .a 需要自己编写对应的 umbrella.h 和 modulemap。即库之间无论何种语言实现，均需要封装为 <code>LLVM Module</code> 来相互访问。</p><h4 id="Cocoapods配置"><a href="#Cocoapods配置" class="headerlink" title="Cocoapods配置"></a>Cocoapods配置</h4><p> use_ modular_ headers! 配置将三方库构建成静态库，或者 use_frameworks! 配置将三方库构建成动态库时，在编译产物中都会生成一个 modulemap 和 module umbrella.h 文件</p><p><code> use_ modular_ headers！</code>是 Cocoapods 1.5.0 引入的配置，目的是为了满足 Xcode 9 以后支持的 Swift Static Libraries ，将 Swift Pods 构建成为静态库</p><ul><li>如果你的 Swift Pod 依赖于 Objective-C，那么你需要为这个 Objective-C 库启用 modular_headers</li><li>对于 pod 开发者可以在 podtargetxcconfig 内添加 ’DEFINES_MODULE’&#x3D;&gt;‘YES’，对于使用者在 podfile 内添加 <code>use _modular _headers!</code></li><li>在 podspec 中通过 modular_headers &#x3D;&gt; true 配置特定的 pod</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tech.youzan.com/swifthe-objective-chun-bian-zai-you-zan-yi-dong-de-shi-jian/">Swift和Objective-C混编在有赞移动的实践</a><br><a href="https://tech.meituan.com/2021/02/25/swift-objective-c.html">从预编译的角度理解Swift与Objective-C及混编机制</a><br><a href="https://blog.csdn.net/csdnnews/article/details/120139297">Swift与Objective-C混编时，我们是如何将编译时间优化了35%</a></p><p>一方：（一方包，一方库），一般指的是本项目或者本工程中的类和方法、接口等。<br>二方：（二方包，二方库），一般指的是公司内部的依赖库，公司内部其他项目发布的jar包，如公司项目平台的核心依赖包。<br>三方：（三方包，三方库），一般指的是外部的开源库或开源项目贡献的jar， 比如apache、google、Ali等发布的依赖</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【译】减少共享内存页</title>
      <link href="/2022/12/20/%E5%87%8F%E5%B0%91%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E9%A1%B5/"/>
      <url>/2022/12/20/%E5%87%8F%E5%B0%91%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="减少共享内存页"><a href="#减少共享内存页" class="headerlink" title="减少共享内存页"></a>减少共享内存页</h2><p>正如Mach-O可执行格式概述中所述，Mach-O二进制文件的__DATA段中的数据是可写的，因此是可共享的(通过写时复制)。在内存不足的情况下，可写数据会增加可能需要写入磁盘的页数，从而降低分页性能。对于frameworks，可写数据最初是共享的，但有可能被复制到每个进程的内存空间。 </p><p>减少可执行文件中动态或非常量数据(non-constant)的数量会对性能产生重大影响(significant)，特别是对于frameworks。以下章节将向您展示如何减少可执行文件的<code>__DATA</code>段的大小，从而减少共享内存页面的数量。</p><span id="more"></span><h2 id="将Data声明为const"><a href="#将Data声明为const" class="headerlink" title="将Data声明为const"></a>将Data声明为const</h2><p>使<code>__DATA</code>段更小的最简单方法是将全局作用域(globally scoped data)的数据标记为常量。大多数时候，很容易将数据标记为常量。例如，如果你永远不打算修改数组中的元素，你应该在数组声明中包含<code>const</code>关键字，如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> fibonacci_table[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>&#125;;</span><br></pre></td></tr></table></figure><p>记住将指针标记为常量(在适当的时候)。在下面的例子中，字符串”a”和”b”是常量，但数组指针foo不是常量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *foo[] = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line">foo[<span class="number">1</span>] = <span class="string">&quot;c&quot;</span>;       <span class="comment">// OK: foo[1] is not constant.</span></span><br></pre></td></tr></table></figure><p>要将整个声明标记为常量，需要向指针添加<code>const</code>关键字以使指针成为常量。在下面的例子中，数组和它的内容都是常量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> foo[] = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line">foo[<span class="number">1</span>] = <span class="string">&quot;c&quot;</span>;       <span class="comment">// NOT OK: foo[1] is constant.</span></span><br></pre></td></tr></table></figure><p>有时，您可能希望重写代码以分离出常量数据。下面的示例包含一个结构数组，其中只有一个字段声明为const。因为整个数组没有声明为<code>const</code>，所以它存储在<code>__DATA</code>段中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *imageName;</span><br><span class="line">    NSImage *image;</span><br><span class="line">&#125; images[<span class="number">100</span>] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;FooImage&quot;</span>, nil&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;FooImage2&quot;</span>, nil&#125;</span><br><span class="line">    <span class="comment">// and so on</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了将尽可能多的数据存储在<code>__TEXT</code>段中，创建两个并行(parallel)数组，一个标记为常量，另一个标记为非常量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> imageNames[<span class="number">100</span>] = &#123; <span class="string">&quot;FooImage&quot;</span>, <span class="comment">/* . . . */</span> &#125;;</span><br><span class="line">NSImage *imageInstances[<span class="number">100</span>] = &#123; nil, <span class="comment">/* . . . */</span> &#125;;</span><br></pre></td></tr></table></figure><p>如果未初始化的数据项包含指针，编译器不能将该项存储在<code>__TEXT</code>段中。字符串在<code>__TEXT</code>段的<code>__cstring section</code>中结束，但数据项的其余部分，包括指向字符串的指针，在<code>__DATA</code>段的<code>const section</code>中结束。在下面的例子中，<code>daytimeTable</code>最终会在<code>__TEXT</code>和<code>__DATA</code>段之间分割，尽管它是常量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">daytime</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">daytime</span> <span class="title">daytimeTable</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="string">&quot;dawn&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="string">&quot;day&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="string">&quot;dusk&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="string">&quot;night&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要将整个数组放在<code>__TEXT</code>段中，必须重写此结构，使其使用固定大小(fixed-size)的char数组而不是字符串指针，如下例所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">daytime</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> name[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">daytime</span> <span class="title">daytimeTable</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, &#123;<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不幸的是，如果字符串的大小相差很大，就没有好的解决方案，因为这种解决方案会留下大量未使用的空间。 </p><p>数组被分成两个段，因为编译器总是在<code>__TEXT</code>段的<code>__cstring section</code>中存储常量字符串。如果编译器将数组的其余部分存储在<code>__DATA</code>段的<code>__data section</code>中，则字符串和指向字符串的指针可能会在不同的页面上结束。如果发生这种情况，系统将不得不用新地址更新指向字符串的指针，如果指针在__TEXT段中，则不能这样做，因为__TEXT段被标记为只读。因此指向字符串的指针以及数组的其余部分必须存储在<code>__DATA</code>段的<code>const section</code>中。<code>__const section</code>保留给声明为<code>const</code>的不能放在<code>__TEXT</code>段中的数据。</p><h2 id="初始化静态数据"><a href="#初始化静态数据" class="headerlink" title="初始化静态数据"></a>初始化静态数据</h2><p>正如Mach-O可执行格式概述中所指出的，编译器将未初始化的静态数据存储在__DATA段的<code>__bss section</code>中，并将初始化的数据存储在<code>__data section</code>中。如果你在<code>__bss section</code>中只有少量的静态数据，你可能会考虑将其移动到<code>__data section</code>。将数据存储在两个不同的部分中增加了可执行文件使用的内存页数，这反过来又增加了分页的可能性。 </p><p>合并<code>__bss</code>和<code>__data</code> sections的目的是减少应用程序使用的内存页数。如果将数据移动到<code>__data</code>区域会增加该区域的内存页数，则此技术没有任何好处。事实上，在<code>__data section</code>中添加页面会增加在启动时读取和初始化该数据所花费的时间。 </p><p>假设你声明了以下静态变量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="type">static</span> <span class="type">short</span> conv_table[<span class="number">128</span>];</span><br></pre></td></tr></table></figure><p>要将这些变量移动到可执行文件的<code>__data</code>段的<code>__data section</code>，您将更改定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">short</span> conv_table[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="避免临时定义-Tentative-Definition-符号"><a href="#避免临时定义-Tentative-Definition-符号" class="headerlink" title="避免临时定义(Tentative-Definition)符号"></a>避免临时定义(Tentative-Definition)符号</h2><p>编译器将遇到的任何重复符号放在__DATA段的__common section(参见Mach-O可执行格式概述)。这里的问题与未初始化的静态变量相同。如果一个可执行文件的非常量全局数据分布在几个sections中，则这些数据更有可能位于不同的内存页上;因此，页面可能必须分别交换进和换出(swapped in and out)。<code>__common section</code>的目标与<code>__bss section</code>的目标相同:如果可执行文件中有少量数据，则将其从可执行文件中删除。 </p><p>暂定定义符号的一个常见来源是头文件中该符号的定义。通常，标头声明一个符号，但不包括该符号的定义;定义是在实现文件中提供的。但是出现在头文件中的定义可能导致该代码或数据出现在包含头文件的每个实现文件中。此问题的解决方案是确保头文件只包含声明，而不包含定义。 </p><p>对于函数，你显然会在头文件中声明该函数的原型，并将该函数的定义放在实现文件中。对于全局变量和数据结构，应该执行类似的操作。与其在头文件中定义变量，不如在实现文件中定义它并适当地初始化它。然后，在头文件中用<code>extern</code>关键字声明该变量。这种技术将变量定义本地化到一个文件，同时仍然允许从其他文件访问该变量。</p><p>当您不小心导入相同的头文件两次时，还可以获得临时定义符号。要确保不这样做，请包含预处理器指令，以禁止包含已经包含的文件。因此，在你的头文件中，你会有以下代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYHEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYHEADER_H</span></span><br><span class="line"><span class="comment">// Your header file declarations. . .</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后，当你想要包含这个头文件时，按照以下方式包含它:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYHEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyHeader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="分析Mach-O可执行文件"><a href="#分析Mach-O可执行文件" class="headerlink" title="分析Mach-O可执行文件"></a>分析Mach-O可执行文件</h2><p>你可以使用几种工具来确定非常量数据占用了多少内存。这些工具可以报告数据使用的各个方面。 </p><p>当你的应用程序或framework正在运行时，使用<code>size</code>和<code>pagestuff</code>工具来查看各种data sections有多大以及它们包含哪些符号。需要注意以下几点:</p><ol><li>要查找具有大量非常量数据的可执行文件，请在__DATA段中检查具有较大__data section的文件。 </li><li>检查__bss和__common sections中可以移除或移动到__data section的变量和符号。 </li><li>要定位虽然声明为常量，但编译器不能将其视为常量的数据，请在__DATA段中检查带有__const section的可执行文件或目标文件。</li></ol><p>__DATA段中一些较大的内存消费者是初始化但未声明为<code>const</code>的固定大小的全局数组。有时可以通过在源代码中搜索“<code>[]=&#123;</code>”来找到这些tables。 </p><p>您还可以让编译器帮助您找到可以将数组设置为常量的地方。将<code>const</code>放在所有您怀疑可能是只读的初始化数组前面，然后重新编译。如果一个数组不是真正的只读，它将不会编译。删除错误的<code>const</code>并重试</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【译】最小化导出的符号</title>
      <link href="/2022/12/20/%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AF%BC%E5%87%BA%E7%9A%84%E7%AC%A6%E5%8F%B7/"/>
      <url>/2022/12/20/%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AF%BC%E5%87%BA%E7%9A%84%E7%AC%A6%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="最小化导出的符号"><a href="#最小化导出的符号" class="headerlink" title="最小化导出的符号"></a>最小化导出的符号</h2><p>如果您的应用程序或framework具有公共接口，则应该将导出的符号限制为接口所需的符号。导出的符号会占用可执行文件中的空间，应该尽可能减少。这不仅减少了可执行文件的大小，还减少了动态链接器所做的工作量。 </p><p>默认情况下，Xcode会从项目中导出所有符号。您可以使用下面的信息来识别和删除不想导出的符号。</p><span id="more"></span><h2 id="识别导出的符号"><a href="#识别导出的符号" class="headerlink" title="识别导出的符号"></a>识别导出的符号</h2><p>要查看应用程序导出的符号，请使用<code>nm</code>工具。此工具读取可执行文件的符号表并显示您请求的符号信息。您可以查看所有符号，也可以只查看可执行代码特定段中的符号。例如，要只显示外部可用的全局符号，可以在命令行上指定<code>-g</code>选项。 </p><p>要查看符号的详细信息，可以使用带<code>-m</code>选项的命令nm。该选项的输出告诉您符号的类型，以及它是外部的还是本地的(非外部的)。例如，要查看<code>TextEdit</code>应用程序的详细符号信息，可以如下所示使用nm:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%<span class="built_in">cd</span> /Applications/TextEdit.app/Contents/MacOS</span><br><span class="line">% nm -m TextEdit</span><br></pre></td></tr></table></figure><p>结果输出的一部分可能如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">9005cea4 (prebound undefined [lazy bound]) external _abort (from libSystem)</span><br><span class="line">9000a5c0 (prebound undefined [lazy bound]) external _atexit (from libSystem)</span><br><span class="line">90009380 (prebound undefined [lazy bound]) external _calloc (from libSystem)</span><br><span class="line">00018d14 (__DATA,__common) [referenced dynamically] external _catch_exception_raise</span><br><span class="line">00018d18 (__DATA,__common) [referenced dynamically] external _catch_exception_raise_state</span><br><span class="line">00018d1c (__DATA,__common) [referenced dynamically] external _catch_exception_raise_state_identity</span><br></pre></td></tr></table></figure><p>在此模式下，nm根据符号显示各种信息。对于驻留在__TEXT段中的函数和其他代码，nm会显示预绑定信息和初始库(originating library)。对于__DATA段中的信息，nm显示符号的specific section及其链接。对于所有符号，nm显示该符号是外部的还是本地的。</p><h2 id="限制导出的符号"><a href="#限制导出的符号" class="headerlink" title="限制导出的符号"></a>限制导出的符号</h2><p>如果您知道要从项目导出的符号，则应该创建一个导出文件，并将该文件添加到项目的链接器设置中。导出文件是一个纯文本文件，其中包含您希望外部调用者可用的符号的名称。每个符号必须列在单独的一行上。前导和后面的空格不被认为是符号名称的一部分。以#号开头的行将被忽略。 </p><p>要在Xcode项目中包含导出文件，请修改项目的target或构建样式设置。将“Exported symbols file”设置的值设置为导出文件的名称。Xcode将适当的选项传递给静态链接器。 </p><p>若要从命令行导出符号列表，请在链接器命令中添加<code>-exported_symbols_list</code>选项。您也可以导出所有符号，然后限制特定列表，而不是导出特定的符号列表。要限制特定的符号列表，请在链接器命令中使用<code>-unexported_symbols_list</code>选项。 </p><p>注意，运行时库导出的符号必须显式地包含在导出文件中，以便应用程序能够正常启动。若要收集这些符号的列表，请在没有导出文件的情况下链接代码，然后从终端执行<code>nm -m</code>命令。从结果输出中，收集任何标记为external且不属于代码的符号，并将它们添加到导出文件中。</p><h2 id="使用GCC-4-0限制导出"><a href="#使用GCC-4-0限制导出" class="headerlink" title="使用GCC 4.0限制导出"></a>使用GCC 4.0限制导出</h2><p>GCC 4.0支持为单个符号自定义可见性属性。此外，编译器提供了编译时标志，允许您为已编译文件的所有符号设置默认可见性。有关使用GCC 4.0的新符号可见性特性的信息，请参阅<a href="">c++运行时环境编程指南</a>中的“<a href="">控制符号可见性</a>”。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【译】提高代码局部性</title>
      <link href="/2022/12/16/%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E5%B1%80%E9%83%A8%E6%80%A7/"/>
      <url>/2022/12/16/%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E5%B1%80%E9%83%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="提高代码局部性-Improving-Locality-of-Reference"><a href="#提高代码局部性-Improving-Locality-of-Reference" class="headerlink" title="提高代码局部性(Improving Locality of Reference)"></a>提高代码局部性(Improving Locality of Reference)</h2><p>可以对应用程序性能进行的一个重要改进是减少应用程序在任何给定时间使用的虚拟内存页的数量。这组页面称为工作集，由应用程序代码和运行时数据组成。减少内存中的数据量是算法的一个功能，但是减少内存中的代码量可以通过一个称为分散加载(scatter loading)的过程来实现。这种技术也被称为改进代码引用的局部性（improving the locality of reference of your code）。 </p><p>通常，方法和函数的编译代码在生成的二进制文件中按源文件组织。分散加载改变了这种组织，而是将相关的方法和函数分组在一起，而不依赖于这些方法和函数的原始位置。这个过程允许内核将活动应用程序最常被引用的可执行页保存在尽可能小的内存空间中。这不仅减少了应用程序的占用空间，还减少了这些页面被换出（paged out）的可能性。</p><blockquote><p>重要提示:您通常应该等到开发周期的晚期才分散应用程序的负载。在开发过程中，代码往往会四处移动，这可能会使先前的分析结果无效。</p></blockquote><span id="more"></span><h3 id="使用gprof的分析代码"><a href="#使用gprof的分析代码" class="headerlink" title="使用gprof的分析代码"></a>使用gprof的分析代码</h3><p>给定运行时收集的概要数据，<code>gprof</code>将生成程序的执行概要。被调用例程的效果被合并到每个调用方的概要文件中。概要数据取自调用图概要文件(默认为gmon.out)，它是由一个编译并与<code>-pg</code>选项链接的程序创建的。可执行文件中的符号表与调用图配置文件相关联。如果指定了多个概要文件，<code>gprof</code>输出将显示给定概要文件中概要信息的总和。 </p><p><code>gprof</code>工具在很多方面都很有用，包括: </p><ol><li>Sampler应用程序不能很好地工作的情况，例如命令行工具或应用程序在短时间后退出 </li><li>在这种情况下，您希望调用图包括给定程序中可能调用的所有代码，而不是对调用进行周期性采样 </li><li>您希望更改代码的链接顺序以优化代码位置的情况</li></ol><h4 id="生成概要数据"><a href="#生成概要数据" class="headerlink" title="生成概要数据"></a>生成概要数据</h4><p>在分析应用程序之前，必须设置项目以生成分析信息。要为你的Xcode项目生成分析信息，你必须修改你的target或构建风格设置，包括“<code>Generate profiling code</code>”选项。(有关启用target和构建样式设置的信息，请参阅Xcode帮助。) </p><p>程序中的分析代码生成一个名为<code>gmon.out</code>的文件。把剖析信息拿出来。(通常，这个文件放在当前工作目录中。)要分析此文件中的数据，请在调用<code>gprof</code>之前将其复制到包含可执行文件的目录中，或者当你运行<code>gprof</code>时指定<code>gmon.out</code>的路径。</p><p>除了分析您自己的代码之外，您还可以通过链接这些框架的配置文件版本来了解在Carbon和Cocoa框架中花费了多少时间。为此，将<code>DYLD_IMAGE_SUFFIX</code>设置添加到target或构建样式中，并将其值设置为<code>_profile</code>。动态链接器将这个后缀与框架名称结合起来，链接到框架的概要文件版本。要确定哪些框架支持分析，请查看框架本身。例如，Carbon库提供了概要文件和调试版本。</p><blockquote><p>注意:库的概要文件和调试版本是作为开发人员工具包的一部分安装的，在用户系统上可能不可用。确保您发布的可执行文件没有链接到这些库之一。</p></blockquote><h4 id="生成Order文件"><a href="#生成Order文件" class="headerlink" title="生成Order文件"></a>生成Order文件</h4><p>order文件包含一个有序的行序列，每行由一个源文件名和一个符号名组成，用冒号分隔，没有其他空格。每一行表示一个块，放置在可执行文件的一个部分。如果手动修改文件，则必须完全遵循此格式，以便链接器可以处理该文件。如果对象文件name:symbol 名对不完全是链接器看到的名称，它会尽力将名称与被链接的对象匹配。 </p><p>order文件中用于过程重新排序的行由对象文件名和过程名(函数、方法或其他符号)组成。order文件中列出过程的顺序表示它们被链接到可执行文件的<code>__text</code>部分的顺序。 </p><p>要从使用程序生成的分析数据创建order文件，可以使用-S选项运行gprof(参见gprof(1)的手册页)。例如</p><blockquote><p>gprof -S MyApp.profile&#x2F;MyApp gmon.out<br>-S选项生成四个互斥的order文件:</p></blockquote><img src="/2022/12/16/%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E5%B1%80%E9%83%A8%E6%80%A7/ordertypes.png" class="&#x3D;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gmon.order:基于分析调用图的“最接近即最佳”分析进行排序。经常相互调用的调用被放置在一起。</span><br><span class="line">callf.order:例程按对每个例程的调用次数排序，最大的数字排在前面。</span><br><span class="line">callo.order:按调用顺序排序的例程。</span><br><span class="line">time.order:程序按照CPU花费的时间排序，最大的时间排在前面。</span><br></pre></td></tr></table></figure><p>您应该尝试使用这些文件中的每一个，看看哪个提供了最大的性能改进(如果有的话)。有关如何测量排序结果的讨论，请参见<a href="">使用pagstuff检查磁盘上的页面</a>。 </p><p>这些order文件只包含分析期间使用的过程。链接器跟踪丢失的过程，并在order文件中列出的顺序之后按默认顺序链接它们。只有当项目目录包含由链接器的<code>- whatloaded</code>选项生成的文件时，才会在order文件中生成库函数的静态名称;有关详细信息，请参见<a href="">创建默认订单文件</a>。 </p><p><code>gprof -S</code>选项不适用于已经使用顺序文件链接的可执行文件。</p><h4 id="修复你的order文件"><a href="#修复你的order文件" class="headerlink" title="修复你的order文件"></a>修复你的order文件</h4><p>生成订单文件后，您应该检查它们并确保它们是正确的。有许多情况下，您需要手动编辑您的order文件，包括以下情况: </p><ul><li>您的可执行文件包含汇编语言(assembly-language)文件。 </li><li>你分析了一个剥离的(stripped)可执行文件。 </li><li>您的可执行文件包含没有<code>-g</code>选项编译的文件。 </li><li>您的项目定义了内部标签(通常用于<code>goto</code>语句)。 </li><li>您希望保留特定对象文件中例程(routines)的顺序。</li></ul><p>如果符号的定义位于汇编文件、剥离的可执行文件或未使用<code>-g</code>选项编译的文件中，<code>gprof</code>将从order文件中的符号条目中省略源文件名。如果项目使用此类文件，则必须手动编辑order文件并添加适当的源文件名。或者，您可以完全删除符号引用，以强制以默认顺序链接相应的例程。 </p><p>如果代码包含内部标签(internal labels)，则必须从order文件中删除这些标签;否则，定义标签的函数将在链接阶段被分开。通过在汇编文件前面加上字符串<code>L_</code>，可以完全防止在汇编文件中包含内部标签。汇编程序将带有此前缀的符号解释为特定函数的局部符号，并将其剥离以防止<code>gprof</code>等其他工具访问。 </p><p>要保留特定对象文件中的例程顺序，请使用特殊符号<code>.section_all</code>。例如，如果对象文件<code>foo.O</code>来自汇编，你想要链接所有的例程而不重新排序，删除任何现有的引用<code>foo.O</code>，并在order文件中插入以下一行:</p><blockquote><p>foo.o:.section_all<br>此选项对于从汇编源编译的目标文件或没有汇编源的目标文件非常有用。</p></blockquote><h4 id="使用order文件链接"><a href="#使用order文件链接" class="headerlink" title="使用order文件链接"></a>使用order文件链接</h4><p>一旦你生成了一个order文件，你可以使用<code>-sectorder</code>和<code>-e start</code>选项链接程序: </p><blockquote><p>cc -o outputFile inputFile.o … -sectorder __TEXT __text orderFile -e start . </p></blockquote><p>要在Xcode项目中使用order文件，请修改项目部署构建样式中的“Other Linker Flags”选项。将文本<code>-sectorder __TEXT __text</code>添加到此设置中以指定您的订单文件。 </p><p>如果任何<code>inputFile</code>是库而不是对象文件，则可能需要在链接之前编辑order文件，以将对对象文件的所有引用替换为对适当库文件的引用。同样，链接器尽最大努力将order文件中的名称与它正在编辑的源相匹配。 </p><p>使用这些选项，链接器构造可执行文件<code>outputFile</code>，以便<code>__TEXT</code>段的<code>__text</code>部分(section)的内容是由输入文件的__text部分(section)的块构造的。链接器按照<code>orderFile</code>中列出的顺序排列输入文件中的例程。 </p><p>当链接器处理order文件时，它将对象文件(object-file)和符号-名称(symbol-name)对不在order文件中列出的过程放入outputFile的__text部分(sectioin)。它以默认顺序链接这些符号。对象文件和符号-名称对列出多次总是会生成警告，并使用第一次出现的对象文件和符号-名称对。 </p><p>默认情况下，链接器会打印以下内容的摘要:被链接对象中不在order文件中的符号名的数量、order文件中不在被链接对象中的符号名的数量，以及它试图匹配的不明确的符号名的数量。要请求这些符号的详细列表，请使用<code>-sectorder_detail</code>选项。 </p><p>链接器的<code>-e start</code>选项保留可执行文件的入口点。符号start(注意前面没有“_”)定义在C运行时共享库<code>/usr/bin/crt1.o</code>;它表示正常链接时程序中的第一个文本地址。重新排序过程时，必须使用此选项来固定入口点。另一种方法是把<code>/usr/lib/crt1.O:start</code>或<code>/usr/lib/crt1.O:section_all</code>放在order文件的第一行。</p><h4 id="gprof命令文件的限制"><a href="#gprof命令文件的限制" class="headerlink" title="gprof命令文件的限制"></a>gprof命令文件的限制</h4><p>由<code>gprof</code>生成的<code>.order</code>文件只包含那些在可执行文件运行时被调用或采样的函数。为了使库函数正确地出现在订单文件中，由链接器生成的加载<code>whatloaded</code>的文件应该存在于工作目录中。 </p><p><code>-S</code>选项不适用于已链接到订单文件的可执行文件。 </p><p>gmon.order的生成可能需要很长时间—可以使用<code>-x</code>参数来抑制(suppressed)。 </p><p>以下项目的文件名将会丢失: </p><ul><li>不使用-g参数编译的文件 </li><li>从汇编语言源生成的例程 </li><li>已删除调试符号的可执行文件(与strip工具一样)</li></ul><h3 id="使用监视函数进行分析"><a href="#使用监视函数进行分析" class="headerlink" title="使用监视函数进行分析"></a>使用监视函数进行分析</h3><p>文件<code>/usr/include/monitor.h</code>声明了一组函数，您可以使用它们以编程方式分析代码的特定部分(sections)。您可以使用这些函数仅为代码的某些部分(sections)或所有代码收集统计信息。然后，您可以使用<code>gprof</code>工具从结果文件构建调用图和其他性能分析数据。清单1显示了如何使用监视器函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;monitor.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* To start profiling: */</span></span><br><span class="line">    moninit();</span><br><span class="line">    moncontrol(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* To stop, and dump to a file */</span></span><br><span class="line">    moncontrol(<span class="number">0</span>);</span><br><span class="line">    monoutput(<span class="string">&quot;/tmp/myprofiledata.out&quot;</span>);</span><br><span class="line">    monreset();</span><br></pre></td></tr></table></figure><h3 id="在编译时组织代码"><a href="#在编译时组织代码" class="headerlink" title="在编译时组织代码"></a>在编译时组织代码</h3><p>GCC编译器允许您在声明的任何函数或变量上指定属性。section属性允许您告诉GCC您希望将特定的代码段放在哪个段和哪个节(section)中。</p><blockquote><p>警告:除非您了解Mach-O可执行文件的结构，并且知道将函数和数据放置在相应段中的规则，否则不要使用节section属性。将函数或全局变量放置在不适当的节中可能会破坏程序。</p></blockquote><p>section属性接受几个参数，这些参数控制结果代码放置的位置。至少，您必须为要放置的代码指定一个段和节名称。其他选项也可用，并在GCC文档中进行了描述。 </p><p>下面的清单显示了如何为函数使用section属性。在本例中，section属性被添加到函数的前向声明中。该属性告诉编译器将函数放置在可执行文件的特定__text部分中。<br><code>void MyFunction (int a) __attribute__((section(&quot;__TEXT,__text.10&quot;)));</code><br>下面的清单展示了如何使用section属性组织全局变量的一些示例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> x __attribute__((section(<span class="string">&quot;__TEXT,__my_const&quot;</span>)));</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> x=<span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> foo_string[] __attribute__((section(<span class="string">&quot;__DATA,__my_data&quot;</span>)));</span><br><span class="line"><span class="type">char</span> foo_string[] = <span class="string">&quot;My text string\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>有关指定section属性的详细信息，请参阅<code>/Developer/ documentation /DeveloperTools/gcc3</code>中的GCC编译器文档。</p><h3 id="重新排序-text-Section"><a href="#重新排序-text-Section" class="headerlink" title="重新排序 __text Section"></a>重新排序 __text Section</h3><p>正如Mach-O可执行格式概述中所述，<code>__TEXT</code>段保存程序的实际代码和只读部分。按照惯例，编译器工具将来自Mach-O对象文件(扩展名为.o)的过程放置在__TEXT段的__text部分(section)。 </p><p>当你的程序运行时，来自__text section的页面会根据需要加载到内存中，就像使用这些页面上的例程一样。代码按照它在给定源文件中出现的顺序链接到__text section，源文件按照它们在链接器命令行中列出的顺序链接(或按Xcode中指定的顺序)。因此，来自第一个目标文件的代码从头到尾被链接，其次是来自第二个文件和第三个文件的代码，以此类推。 </p><p>按源文件声明顺序加载代码很少是最优的。例如，假设代码中的某些方法或函数被重复调用，而其他方法或函数很少使用。将过程重新排序，将经常使用的代码放在__text section的开头，可以最大限度地减少应用程序使用的平均页面数，从而减少分页活动。 </p><p>作为另一个例子，假设代码定义的所有对象同时初始化。因为每个类的初始化例程定义在一个单独的源文件中，初始化代码通常分布在__text section。通过连续地重新排序所有类的初始化代码，可以减少需要读入的页面数量，从而增强初始化性能。应用程序只需要少量包含初始化代码的页面，而不是大量的页面，每个页面包含一小段初始化代码。</p><h4 id="重新排序程序-Reordering-Procedures"><a href="#重新排序程序-Reordering-Procedures" class="headerlink" title="重新排序程序(Reordering Procedures)"></a>重新排序程序(Reordering Procedures)</h4><p>根据应用程序的大小和复杂性，应该采用一种最能提高可执行文件性能的代码排序策略。与大多数性能调优一样，花在测量和重新调优过程顺序上的时间越多，节省的内存就越多。通过运行应用程序并根据调用频率对例程进行排序，可以很容易地获得良好的第一切割(first-cut)排序。下面列出了该策略的步骤，并在接下来的部分中进行了更详细的解释:</p><ol><li>构建应用程序的概要文件版本(profile version)。此步骤生成一个可执行文件，其中包含分析和重新排序过程中使用的符号。 </li><li>运行并使用该应用程序创建一组概要数据。执行一系列功能测试，或让某人在测试期间使用该程序。</li></ol><blockquote><p>重要提示:为了获得最佳效果，请关注最典型的使用模式。避免使用应用程序的所有特性，否则概要数据可能会被稀释。例如，关注启动时间以及激活和禁用主窗口的时间。不要打开辅助窗口。</p></blockquote><ol><li>创建order文件。order文件以优化的顺序列出程序。链接器使用order文件对可执行文件中的过程重新排序。 </li><li>使用order文件运行链接器。这将创建一个可执行文件，其中的过程链接到订单文件中指定的__text section。</li></ol><p>有关分析代码以及生成和链接订单文件的信息，请参见<a href="">使用gprof分析代码</a>。</p><h4 id="大程序的程序重排"><a href="#大程序的程序重排" class="headerlink" title="大程序的程序重排"></a>大程序的程序重排</h4><p>对于许多程序来说，由刚才描述的步骤生成的顺序比无序过程带来了实质性的改进。对于一个特性很少的简单应用程序，这样的排序代表了过程重新排序(procedure reordering)所能获得的大部分好处。然而，更大的应用程序和其他大型程序可以从额外的分析中获益良多。虽然基于调用频率或调用图的顺序文件是一个很好的开始，但您可以使用您对应用程序结构的了解来进一步减少虚拟内存工作集</p><ul><li>创建一个默认的order文件<br>如果希望使用上述技术以外的技术对应用程序的过程(procedures)进行重新排序，则可能希望跳过分析步骤，只需从列出应用程序所有例程的默认顺序文件开始。一旦有了合适形式的例程列表，就可以手动或使用您选择的排序技术重新排列条目。然后，您可以使用链接器的<code>-sectorder</code>选项使用生成的order文件，如<a href="">与订单文件链接中</a>所述。<br>要创建一个默认的order文件，首先运行带有<code>-whatloaded</code>选项的链接器:</li></ul><p><code>cc -o outputFile inputFile.o -whatsloaded &gt; loadedFile</code></p><p>这将创建一个名为<code>loaddfile</code>的文件，该文件列出了加载在可执行文件中的目标文件，包括框架或其他库中的任何文件。<code>-whatloaded</code>选项还可用于确保<code>gprof -S</code>生成的order文件包含静态库中的过程(procedures)名称。 </p><p>使用<code>loaddfile</code>文件，你可以使用<code>-onjls</code>选项和<code>__TEXT __text</code>参数运行nm:</p><p><code>nm -onjls __TEXT __text </code>cat loadedFile<code> &gt; orderFile</code><br>文件orderFile的内容是text section的符号表。过程以默认的链接顺序列在符号表中。您可以重新排列此文件中的条目，以更改希望链接过程的顺序，然后按照<a href="">与order文件链接</a>中所述的方法运行链接器。</p><ul><li>使用pagstuff检查磁盘上的页面<br>pagstuff工具通过告诉您在给定时间内可执行文件的哪些页可能被加载到内存中来帮助您度量过程排序的有效性。本节简要介绍该工具的使用方法。有关更多信息，请参阅pagestff手册页。</li></ul><p>pagstuff工具打印可执行代码的特定页上的符号。命令格式如下: </p><p><code>pagstuff filename [pageNumber | -a] </code></p><p>pagstuff的输出是包含在页面pageNumber上的filename中的过程列表。要查看文件的所有页面，请使用<code>-a</code>选项代替页码。此输出允许您确定内存中与文件关联的每个页面是否都经过优化。如果不是，您可以重新安排order文件中的条目，并再次链接可执行文件，以最大限度地提高性能。例如，将两个相关的过程移动到一起，使它们链接到同一个页面上。完善排序可能需要几个链接和调优周期。</p><ul><li>根据用法分组例程（routines）<br>为什么要为应用程序的各个操作生成概要数据?该策略基于以下假设:一个大型应用程序通常有三组例程:</li></ul><p>热例程在应用程序最常见的使用过程中运行。这些通常是基本例程，为应用程序的特性(例如，访问文档数据结构的例程)提供基础，或者实现应用程序核心特性的例程，例如在字处理器中实现输入的例程。这些例程应该聚集在同一组页面中。</p><p>Warm例程实现应用程序的特定功能。Warm例程通常与用户偶尔执行的特定功能相关(例如启动、打印或导入图形)。因为这些例程使用得相当频繁，所以将它们集中在相同的一小组页面中，这样它们就可以快速加载。但是，由于用户在很长一段时间内没有访问此功能，因此这些例程不应该位于热门类别中。</p><p>冷例程很少在应用程序中使用。冷例程实现模糊的特性或覆盖边界或错误情况。将这些例程组合在一起，以避免在热页或Warm页上浪费空间。</p><p>在任何给定的时间，您都应该期望大多数热页都是常驻的，而对于用户当前正在使用的特性，您应该期望warm页是常驻的。只有极少数情况下才需要常驻冷页。</p><p>要实现这种理想的排序，需要收集一些概要数据集。首先，收集热门例程。如上所述，编译用于分析的应用程序，启动它，并使用该程序。使用<code>gprof -S</code>，生成一个称为hot的频率排序顺序文件。从配置文件数据排序。</p><p>创建热order文件后，为用户偶尔使用的功能创建order文件，例如仅在应用程序启动时运行的例程。打印、打开文档、导入图像和使用各种非文档窗口和工具是用户偶尔使用但不是经常使用的其他特性的示例，并且是拥有自己的order文件的良好候选。建议用被分析的特性来命名这些顺序文件(例如，feature.order)。</p><p>最后，为了生成所有例程的列表，构建一个“默认”order文件default.order(如重新排序过程中所述)。</p><p>有了这些order文件之后，就可以使用清单2中所示的代码将它们组合起来。您可以使用这个清单构建一个命令行实用程序，它可以删除顺序文件中的重复行，同时保留原始数据的顺序。</p><p>Listing 2  Code for Unique.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  unique</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  A command for combining files while removing</span></span><br><span class="line"><span class="comment">//  duplicate lines of text. The order of other lines of text</span></span><br><span class="line"><span class="comment">//  in the input files is preserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Build using this command line:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  cc -ObjC -O -o unique -framework Foundation Unique.c</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Note that “unique” differs from the BSD command “uniq” in that</span></span><br><span class="line"><span class="comment">//  “uniq” combines duplicate adjacent lines, while “unique” does not</span></span><br><span class="line"><span class="comment">//  require duplicate lines to be adjacent. “unique” is also spelled</span></span><br><span class="line"><span class="comment">//  correctly.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#import <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/NSSet.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/NSData.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kBufferSize 8*1024</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessFile</span><span class="params">(FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[ kBufferSize ];</span><br><span class="line"> </span><br><span class="line">    <span class="type">static</span> id theSet = nil;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( theSet == nil )</span><br><span class="line">    &#123;</span><br><span class="line">        theSet = [[NSMutableSet alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>( fgets(buf, kBufferSize, fp) )</span><br><span class="line">    &#123;</span><br><span class="line">        id dataForString;</span><br><span class="line"> </span><br><span class="line">        dataForString = [[NSData alloc] initWithBytes:buf length:<span class="built_in">strlen</span>(buf)];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( ! [theSet containsObject:dataForString] )</span><br><span class="line">        &#123;</span><br><span class="line">            [theSet addObject:dataForString];</span><br><span class="line">            <span class="built_in">fputs</span>(buf, <span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        [dataForString release];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>     i;</span><br><span class="line">    FILE *  theFile;</span><br><span class="line">    <span class="type">int</span>     status = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>( argc &gt; <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt; argc; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( theFile = fopen( argv[i], <span class="string">&quot;r&quot;</span> ) )</span><br><span class="line">            &#123;</span><br><span class="line">                ProcessFile( theFile );</span><br><span class="line">                fclose( theFile );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>( <span class="built_in">stderr</span>, <span class="string">&quot;Could not open ‘%s’\n&quot;</span>, argv[i] );</span><br><span class="line">                status = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ProcessFile( <span class="built_in">stdin</span> );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦构建，您将使用该程序生成您的最终order文件，其语法类似于以下:<br><code>unique hot.order feature1.order ... featureN.order default.order &gt; final.order</code><br>当然，真正的排序测试是减少了多少分页I&#x2F;O。运行您的应用程序，使用不同的特性，并检查您的排序文件在不同条件下的执行情况。您可以使用<code>top</code>工具(among others)来度量分页性能。</p><ul><li>找到最后一个热门Routine<br>在重新排序之后，你通常会有一个带有冷例程的页面区域，你希望很少使用这些例程，通常是在文本排序的末尾。然而，一两个热例程可能会从裂缝中溜走，落在这个冷的部分(section)。这是一个代价高昂的错误，因为使用这些热例程之一现在需要常驻整个页面，否则该页将充满不太可能使用的冷例程。</li></ul><p>检查可执行文件的冷页是否被意外地换入(paged in)。在应用程序文本段的冷区中寻找具有高页偏移量的页面。如果存在一个不需要的页面，则需要找出正在调用该页上的哪个例程。一种方法是在涉及该页的特定操作期间进行分析，并使用<code>grep</code>工具搜索分析器输出，以查找驻留在该页上的例程。另外，一种快速的方法来识别页面被触摸的位置是在<code>gdb</code>调试器下运行应用程序，并使用Mach调用<code>vm_protect</code>来禁止对该页的所有访问:</p><p><code>(gdb) p vm_protect(task_self(), startpage_addr, vm_page_size, FALSE, 0);</code><br>在清除页保护之后，对该页的任何访问都会导致内存错误，从而破坏调试器中的程序。此时，您可以简单地查看函数调用堆栈(使用bt命令)来了解为什么要调用例程。</p><h3 id="重排其他Sections"><a href="#重排其他Sections" class="headerlink" title="重排其他Sections"></a>重排其他Sections</h3><p>您可以使用链接器的<code>-sectorder</code>选项来组织可执行文件的大多数sections中的blocks。偶尔可以从重排序中受益的部分是literal sections，例如__TEXT段的__cstring section和__DATA段的__data section。</p><h4 id="重排-Literal-Sections"><a href="#重排-Literal-Sections" class="headerlink" title="重排 Literal Sections"></a>重排 Literal Sections</h4><p>使用ld和otool工具可以最容易地生成literal sections的order文件中的行。对于literal sections，otool为每种类型的literal sections创建特定类型的order文件:</p><ul><li>对于C字符串literal sections，order-file格式是每行一个C字符串文字(C字符串中允许ANSI C转义序列)。例如，一行可能是这样的<br><code>Hello world\n</code></li><li>对于4字节literal sections，order-file格式是一个32位十六进制数字，每行以0x开头，其余的行被视为注释。例如，一行可能是这样的<br><code>0x3f8ccccd (1.10000002384185790000e+00)</code></li><li>对于literal pointer sections，order-file中的行格式表示指针，每行一个。A literal pointer由段名、literal pointer的section name和literal本身表示。它们由冒号分隔，没有额外的空格。例如，一行可能是这样的:<br><code>__OBJC:__selector_strs:new</code><br>对于所有literal sections，order文件中的每一行都被简单地输入到literal section中，并按照order文件的顺序出现在输出文件中。不检查literal是否在已加载的对象中。</li></ul><p>要重新排序literal section，首先使用<code>ld - whatloaded</code>选项创建一个“whatloaded”文件，如<a href="">创建默认order文件</a>小节所述。然后，使用适当的选项、段和section名称以及文件名运行otool。otool的输出是指定section的默认order文件。例如，下面的命令行生成一个order文件，列出文件cstring_order中__TEXT段的__cstring section的默认加载顺序:<br><code>otool -X -v -s __TEXT __cstring </code>cat whatsloaded<code> &gt; cstring_order</code><br>一旦创建了文件<code>cstring_order</code>，就可以编辑该文件并重新排列其条目以优化引用的位置。例如，您可以将程序最常使用的文字字符串(例如出现在用户界面中的标签)放在文件的开头。要在可执行文件中产生所需的加载顺序，使用以下命令:<br><code>cc -o hello hello.o -sectorder __TEXT __cstring  cstring_order</code></p><h4 id="重排数据sections"><a href="#重排数据sections" class="headerlink" title="重排数据sections"></a>重排数据sections</h4><p>目前还没有工具来测量对数据符号的代码引用。但是，您可能知道程序的数据引用模式，并且可以通过将很少使用的特性的数据与其他数据分开来节省一些开销。__data section重新排序的一种方法是按大小对数据进行排序，这样小的数据项就会在尽可能少的页面上结束。例如，如果一个较大的数据项被放置在两个页面上，而两个较小的项共享每个页面，则必须将较大的项换入以访问较小的项。按大小重新排序数据可以最大限度地降低这种低效率。因为这些数据通常需要被写入虚拟内存备份存储（virtual-memory backing store），所以在某些程序中，这可能是一个很大的节省。 </p><p>要重新排序__data section，首先创建一个order文件，按照您希望它们链接的顺序列出源文件和符号(order文件条目在<a href="">生成order文件</a>的开头描述)。然后，使用-sectorder命令行选项链接程序:<br><code>cc -o outputFile inputFile.o … -sectorder __DATA __data orderFile -e start</code><br>要在Xcode项目中使用order文件，请修改项目部署构建样式中的“Other Linker Flags”选项。将 <code>-sectorder __DATA __data</code> orderFile添加到此设置中，以指定您的order文件。</p><h4 id="重排汇编语言代码"><a href="#重排汇编语言代码" class="headerlink" title="重排汇编语言代码"></a>重排汇编语言代码</h4><p>在重新排序用汇编语言编写的例程时，需要记住的一些附加准则:</p><ul><li>汇编代码中的临时标签<br>在手工编码(hand-coded)的汇编代码中，要注意到临时标签的分支，而该分支跨越了非临时标签。例如，如果您使用以“L”或d标签(其中d是数字)开头的标签，如本例所示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo: b 1f</span><br><span class="line">    ...</span><br><span class="line">bar: ...</span><br><span class="line">1:   ...</span><br></pre></td></tr></table></figure><p>结果程序将不能正确链接或执行，因为只有符号foo和bar才能进入目标文件的符号表。对临时标签<code>1</code>的引用被编译为偏移量;因此，不会为指令<code>b1f</code>生成重定位表项。如果链接器没有将与符号<code>bar</code>相关联的块直接放在与foo相关联的块之后，到1f的分支将不会到达正确的位置。因为没有重定位表项，所以链接器不知道如何修复分支。修复此问题的源代码更改是将标签<code>1</code>更改为非临时标签(例如bar1)。通过将包含手工编写的程序集代码的目标文件完整地链接起来，而无需重新排序，可以避免出现问题。</p><ul><li>伪符号.section_start</li></ul><p>如果任何输入文件中的指定section的大小为非零，并且没有与其section的开头值相同的符号，链接器将使用伪符号<code>.section_start</code>作为与节中的第一个块相关联的符号名。此符号的目的是处理其符号不持久化到目标文件中的文字常量( literal constants)。因为字面值字符串( literal strings)和浮点常量都在字面值区段(literal sections)中，这对Apple编译器来说不是问题。你可能会在汇编语言程序或非apple编译器中看到这个符号。但是，您不应该重新排序这样的代码，而是应该链接整个文件，而不是重新排序(查看<a href="">与订单文件的链接</a>)。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【译】管理代码大小</title>
      <link href="/2022/12/16/%E7%AE%A1%E7%90%86%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%B0%8F/"/>
      <url>/2022/12/16/%E7%AE%A1%E7%90%86%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="管理代码大小"><a href="#管理代码大小" class="headerlink" title="管理代码大小"></a>管理代码大小</h2><p>GCC编译器支持多种优化代码的选项。根据您的需要，大多数这些技术都会生成更少的代码或更快的代码。在准备软件发布时，您应该尝试使用这些技术，看看哪些技术对您的代码最有利。</p><span id="more"></span><h3 id="编译器层优化"><a href="#编译器层优化" class="headerlink" title="编译器层优化"></a>编译器层优化</h3><p>GCC编译器支持优化选项，可以让您选择是更小的二进制大小、更快的代码还是更快的构建时间。</p><p>对于新项目，Xcode会自动禁用开发构建风格（the development build style）的优化，并为部署构建风格(the deployment build style)选择“最快，最小”选项。任何类型的代码优化都会导致构建时间变慢，因为优化过程中涉及到额外的工作。如果您的代码在开发周期中发生了变化，那么您不希望启用优化。但是，当您接近开发周期的末尾时，部署构建样式可以指示您完成的产品的大小。 </p><p>表1列出了Xcode中可用的优化级别。当你选择其中一个选项时，Xcode会为给定的组或文件将适当的标志传递给GCC编译器。这些选项可以在目标级别使用，也可以作为构建样式的一部分使用。请参阅Xcode帮助以获得有关如何为项目构建设置的信息。</p><img src="/2022/12/16/%E7%AE%A1%E7%90%86%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%B0%8F/optimize-level.png" class="&#x3D;"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">None:编译器不会尝试优化代码。当您专注于解决逻辑错误并需要快速编译时，请在开发过程中使用此选项。不要在发布可执行文件时使用此选项。</span><br><span class="line">Fast:编译器执行简单的优化来提高代码性能，同时最大限度地减少对编译时间的影响。该选项还会在编译期间使用更多内存。</span><br><span class="line">Faster:执行几乎所有支持的不需要考虑时间空间权衡的优化。编译器不使用此选项执行循环展开或函数内联。这个选项增加了编译时间和提高了生成代码的性能</span><br><span class="line">Fastest：执行所有优化，以提高生成代码的速度。当编译器执行积极的函数内联时，此选项会增加生成的代码的大小。 通常不建议使用此选项。有关更多信息，请参见避免过多的函数内联。</span><br><span class="line">Fastest，smallest： 执行通常不会增加代码大小的所有优化。这是交付代码的首选选项，因为它为您的可执行文件提供了更小的内存占用。</span><br></pre></td></tr></table></figure><p>与任何性能增强一样，不要假设哪个选项会给您带来最好的结果。您应该始终衡量所尝试的每次优化的结果。例如，“Fastest”选项可能为特定模块生成非常快的代码，但它通常以可执行文件的大小为代价。如果运行时需要从磁盘调入代码，那么从代码生成中获得的任何速度优势都很容易丧失。</p><h3 id="额外的优化"><a href="#额外的优化" class="headerlink" title="额外的优化"></a>额外的优化</h3><p>除了代码级优化之外，还有一些额外的技术可以用于在模块级(the module level)组织代码。下面几节将介绍这些技术。</p><h4 id="Dead-Strip-Your-Code"><a href="#Dead-Strip-Your-Code" class="headerlink" title="Dead Strip Your Code"></a>Dead Strip Your Code</h4><p>对于静态链接(statically-linked)的可执行文件，死代码剥离(dead-code stripping)是从可执行文件中删除未引用代码的过程。死剥背后的思想是，如果代码没有被引用，它就不能被使用，因此在可执行文件中也不需要它。删除死代码可以减少可执行文件的大小，并有助于减少分页(paging)。 </p><p>从Xcode Tools 1.5版开始，静态链接器(ld)支持可执行文件的死剥。你可以直接从Xcode中启用这个特性，也可以将适当的命令行选项传递给静态链接器。 </p><p>要在Xcode中启用死代码剥离，请执行以下操作: </p><ol><li>选择你的target。 </li><li>打开“检查器”或“获取信息”窗口并选择“构建”选项卡。 </li><li>在链接设置中，启用死代码剥离(Dead Code Stripping)选项。 </li><li>在“代码生成设置”(Code Generation settings)中，将“调试符号级别”选项设置为“所有符号”。</li></ol><p> 要从命令行启用死代码剥离，将<code>-dead_strip</code>选项传递给ld。您还应该将<code>-gfull</code>选项传递给GCC，为您的代码生成一组完整的调试符号。链接器使用这些额外的调试信息来死剥可执行文件。</p><blockquote><p>注意:建议使用“All Symbols”或-gfull选项，即使您不打算对代码进行死剥。尽管该选项生成较大的中间文件，但它通常会生成较小的可执行文件，因为链接器能够更有效地删除重复的符号信息。</p></blockquote><p> 如果你不想删除任何未使用的函数，你至少应该将它们隔离在__TEXT段的单独section(a separate section)中。将未使用的函数移动到公共部分可以改善代码引用的局部性，并降低它们被加载到内存中的可能性。有关如何在公共部分(a common section)中对函数进行分组的更多信息，请参见<a href="">改进引用的局部性</a>。</p><h4 id="Strip-Symbol-Information"><a href="#Strip-Symbol-Information" class="headerlink" title="Strip Symbol Information"></a>Strip Symbol Information</h4><p>调试符号和动态绑定信息会占用大量空间，并占可执行文件的很大比例。在发布代码之前，应该去掉所有不需要的符号。 </p><p>要从可执行文件中剥离调试符号，请将Xcode构建风格设置更改为“部署”并重新构建可执行文件。如果您愿意，还可以在逐个目标的基础上生成调试符号。有关构建样式和目标设置的更多信息，请参阅Xcode Help。 </p><p>若要手动从可执行文件中删除动态绑定符号，请使用<code>strip</code>工具。此工具删除通常由动态链接器用于在运行时绑定外部符号的符号信息。删除不希望动态绑定的函数的符号可以减少可执行文件的大小，并减少动态连接器必须绑定的符号数量。通常，你会使用这个命令不带任何选项来删除非外部符号，如下例所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% cd ~/MyApp/MyApp.app/Contents/MacOS</span><br><span class="line">% strip MyApp</span><br></pre></td></tr></table></figure><p>该命令相当于带<code>-u</code>和<code>-r</code>选项运行<code>strip</code>命令。它删除任何标记为<code>non-external</code>的符号，但不删除标记为<code>external</code>的符号。 </p><p>手动去除动态绑定符号的另一种方法是使用导出文件来限制在构建时导出的符号。导出文件标识可执行文件中运行时可用的特定符号。有关创建导出文件的详细信息，请参见<a href="">最小化导出的符号</a>。</p><h4 id="消除c-异常处理开销"><a href="#消除c-异常处理开销" class="headerlink" title="消除c++异常处理开销"></a>消除c++异常处理开销</h4><p>当抛出异常时，c++运行时库必须能够将堆栈展开到第一个匹配catch块的位置。为此，GCC编译器为每个可能引发异常的函数生成堆栈展开信息。此展开信息存储在可执行文件中，并描述堆栈上的对象。这些信息使得在抛出异常时调用这些对象的析构函数来清除它们成为可能。 </p><p>即使您的代码没有抛出异常，GCC编译器仍然会在默认情况下为c++代码生成堆栈展开信息。如果大量使用异常，这些额外的代码会显著增加可执行文件的大小。</p><ul><li><p>禁用异常<br>你可以通过禁用target的“<code>Enable c++ Exceptions</code>”构建选项来禁用Xcode中的异常处理。在命令行中，将<code>-fno-exceptions</code>选项传递给编译器。此选项删除函数的堆栈展开信息。但是，您仍然必须从代码中删除任何<code>try、catch</code>和<code>throw</code>语句。</p></li><li><p>选择性禁用异常<br>如果您的代码在某些地方使用了异常，但不是在所有地方都使用了异常，您可以通过在方法声明中添加空异常规范来显式地识别不需要展开信息的方法。例如，在下面的代码中，编译器必须为<code>my_function</code>生成堆栈展开信息，因为<code>my_other_function</code>或它调用的函数可能抛出异常。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">my_other_function</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_function</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">my_other_function</span> (a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，如果你知道<code>my_other_function</code>不能抛出异常，你可以通过在函数声明中包含空的异常规范(<code>throw()</code>)向编译器发出信号。因此，你可以这样声明前面的函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">foo</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="title">throw</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_function</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="title">throw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">foo</span> (a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尽量减少异常使用<br> 在编写代码时，请谨慎考虑异常的使用。异常应该用来表示特殊情况——也就是说，它们应该用来报告您没有预料到的问题。如果从文件中读取并得到文件结束错误，则不希望抛出异常，因为这是一种已知的错误类型，可以轻松处理。如果您试图从您知道已打开的文件中读取，但被告知文件ID无效，那么您可能会抛出异常。</li></ul><h4 id="避免过多的函数内联"><a href="#避免过多的函数内联" class="headerlink" title="避免过多的函数内联"></a>避免过多的函数内联</h4><p>尽管内联函数在某些情况下可以提高速度，但如果过度使用，它们也会降低OS X上的性能。<strong>内联函数消除了调用函数的开销，但这样做的方法是将每个函数调用替换为代码的副本。如果频繁调用内联函数，这些额外的代码会迅速增加，使可执行文件膨胀，并导致分页问题</strong>。 </p><p>如果使用得当，内联函数可以节省时间，并且对代码占用空间的影响最小。记住，<strong>内联函数的代码通常应该非常短，并且不经常调用。如果在函数中执行代码所花费的时间小于调用函数所花费的时间，则该函数很适合进行内联</strong>。通常，这意味着内联函数的代码应该不超过几行。您还应该确保从代码中尽可能少的地方调用函数。即使是一个很短的函数，如果它内联在几十个或数百个地方，也会导致过度膨胀。 </p><p>此外，您应该意识到GCC的“Fastest”优化级别通常应该避免。在此优化级别，编译器会积极尝试创建内联函数，即使对于未标记为内联的函数也是如此。不幸的是，这样做会显著增加可执行文件的大小，并由于分页而导致更糟糕的性能问题</p><h4 id="将框架构建为单个模块"><a href="#将框架构建为单个模块" class="headerlink" title="将框架构建为单个模块"></a>将框架构建为单个模块</h4><p>大多数共享库不需要Mach-O运行时的模块特性。此外，跨模块调用所引起的开销与跨库调用相同。因此，您应该将项目的所有中间对象文件链接到一个单独的模块中。 </p><p>要组合目标文件，必须在链接阶段将<code>-r</code>选项传递给<code>ld</code>。如果你使用Xcode来构建你的代码，默认情况下这是为你完成的。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【译】Mach-O格式</title>
      <link href="/2022/12/14/Mach-O%E6%A0%BC%E5%BC%8F%E7%BF%BB%E8%AF%91/"/>
      <url>/2022/12/14/Mach-O%E6%A0%BC%E5%BC%8F%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Mach-O可执行格式概述"><a href="#Mach-O可执行格式概述" class="headerlink" title="Mach-O可执行格式概述"></a>Mach-O可执行格式概述</h2><p>Mach-O是OS X中二进制文件的本机可执行格式，是发布代码的首选格式。<strong>可执行格式决定二进制文件中的代码和数据读入内存的顺序。代码和数据的顺序影响内存使用和分页活动，因此直接影响程序的性能。</strong></p><p>Mach-O二进制文件被组织成段(segments)。每个段包含一个或多个节(sections)。不同类型的代码或数据进入每个节（section）。段总是从页面边界（a page boundary）开始，但节不一定是页对齐的。段的大小是由它所包含的所有节(sections)部分的字节数来衡量的，并四舍五入到（rounded up to）下一个虚拟内存页边界。因此，一个段总是4096字节的倍数，或4千字节，4096字节是最小大小。 </p><p>Mach-O可执行文件的段和节是根据它们的预期用途命名的。段名称的约定是使用全大写字母，前面加双下划线(例如，<code>__TEXT</code>);<code>section</code>名称的约定是使用全小写字母加双下划线(例如，<code>__text</code>)。 </p><p>在Mach-O可执行文件中有几个可能的段，但其中<strong>只有两个段与性能有关:<code>__TEXT</code>段和<code>__DATA</code>段</strong>。</p><span id="more"></span><h3 id="TEXT段：只读"><a href="#TEXT段：只读" class="headerlink" title="__TEXT段：只读"></a>__TEXT段：只读</h3><p><code>__TEXT</code>段是一个只读区域，<strong>包含可执行代码和常量数据</strong>。按照惯例，编译器工具创建的每个可执行文件至少有一个只读的<code>__TEXT</code>段。因为这个段是只读的，内核只能将<code>__TEXT</code>段直接从可执行文件映射到内存中，只有一次。当这个段被映射到内存中时，它可以被所有对其内容感兴趣的进程共享。(这主要是框架和其他共享库的情况。)只读属性还意味着构成<code>__TEXT</code>段的页永远不需要保存到备份存储中。如果内核需要释放物理内存，它可以丢弃一个或多个<code>__TEXT</code>页，并在需要时从磁盘重新读取它们。 </p><p>表1列出了一些可以出现在<code>__TEXT</code>段中的更重要的部分。有关段的完整列表，请参阅Mach-O运行时体系结构(Mach-O Runtime Architecture)。</p><img src="/2022/12/14/Mach-O%E6%A0%BC%E5%BC%8F%E7%BF%BB%E8%AF%91/text.png" class="&#x3D;"> <h3 id="DATA-段-读写"><a href="#DATA-段-读写" class="headerlink" title="__DATA 段: 读写"></a>__DATA 段: 读写</h3><p><code>__DATA</code>段包含可执行文件的非常量数据。这个段既可读又可写。因为它是可写的，所以框架或其他共享库的<code>__DATA</code>段在逻辑上被复制给每个与该库链接的进程。当内存页可读可写时，内核将其标记为写时复制(copy-on-write)。这种技术将延迟(defers)复制页面，直到共享该页的进程之一尝试写入该页。当这种情况发生时，内核为该进程创建一个页面的私有副本。 </p><p>__DATA段有许多sections，其中一些只被动态链接器使用。表2列出了__DATA段中可能出现的一些更重要的sections。有关段的完整列表，请参阅Mach-O运行时体系结构</p><img src="/2022/12/14/Mach-O%E6%A0%BC%E5%BC%8F%E7%BF%BB%E8%AF%91/data.png" class="&#x3D;"><h3 id="Mach-O性能影响"><a href="#Mach-O性能影响" class="headerlink" title="Mach-O性能影响"></a>Mach-O性能影响</h3><p>Mach-O可执行文件的<code>__TEXT</code>和<code>__DATA</code>段的组合直接影响性能。优化这些部分的技术和目标是不同的。然而，他们有一个共同的目标:<strong>提高内存的使用效率</strong>。 </p><p>典型的Mach-O文件大部分由可执行代码组成，这些代码占据了__TEXT， __TEXT部分。如__TEXT段:Read Only中所述，__TEXT段是只读的，直接映射到可执行文件。因此，如果内核需要回收一些__text页所占用的物理内存，它不必将这些页保存到备份存储（backing store）中，然后再将它们换入。它只需要释放内存，当代码稍后被引用时，从磁盘读入它。尽管这比交换更划算(因为它只涉及一个磁盘访问而不是两个)，但成本仍然很高，特别是如果必须从磁盘重新创建许多页面时。 </p><p>改善这种情况的一种方法是<strong>通过过程重新排序来改善代码的引用位置</strong>，如<a href="">改进引用位置</a>中所述。这种技术<strong>根据方法和函数的执行顺序、调用频率以及它们彼此调用的频率将它们分组在一起</strong>。如果__text节组中的页面在逻辑上以这种方式工作，则不太可能需要多次释放并读取它们。例如，如果您将所有启动时初始化函数放在一个或两个页面上，则在这些初始化发生后不必重新创建页面。 </p><p>与__TEXT段不同，__DATA段可以被写入，因此__DATA段中的页面是不可共享的。框架中的非常量全局变量(non-constant global variables)会对性能产生影响，因为与框架链接的每个进程都有自己的这些变量副本。这个问题的主要解决方案是<strong>将尽可能多的非常量全局变量通过声明为const来移动到__TEXT，__const部分</strong>。<a href="">减少共享内存页</a>描述了这一点和相关的技术。这对于应用程序来说通常不是问题，因为应用程序中的<code>__DATA</code>部分不会与其他应用程序共享。 </p><p>编译器将不同类型的非常量全局数据存储在__DATA段的不同节(section)。这些类型的数据是<strong>未初始化的静态数据</strong>和<strong>符号常量</strong>，与ANSI C“暂定定义”(tentative definition)的概念一致，没有声明为extern。未初始化的静态数据位于<code>__DATA</code>段的<code>__bss</code>部分。暂定定义符号位于<code>__DATA</code>段的<code>__common</code>部分。 </p><p>ANSI C和c++标准规定，系统必须将未初始化的静态变量设置为零。(其他类型的未初始化数据保持未初始化状态。)由于未初始化的静态变量和暂定定义符号存储在不同的sections中，系统需要区别对待它们。但是，当变量位于不同的sections时，它们更有可能在不同的内存页中结束，因此可以分别交换进出（swapped in and out separately），从而使代码运行速度变慢。如<a href="">减少共享内存页</a>中所述，这些问题的解决方案是将非常量全局数据合并到<code>__DATA</code>段的一个section中。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【译】iOS蓝牙</title>
      <link href="/2022/12/12/iOS%E8%93%9D%E7%89%99%E7%BF%BB%E8%AF%91/"/>
      <url>/2022/12/12/iOS%E8%93%9D%E7%89%99%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h2 id="关于Core-Bluetooth"><a href="#关于Core-Bluetooth" class="headerlink" title="关于Core Bluetooth"></a>关于Core Bluetooth</h2><p>蓝牙低耗能无线技术（Bluetooth low energy wireless technology）基于蓝牙4.0规范，该规范定义了一组用于低耗能设备之间通信的协议。核心蓝牙框架（The Core Bluetooth framework）是蓝牙低能耗协议栈的抽象。也就是说，它对开发人员隐藏了规范的许多底层细节，使您更容易开发与蓝牙低能耗设备交互的应用程序。</p><img src="/2022/12/12/iOS%E8%93%9D%E7%89%99%E7%BF%BB%E8%AF%91/CBTechnologyFramework_2x.png" class="&#x3D;"><span id="more"></span><h2 id="中心-和-外围设备"><a href="#中心-和-外围设备" class="headerlink" title="中心 和 外围设备"></a>中心 和 外围设备</h2><p>在所有的蓝牙低能耗通信中有两个主要的参与者:中心和外围设备。基于某种传统的客户机-服务器体系结构(client-server architecture)，<strong>外围设备通常拥有其他设备需要的数据。中心通常使用外设提供的信息来完成某些特定的任务</strong>。如图1-1所示，例如，心率监测器可能具有Mac或iOS应用程序可能需要的有用信息，以便以用户友好的方式显示用户的心率。</p><img src="/2022/12/12/iOS%E8%93%9D%E7%89%99%E7%BF%BB%E8%AF%91/CBDevices1_2x.png" class="&#x3D;"><blockquote><p>每个玩家在扮演自己的角色时都要执行不同的任务。<strong>外围设备通过广播宣传它们所拥有的数据来表明它们的存在</strong>。中央设备扫描附近可能有他们感兴趣的数据的外围设备。当中心发现这样的外设时，中心请求连接到外设，并开始探索外设的数据并与之交互。外围设备负责以适当的方式响应中央设备。</p></blockquote><p>如图1-2所示。中心设备可以请求连接到任何发现广告的外围设备。</p><img src="/2022/12/12/iOS%E8%93%9D%E7%89%99%E7%BF%BB%E8%AF%91/AdvertisingAndDiscovery_2x.png" class="&#x3D;"><h2 id="外围数据结构"><a href="#外围数据结构" class="headerlink" title="外围数据结构"></a>外围数据结构</h2><p><strong>外设可能包含一个或多个服务</strong>，或提供有关其连接的信号强度的有用信息。服务是用于完成设备(或该设备的部分)的功能或特性的数据和相关行为的集合。<br>例如，心率监控器的一项服务可能是公开来自监控器的心率传感器的心率数据。</p><p>服务本身由特征或包含的服务(即对其他服务的引用)组成。特性提供了关于外设服务的更多细节。例如，刚才描述的心率服务可以包含描述设备的心率传感器的预期身体位置的一个特征和传输心率测量数据的另一个特征</p><img src="/2022/12/12/iOS%E8%93%9D%E7%89%99%E7%BF%BB%E8%AF%91/CBPeripheralData_Example_2x.png" class="&#x3D;"><h2 id="中心端对象"><a href="#中心端对象" class="headerlink" title="中心端对象"></a>中心端对象</h2><h3 id="中心设备探索外设上的数据并与之交互"><a href="#中心设备探索外设上的数据并与之交互" class="headerlink" title="中心设备探索外设上的数据并与之交互"></a>中心设备探索外设上的数据并与之交互</h3><p>在中心成功地建立到外围设备的连接后，它可以发现外围设备必须提供的全部服务和特征(广告数据可能只包含可用服务的一小部分)。 </p><p>中心还可以通过读取或写入外围服务的特征值来与该服务交互。例如，你的应用程序可以从数字恒温器请求当前的室温，或者它可以为恒温器提供一个值来设置房间的温度</p><h3 id="本地中心和远程外围设备"><a href="#本地中心和远程外围设备" class="headerlink" title="本地中心和远程外围设备"></a>本地中心和远程外围设备</h3><p>在中心端，本地中心设备由<code>CBCentralManager</code>对象表示。这些对象用于管理已发现或已连接的远程外围设备(由<code>CBPeripheral</code>对象表示)，包括扫描、发现和连接到广告外围设备。图1-4显示了本地中心和远程外围设备如何在核心蓝牙框架中表示。</p><img src="/2022/12/12/iOS%E8%93%9D%E7%89%99%E7%BF%BB%E8%AF%91/CBObjects_CentralSide_2x.png" class="&#x3D;"><p>远程外设的数据由<code>CBService</code>和<code>CBCharacteristic</code>对象表示</p><p>当您与远程外设(由<code>CBPeripheral</code>对象表示)上的数据交互时，您正在处理它的服务和特征。在核心蓝牙框架中，远程外设的服务由<code>CBService</code>表示,类似地，远程外围设备服务的特征由<code>CBCharacteristic</code>对象表示。远程外设的基本结构和特点如图1-5所示。</p><img src="/2022/12/12/iOS%E8%93%9D%E7%89%99%E7%BF%BB%E8%AF%91/TreeOfServicesAndCharacteristics_Remote_2x.png" class="&#x3D;"><h2 id="外围端对象"><a href="#外围端对象" class="headerlink" title="外围端对象"></a>外围端对象</h2><p>从macOS 10.9和iOS 6开始，Mac和iOS设备可以作为蓝牙低耗能外设，为其他设备(包括其他Mac、iPhone和iPad设备)提供数据。当设置您的设备以实现外设角色时，您正在蓝牙低耗能通信的外设端执行操作</p><h3 id="本地外设和远程中心"><a href="#本地外设和远程中心" class="headerlink" title="本地外设和远程中心"></a>本地外设和远程中心</h3><p>在外围端，本地外围设备由一个<code>CBPeripheralManager</code>对象表示。这些对象用于在本地外围设备的服务和特征数据库中管理已发布的服务，并将这些服务发布到远程中心设备(由<code>CBCentral</code>对象表示)。外围管理器对象还用于响应来自这些远程中心的读写请求。图1-6显示了本地外围设备和远程中心如何在核心蓝牙框架中表示。</p><img src="/2022/12/12/iOS%E8%93%9D%E7%89%99%E7%BF%BB%E8%AF%91/CBObjects_PeripheralSide_2x.png" class="&#x3D;"><p>本地外设的数据由<code>CBMutableService</code>和<code>cbmutablecharistic</code>对象表示</p><p>当您在本地外设(由<code>CBPeripheralManager</code>对象表示)上设置数据并与之交互时，您正在处理其服务和特征的可变版本。在核心蓝牙框架中，本地外围设备的服务由<code>CBMutableService</code>对象表示。类似地，本地外围设备的服务的特征由<code>cbmutablechartraits</code>对象表示。本地外设的基本结构和特点如图1-7所示。</p><img src="/2022/12/12/iOS%E8%93%9D%E7%89%99%E7%BF%BB%E8%AF%91/TreeOfServicesAndCharacteristics_Local_2x.png" class="&#x3D;"><h2 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h2><h3 id="检索特征值"><a href="#检索特征值" class="headerlink" title="检索特征值"></a>检索特征值</h3><p>一个特征包含一个表示外设服务信息的值。例如，健康温度计服务的温度测量特性可能具有一个值，该值指示以摄氏度为单位的温度。您**可以通过直接读取或订阅来检索特征的值 **</p><ul><li>直接读取<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Reading value for characteristic %@&quot;</span>, interestingCharacteristic);</span><br><span class="line">    [peripheral readValueForCharacteristic:interestingCharacteristic];</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)peripheral:(CBPeripheral *)peripheral</span><br><span class="line">didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic</span><br><span class="line">             error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSData</span> *data = characteristic.value;</span><br><span class="line">    <span class="comment">// parse the data as needed</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><ul><li>订阅特征值<br>使用<code>readValueForCharacteristic</code>:方法读取特征值对于静态值是有效的，但它不是检索动态值的最有效方法。检索随时间变化的特征值——例如，您的心率——通过订阅它们。当你订阅一个特征值时，当值发生变化时，你会收到来自外围设备的通知。</li></ul><p><code> [peripheral setNotifyValue:YES forCharacteristic:interestingCharacteristic];</code></p><p>当你订阅(或取消订阅)一个特征值时，外围设备调用它的委托对象的<code>peripheral:didUpdateNotificationStateForCharacteristic:error:</code>方法。如果订阅请求由于任何原因失败，您可以实现这个委托方法来访问错误的原因，如下例所示:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)peripheral:(CBPeripheral *)peripheral</span><br><span class="line">didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic</span><br><span class="line">             error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Error changing notification state: %@&quot;</span>,</span><br><span class="line">           [error localizedDescription]);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><blockquote><p>注:并非所有特征都提供订阅。您可以通过检查其properties属性是否包含CBCharacteristicPropertyNotify或CBCharacteristicPropertyIndicate常量来确定一个特征是否提供订阅。</p></blockquote><p>当你成功订阅了一个特征值后，当值发生变化时，外围设备会通知你的应用程序。每次这个值改变时，外围设备都会调用它的委托对象的<code>peripheral:didUpdateValueForCharacteristic:error:</code>方法。要检索更新的值，可以按照上面读取特征值中描述的方法实现此方法。</p><h3 id="写特征值"><a href="#写特征值" class="headerlink" title="写特征值"></a>写特征值</h3><p>如果一个特征的值是可写的，你可以通过调用外围的<code>writeValue:forCharacteristic:type:</code>方法来写它的值(NSData的一个实例)，就像这样:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Writing value for characteristic %@&quot;</span>, interestingCharacteristic);</span><br><span class="line">[peripheral writeValue:dataToWrite forCharacteristic:interestingCharacteristic</span><br><span class="line">    type:CBCharacteristicWriteWithResponse];</span><br></pre></td></tr></table></figure><p>当您写入一个特征的值时，您可以指定要执行哪种类型的写入。在上面的例子中，写类型是<code>CBCharacteristicWriteWithResponse</code>，它指示外围设备通过调用它的委托对象的<code>peripheral:didWriteValueForCharacteristic:error:</code>方法让你的应用程序知道写是否成功。你可以实现这个委托方法来处理错误情况，如下面的例子所示:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)peripheral:(CBPeripheral *)peripheral</span><br><span class="line">didWriteValueForCharacteristic:(CBCharacteristic *)characteristic</span><br><span class="line">             error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Error writing characteristic value: %@&quot;</span>,</span><br><span class="line">            [error localizedDescription]);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>如果您指定写类型为<code>CBCharacteristicWriteWithoutResponse</code>，那么写操作将尽最大努力执行，并且既不保证也不报告交付。外围设备不调用任何委托方法。</p><blockquote><p>注意:特征可能只支持某些类型的写操作，也可能根本不支持。您可以通过检查CBCharacteristicPropertyWriteWithoutResponse或CBCharacteristicPropertyWrite常量之一的properties属性来确定一个特性支持哪种类型的写操作</p></blockquote><h2 id="服务和特征由uuid标识"><a href="#服务和特征由uuid标识" class="headerlink" title="服务和特征由uuid标识"></a>服务和特征由uuid标识</h2><p>外设的服务和特征由128位特定于蓝牙的uuid标识，这些uuid在核心蓝牙框架中由<code>CBUUID</code>对象表示。并非所有标识服务或特征的<code>uuid</code>都是由蓝牙特殊兴趣小组(Bluetooth Special Interest Group, SIG)预定义的，但蓝牙SIG已经定义并发布了许多常用的uuid，为了方便起见，这些uuid已被缩短为<code>16</code>位。例如，Bluetooth SIG预定义了用于<strong>标识心率服务的16位UUID为180D</strong>。该UUID是其<code>等效的128位UUID 0000180D-0000-1000-8000-00805F9B34FB</code>的缩写，它基于蓝牙4.0规范，卷3,F部分，章节3.2.1中定义的蓝牙基本UUID。</p><p><code>CBUUID *heartRateServiceUUID = [CBUUID UUIDWithString: @&quot;180D&quot;];</code></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codable协议</title>
      <link href="/2022/12/02/Codable%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/12/02/Codable%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>Codable 本身就是个类型别名</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Codable</span> <span class="operator">=</span> <span class="type">Decodable</span> &amp; <span class="type">Encodable</span></span><br></pre></td></tr></table></figure><p>代表一个同时符合 <code>Decodable</code> 和 <code>Encodable</code> 协议的类型，即可解码且可编码的类型。</p><span id="more"></span><h4 id="Codable-的用法"><a href="#Codable-的用法" class="headerlink" title="Codable 的用法"></a>Codable 的用法</h4><p>Codable 是用来做系统自身数据结构和外部公共数据结构做转换的。系统内部数据结构可以是基础类型、结构体、枚举、类等，外部公共数据结构可以是 JSON、XML 等。</p><h4 id="JSON-和-模型的相互转换"><a href="#JSON-和-模型的相互转换" class="headerlink" title="JSON 和 模型的相互转换"></a>JSON 和 模型的相互转换</h4><ol><li>在 Swift 中可以通过继承 <code>NSObject</code> 的方式，来使用基于 OC Runtime 的 <code>JSON</code> 模型互转方案</li><li>苹果提供了 <code>JSONEncoder</code> 和 <code>JSONDecoder</code> 这两个结构体来方便得在 <code>JSON</code> 数据和自定义模型之间互相转换.苹果可以利用一些系统私有的机制来实现转换，而不需要通过 OC Runtime</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line"><span class="keyword">let</span> json <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;name&quot;: &quot;zhangsan&quot;,</span></span><br><span class="line"><span class="string">        &quot;age&quot;: 25</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.data(using: .utf8)<span class="operator">!</span></span><br><span class="line"><span class="keyword">let</span> user <span class="operator">=</span> <span class="type">JSONDecoder</span>().decode(<span class="type">User</span>.<span class="keyword">self</span>, from: json)</span><br><span class="line"></span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="keyword">let</span> data <span class="operator">=</span> <span class="type">JSONEncoder</span>().encode(user)</span><br></pre></td></tr></table></figure><h4 id="自定义-CodingKeys"><a href="#自定义-CodingKeys" class="headerlink" title="自定义 CodingKeys"></a>自定义 CodingKeys</h4><p>自定义 <code>CodingKeys</code> 主要是两个目的</p><ol><li>当数据类型属性名和 <code>JSON</code> 中字段名不同时，做 key 的映射。</li><li>通过在不添加某些字段的 <code>case</code>，来跳过某些字段的编解码过程。</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> birthday: <span class="type">Date</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_">String</span>, <span class="title class_">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> name <span class="operator">=</span> <span class="string">&quot;userName&quot;</span></span><br><span class="line">        <span class="keyword">case</span> age <span class="operator">=</span> <span class="string">&quot;userAge&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CodingKeys</code> 必须是一个 <code>RawValue</code> 为 <code>String</code> 类型的枚举，并符合 <code>CodingKey</code> 协议。以上代码实现的效果为，为 <code>name</code> 和 <code>age</code> 字段做了 <code>key</code> 映射，让编解码过程中不包含 <code>birthday</code> 字段。</p><h4 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h4><p>在 Swift 的 JSON 转模型方法中一共有三种实现方案：</p><ol><li>Objective-C Runtime</li><li><code>Key 映射</code> 比如 <code>ObjectMapper</code> 就是这种，这种的缺点是每个对象都要写一大堆映射代码，比较麻烦</li><li>利用对象底层内存布局 <code>SwiftyJSON</code> 就属于这种，这种方法使用起来一样很方便，但是依赖苹果的私有代码，苹果如果调整了内部实现就会失效。</li></ol><p><code>Codable</code> 基本上就是 <code>Key</code> 映射的方案，只不过编译器帮我们自动合成了很多代码来让我们使用起来一样可以非常简单。由于编译器不会帮第三方库合成代码，因此 <code>Codable</code> 秒杀了一众基于 <code>key</code> 映射实现的第三方库</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/preyer2011/article/details/126824170">详解 Codable 的用法和原理</a><br><a href="https://juejin.cn/post/7029281323453792269">Swift 之 Codable 实战技巧</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】iOS启动优化</title>
      <link href="/2022/12/02/iOS%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E7%BF%BB%E8%AF%91/"/>
      <url>/2022/12/02/iOS%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>通过最小化启动时间，为应用创造更快速的体验。</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> 用户使用应用程序的第一次体验是它启动时的等待。操作系统表明，应用程序在iOS上启动时出现闪屏，在<code>macOS</code>上的<code>Dock</code>中弹出图标。应用程序需要准备好帮助用户尽快完成任务。如果一款应用启动时间过长，可能会让用户感到沮丧。在iOS平台上，<strong>如果启动时间过长，看门狗就会终止该应用</strong>。通常情况下，如果应用是用户日常工作流程的一部分，那么用户一天会启动应用多次，而较长的启动时间会导致执行任务的延迟。 </p><p>当用户点击主屏幕上应用程序的图标时，iOS会在将控制权移交给应用程序进程之前为应用程序的启动做好准备。然后，应用程序运行代码，准备将其UI绘制到屏幕上。即使在应用程序的UI可见之后，应用程序可能仍然在准备内容或用最终控件替换插页界面(例如，加载旋转器)。这些步骤都会影响应用的总启动时间，你可以采取措施减少它们的持续时间。</p><h2 id="了解应用激活"><a href="#了解应用激活" class="headerlink" title="了解应用激活"></a>了解应用激活</h2><p>当用户点击你的图标或回到你的应用程序时，就会发生激活。 </p><p>在iOS上，激活既可以是启动，也可以是恢复。启动是当进程需要启动时，而恢复是当你的应用程序已经有一个活跃的进程，即使暂停。恢复通常要快得多，优化启动和恢复的工作是不同的。 </p><p>在macOS上，系统不会终止您的进程作为正常使用的一部分。激活可能需要系统从压缩器（compressor）引入内存、交换和重新渲染。</p><h2 id="理解冷启动和热启动"><a href="#理解冷启动和热启动" class="headerlink" title="理解冷启动和热启动"></a>理解冷启动和热启动</h2><p>应用程序的激活取决于设备上之前的操作。 </p><p>例如，在iOS平台上，如果你滑回主屏幕并立即重新进入应用程序，这就是最快的激活速度。它也可能是一份恢复。当系统确定需要启动时，通常称为“热启动”。 </p><p>相反地，如果用户刚刚玩了一款内存密集型的游戏，然后他们再次进入你的应用，那么它可能会比你的平均激活速度慢得多。在iOS上，你的应用程序通常会被从内存中移除，以允许前台应用程序拥有更多的内存。<strong>应用程序启动所依赖的框架和守护进程(Frameworks and daemons)也可能需要重新启动并从磁盘进行分页加载</strong><a href="%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%8D%E7%A7%B0%E9%80%9A%E5%B8%B8%E4%BB%A5%E5%AD%97%E6%AF%8Dd%E7%BB%93%E5%B0%BE%EF%BC%8C%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%AB%E5%90%8D%E5%8C%85%E6%8B%AC%E6%9C%8D%E5%8A%A1">^守护进程</a>。这种场景，或者在系统启动后立即启动app，通常称为“冷启动”。 </p><p>把冷启动和热启动看作一个光谱。在实际使用中，用户将根据设备的状态体验到不同的性能。这就是为什么在各种条件下进行测试对于预测真实世界的性能至关重要。</p><h2 id="收集关于应用发布时间的参数"><a href="#收集关于应用发布时间的参数" class="headerlink" title="收集关于应用发布时间的参数"></a>收集关于应用发布时间的参数</h2><p>启动过程中的各种变化意味着理解应用在该领域的运行方式可能具有挑战性。 </p><p>对于iOS应用，使用<code>Xcode Organizer</code>中的<code>Launch Time</code>面板来查看从用户点击图标到静态启动屏幕后绘制第一个屏幕之间的毫秒数。使用过滤器检查不同设备上的启动时间以及典型(第50个百分位数)和最长(第90个百分位数)时间。通过单击所需版本的图表中的栏，比较当前版本的发布时间与之前版本的发布时间。</p><img src="/2022/12/02/iOS%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E7%BF%BB%E8%AF%91/reducing-your-app-s-launch-time-1@2x.png" class="&#x3D;"><p><code>MetricKit</code>除了报告启动时间外，还报告恢复应用程序的时间。<code>MXAppLaunchMetric</code>包含前一天启动和恢复时间的直方图。</p><h2 id="分析应用的启动时间"><a href="#分析应用的启动时间" class="headerlink" title="分析应用的启动时间"></a>分析应用的启动时间</h2><p>一旦你知道应用启动需要多长时间，你就需要知道为什么需要这么长时间。分析你的应用程序的代码是一种收集你需要的关于你的应用程序花费时间的数据的方法。在分析过程中，<code>Instruments</code>收集有关应用程序调用的方法以及执行这些方法花费的时间的信息。使用这些数据来识别代码中潜在的瓶颈或问题。 </p><p>在<code>Instruments</code>中使用<code>app Launch</code>模板来配置你的应用。在启动期间，<code>Instruments</code>收集时间配置文件和线程状态跟踪。使用时间配置文件来识别应用程序在启动期间运行的代码。使用线程状态跟踪来查找线程活动或阻塞的时间，并发现线程阻塞的原因。 </p><p>分析应用在不同情况下的启动时间，看看这些因素是如何影响体验的。下面是一些需要测试的不同情况的例子:</p><ul><li><p>打开设备，第一次解锁，然后启动你的应用。 </p></li><li><p>强制退出你的应用，然后启动它。系统将终止应用程序进程，系统将执行热启动。 </p></li><li><p>如果你打开其他应用程序，然后启动你的应用程序，系统将部分回收你的应用程序及其依赖项。这反映了一个常见的用户工作流程。 </p></li><li><p>使用一个非常大的应用程序——例如，一个使用许多图形资源或实时摄像头输入的应用程序——然后启动你的应用程序。系统可能会终止你的应用程序的进程，这意味着系统需要在你下次启动时分页加载应用程序的许多依赖项。</p></li></ul><img src="/2022/12/02/iOS%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E7%BF%BB%E8%AF%91/reducing-your-app-s-launch-time-2.png" class="&#x3D;"><p>UIKit在主线程上绘制视图和处理用户事件，所以当应用程序完成启动时，该线程必须可用来绘制第一帧。在<code>Instruments</code>线程跟踪中，主线程运行或被抢占的时间是它无法绘制视图或响应用户输入事件的时间。 </p><p>对于应用程序启动的不同视图，使用时间配置文件模板(Time Profile template)分析应用程序。App生命周期时间轴将App启动期间的活动划分为进程初始化、UIKit初始化、UIKit初始场景渲染和初始帧渲染。</p><img src="/2022/12/02/iOS%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E7%BF%BB%E8%AF%91/reducing-your-app-s-launch-time-3.png" class="&#x3D;"><h2 id="减少对外部框架和动态库的依赖"><a href="#减少对外部框架和动态库的依赖" class="headerlink" title="减少对外部框架和动态库的依赖"></a>减少对外部框架和动态库的依赖</h2><p>在你的任何代码运行之前，系统必须找到并加载你的应用程序的可执行文件和它所依赖的任何库。 </p><p>动态加载器(dyld)加载应用程序的可执行文件，并检查可执行文件中的<code>Mach</code>加载命令，以查找应用程序需要的框架(frameworks)和动态库。然后它将每个框架加载到内存中，并解析可执行文件中的动态符号以指向动态库中的适当地址。 </p><p>你的应用加载的每一个额外的第三方框架都会增加启动时间。尽管dyld在用户安装应用程序时在启动闭包(launch closure)中缓存了大量的工作，但启动闭包的大小和加载后完成的工作量仍然取决于加载的库的数量和大小。你可以通过限制嵌入的第三方框架的数量来缩短应用程序的启动时间。在Xcode的Target编辑器中，你导入或添加到应用的链接框架和库设置中的框架都计入这个数字。像<code>CoreFoundation</code>这样的内置框架对启动的影响要小得多，因为它们与使用相同框架的其他进程使用<strong>共享内存</strong>。</p><h2 id="删除或减少静态初始化代码"><a href="#删除或减少静态初始化代码" class="headerlink" title="删除或减少静态初始化代码"></a>删除或减少静态初始化代码</h2><p>应用程序中的某些代码必须在iOS运行你的应用程序的main()函数之前运行，这增加了启动时间。此代码包括: </p><ul><li>c++ static constructors。 </li><li>Objective-C + load在类或类别中定义的方法。 </li><li>带有clang属性<code>__attribute__((constructor))</code>标记的函数。 </li><li>任何链接到应用程序或框架二进制文件的<code>__DATA</code>，<code>__mod_init_func</code>部分的函数。</li></ul><p>在可能的情况下，将代码移到应用程序生命周期的后期阶段，即在应用程序完成启动后，但在需要工作结果之前。在Instruments中，静态初始化器调用工具测量应用程序运行静态初始化器所花费的时间。</p><img src="/2022/12/02/iOS%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E7%BF%BB%E8%AF%91/reducing-your-app-s-launch-time-4.png" class="&#x3D;"><h2 id="将耗时（expensive）的任务移出应用程序委托"><a href="#将耗时（expensive）的任务移出应用程序委托" class="headerlink" title="将耗时（expensive）的任务移出应用程序委托"></a>将耗时（expensive）的任务移出应用程序委托</h2><p>审查初始化代码以延迟耗时的工作。系统在启动周期中调用你的应用程序委托的方法，给你时间来执行所需的任务。这些方法在主线程上同步执行，直到两个方法都成功返回，启动周期才会结束。因此，从这些方法执行的任何开销很大的任务都会延迟该启动周期的完成。 </p><p>UIKit初始化你的应用程序委托类的一个实例(符合<code>UIApplicationDelegate</code>协议的类)，并向它发送 <code>application(_:willFinishLaunchingWithOptions:)</code>和 <code>application(_:didFinishLaunchingWithOptions:)</code>消息。UIKit在主线程上发送这些消息，在这些方法中执行代码所花费的时间增加了应用程序的启动时间。在这些方法中只做准备应用程序初始显示所需的工作;将其他任务推迟到应用程序生命周期中更合适的时间。 </p><p>在刷新内容时向用户显示过时的内容是有意义的，将网络服务的数据模型的同步推迟到应用程序运行时。将同步移动到异步后台队列。注册一个后台任务来从网络服务中获取更新，以减少启动时数据的陈旧性和更新数据所需的工作量。 </p><p>初始化非视图功能，如持久存储和位置服务，在第一次使用时，而不是在应用启动时。只检索显示应用程序初始视图所需的数据。请注意您的应用程序是否正在恢复状态，并准备显示正在恢复的视图所需的数据。如果没有恢复状态，只准备默认的初始视图。例如，一个图片库应用程序可能会在默认情况下显示一组图像缩略图，并让用户选择一张照片以获得详细视图。如果应用程序启动时没有恢复状态，它只需要显示一个占位符的一个屏幕的缩略图，并在应用程序完成启动后用真实的图像缩略图填充它们。它不需要加载完整的、详细的图片，直到用户点击其中一个缩略图。 </p><p>初始化应用行为的受限子集，这在初始启动时是可行的。例如，一个任务管理器应用程序可以让用户在启动时创建一个新任务，即使应用程序还没有从它的持久存储或网络服务中检索到用户现有的所有任务。</p><h2 id="降低初始视图的复杂性"><a href="#降低初始视图的复杂性" class="headerlink" title="降低初始视图的复杂性"></a>降低初始视图的复杂性</h2><p><code>Xcode Organizer</code>和<code>MetricKit</code>都使用到第一帧的时间作为启动时间的度量，包括绘制在第一帧上显示的视图所需的时间。你只能在主线程上修改视图层次结构;因此，具有更多视图的更复杂的视图层次结构比简单的层次结构需要更长的渲染时间。 </p><p>减少应用程序初始视图的复杂性可以提高加载时间，用标准视图替换重写(override)<code>draw(_:)</code>的自定义视图也是如此。在需要自定义视图的地方，注意传递给<code>draw(_:)</code>的矩形，只渲染该矩形内的部分视图。这样做可以避免在视图中未呈现到屏幕的部分解码图像和计算颜色、坐标和绘图命令。</p><h2 id="跟踪额外的启动活动"><a href="#跟踪额外的启动活动" class="headerlink" title="跟踪额外的启动活动"></a>跟踪额外的启动活动</h2><p>启动时间度量从用户点击主屏幕上的应用程序图标到应用程序在屏幕上绘制第一帧的时间。在此期间绘制<code>default.png</code>或<code>launch-screen storyboard</code>，它的出现不会结束启动时间计数器。 </p><p>如果你的应用在绘制了第一帧之后，但在用户可以开始使用应用之前，仍然需要运行代码，那么这段时间不会影响到启动时间指标。额外的启动活动仍然有助于用户感知应用程序的响应能力。例如，如果你的应用程序在打开后渲染一个文档，用户可能会等待文档渲染，并将其视为你的启动时间的一部分，即使系统将在你显示加载图标时结束启动测量。 </p><p>要跟踪额外的启动活动，在应用程序中创建一个<code>OSLog</code>对象，类别为<code>pointsOfInterest</code>。使用<code>os_signpost</code>函数来记录应用程序准备任务的开始和结束，如下例所示:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ViewController</span>: <span class="title class_">UIViewController</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> startupActivities:<span class="type">StaticString</span> <span class="operator">=</span> <span class="string">&quot;Startup Activities&quot;</span></span><br><span class="line">    <span class="keyword">let</span> poiLog <span class="operator">=</span> <span class="type">OSLog</span>(subsystem: <span class="string">&quot;com.example.CocoaPictures&quot;</span>, category: .pointsOfInterest)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidAppear</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidAppear()</span><br><span class="line">        os_signpost(.begin, log: <span class="keyword">self</span>.poiLog, name: <span class="type">ViewController</span>.startupActivities)</span><br><span class="line">        <span class="comment">// do work to prepare the view</span></span><br><span class="line">        os_signpost(.end, log: <span class="keyword">self</span>.poiLog, name: <span class="type">ViewController</span>.startupActivities)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Instruments中，<code>Points of Interest</code>在其时间轴中显示<code>os_signposts</code>。你可以使用这些信息将应用程序中的活动与应用程序的附加启动任务关联起来。</p><img src="/2022/12/02/iOS%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E7%BF%BB%E8%AF%91/reducing-your-app-s-launch-time-5@2x.png" class="&#x3D;"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://zh.m.wikipedia.org/zh/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">守护进程百科</a></p><p><a href="https://developer.apple.com/documentation/xcode/reducing-your-app-s-launch-time">启动优化</a></p><p><a href="https://linux.vbird.org/linux_basic/centos7/0560daemons.php">認識系統服務 (daemons)</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【译】创建扩展小组件</title>
      <link href="/2022/11/28/%E5%88%9B%E5%BB%BA%E6%8B%93%E5%B1%95%E5%B0%8F%E7%BB%84%E4%BB%B6%E7%BF%BB%E8%AF%91/"/>
      <url>/2022/11/28/%E5%88%9B%E5%BB%BA%E6%8B%93%E5%B1%95%E5%B0%8F%E7%BB%84%E4%BB%B6%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>添加和配置一个扩展，以显示您的应用程序的内容在主屏幕，今日视图，或通知中心。</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>小组件显示相关的、可浏览的内容，让用户快速访问你的应用程序获得更多细节。你的应用程序可以提供各种小组件，让用户专注于对他们来说最重要的信息。他们可以添加同一个小组件的多个副本，并根据各自的独特需求和布局进行定制。如果在小组件中包含自定义意图（custom intent），用户还可以对每个小组件单独进行个性化设置。小部件支持多种大小;选择最适合应用内容的大小。由于空间有限，请确保您的小组件显示人们最重视的信息。 </p><p>向应用程序中添加小组件只需要最少的设置，以及关于用户界面的配置和风格的一些决策。小组件使用<code>SwiftUI</code>视图显示其内容。更多信息请参见<code>SwiftUI</code></p><h2 id="添加一个小组件目标到您的应用程序"><a href="#添加一个小组件目标到您的应用程序" class="headerlink" title="添加一个小组件目标到您的应用程序"></a>添加一个小组件目标到您的应用程序</h2><p>小组件扩展模板提供了创建小组件的起点。一个小组件扩展可以包含多个小组件。例如，一个体育应用程序可能有一个显示球队信息的小组件，而另一个显示比赛日程。一个小组件扩展可以包含两个小组件。</p><ol><li>在<code>Xcode</code>中打开你的应用项目，选择<code>File &gt; New &gt; Target</code>。 </li><li>从应用程序扩展组中选择小组件扩展，然后单击下一步。 </li><li>输入您的扩展名。 </li><li>如果小组件提供用户可配置的属性，请选中<code>Include Configuration Intent</code>复选框。 </li><li>单击Finish。</li></ol><p>通常，你将所有的小组件包含在一个小组件扩展中，尽管你的应用程序可以包含多个扩展。例如，如果您的一些小组件使用位置信息，而其他小组件不使用，那么将使用位置信息的小组件保留在单独的扩展中。这允许系统提示用户授权只对使用位置信息的扩展的小组件使用位置信息。</p><h2 id="添加配置详情"><a href="#添加配置详情" class="headerlink" title="添加配置详情"></a>添加配置详情</h2><p>小组件扩展模板提供了符合<code>widget</code>协议的初始小组件实现。此小组件的主体属性确定该小组件是否具有用户可配置的属性。有两种配置:</p><p><code>StaticConfiguration</code>（静态配置）<br>对于没有用户可配置属性的小组件。例如，显示一般市场信息的股票市场小组件，或显示趋势标题的新闻小组件。</p><p><code>IntentConfiguration</code>（意向配置）<br> 对于具有用户可配置属性的小组件。使用<code>SiriKit</code>自定义意图（custom intent）来定义属性。例如，一个天气小组件需要一个城市的邮政编码或邮政编码（zip or postal code），或者一个包裹跟踪（package-tracking）小组件需要一个跟踪号。</p><p> 包含配置意图复选框决定了<code>Xcode</code>使用哪种配置。当你选中这个复选框时，<code>Xcode</code>会使用一个意向配置;否则，它使用静态配置。要初始化一个<code>IntentConfiguration</code>，向它的初始化器提供以下信息:</p><p> kind （种类）<br>标识小组件的字符串。这是您选择的标识符，并且应该描述小组件所代表的内容。</p><p>provider（供应商）<br>一个符合<code>TimelineProvider</code>并生成时间轴的对象，告诉<code>WidgetKit</code>何时呈现小组件。时间轴包含您定义的自定义<code>TimelineEntry</code>类型。当您希望<code>WidgetKit</code>更新小部件的内容时，时间轴条目（entry）标识日期。包含小组件视图需要以自定义类型呈现的属性。</p><p>intent（意图）<br>自定义用户可配置属性的自定义意图。有关添加自定义的详细信息，请参见制作可配置小组件。</p><p>content（内容）<br>包含<code>SwiftUI</code>视图的闭包。<code>WidgetKit</code>调用它来呈现小组件的内容，并从提供程序传递一个<code>TimelineEntry</code>参数。</p><p>使用修饰符（modifiers）提供额外的配置细节，包括显示名称、描述和小组件支持的系列（families）。以下代码显示了一个小组件，它为游戏提供了一般的、不可配置的状态:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameStatusWidget</span>: <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">WidgetConfiguration</span> &#123;</span><br><span class="line">        <span class="type">StaticConfiguration</span>(</span><br><span class="line">            kind: <span class="string">&quot;com.mygame.game-status&quot;</span>,</span><br><span class="line">            provider: <span class="type">GameStatusProvider</span>(),</span><br><span class="line">        ) &#123; entry <span class="keyword">in</span></span><br><span class="line">            <span class="type">GameStatusView</span>(entry.gameStatus)</span><br><span class="line">        &#125;</span><br><span class="line">        .configurationDisplayName(<span class="string">&quot;Game Status&quot;</span>)</span><br><span class="line">        .description(<span class="string">&quot;Shows an overview of your game status&quot;</span>)</span><br><span class="line">        .supportedFamilies([.systemSmall, .systemMedium, .systemLarge, .systemExtraLarge])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小组件的提供者为小组件生成时间轴，并在每个条目（entry）中包含游戏状态细节。当每个时间轴条目（entry）的日期到达时，<code>WidgetKit</code>调用内容闭包来显示小组件的内容。最后，修饰符指定（specify）小组件库（gallery）中显示的名称和描述，并允许用户选择小组件的小、中或大版本。</p><blockquote><p>要让应用程序的小组件出现在小组件库中，用户必须在应用程序安装后启动包含该小组件的应用程序至少一次。</p></blockquote><p>注意这个小组件上<code>@main</code>属性的用法。这个属性表明<code>GameStatusWidget</code>是小组件扩展的入口点，这意味着扩展包含单个小组件。要支持多个小组件，请参阅下面的部分在您的应用程序扩展中声明多个小组件。</p><h2 id="提供时间轴条目"><a href="#提供时间轴条目" class="headerlink" title="提供时间轴条目"></a>提供时间轴条目</h2><p>时间轴供应商生成由时间轴条目组成的时间轴，每个条目指定更新小组件内容的日期和时间。游戏状态小组件可以定义它的时间轴条目，包括一个表示游戏状态的字符串，如下所示:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">GameStatusEntry</span>: <span class="title class_">TimelineEntry</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> date: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">var</span> gameStatus: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要在小组件库中显示小组件，<code>WidgetKit</code>要求提供者提供预览快照。通过检查传递给<code>getSnapshot(in:completion:)</code>方法的上下文参数的<code>isPreview</code>属性来识别这个预览请求。当<code>isPreview</code>为<code>true</code>时，<code>WidgetKit</code>在小组件库中显示您的小组件。因此，您需要快速创建预览快照。如果您的小组件需要从服务器生成或获取需要时间的资产（assets）或信息，请使用示例数据。 </p><p>在以下代码中，游戏状态小组件的提供者通过显示一个空状态来实现<code>snapshot</code>方法，如果它还没有完成从其服务器获取状态:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">GameStatusProvider</span>: <span class="title class_">TimelineProvider</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> hasFetchedGameStatus: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">var</span> gameStatusFromServer: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">getSnapshot</span>(<span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>, <span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Entry</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> date <span class="operator">=</span> <span class="type">Date</span>()</span><br><span class="line">        <span class="keyword">let</span> entry: <span class="type">GameStatusEntry</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> context.isPreview <span class="operator">&amp;&amp;</span> <span class="operator">!</span>hasFetchedGameStatus &#123;</span><br><span class="line">            entry <span class="operator">=</span> <span class="type">GameStatusEntry</span>(date: date, gameStatus: <span class="string">&quot;—&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry <span class="operator">=</span> <span class="type">GameStatusEntry</span>(date: date, gameStatus: gameStatusFromServer)</span><br><span class="line">        &#125;</span><br><span class="line">        completion(entry)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 在请求初始快照之后，WidgetKit调用getTimeline(in:completion:)从提供程序请求一个常规的时间轴。时间轴由一个或多个时间轴条目和一个重新加载策略组成，该策略通知WidgetKit何时请求后续的时间轴。 </p><p>下面的例子展示了游戏状态小组件的提供者如何生成一个时间轴，它包含来自服务器的包含当前游戏状态的单个条目，以及一个在15分钟内请求新时间轴的重新加载策略:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">GameStatusProvider</span>: <span class="title class_">TimelineProvider</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">getTimeline</span>(<span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>, <span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Timeline</span>&lt;<span class="type">GameStatusEntry</span>&gt;) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="comment">// Create a timeline entry for &quot;now.&quot;</span></span><br><span class="line">        <span class="keyword">let</span> date <span class="operator">=</span> <span class="type">Date</span>()</span><br><span class="line">        <span class="keyword">let</span> entry <span class="operator">=</span> <span class="type">GameStatusEntry</span>(</span><br><span class="line">            date: date,</span><br><span class="line">            gameStatus: gameStatusFromServer</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a date that&#x27;s 15 minutes in the future.</span></span><br><span class="line">        <span class="keyword">let</span> nextUpdateDate <span class="operator">=</span> <span class="type">Calendar</span>.current.date(byAdding: .minute, value: <span class="number">15</span>, to: date)<span class="operator">!</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the timeline with the entry and a reload policy with the date</span></span><br><span class="line">        <span class="comment">// for the next update.</span></span><br><span class="line">        <span class="keyword">let</span> timeline <span class="operator">=</span> <span class="type">Timeline</span>(</span><br><span class="line">            entries:[entry],</span><br><span class="line">            policy: .after(nextUpdateDate)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call the completion to pass the timeline to WidgetKit.</span></span><br><span class="line">        completion(timeline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，如果小部件没有来自服务器的当前状态，它可以存储对完成的引用，向服务器执行异步请求以获取游戏状态，并在请求完成时调用完成。 </p><p>有关生成时间线(包括在小部件中处理网络请求)的更多信息，请参见保持小部件最新</p><h2 id="显示占位符小组件并隐藏敏感数据"><a href="#显示占位符小组件并隐藏敏感数据" class="headerlink" title="显示占位符小组件并隐藏敏感数据"></a>显示占位符小组件并隐藏敏感数据</h2><p>占位符视图是没有特定内容的通用可视化表示。当<code>WidgetKit</code>呈现您的小部件时，它可能需要将您的内容呈现为占位符;例如，当您在后台加载数据时。它使用<code> redacted(reason:)</code>视图修饰符生成占位符，并将<code>reason</code>设置为占位符。该设置自动呈现小部件的视图，其方式适合作为占位符使用。若要选择不将呈现为占位符，并控制小部件的哪些视图显示为审查（redacted）以隐藏敏感信息，请在<code>redacted(reason:)</code>回调中使用<code>unredacted()</code>视图修饰符。 </p><p>除了首次出现外，当您为小部件扩展启用<code>Data Protection</code>功能时，<code>WidgetKit</code>还将小部件视图呈现为占位符。<code>WidgetKit</code>使用您应用的编辑（redactions）来呈现小部件的视图，或者如果您将数据保护授权设置为:</p><ul><li><code>NSFileProtectionComplete</code> and the device is locked</li><li><code>NSFileProtectionCompleteUnlessOpen</code> and the device is locked</li><li><code>NSFileProtectionCompleteUntilFirstUserAuthentication</code> and the user has not yet authenticated</li></ul><p>用户控制小部件在某些表示上下文中是否显示编辑（redacted）视图或占位符，例如在<code>iPhone</code>锁定屏幕或<code>watchOS</code>中的表面上。 </p><p>在<code>watchOS</code>中，设备在使用过程中很少被锁定，因为<code>Apple Watch</code>通常是在用户佩戴时解锁的。但是，用户可以通过选择“设置”来配置是否在“始终打开”期间显示敏感数据(<code>Settings &gt; Display &amp; Brightness &gt; Always On &gt; Hide Sensitive Complications</code>)。如果用户启用隐藏敏感并发症，<code>WidgetKit</code>将呈现您配置的编校(redactions)或返回占位符。他们可以选择为所有或个别并发症(individual complications)显示经过修订的内容。类似地，在iOS中，设备也可能支持<code>Always On</code>，用户可以配置在<code>Always On</code>期间是否显示敏感数据。在不支持<code>Always On</code>的iOS设备上，用户可以通过选择<code>设置&gt;面部ID和密码</code>来控制是否在锁屏上显示敏感数据，并在<code>ALLOW access WHEN LOCKED</code>部分取消对锁屏小部件的数据访问</p><p>有关配置数据保护的详细信息，请参阅数据保护授权</p><h2 id="在小部件中显示内容"><a href="#在小部件中显示内容" class="headerlink" title="在小部件中显示内容"></a>在小部件中显示内容</h2><p>小部件使用<code>SwiftUI</code>视图定义其内容，通常是通过组合其他<code>SwiftUI</code>视图。如<code>Add Configuration Details</code>部分所示，小部件的配置包含一个闭包，<code>WidgetKit</code>调用该闭包来呈现小部件的内容。 </p><p>当用户从小部件库中添加您的小部件时，他们从小部件支持的小部件中选择特定的家族—例如，小型或中型。小部件的内容闭包必须能够呈现小部件支持的每个族。<code>WidgetKit</code>在<code>SwiftUI</code>环境中设置相应的族和附加属性，例如配色方案(亮或暗)。 </p><p>在上图所示的游戏状态小部件配置中，内容闭包使用<code>GameStatusView</code>来显示状态。因为小部件支持锁定屏幕上的大小和附件小部件，它使用<code>widgetFamily</code>来决定要显示哪个特定的<code>SwiftUI</code>视图，如下所示:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">GameStatusView</span> : <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@Environment</span>(\.widgetFamily) <span class="keyword">var</span> family: <span class="type">WidgetFamily</span></span><br><span class="line">    <span class="keyword">var</span> gameStatus: <span class="type">GameStatus</span></span><br><span class="line">    <span class="keyword">var</span> selectedCharacter: <span class="type">CharacterDetail</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ViewBuilder</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> family &#123;</span><br><span class="line">        <span class="keyword">case</span> .systemSmall: <span class="type">GameTurnSummary</span>(gameStatus)</span><br><span class="line">        <span class="keyword">case</span> .systemMedium: <span class="type">GameStatusWithLastTurnResult</span>(gameStatus)</span><br><span class="line">        <span class="keyword">case</span> .systemLarge: <span class="type">GameStatusWithStatistics</span>(gameStatus)</span><br><span class="line">        <span class="keyword">case</span> .systemExtraLarge: <span class="type">GameStatusWithStatisticsExtraLarge</span>(gameStatus)</span><br><span class="line">        <span class="keyword">case</span> .accessoryCircular: <span class="type">HealthLevelCircular</span>(selectedCharacter)</span><br><span class="line">        <span class="keyword">case</span> .accessoryRectangular: <span class="type">HealthLevelRectangular</span>(selectedCharacter)</span><br><span class="line">        <span class="keyword">case</span> .accessoryInline: <span class="type">HealthLevelInline</span>(selectedCharacter)</span><br><span class="line">        <span class="keyword">default</span>: <span class="type">GameDetailsNotAvailable</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于小家庭(small family)，小部件使用一个视图来显示它在游戏中的回合的简单摘要。对于<code>medium</code>，它显示状态，表示上一轮的结果。对于大号和特大号，因为有更多的空间可用，它会显示每个玩家的运行统计数据。附件小部件比主屏幕上显示的小部件小得多。因此，它们会显示圆形附件小部件当前所选字符的健康水平。因为矩形和内联附件小部件允许更多的文本，所以它们会显示角色的生命值级别和剩余的治疗时间。如果家族是未知类型，则显示默认视图，这表示游戏状态不可用</p><blockquote><p>视图用<code>@ViewBuilder</code>声明它的主体，因为它使用的视图类型是不同的。</p></blockquote><p>对于可配置的小部件，提供程序遵循<code>IntentTimelineProvider</code>。该提供程序执行与<code>TimelineProvider</code>相同的功能，但它合并了用户在小部件上自定义的值。在传递给<code>getSnapshot(for:in:completion:)</code>和<code>getTimeline(for:in:completion:)</code>的配置参数中，意图时间轴提供程序可以使用这些自定义。您通常将用户配置的值作为自定义时间轴条目类型的属性包含进来，因此小部件的视图可以使用详细信息</p><blockquote><p>小部件显示只读信息，不支持滚动元素或开关等交互元素。在呈现小部件的内容时，<code>WidgetKit</code>会忽略交互元素。</p></blockquote><p>有关<code>WidgetKit</code>支持的视图列表，请参阅<code>SwiftUI views</code>。</p><h2 id="向小部件添加动态内容"><a href="#向小部件添加动态内容" class="headerlink" title="向小部件添加动态内容"></a>向小部件添加动态内容</h2><p>尽管小部件的显示基于视图的快照，但您可以使用各种<code>SwiftUI</code>视图，它们在小部件可见时继续更新。有关提供动态内容的更多信息，请参见<code>保持小部件更新</code></p><h2 id="响应用户交互"><a href="#响应用户交互" class="headerlink" title="响应用户交互"></a>响应用户交互</h2><p>当用户与您的小部件交互时，系统启动您的应用程序来处理请求。当系统激活你的应用程序时，导航到与小部件内容对应的细节。小部件可以指定一个<code>URL</code>来通知应用程序要显示什么内容。要在小部件中配置自定义<code>URLs</code>: </p><ul><li><p>对于所有小部件，在小部件的视图层次结构中添加<code>widgetURL(_:)</code>视图修饰符。如果小部件的视图层次结构包含多个<code>widgetURL</code>修饰符，则行为未定义。 </p></li><li><p>对于使用<code>WidgetFamily.systemMedium</code>, <code>WidgetFamily.systemLarge</code>或<code>WidgetFamily.systemextrallarge</code>的小部件。将一个或多个<code>Link</code>控件添加到小部件的视图层次结构中。可以同时使用<code>widgetURL</code>和<code>Link</code>控件。如果交互以<code>Link</code>控件为目标，则系统使用该控件中的<code>URL</code>。对于小部件中其他任何地方的交互，系统使用<code>widgetURL</code>视图修饰符中指定的<code>URL</code>。</p></li></ul><p>例如，显示游戏中单个角色细节的小部件可以使用<code>widgetURL</code>打开应用，显示该角色的细节。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewBuilder</span></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">ZStack</span> &#123;</span><br><span class="line">        <span class="type">AvatarView</span>(entry.character)</span><br><span class="line">            .widgetURL(entry.character.url)</span><br><span class="line">            .foregroundColor(.white)</span><br><span class="line">    &#125;</span><br><span class="line">    .background(<span class="type">Color</span>.gameBackground)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果小部件显示一个字符列表，则列表中的每个项都可以位于一个<code>Link</code>控件中。每个Link控件为它所显示的特定字符指定<code>URL</code>。 </p><p>当小部件接收到交互时，系统激活包含该应用程序的应用程序，并将URL传递给<code>onOpenURL(perform:)</code>、<code>application(_:open:options:)</code>或<code>application(_:open:)</code>，这取决于应用程序使用的生命周期。 </p><p>如果小部件不使用<code>widgetURL</code>或<code>Link</code>控件，系统将激活包含该应用的应用程序，并将<code>NSUserActivity</code>传递给<code>onContinueUserActivity(_:perform:)</code>、<code>application(_:continue:restorationHandler:)</code>或<code>application(_:continue:restorationHandler:)</code>。用户活动的<code>userInfo</code>字典包含与用户交互的小部件的详细信息。通过<code>WidgetCenter.UserInfoKey</code>中的键获取Swift代码种的值。要从<code>Objective-C</code>访问<code>userInfo</code>值，请使用键<code>WGWidgetUserInfoKeyKind</code>和<code>WGWidgetUserInfoKeyFamily</code>来代替。 </p><p>对于使用<code>IntentConfiguration</code>的小部件，用户活动的<code>交互</code>属性包含小部件的<code>INIntent</code>。</p><h2 id="在你的应用程序扩展中声明多个小部件"><a href="#在你的应用程序扩展中声明多个小部件" class="headerlink" title="在你的应用程序扩展中声明多个小部件"></a>在你的应用程序扩展中声明多个小部件</h2><p>上面的<code>GameStatusWidget</code>示例使用<code>@main</code>属性为小部件扩展指定一个入口点。要支持多个小部件，声明一个符合<code>WidgetBundle</code>的结构，该结构在其<code>body</code>属性中将多个小部件分组在一起。在这个小部件包结构上添加<code>@main</code>属性，以告诉<code>WidgetKit</code>您的扩展支持多个小部件。 </p><p>例如，如果游戏应用有第二个显示角色生命值的小部件和第三个显示排行榜的小部件，它就会将它们组合在一起，如下所示:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameWidgets</span>: <span class="title class_">WidgetBundle</span> &#123;</span><br><span class="line">    <span class="meta">@WidgetBundleBuilder</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Widget</span> &#123;</span><br><span class="line">        <span class="type">GameStatusWidget</span>()</span><br><span class="line">        <span class="type">CharacterDetailWidget</span>()</span><br><span class="line">        <span class="type">LeaderboardWidget</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在Xcode中预览widget"><a href="#在Xcode中预览widget" class="headerlink" title="在Xcode中预览widget"></a>在Xcode中预览widget</h2><p><code>Xcode</code>允许你查看小部件的预览，而无需在模拟器或测试设备上运行应用程序。下面的示例显示了使用了<a href="https://developer.apple.com/documentation/widgetkit/building_widgets_using_widgetkit_and_swiftui"> Building Widgets Using WidgetKit and SwiftUI</a>sample code的表情符号管理员小部件的预览代码。注意它是如何使用<code>widgetFamily</code>环境值来避免为每个小部件手动指定名称的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Environment</span>(\.widgetFamily) <span class="keyword">var</span> family</span><br><span class="line">        </span><br><span class="line"><span class="type">Group</span> &#123;</span><br><span class="line">    <span class="type">EmojiRangerWidgetEntryView</span>(entry: <span class="type">SimpleEntry</span>(date: <span class="type">Date</span>(), relevance: <span class="literal">nil</span>, character: .panda))</span><br><span class="line">        .previewContext(<span class="type">WidgetPreviewContext</span>(family: .accessoryCircular))</span><br><span class="line">        .previewDisplayName(<span class="string">&quot;<span class="subst">\(family)</span>&quot;</span>)</span><br><span class="line">  <span class="type">EmojiRangerWidgetEntryView</span>(entry: <span class="type">SimpleEntry</span>(date: <span class="type">Date</span>(), relevance: <span class="literal">nil</span>, character: .panda))</span><br><span class="line">        .previewContext(<span class="type">WidgetPreviewContext</span>(family: .accessoryRectangular))</span><br><span class="line">        .previewDisplayName(<span class="string">&quot;<span class="subst">\(family)</span>&quot;</span>)</span><br><span class="line">    <span class="type">EmojiRangerWidgetEntryView</span>(entry: <span class="type">SimpleEntry</span>(date: <span class="type">Date</span>(), relevance: <span class="literal">nil</span>, character: .panda))</span><br><span class="line">        .previewContext(<span class="type">WidgetPreviewContext</span>(family: .accessoryInline))</span><br><span class="line">        .previewDisplayName(<span class="string">&quot;<span class="subst">\(family)</span>&quot;</span>)</span><br><span class="line">    <span class="type">EmojiRangerWidgetEntryView</span>(entry: <span class="type">SimpleEntry</span>(date: <span class="type">Date</span>(), relevance: <span class="literal">nil</span>, character: .panda))</span><br><span class="line">        .previewContext(<span class="type">WidgetPreviewContext</span>(family: .systemSmall))</span><br><span class="line">      .previewDisplayName(<span class="string">&quot;<span class="subst">\(family)</span>&quot;</span>)</span><br><span class="line">    <span class="type">EmojiRangerWidgetEntryView</span>(entry: <span class="type">SimpleEntry</span>(date: <span class="type">Date</span>(), relevance: <span class="literal">nil</span>, character: .panda))</span><br><span class="line">        .previewContext(<span class="type">WidgetPreviewContext</span>(family: .systemMedium))</span><br><span class="line">        .previewDisplayName(<span class="string">&quot;<span class="subst">\(family)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/documentation/widgetkit/creating-a-widget-extension">Creating a Widget Extension</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【译】Protocol Oriented Programming in Swift</title>
      <link href="/2022/11/01/POP%20in%20Swift/"/>
      <url>/2022/11/01/POP%20in%20Swift/</url>
      
        <content type="html"><![CDATA[<p>在2015年的全球开发者大会上，苹果公司宣布Swift是世界上第一种面向协议的编程(POP)语言</p><span id="more"></span><h2 id="什么是POP？"><a href="#什么是POP？" class="headerlink" title="什么是POP？"></a>什么是POP？</h2><p>面向协议编程是<code>Swift 2.0</code>引入的一种新的编程范式。在面向协议的方法中，我们通过定义协议开始设计我们的系统。我们依赖于新的概念:<code>协议扩展</code>、<code>协议继承</code>和<code>协议组合</code>。范式也改变了我们对语义的看法。<strong>在Swift中，值类型优先于类</strong>。然而，面向对象的概念不能很好地与结构体和枚举一起工作:一个结构体不能从另一个结构体继承，一个enum也不能从另一个enum继承。因此继承—一个基本的面向对象的概念—不能应用于值类型。另一方面，<strong>值类型可以从协议继承</strong>，甚至<strong>可以从多个协议继承</strong>。因此，有了POP，值类型就成为了Swift的头等公民。</p><h2 id="从协议开始"><a href="#从协议开始" class="headerlink" title="从协议开始"></a>从协议开始</h2><p>在设计软件系统时，我们试图确定满足给定系统需求所需的元素。然后我们为这些元素之间的关系建模。我们可以从一个超类(superclass)开始，通过继承来建模它的关系。或者我们可以从一个协议开始，将关系建模为一个协议实现。Swift为这两种处理提供了完全支持。然而，苹果告诉我们: </p><p>“不要从类开始，要从协议开始。” </p><p>为什么?协议是比类更好的抽象。</p><img src="/2022/11/01/POP%20in%20Swift/popclasses.png" class="&#x3D;"><p>如果使用类为抽象建模，则需要依赖继承。超类定义核心功能并暴露给子类。子类可以完全覆盖该行为，添加特定的行为，或者由父类完成所有工作。这工作得很好，直到您意识到需要从不同的类中获得更多功能。与许多其他编程语言一样，<strong>Swift不支持多重继承</strong>。为了遵循类优先的处理，您必须不断向超类添加新功能，或者创建新的中介类，从而使问题复杂化。另一方面，协议是模版而不是父母(parents)。协议通过描述实现类型应该实现什么来对抽象进行建模。让我们以以下协议为例:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">uid</span>() -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上可知，该协议的采用者将能够通过实现类型方法<code>uid()</code>创建一个实体，为它分配一个名称并生成它的唯一标识符。</p><img src="/2022/11/01/POP%20in%20Swift/pop01.png" class="&#x3D;"><p>一种类型可以对多个抽象建模，因为任何类型——包括值类型——都可以实现多个协议。与类继承相比，这是一个巨大的好处。您可以根据需要创建尽可能多的协议和协议扩展来分离这些关注点。跟单一(monolithic)超类说再见!唯一需要注意的是，协议抽象地定义了模板——没有实现。这时协议扩展就派上用场了。</p><h2 id="协议编程的支柱-–-协议扩展"><a href="#协议编程的支柱-–-协议扩展" class="headerlink" title="协议编程的支柱 – 协议扩展"></a>协议编程的支柱 – 协议扩展</h2><p>协议就像模版:它们告诉我们采用者应该实现什么，但是您不能在协议中提供实现。如果我们需要为符合规范的类型定义默认行为呢?我们需要在基类中实现它，对吧?错了!必须依赖基类进行默认实现将使协议的好处黯然失色。此外，这对值类型不起作用。幸运的是，还有另一种方法:协议扩展是可行的!在Swift中，您可以扩展协议，并为方法、计算属性、下标和便利初始化器提供默认实现。在下面的示例中，我为类型方法<code>uid()</code>提供了默认实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">uid</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UUID</span>().uuidString</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，采用该协议的类型不再需要实现<code>uid()</code>方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Order</span>: <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> uid: <span class="type">String</span> <span class="operator">=</span> <span class="type">Order</span>.uid()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> order <span class="operator">=</span> <span class="type">Order</span>(name: <span class="string">&quot;My Order&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(order.uid)</span><br><span class="line"><span class="comment">// 4812B485-3965-443B-A76D-72986B0A4FF4</span></span><br></pre></td></tr></table></figure><h2 id="协议继承"><a href="#协议继承" class="headerlink" title="协议继承"></a>协议继承</h2><p>一个协议可以继承其他协议，然后在它继承的需求之上添加进一步的需求。在下面的例子中，协议<code>persistent</code>继承自我前面介绍的<code>Entity</code>协议。它添加了将实体保存到文件并根据其惟一标识符加载它的需求。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Persistable</span>: <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">write</span>(<span class="params">instance</span>: <span class="type">Entity</span>, <span class="params">to</span> <span class="params">filePath</span>: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">by</span> <span class="params">uid</span>: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遵循<code>Persistable</code>协议的类型必须满足<code>Entity </code>和<code>Persistable </code>协议中定义的需求。 </p><p>如果您的类型需要<code>persistence</code>功能，那么它应该实现<code>Persistable </code>协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PersistableEntity</span>: <span class="title class_">Persistable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">write</span>(<span class="params">instance</span>: <span class="type">Entity</span>, <span class="params">to</span> <span class="params">filePath</span>: <span class="type">String</span>) &#123; <span class="comment">// ...</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">by</span> <span class="params">uid</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="comment">// try to load from the filesystem based on id</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不需要<code>persisted </code>的类型只能实现<code>Entity</code>协议:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">InMemoryEntity</span>: <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协议继承是一个功能强大的特性，因为它支持更细粒度和更灵活的设计。</p><h2 id="协议组成"><a href="#协议组成" class="headerlink" title="协议组成"></a>协议组成</h2><p>Swift不允许类的多重继承。但Swift类型可以遵循多种协议。有时您可能会发现这个特性很有用。 </p><p>下面是一个例子:假设我们需要一个表示<code>Entity</code>的类型。 </p><p>我们还需要比较给定类型的实例。我们还想提供一个自定义描述。</p><p>我们有三个协议来定义上述的需求: </p><ul><li>Entity</li><li>Equatable </li><li>CustomStringConvertible<br>如果这些是基类，我们必须将功能合并到一个超类中;然而，有了POP和协议组合，解决方案变成:</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyEntity</span>: <span class="title class_">Entity</span>, <span class="title class_">Equatable</span>, <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="comment">// Equatable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span>(<span class="params">lhs</span>: <span class="type">MyEntity</span>, <span class="params">rhs</span>: <span class="type">MyEntity</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.name <span class="operator">==</span> rhs.name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// CustomStringConvertible</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyEntity: <span class="subst">\(name)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> entity1 <span class="operator">=</span> <span class="type">MyEntity</span>(name: <span class="string">&quot;42&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(entity1)</span><br><span class="line"><span class="keyword">let</span> entity2 <span class="operator">=</span> <span class="type">MyEntity</span>(name: <span class="string">&quot;42&quot;</span>)</span><br><span class="line"><span class="built_in">assert</span>(entity1 <span class="operator">==</span> entity2, <span class="string">&quot;Entities shall be equal&quot;</span>)</span><br></pre></td></tr></table></figure><p>这种设计不仅比将所有需要的功能压缩到单个(monolithic)基类中更灵活，而且也适用于值类型。</p><h2 id="更干净的POP设计示例"><a href="#更干净的POP设计示例" class="headerlink" title="更干净的POP设计示例"></a>更干净的POP设计示例</h2><p>我将通过一个示例向您展示面向协议编程相对于传统方法的好处。 </p><p>我们的目标是创建满足以下要求的类型: </p><ul><li>创建一个给定名称和图像数据的图像 </li><li>图像应该持久化到文件系统并从文件系统加载 </li><li>创建图像的有损压缩版本 </li><li>Base64对图像进行编码，以便在因特网上传输它</li></ul><h3 id="使用超类的方式"><a href="#使用超类的方式" class="headerlink" title="使用超类的方式"></a>使用超类的方式</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> imageName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> imageData: <span class="type">Data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> imageName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">data</span>: <span class="type">Data</span>) &#123;</span><br><span class="line">        imageName <span class="operator">=</span> name</span><br><span class="line">        imageData <span class="operator">=</span> data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// persistence</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">save</span>(<span class="params">to</span> <span class="params">url</span>: <span class="type">URL</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">self</span>.imageData.write(to: url)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">contentsOf</span> <span class="params">url</span>: <span class="type">URL</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try</span> <span class="type">Data</span>(contentsOf: url)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, data: data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compression</span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init?</span>(<span class="params">named</span> <span class="params">name</span>: <span class="type">String</span>, <span class="params">data</span>: <span class="type">Data</span>, <span class="params">compressionQuality</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">UIImage</span>.<span class="keyword">init</span>(data: data) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> jpegData <span class="operator">=</span> <span class="type">UIImageJPEGRepresentation</span>(image, <span class="type">CGFloat</span>(compressionQuality)) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, data: jpegData)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BASE64 encoding</span></span><br><span class="line">    <span class="keyword">var</span> base64Encoded: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> imageData.base64EncodedString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="keyword">var</span> image <span class="operator">=</span> <span class="type">Image</span>(name: <span class="string">&quot;Pic&quot;</span>, data: <span class="type">Data</span>(repeating: <span class="number">0</span>, count: <span class="number">100</span>))</span><br><span class="line"><span class="built_in">print</span>(image.base64Encoded)</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// persist image</span></span><br><span class="line">    <span class="keyword">let</span> documentDirectory <span class="operator">=</span> <span class="keyword">try</span> <span class="type">FileManager</span>.default.url(for: .documentDirectory, in: .userDomainMask, appropriateFor:<span class="literal">nil</span>, create:<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">let</span> imageURL <span class="operator">=</span> documentDirectory.appendingPathComponent(<span class="string">&quot;MyImage&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span> image.save(to: imageURL)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Image saved successfully to path <span class="subst">\(imageURL)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load image from persistence</span></span><br><span class="line">    <span class="keyword">let</span> storedImage <span class="operator">=</span> <span class="keyword">try</span> <span class="type">Image</span>.<span class="keyword">init</span>(name: <span class="string">&quot;MyRestoredImage&quot;</span>, contentsOf: imageURL)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Image loaded successfully from path <span class="subst">\(imageURL)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br><span class="line">swift</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，如果我们不需要所有这些功能呢?假设我并不总是需要<code>Base64</code>编码功能。如果我对<code>Image</code>类进行子类化，我将获得所有的特性—即使我不需要它们。 </p><p>如果我们需要创建子类来专门化(specialize)某些方法，就没有办法去除那些我们不需要的公共方法和属性。当我们继承的时候，我们得到了一切。 </p><p>此外，我们受限于classes。现在，让我们使用POP修改这个设计。</p><h3 id="用POP重新设计"><a href="#用POP重新设计" class="headerlink" title="用POP重新设计"></a>用POP重新设计</h3><p>我将为每个主要特性创建协议，即持久性、创建压缩的有损版本和Base64编码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">NamedImageData</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">Data</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">data</span>: <span class="type">Data</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">ImageDataPersisting</span>: <span class="title class_">NamedImageData</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">contentsOf</span> <span class="params">url</span>: <span class="type">URL</span>) <span class="keyword">throws</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">save</span>(<span class="params">to</span> <span class="params">url</span>: <span class="type">URL</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">ImageDataPersisting</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">contentsOf</span> <span class="params">url</span>: <span class="type">URL</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try</span> <span class="type">Data</span>(contentsOf: url)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, data: data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">save</span>(<span class="params">to</span> <span class="params">url</span>: <span class="type">URL</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">self</span>.data.write(to: url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">ImageDataCompressing</span>: <span class="title class_">NamedImageData</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">compress</span>(<span class="params">withQuality</span> <span class="params">compressionQuality</span>: <span class="type">Double</span>) -&gt; <span class="keyword">Self</span><span class="operator">?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">ImageDataCompressing</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">compress</span>(<span class="params">withQuality</span> <span class="params">compressionQuality</span>: <span class="type">Double</span>) -&gt; <span class="keyword">Self</span><span class="operator">?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> uiImage <span class="operator">=</span> <span class="type">UIImage</span>.<span class="keyword">init</span>(data: <span class="keyword">self</span>.data) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> jpegData <span class="operator">=</span> <span class="type">UIImageJPEGRepresentation</span>(uiImage, <span class="type">CGFloat</span>(compressionQuality)) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">Self</span>(name: <span class="keyword">self</span>.name, data: jpegData)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">ImageDataEncoding</span>: <span class="title class_">NamedImageData</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> base64Encoded: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">ImageDataEncoding</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> base64Encoded: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.data.base64EncodedString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方法，我们可以创造出更细粒度的设计。你可以创建一个遵循所有协议的类型:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyImage</span>: <span class="title class_">ImageDataPersisting</span>, <span class="title class_">ImageDataCompressing</span>, <span class="title class_">ImageDataEncoding</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">Data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者您可以决定跳过遵从 <code>ImageDataPersisting </code>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">InMemoryImage</span>: <span class="title class_">NamedImageData</span>, <span class="title class_">ImageDataCompressing</span>, <span class="title class_">ImageDataEncoding</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">Data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底线是您可以选择在类型中遵循哪种协议。类型可以是引用或值类型。如果使用超类实现，则不存在这种灵活性。 </p><p>另一个好处是我们可以通过协议扩展提供默认实现。实际上，我们甚至可以添加新的功能——这里是最好的部分:我们甚至不需要原始代码。我们可以扩展任何<code>Foundation</code>或<code>UIKit</code>协议，并根据我们的需要装饰它，而无需深入研究类结构或其他细节。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Swift支持多种范式:面向对象编程、面向协议编程和函数式编程。这对我们软件开发人员意味着什么?答案是自由。 </p><p>选择哪种范式取决于您。如果您愿意，您仍然可以走oop路线。你可以混合搭配。然而，一旦你掌握了面向协议编程，你可能就再也不会回头了。 </p><p>查看我的Pluralsight Swift课程。 </p><p>谢谢大家，编码愉快!</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.pluralsight.com/guides/protocol-oriented-programming-in-swift">Protocol Oriented Programming in Swift</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】Improve Performance in Your iOS Applications 四</title>
      <link href="/2022/10/31/Improve%20Performance%20iOS%20%E2%85%A0V/"/>
      <url>/2022/10/31/Improve%20Performance%20iOS%20%E2%85%A0V/</url>
      
        <content type="html"><![CDATA[<p>翻译几篇iOS性能优化的文章 ⅠV，这是本系列的第四篇文章，重点关注UI改进、代码改进、动画、视觉体验最佳实践等</p><span id="more"></span><p>有许多因素，包括速度、性能、UI交互等，对你的iOS应用的成功至关重要。缓慢和无响应的应用程序被用户所鄙视，因此在向公众发布之前进行彻底的测试是至关重要的。 </p><p>本文中提到的技术旨在测试<code>iOS</code>应用程序的性能，可能需要<code>iOS</code>测试的基本知识;不过，本指南还将介绍测试的基本原理，以便您可以开始编写第一个测试用例。 </p><p>在我们开始之前，先快速回顾一下本系列的前三篇文章…… </p><p>本系列的第一篇文章展示了一些性能技巧，以帮助您改进iOS应用程序的编译时间，构建更快的应用程序，并专注于在构建系统中改进iOS性能。本系列的第二篇文章将讨论帮助您改进UI交互、媒体播放、动画和视觉效果等的性能提示—提供流畅和无缝的体验。在本系列的第3部分中，我将讨论通过现有代码库、模块化架构、利用代码中的可重用组件等优化iOS应用程序性能的技术。</p><h2 id="性能测试基础知识"><a href="#性能测试基础知识" class="headerlink" title="性能测试基础知识"></a>性能测试基础知识</h2><p>开发人员和测试人员在虚拟环境中审查和分析应用程序的性能，以预测当产品发布时用户将如何与产品交互。这意味着:</p><ul><li>应用程序在高流量(high traffic periods)期间的性能测试。 </li><li>糟糕的互联网接入可能会对应用的稳定性产生负面影响。 </li><li>与各种移动设备的兼容性。 </li><li>分析应用程序的整体性能。 </li><li>准确地发现和报告错误。 </li><li>对应用程序处理额外需求能力的评估。</li></ul><p>当同时发生的用户或活动的数量增加时，开发人员可能需要查看后端服务器和网络请求的性能，并进行更改以保持整体用户体验的平稳。当流量很大时，了解应用程序的工作速度和系统的工作方式是很有帮助的。负载测试可以让您了解数据从后端服务器加载到iOS应用程序所需的时间。如果应用程序显示内容所需的时间超过几秒钟，则需要研究改进方法。</p><p>您可以通过应用程序的压力测试来评估应用程序的持久性，例如数据处理、响应速度和在无响应服务器等情况下的功能行为。这些数据可用于检测和修复应用程序瓶颈，从而提高应用程序性能。与压力测试一样，峰值测试包括增加需求，以查看应用程序是否会因为管理不当的大量数据而变慢，或者在某些情况下停止响应并崩溃，或者由于网络请求和响应的峰值(用户活动呈指数增长)而导致服务器崩溃。它可以帮助您确定服务器的加载能力，以及应用程序在关键场景中的行为。频繁出现用户峰值的应用需要进行峰值测试。</p><p>批量测试评估应用程序的总容量。此测试评估应用程序管理大量数据而不降低或丢失数据的能力。另一方面，容量测试可以识别用户在应用性能下降时所面临的困难。随着应用程序用户基数的增长，它的可靠性也会增加。</p><p>可伸缩性测试分析响应时间、每秒请求和事务处理速度，以确定后端服务器管理不断增加的工作负载的能力。虽然它不直接专注于测试你的iOS应用程序，但它肯定可以识别支持iOS应用程序的后端服务器的问题，以确保数据流的稳定性和整体用户体验。持久性测试衡量的是应用的长期性能。在耐力测试中，开发人员和测试人员长时间模拟强大的流量，以验证应用程序的稳定性。</p><h2 id="iOS测试基础知识"><a href="#iOS测试基础知识" class="headerlink" title="iOS测试基础知识"></a>iOS测试基础知识</h2><p>第一步是了解在iOS中如何进行测试，以及如何开始测试iOS应用程序。要编写测试用例，你需要关注不同类型的测试:</p><ul><li>单元测试:测试一个不依赖于任何外部依赖的函数，如验证函数逻辑、验证电子邮件地址等。 </li><li>UI测试:复制用户行为和操作，例如在应用程序中导航。 </li><li>集成测试:测试依赖于另一个函数的单个函数，例如，测试对本地文件或数据库调用的操作。 </li><li>性能测试:测试应用程序在实际使用过程中的表现，例如，加载一个非常大的图像结果列表。</li></ul><p>首先，让我们用下面的例子来理解单元测试。下面的函数返回一个整数的阶乘。要测试下面的函数，可以运行这个示例并使用不同的数字测试它，例如4的阶乘等于24</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getFactorial</span>(<span class="params">of</span> <span class="params">num</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">var</span> fact <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> factor <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span>num &#123;</span><br><span class="line">fact <span class="operator">=</span> fact <span class="operator">*</span> factor</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fact</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，为了自动化检查，让我们编写一个简单的函数，它将在逻辑上检查条件并返回相应的结果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">getFactorialTest</span>: <span class="title class_">XCTestCase</span> &#123;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">testGetFactorial</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> factorial <span class="operator">=</span> (<span class="number">1</span><span class="operator">...</span><span class="number">4</span>).map(<span class="type">Double</span>.<span class="keyword">init</span>).reduce(<span class="number">1.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="type">XCTAssertEqual</span>(factorial, <span class="number">24.0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段简单的代码在逻辑上检查阶乘是否正确，如果结果不正确，则测试失败。为了本文的简洁，接下来的部分将关注如何在iOS中运行测试来检查应用程序的性能。</p><p>…</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要获得可靠的结果，必须运行有意义的测试。不准确的测试结果可能会阻止应用程序的部署。如果你的程序不能为真正的用户工作，你的时间和金钱将被浪费，如果一个应用程序发布给公众时存在bug或性能问题，负面的在线评论可能会扼杀它的受欢迎程度。苹果生态系统和Android生态系统中的设备和操作系统如此多样化，以至于模拟器可能不足以对应用进行完整的测试覆盖。诸如<code>AWS Device Farm</code>、<code>Kobiton</code>、<code>Hockeyapp</code>等仿真工具可以让您比较软件版本或与竞争对手进行测试。您需要在模拟器和实际设备上测试应用程序的性能，以获得准确的移动用户体验数据。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.sentry.io/2022/06/27/improve-performance-in-your-ios-applications-part-4/">Part 4</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【译】Improve Performance in Your iOS Applications 三</title>
      <link href="/2022/10/28/Improve%20Performance%20iOS%20%E2%85%A0%E2%85%A0%E2%85%A0/"/>
      <url>/2022/10/28/Improve%20Performance%20iOS%20%E2%85%A0%E2%85%A0%E2%85%A0/</url>
      
        <content type="html"><![CDATA[<p>翻译几篇iOS性能优化的文章 ⅠⅠⅠ，这是本系列的第三篇文章，重点介绍如何提高代码的可读性和性能。 请根据您的需要谨慎选择。通常，更改或改进体系结构和代码重构需要更多的时间和精力。</p><p>尽管现代iOS设备能够处理大量密集而复杂的任务，但如果你不密切关注应用程序的运行方式，设备可能会显得很慢。  </p><span id="more"></span><h2 id="开启Swift快速优化"><a href="#开启Swift快速优化" class="headerlink" title="开启Swift快速优化"></a>开启Swift快速优化</h2><p>第一步总是启用优化。Swift有三个优化级别:</p><ul><li>One:常规开发。它只进行最低限度的优化，并保留所有调试信息。</li></ul><p>-o:用于大多数生产代码。它的极端优化可能会极大地改变输出代码的性质和数量。调试数据将丢失发出。 </p><p>-Osize:在这种模式下，编译器更倾向于代码大小而不是速度。<br>1<br> 当前的优化级别可以通过<code>Xcode</code> UI来改变:<br>在项目导航器（Project Navigator）中选择项目编辑器图标（ Project Editor）。要访问项目设置编辑器，请单击项目标题下面的图标。更改“生成设置”（Build Settings）标题下的“优化级别”（Optimization Level）框，以便对项目中的所有目标应用优化设置。 </p><p>在“项目编辑器”（Project Editor）中的“目标”（Targets）下选择目标（target），并覆盖“生成设置”（Build Settings）标题下的“优化级别”（Optimization Level）框。</p><h2 id="理解自动引用计数"><a href="#理解自动引用计数" class="headerlink" title="理解自动引用计数"></a>理解自动引用计数</h2><p>如果你想构建一个高性能的iOS应用程序，你必须分析你的组件如何使用内存以及如何优化它。循环引用问题是典型的内存管理问题。但首先，让我们看看iOS是如何处理自己的内存的。 </p><p>苹果的自动内存管理系统被称为自动引用计数(ARC)。引用计数用于确定内存块是否应该被释放。新对象的引用计数从1开始。这个引用计数可能会随着时间的推移而改变。最后，当引用计数接近0时，对象被释放。</p><h3 id="强引用和弱引用"><a href="#强引用和弱引用" class="headerlink" title="强引用和弱引用"></a>强引用和弱引用</h3><p>根据上面的想法，在声明变量时还应该理解强引用和弱引用。默认情况下，变量之间保持强引用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> strongCar <span class="operator">=</span> <span class="type">UIView</span>()</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> weakCar <span class="operator">=</span> <span class="type">UIView</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着变量变得更强大，引用的数量也会增加。当一个引用计数为2的对象被一个新的变量强引用时，对象的引用计数增加到3。 </p><p>另一方面，弱引用对引用计数的增加没有影响。如果一个引用计数为2的对象被赋值给一个引用计数已经为3的对象，那么该对象的引用计数将保持为2。 </p><p>此外，当强变量处于活动状态时，强变量的引用组件保证同时保留在内存中。另一方面，这种确定性不适用于弱变量。</p><h3 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h3><p>一个实体<code>Vehicle</code>包含另一个实体<code>Car</code>的许多实例，并且一个实体Car的每个实例都与一个实体Vehicle相连接的模型很可能是您以前见过的。在一个非常简化的实现中，它看起来像这样:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> cars <span class="operator">=</span> [<span class="type">Car</span>]()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">add</span>(<span class="keyword">_</span> <span class="params">car</span> : <span class="type">Car</span>) &#123;</span><br><span class="line">        cars.append(car)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> vehicle : <span class="type">Vehicle</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="params">vehicle</span> : <span class="type">Vehicle</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.vehicle <span class="operator">=</span> vehicle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vehicle <span class="operator">=</span> <span class="type">Vehicle</span>()</span><br><span class="line"><span class="keyword">let</span> car <span class="operator">=</span> <span class="type">Car</span>(vehicle: <span class="type">Vehicle</span>)</span><br><span class="line">vehicle.add(car)</span><br></pre></td></tr></table></figure><p>在上面的例子中，一切看起来都很好，但事实并非如此。观察<code>Vehicle</code>和<code>Cars</code>之间的相似之处:它们彼此之间有着密切的联系。接下来，你要猜。内存泄漏是罪魁祸首。 </p><p>当一段数据在其生命期结束后仍然存在于内存中时，就出现了内存泄漏。当两个强变量相互强引用时，它们会产生内存泄漏。循环引用是这个问题的技术术语。然后，让我们看看几个选项。</p><h2 id="使用面向协议编程"><a href="#使用面向协议编程" class="headerlink" title="使用面向协议编程"></a>使用面向协议编程</h2><p>当涉及到在应用程序中存储数据和建模行为时，结构（structures）和类（classes）都是很好的选择。然而，由于它们的相似之处，可能很难决定哪个更好。 </p><p>仔细检查标准Swift库中的代码，就会发现协议使用得相当频繁。Apple喜欢面向协议编程(Protocol Oriented Programming)，如果你正开始创建继承连接的新项目，建议你使用它。 </p><p>多态是OOP范式中最有帮助的部分之一。它决定要调用的运行时参数或函数。动态调度是一个决策过程。下面是OOP的一个基本示例。Car类有一个带有override关键字的echo方法，因为它是在超类Vehicle中定义的。调用类Car中的echo方法，而不是类Vehicle中的echo方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">echo</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Improving iOS App performance.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Car</span>: <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">        <span class="keyword">override</span> fun echo() &#123;</span><br><span class="line">        <span class="comment">// your code</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那不是很好吗?不，正如前面的例子所示，每个运行时作业都会减慢我们的执行时间。那么解决办法是什么呢?</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">echo</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>: <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">echo</span> &#123;</span><br><span class="line">        <span class="comment">// your code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POP是面向协议编程的缩写，现在可以使用了。它只需要一个小小的调整就可以显著减少运行时计算。POP术语如此熟悉是不是很有趣?它是苹果<code>UIKit</code>中最常用的委派模式。</p><h2 id="使用静态调用"><a href="#使用静态调用" class="headerlink" title="使用静态调用"></a>使用静态调用</h2><p>在参考Apple的Swift标准库文档时，你会发现与类相反，struct是值类型，而class是引用类型。因此，它们可以互换使用。一开始似乎有一点变化。这比我想象的要小得多!</p><p><code>Structs</code>是静态分配的，而动态构造的类是动态分配的。但是，如果类具有结构类型参数，会发生什么情况呢?那么，你打算怎么做?即使struct参数是一个结构，也仍然需要堆栈分配和结构构造。根本不是这样的!因此，即使实参是struct类型的，存储它的类也允许它在堆中分配和动态调用，而不依赖于实参的类型。</p><p>对于前面提到的例子，你可以继续使用你之前创建的类，但是使用变量的弱引用:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> cars <span class="operator">=</span> [<span class="type">Car</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">add</span>(<span class="keyword">_</span> <span class="params">car</span> : <span class="type">Car</span>) &#123;</span><br><span class="line">        cars.append(car)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> vehicle : <span class="type">Vehicle</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="params">vehicle</span> : <span class="type">Vehicle</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.vehicle <span class="operator">=</span> vehicle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vehicle <span class="operator">=</span> <span class="type">Vehicle</span>()</span><br><span class="line"><span class="keyword">let</span> car <span class="operator">=</span> <span class="type">Car</span>(vehicle: vehicle)</span><br><span class="line">vehicle.add(<span class="type">Car</span>)</span><br></pre></td></tr></table></figure><p>最后，不要在代码中大范围使用类继承，而是尝试使用结构体（structs）和协议（protocols）。</p><h2 id="限制变量的作用域"><a href="#限制变量的作用域" class="headerlink" title="限制变量的作用域"></a>限制变量的作用域</h2><p>包含<code>private</code>或<code>fileprivate</code>关键字的声明将该声明的可见性限制在包含这些关键字的文件中。这使编译器能够确定代码中是否有任何其他可能的覆盖声明。</p><p>因此，由于没有任何这样的声明，编译器就可以自动推导出最终关键字，并在过程中根据需要删除对方法和字段访问的间接调用。使用以下示例，<code>vehicle.doSomething()</code>和<code>car. dosomething()</code>。<code>myPrivateVar</code>将能够直接使用，提供<code>Vehicle</code>和<code>Car</code>不包含任何覆盖声明在同一文件:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">doSomething</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">var</span> myPrivateVar: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">usingVehicle</span>(<span class="keyword">_</span> <span class="params">vehicle</span>: <span class="type">Vehicle</span>) &#123;</span><br><span class="line">  vehicle.doSomething() <span class="comment">// The compiler will remove calls to this method</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">usingCar</span>(<span class="keyword">_</span> <span class="params">car</span>: <span class="type">Car</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> car.myPrivateVar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用值类型"><a href="#使用值类型" class="headerlink" title="使用值类型"></a>使用值类型</h2><p>Swift有两种类型:值类型(结构、枚举和元组)和引用类型(类)。重要的是要注意<code>NSArrays </code>不能包含值类型。因此，当使用值类型时，优化器可以避免大部分与处理由<code>NSArray</code>支持的<code>Array</code>的可能性相关的成本。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Avoid using a class here.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> manufacturedYear: [<span class="type">Int</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newCar: [<span class="type">Car</span>]</span><br></pre></td></tr></table></figure><p>此外，与引用类型不同，值类型只需要对包含递归引用类型的引用进行计数。为了避免Array中不必要的retain和release流量，可以使用值类型而不是引用类型。</p><h2 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a>使用闭包</h2><p>说到特性，Swift的闭包是目前最强大的特性之一。另一方面，它们不受循环引用的影响。闭包有可能导致循环引用，原因很简单:它们在不使用时维持对使用它们的对象的强引用。 </p><p>在本例中，我们有一个包含闭包的循环引用。注意下面连续的代码块是如何修改自我声明的:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> tyres <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> closure : (() -&gt; ()) <span class="operator">=</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        closure <span class="operator">=</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.tyres <span class="operator">+=</span> <span class="number">1</span><span class="comment">// standard way</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">self</span>.tyres)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">        closure()</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子与闭包有很强的连接，而闭包又与对象本身有很强的连接，因为self在闭包块中使用。有两种方法可以解决这个问题:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> tyres <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> closure : (() -&gt; ()) <span class="operator">=</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        closure <span class="operator">=</span> &#123; </span><br><span class="line">[__unowned self__] <span class="keyword">in</span> <span class="keyword">self</span>.tyres <span class="operator">+=</span> <span class="number">1</span><span class="comment">// unowned declaration</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">self</span>.tyres)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">        closure()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了以上的改进，闭包不再有强引用。但是，使用<code>[unowned self]</code>要小心，如果在调用闭包之前已经释放了对象，则会导致崩溃。同样，你也可以修改实现如下:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> tyres <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> closure : (() -&gt; ()) <span class="operator">=</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        closure <span class="operator">=</span> &#123; </span><br><span class="line">[<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span> <span class="keyword">self</span><span class="operator">?</span>.tyres <span class="operator">+=</span> <span class="number">1</span><span class="comment">// weak declaration</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">self</span><span class="operator">?</span>.tyres <span class="operator">??</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">        closure()</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>[weak self]</code>返回与<code>[unowned self]</code>相同的结果，但它是可选处理的。 </p><p>在闭包的上下文中，从周围的作用域捕获变量和常量。这在它和闭包所需的值之间建立了紧密的连接。在我们的项目中，很可能会有数千个闭包，这意味着检查每一个闭包的内存问题将非常耗时。可以在Xcode中监控内存泄漏;所需要的是打开<code>Instruments </code>并选择<code>Leaks</code>。</p><blockquote><p>Navigate to Xcode and then Open Developer Tool → Instruments → Leaks.</p></blockquote><p>打开后，选择模拟器和应用程序目标并跟踪需要修复的泄漏。 </p><p>作为最佳实践，在处理闭包或代理时，最好使用<code>weak</code>或<code>unowned</code>。在你的项目中保持健壮的编码风格，这样<code>weak self</code>的存在就会立刻显现出来。一旦你准备好了，就去安装<code>SwiftLint</code>，这是一个执行编码标准的强大工具。为了整个团队的利益，编译器时的问题可以被发现，代码样式可以被自动化。</p><h2 id="提高Arrays的利用率"><a href="#提高Arrays的利用率" class="headerlink" title="提高Arrays的利用率"></a>提高Arrays的利用率</h2><p>Arrays通常将它们的元素存储在不相邻的内存块中。只需分配一个新块并将其附加到数组中，就可以添加数组中的新元素。这对于添加来说非常好，但是对于迭代来说就不那么好了。所以，如果你在一个巨大的数组上迭代，<code>ContinuousArray</code>可能是一个很好的选择。 </p><p>当使用<code>ContinuousArray </code>时，它确保数组的所有元素按顺序排列。这在查找以下信息时非常有用。这是一种取舍，一如既往，没有什么神奇的事情发生。由于在<code>ContinuousArray</code>中增加了对数组管理的限制，插入和追加等任务现在变得更加困难。由于我们最近的更改，您的用例将不再受到限制。 </p><p>Swift对象通常表现良好，我们可以忽略内存问题和安全问题，因为Swift为我们处理一切。这对整体性能有负面影响。您可以使用<code>withUnsafeBufferPointer</code>函数来获取数组元素的指针数组，这使您能够在安全性和性能之间进行权衡。但是您需要小心，因为如果由于某种原因这些元素被释放，它可能会导致崩溃。 </p><p>Apple SDK for Sentry允许你监视和跟踪应用性能、用户会话、用户可能面临的崩溃等。 </p><p>一般来说， Sentry.io 中捕捉到这个事件的问题应该可以检查。由其他原因引起的错误不应该显示。要在Discover或Issues页面中查找它们，请使用未处理的错误搜索过滤器<code>unhandled:true</code>。因为会话不受数据速率的限制，所以未处理事件的数量预计不会与失败会话的数量匹配。</p><h2 id="利用范型"><a href="#利用范型" class="headerlink" title="利用范型"></a>利用范型</h2><p>Swift的泛型类型提供了一个强大的抽象工具。Swift编译器用<code>T</code>的任意值构造<code>CustomFunc&lt;T&gt;</code>。还需要一个函数指针表和一个包含<code>T</code>的方框。这是因为<code>CustomFunc&lt;Int&gt;</code>的行为与<code>CustomFunc&lt;String&gt;</code>的行为不同。下面是一个泛型函数的例子:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomFunc</span>&lt;<span class="title class_">T</span>&gt; &#123; <span class="operator">...</span> &#125;</span><br><span class="line"><span class="type">CustomFunc</span>&lt;<span class="type">Int</span>&gt; <span class="type">X</span> <span class="comment">// Same function CustomFunc&lt;String&gt; Y // Works for different data types</span></span><br></pre></td></tr></table></figure><p>每次调用此类代码时，Swift都会尝试识别正在使用的具体(非泛型)类型。当优化器看到泛型函数声明并理解具体类型时，Swift编译器可能会生成根据该类型定制的泛型函数的变体。专门化消除了泛型的管理开销。下面是一些更多的泛型:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomStack</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">T</span>) &#123; <span class="operator">...</span> &#125;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">T</span> &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">customAlgorithm</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">a</span>: [<span class="type">T</span>], <span class="params">length</span>: <span class="type">Int</span>) &#123; <span class="operator">...</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stackOfInt: <span class="type">CustomStack</span>&lt;<span class="type">Int</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="operator">...</span> &#123;</span><br><span class="line">  stack.push(<span class="operator">...</span>)</span><br><span class="line">  stack.pop(<span class="operator">...</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrayOfInt: [<span class="type">Int</span>]   <span class="comment">// Compiler emits a specialized version for [Int] type</span></span><br><span class="line"></span><br><span class="line">customAlgorithm(arrayOfInt, arrayOfInt.length)</span><br></pre></td></tr></table></figure><p>为了让优化器执行专业化，泛型声明定义必须能够在当前<code>Module</code>中可见。除非启用了<code>-whole-module-optimization</code>开关，否则只有在泛型的声明和调用都与泛型的调用在同一个文件中时才会发生这种情况。 </p><p>标准库是这一规则的一个例外。标准库中的定义可以在所有模块中使用，并且可以定制以满足特定的需求</p><h2 id="优化SpriteKit"><a href="#优化SpriteKit" class="headerlink" title="优化SpriteKit"></a>优化SpriteKit</h2><p><code>SpriteKit</code>是一个快速的2D框架，它使用苹果的<code>Metal</code>库直接访问<code>GPU</code>。像<code>iPad Pro</code>这样的设备有<code>120Hz</code>的显示，你需要努力保持帧更新在分配的<code>8毫秒</code>内。 </p><p>从你的应用程序包加载纹理（Textures）是非常昂贵的。即使图片很普通，尝试加载一个全屏的背景图片可能会导致你超过你分配的时间限制，导致丢失帧。确保你在背景中预加载纹理，这样当你需要它们的时候，它们就会准备好了。因此，丢失帧的风险大大降低。 </p><p>纹理或动画停顿和缓慢移动的UI元素会激怒用户，并影响整体用户体验。有两种方法可以评估这类体验:慢速和定格帧(slow and frozen frames)。如果你想让你的应用程序正常运行，这两种情况都应该避免。Sentry’s SDK 跟踪在设备上渲染时遇到的慢帧和冻结帧。 </p><p>理解<code>SKTexture</code>类似于<code>UIImage</code>，因为它直到需要时才真正加载数据，这对于理解它是如何工作的至关重要。正因为如此，即使是非常大的照片，这种代码也几乎是瞬间的:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> texture <span class="operator">=</span> <span class="type">SKTexture</span>(imageNamed: <span class="string">&quot;Void&quot;</span>)</span><br></pre></td></tr></table></figure><p>然而，一旦该纹理被分配给游戏场景中的精灵节点(sprite node )，它就必须在渲染之前被加载。理想情况下，你希望加载发生在场景显示之前——可能在加载屏幕中——以减少帧的困难;因此，你应该像下面这样预加载:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">texture.preload &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Texture is ready!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-replace代替Blend"><a href="#使用-replace代替Blend" class="headerlink" title="使用.replace代替Blend"></a>使用.replace代替Blend</h2><p>游戏渲染是开发过程中最耗时的部分之一，甚至包括所有需要的计算。这很复杂，因为大多数精灵都有不规则的形式和<code>alpha</code>透明度，场景通常有许多层，效果经常为场景提供生命。 </p><p>你可以通过告诉<code>SpriteKit</code>渲染没有<code>alpha</code>透明度的精灵，例如实体形式或背景图片来避免这种情况:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yourSprite.blendMode <span class="operator">=</span> .replace</span><br></pre></td></tr></table></figure><p>实际上，这意味着<code>SpriteKit</code>不需要读取旧的颜色值并将其与新的颜色值混合。</p><h2 id="分析访问级别"><a href="#分析访问级别" class="headerlink" title="分析访问级别"></a>分析访问级别</h2><p>在程序执行的过程中，由类形成的对象的方法调用和参数访问仍然是未知的。这意味着当你点击Xcode中的运行按钮时，编译器就会启动并执行分配内存和评估多态性使用等任务。最后，如果一个方法或参数不能从程序的作用域之外访问，编译器就会指出它是<code>final</code>的。 </p><p>当您知道一个类不是任何其他类的基类时，就有必要在类声明中添加<code>final</code>关键字。将类添加到类中时，在类的所有参数和方法中都包含类的最终定义。 </p><p>因此，让我们假设您想要覆盖类的行为。这样做的后果是，这个类不允许使用<code>final</code>关键字。一个新特性允许将子类不能访问的所有参数和方法指定为<code>private</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>选择在任何特定情况下采用的任何性能改进可能需要一些思考、测试和试验，特别是当我们希望在向代码中添加更多数据时保持代码的效率时。可能需要混合使用各种性能改进技术，而不是简单地使用一种技术，以获得所需的性能特征。扩展您对Swift以外的理解通常对于确定每种情况的最佳格式非常重要。 </p><p>在本文中，您了解了如何使用最佳实践优化现有代码库、模块化体系结构以及在代码中创建和利用可重用组件，从而提高iOS应用程序的性能。 </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【译】Improve Performance in Your iOS Applications 二</title>
      <link href="/2022/10/27/Improve%20Performance%20iOS%20Applications%20%E2%85%A0%E2%85%A0/"/>
      <url>/2022/10/27/Improve%20Performance%20iOS%20Applications%20%E2%85%A0%E2%85%A0/</url>
      
        <content type="html"><![CDATA[<p>翻译几篇iOS性能优化的文章 ⅠⅠ，这是本系列的第二篇文章，重点介绍iOS性能技巧，帮助你改进UI交互、媒体播放、动画和视觉效果等，提供流畅、无缝的体验。 </p><span id="more"></span><p>当你的iOS应用面向任何数量的用户开发和发布时，它的性能都是至关重要的。你的用户希望它是令人愉快的、快速的、有响应的，所以如果你的应用看起来迟钝或无响应，它就会影响你的评价，你可能会失去有价值的用户。在为应用解决这个问题时，很容易忽略在整个开发过程中所做的选择对性能的影响。 </p><p>在尝试优化任何代码之前，确保有一个问题需要修复是很重要的!不要被“预先优化”代码的诱惑所迷惑，这是错误的。定期使用Instruments来分析代码并发现任何缺陷。<code>Matt Galloway</code>有一节关于如何使用<code>Instruments</code>优化代码的精彩课程。 </p><p>本文中提出的一些建议可能需要付出很大的努力才能实现，或者可能会使您的代码更加困难;因此选择谨慎。让我们开始吧。 </p><p>你可以在这里阅读本系列的第一篇文章，它关注的是性能技巧，帮助你提高iOS应用程序的编译时间，更快地构建应用程序，并专注于在构建系统中改进iOS性能。</p><h2 id="监控应用程序行为"><a href="#监控应用程序行为" class="headerlink" title="监控应用程序行为"></a>监控应用程序行为</h2><p>苹果的iOS应用商店是一个拥有数百万应用程序的巨大市场，它为任何组织或个人开发和发布应用程序提供了多种机会。然而，有这么多可访问的应用程序，确定你的“最佳点”——吸引新客户的最佳地点——可能是困难的。 </p><p>在App Store营收增长之前，你必须制定一套指标，让我们能够根据你的目标来监测你的成功情况。在定义了度量指标和衡量性能的明确目标后，保持警惕并了解应用在部署新功能时的反应非常重要。 </p><p>Sentry是维护应用程序代码运行状况和性能的必要监视工具。错误跟踪和性能监视特性使您能够以更清晰、快速和有效的方式从前端到后端查看、纠正和了解应用程序。 </p><p>Sentry对iOS应用程序的iOS性能监控允许你确定性能问题的根源，如API调用和数据库查询缓慢。</p><h2 id="iOS-UI的基本原理"><a href="#iOS-UI的基本原理" class="headerlink" title="iOS UI的基本原理"></a>iOS UI的基本原理</h2><p>在了解这些建议之前，必须定义和理解主线程的工作方式，以便优化呈现UI的性能。 </p><p>根据经验，主线程不应该用于非常繁重的任务。相反，它应该主要用于以下行为: </p><ul><li>接受用户输入和交互 </li><li>显示结果并更新UI</li></ul><p>大多数时候，主线程处理太多的事情，这导致帧的丢失或下降。当设备不能处理标准帧速率和用户看到延迟或屏幕卡住时，就会发生这种情况。 </p><p>因此，确定哪些帧丢失了，哪些帧没有丢失就变得很重要了，但是为何丢失呢? </p><p>有时候很容易发现他们，因为最重要的是他们没有回应。其他时候，它不是，你需要更精确的东西来追踪他们。如果您想要快速跟踪它们，您可以使用分析工具来识别问题。</p><p>一旦你确定了帧丢失的根本原因，你就可以在开发过程中解决它们。以下是你可以想到的解决帧下降的一些可能性: </p><ul><li>限制在移动屏幕上呈现的视图数量 </li><li>尽可能避免元素的透明度 </li><li>减少请求作业的时间和频率 </li><li>解码JPEG图像 </li><li>执行后台线程操作</li></ul><p>让我们一个一个地看一遍。</p><h3 id="如何减少视图层次结构"><a href="#如何减少视图层次结构" class="headerlink" title="如何减少视图层次结构"></a>如何减少视图层次结构</h3><p>最简单的方法是减少视图层次结构中的视图数量，尽可能避免透明度。为了达到同样的效果，下面的代码片段帮助绘制一个白色背景，它指示渲染者避免任何复杂的透明度处理: </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label.layer.opacity <span class="operator">=</span> <span class="number">1.0</span> </span><br><span class="line">label.backgroundColor <span class="operator">=</span> .white </span><br></pre></td></tr></table></figure><p>要验证透明度重叠的问题已经修复，你可以使用<code>Xcode</code>中的<code>Debug- &gt;View Debugging- &gt;Rendering menu</code>中的<code>Color Blended Layers </code>(颜色混合图层)工具。</p><h3 id="减少操作频率"><a href="#减少操作频率" class="headerlink" title="减少操作频率"></a>减少操作频率</h3><p>像<code>cellForItemAt</code>, <code>indexPath</code>和<code>scrollViewDidScroll</code>这样的函数必须非常流畅和快速，因为它们经常被调用，几乎每时每刻都在调用，所以它们需要非常快。 </p><p>您应该始终确保您拥有可以创建和维护的最简单的视图和单元格。你还应该确保你使用的配置方法总是很轻的，比如有约束的布局。</p><h3 id="图像解码"><a href="#图像解码" class="headerlink" title="图像解码"></a>图像解码</h3><p>说到丢失帧，最常见的原因之一是图像解码。通常，<code>imageview</code>在主线程中，在幕后完成这个过程。然而，这可能会偶尔导致你的应用程序持续变慢，特别是当图像的大小或分辨率相当大时。 </p><p>这个问题的一个解决方案是将解码任务委派给后台线程或队列。操作将不会像<code>UIImageView</code>的标准解码那样有效，但是主线程将是空闲的。 </p><p>在这种方法中，重要的是同步特定的更新，如错误或警告，因为它们由主线程处理，而图像处理发生在后台线程，以避免任何故障或崩溃。</p><ul><li>额外提示:处理应用程序在后台</li></ul><p>来自<a href="https://developer.apple.com/documentation/uikit/app_and_environment/scenes/preparing_your_ui_to_run_in_the_background">Apple Developer</a>的官方文档表明，你应该准备你的应用程序在后台运行。即使是最简单的实例，当用户退出前台应用时，你的应用在<code>UIKit</code>挂起它之前移动到后台。根据文档指南，当你的应用程序在后台时，它应该做的越少越好，最好什么都不做。 </p><p>在这种情况下，所有的进程，包括非主线程操作，也应该释放正在使用的资源-不损害你的应用程序的性能。当你的应用程序进入后台，<code>UIKit</code>调用你的应用程序的以下方法之一:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sceneDidEnterBackground(<span class="keyword">_</span>:)  <span class="comment">//method of the appropriate scene delegate for apps that support Scenes</span></span><br><span class="line">applicationDidEnterBackground(<span class="keyword">_</span>:)  <span class="comment">//method for all other apps</span></span><br></pre></td></tr></table></figure><p>好消息是，您不需要丢弃从应用程序的<code>asset</code>(资产目录)中加载的图像。</p><ul><li>额外建议:缩放图像<br><code>UIImageView</code>只能显示与<code>UIImageView</code>具有相同尺寸的图像。封装在<code>UIScrollView</code>中的<code>UIImageView</code>使动态放大和缩小照片变得非常昂贵。</li></ul><p>如果它是从远程服务加载的，并且在下载之前你不能控制它的大小，那么你可以使用后台线程来缩放已经下载并在<code>UIImageView</code>中使用的图像。</p><h2 id="执行优化操作"><a href="#执行优化操作" class="headerlink" title="执行优化操作"></a>执行优化操作</h2><p>在处理<code>UI</code>项的某些属性时，你可能会遇到一些离屏渲染的困难，因为你必须在暴露这些元素之前准备它们。换句话说，它大量使用了<code>CPU</code>和<code>GPU</code>。那么，如何识别这个问题呢? </p><p><code>Color Offscreen-Rendered Yellow</code>（离屏渲染黄色）非常方便!你可以在<code>Debug - &gt; View Debugging - &gt; Rendering menu</code>中找到相同的选项。 </p><p>使用这个工具，您可以根据资源的重度来识别黄色或红色的元素。 </p><p>一个常见的例子，例如使用圆角半径属性，在你的应用程序中表明这样的东西:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageView.layer.cornerRadius <span class="operator">=</span> imageHeight <span class="operator">/</span> <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>上面的代码行导致对每个图像的操作多消耗50%的资源。为了避免这种情况，您应该适应以下性能最佳实践:</p><ul><li>避免使用<code>CornerRadius </code>属性，用其他方法替换它 </li><li>除非非常必要，否则避免使用<code>ShouldRasterize</code>属性 </li><li>避免在大多数情况下使用<code>Shadows</code>，因为它会导致离屏渲染 </li><li>避免使用<code>boundingRectWithSize</code>进行文本测量，因为它会导致繁重的处理 </li><li>使用<code>.round()</code>，因为它们更轻，计算时的资源负担更小</li></ul><h2 id="设置有效背景"><a href="#设置有效背景" class="headerlink" title="设置有效背景"></a>设置有效背景</h2><p>来自<code>UIColor</code>类的<code>colorWithPatternImage</code>被设计用来生成小的重复图片作为背景，如果你想使用全帧背景，你必须使用<code>UIImageView</code>。在这种情况下，切换到<code>UIImageView</code>可能会节省大量的内存。 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *bgView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;background&quot;</span>]]; </span><br><span class="line">[<span class="keyword">self</span>.view addSubview:bgView];</span><br></pre></td></tr></table></figure><p>如果你的背景是由小瓷砖组成的，你应该利用<code>UIColor</code>类的<code>colorWithPatternImage</code>函数，它显示更快，消耗更少的内存。 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.backgroundColor = [uiicolor colorWithPatternImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;background&quot;</span>]];</span><br></pre></td></tr></table></figure><h2 id="缩短应用启动时间"><a href="#缩短应用启动时间" class="headerlink" title="缩短应用启动时间"></a>缩短应用启动时间</h2><p>在进行任何优化之前，评估iOS应用程序的启动时间是一个好主意。你的应用需要多少时间启动?开始时间延迟了，或者您对现有的阈值是否满意? </p><p>在你完成研究之后，你需要确定应用的实际启动窗口。根据苹果在2019年<a href="https://developer.apple.com/videos/play/wwdc2019/423/?time=305">WWDC</a>大会上的说法，应用程序的初始帧生成时间<code>不应超过400毫秒</code>。如果您对您的申请有很高的期望，您应该将此设置为最低目标。</p><p>有三种不同类型的启动:</p><p>当您的应用程序很长时间没有启动或在重新启动之后，您可能会经历“<code>冷启动</code>”。冷启动之后，每次后续的启动都被称为<code>热启动</code>。系统端服务目前正在运行，您的程序已经被放入内存。从主屏幕或应用程序切换器重新启动应用程序将恢复之前的启动。我们不需要等待您的应用程序上线太久，因为它已经在运行了!</p><p>要检查你的代码如何影响启动时间，可以使用<code>Xcode</code>的<code>App Launch time</code>模板。使用模板可以让我们在应用最初发布时了解它的生命周期。这是一种很好的方法，可以帮助你尽早了解哪些阶段会产生最大的延迟。<code>Instruments</code>对于处理产生性能问题的代码特别有用。</p><p>Sentry跟踪应用程序性能，度量吞吐量和延迟等指标，并在捕获由事务和跨度组成的分布式跟踪的同时跨多个服务显示错误的影响，以度量这些服务中的单个服务和操作。</p><p>对于iOS, Sentry允许不同的SDK安装方法，包括Cocoapods SDK, Swift Package Manager和Carthage。SDK还能够测量应用程序启动活动，跨越从应用程序启动到第一个自动生成的UI事务的不同阶段。 </p><p>应用程序启动指标跟踪移动应用程序启动所需的时间。为此，Sentry测量冷启动和热启动。应用程序开始的开始是由进程开始时间标记的，而结束是由<code>UIWindowDidBecomeVisibleNotification</code>标记的。结果生成如下:</p><ul><li><p>Pre main: From the beginning of the process time to the runtime init.</p></li><li><p>UIKit and Application Init: From the runtime init to the <code>didFinishLaunchingNotification</code>.</p></li><li><p>Initial Frame Render: From <code>didFinishLaunchingNotification</code> to <code>UIWindowDidBecomeVisibleNotification</code>.</p></li></ul><h2 id="延迟加载和重用您的视图"><a href="#延迟加载和重用您的视图" class="headerlink" title="延迟加载和重用您的视图"></a>延迟加载和重用您的视图</h2><p>那些在<code>UIScrollView</code>中嵌套了很多视图的人比那些应用程序没有很多视图的人消耗更多的CPU和内存。这个想法是重复了<code>UITableView</code>和<code>UICollectionView</code>的行为。 </p><p>不要一次创建所有的子视图，而是根据需要创建它们，并在完成时将它们放在一个队列中。 </p><p>通过这种方式，您只需要在有人滚动时创建视图，这节省了内存。在创建视图时产生的能源效率问题也会影响到软件的其他方面。假设用户点击了一个按钮并希望显示一个视图。有两种选择:</p><ul><li><p>当屏幕加载时，创建并隐藏视图，然后在需要时显示它 </p></li><li><p>根据需要制作和展示items</p></li></ul><p>第一种方法的优点是要求您从一开始就建立一个 <code>viewpoint</code>（观点），并一直维护它，直到不再需要它。这个选项比第二个选项消耗更多的内存。因为当用户点击一个按钮时，你的程序只需要重新启用视图。第二个选项是相反的——它使用更少的内存，但当按下按钮时运行速度会稍微慢一些。</p><p>在这种情况下，<code>Mobile Vitals</code>为您提供iOS应用程序上的信息，允许您优先考虑重大问题，并快速解决它们。Sentry检测迟缓帧和冻结帧以跟踪用户界面响应。手机或平板电脑通常渲染<code>60帧/秒</code>，即每帧渲染速度为<code>16.67毫秒</code>。</p><p>苹果可以使用更快的帧率，特别是在<code>120帧/</code>秒的面板变得越来越普遍的情况下。Sentry检测帧率并更改这些程序的慢帧计算。</p><h2 id="重用标识符以提高性能"><a href="#重用标识符以提高性能" class="headerlink" title="重用标识符以提高性能"></a>重用标识符以提高性能</h2><p>为<code>UITableViewCells</code>、<code>UICollectionViewCells</code>甚至<code>UITableViewHeaderFooterViews</code>设置错误的重用标识符是一个常见的应用程序开发错误。在给<code>tableView</code>中的行分配单元格时，数据源应该经常重用<code>UITableViewCell</code>实例。 </p><p>如果没有<code>reuseIdentifier</code>，每次显示表视图时，必须在<code>UI</code>上设置一个新单元格。这可能会对性能产生重大影响，特别是应用程序的滚动体验。除了<code>UICollectionView</code>单元格cells和supplemental views（补充视图）外，<code>reuseidentifier</code>应该用于<code>header</code>和<code>footer</code>视图。 </p><p>如果需要，此过程将从队列中删除单元格或使用先前注册的<code>nib</code>或<code>classes</code>生成新单元格。如果没有可重用单元格，也没有设置classes或nib，则此方法返回nil。Sentry允许您设置警报，实时洞察错误，问题，甚至自定义的标准，您可以为自己的应用程序指定:</p><ul><li>新的问题出现 </li><li>问题越来越频繁 </li><li>过去已解决或被忽视的问题变得无法解决并再次浮出水面</li></ul><p>您还可以为特定的失败率、操作的延迟等定义警报和接收通知。您可以从Sentry仪表板上的alerts页面创建和管理警报。 </p><p>默认情况下，Sentry将提供相当数量的数据作为问题通知的一部分。在某些情况下，这些数据可能是源代码或其他用户数据。启用“增强隐私”选项将允许您规范这一点。为此，请访问组织的仪表板，选择设置，然后选中允许增加隐私的选项。当您激活此选项时，电子邮件提醒和系统的其他元素将开始将数据限制为问题的标题和描述。</p><h2 id="如何进一步改进UI滚动"><a href="#如何进一步改进UI滚动" class="headerlink" title="如何进一步改进UI滚动"></a>如何进一步改进UI滚动</h2><p>如果在复杂的层次结构中，如<code>Table</code>视图中滚动时，用户体验卡顿，请确保执行以下操作以保持Table视图滚动顺畅:</p><ul><li><code>reuseIdentifier</code>在重用cells时以适当的方式 </li><li>使所有视图都opaque（不透明），包括cells</li><li>避免使用<code>gradients</code>（渐变）、<code>zooming</code>（缩放）或<code>selecting a backdrop color</code>（选择背景色）。 </li><li>如果cell中的数据是从Internet获取的，则使用异步加载和缓存。 </li><li><code>shadowPath</code>应该只在必要的时候用来绘制阴影。 </li><li>尽量避免使用子视图。 </li><li>避免使用<code>applycellForRowAtIndexPath</code>。如果您需要使用它，只需执行一次，并将结果保存在缓存中。 </li><li>提供<code>userowHeight.section</code>固定的高度，并在设置高度时避免对委托的请求。</li></ul><h2 id="缓存的使用"><a href="#缓存的使用" class="headerlink" title="缓存的使用"></a>缓存的使用</h2><p>在iOS平台上，有多种方法可以创建具有视觉吸引力的UI。可以使用全尺寸图片或可调整大小的图片，它们可以使用<code>CALayer</code>、<code>CoreGraphics</code>甚至<code>OpenGL</code>进行渲染。当然，每种解决方案在复杂性和性能方面都有所不同。</p><p>利用预渲染的图形可以节省时间，因为不需要iOS创建图片，在上面画画，然后显示在屏幕上。问题是，你必须在程序包中包含所有相关的照片，这就增加了它的容量——这就是为什么使用可变大小的图像更好:你可以节省不必要的空间，避免为应用程序的不同部分开发不同的图像，例如按钮。</p><p>另一方面，使用图像意味着你失去了改变图像可用性的能力，你将不得不反复重做它们，这将消耗时间和资源，如果你想创建动画效果，即使每张图像只代表一小部分更改，你将需要大量的图像，这将增加<code>bundle</code>的大小。</p><p>作为一种普遍的权衡，平衡性能和管理不断增长的bundle大小是可取的。 </p><p>从bundle中加载图像最流行的方法之一是<code>imageNamed</code>，另一种是<code>image with content file</code>，这是不太常见的。 </p><p>加载图像时，<code>imageNamed</code>将它们保存在缓存中。它在系统缓存中搜索具有指定名称的图像对象，如果找到就返回该对象。缓存中没有匹配图片的对象将从提供的文档中获取，然后使用此函数进行缓存和返回。<code>imageWithContentsOfFile</code>，另一方面，它只是加载图片。 </p><p>问题是，你如何选择使用哪一个? </p><p>如果你只打算使用一次重图像，就没有必要缓存它们。相反，使用<code>image with a Content file</code> 的图像来节省内存。另一方面，<code>ImageNamed</code>在经常重用图像(如列表)的情况下是一个更好的选项。</p><h2 id="如何有效地显示阴影"><a href="#如何有效地显示阴影" class="headerlink" title="如何有效地显示阴影"></a>如何有效地显示阴影</h2><p>为了在一个layer或view上显示阴影，开发人员通常会选择如下示例的<code>QuartzCore</code>框架:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;QuartzCore/QuartzCore.h&gt; </span></span></span><br><span class="line"><span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] init]; </span><br><span class="line">view.layer.shadowOffset = <span class="built_in">CGSizeMake</span>(<span class="number">-1.0</span>f, <span class="number">1.0</span>f); </span><br><span class="line">view.layer.shadowRadius = <span class="number">5.0</span>f; </span><br><span class="line">view.layer.shadowOpacity = <span class="number">0.6</span>;</span><br></pre></td></tr></table></figure><p>这对系统来说似乎更容易表示。不是吗?遗憾的是，上述策略存在缺陷。因为<code>Core Animation</code>必须先执行一个屏幕外的传递来确定你的视图的确切形状，这是很重的资源。 </p><p>使用<code>shadowPath</code>解决了这个问题:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.layer.shadowPath = [[<span class="built_in">UIBezierPath</span> bezierPathWithRect:view.bounds] <span class="built_in">CGPath</span>];</span><br></pre></td></tr></table></figure><p>有了<code>shadowPath</code>, iOS不再需要每次都重新计算如何绘制，而是利用先前确定的路径。当您必须在某些视图中手动计算和更新阴影路径时，问题就出现了，这是耗时的。</p><h2 id="注意内存警告"><a href="#注意内存警告" class="headerlink" title="注意内存警告"></a>注意内存警告</h2><p>当系统内存不足时，iOS会通知所有正在运行的应用程序。当你的应用程序收到一个内存警告，它必须清除尽可能多的内存。这与苹果团队制定的指导方针是一致的。最有效的方法是删除对可重用缓存、图像对象和其他东西的强引用。在大多数情况下，使用UIKit的通知跟踪低内存变得简单。 </p><p>另一方面，Sentry在问题发展之前添加面包屑。与传统日志一样，这些事件可能包含大量结构化数据。你可以允许SDK自动捕捉应用程序的面包屑，如点击和按键事件，或手动添加使用以下代码执行的特定操作的面包屑</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Sentry</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> breadcrumb <span class="operator">=</span> <span class="type">Breadcrumb</span>()</span><br><span class="line"></span><br><span class="line">breadcrumb.level <span class="operator">=</span> <span class="type">SentryLevel</span>.info</span><br><span class="line"></span><br><span class="line">breadcrumb.category <span class="operator">=</span> <span class="string">&quot;auth&quot;</span></span><br><span class="line"></span><br><span class="line">breadcrumb.message <span class="operator">=</span> <span class="string">&quot;Authenticated user <span class="subst">\(user.email)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">SentrySDK</span>.addBreadcrumb(crumb: breadcrumb)</span><br></pre></td></tr></table></figure><p>您可以参考本文档来理解和配置面包屑的数据和属性。从系统获得这些警报后，您应该从内存中删除任何不必要的对象。此外，还可以从应用程序的图像缓存中删除当前没有显示在屏幕上的图像。如果你不以这种方式处理内存警报，操作系统可能会关闭你的应用程序。要释放内存，对象必须能够被重新创建。在创建时，要注意基于仿真的渲染。 </p><p>对于终端用户来说，响应时间是至关重要的，因为由于内存溢出和其他事情导致的延迟或无响应可能会让用户感到沮丧，导致用户完全放弃应用程序。 </p><p>Sentry Metrics可以让你更好地了解用户与应用的交互方式。你可以更快地量化应用的健康状况，并发现可能出现的故障或性能问题，如内存不足错误(OOMs)。 </p><p>在应用程序终止之前，Apple SDK会写一个报告到磁盘，其中包含堆栈跟踪、标签和面包屑等数据。这是因为OOM崩溃迫使操作系统在没有通知的情况下停止您的软件。在一次OOM之后，要恢复应用程序的状态并不容易。所以我们需要常规地存储应用程序状态。这将产生大量的I&#x2F;O，降低应用程序的速度。OOM事件缺乏上下文。</p><h2 id="管理历史遗留项目"><a href="#管理历史遗留项目" class="headerlink" title="管理历史遗留项目"></a>管理历史遗留项目</h2><p><code>Storyboards</code>已经取代<code>xib</code>成为<code>iOS 5</code>的主要视觉设计工具。虽然<code>xib</code>在某些情况下可能是方便的，但它们并不总是必需的。你必须处理它们，除非你的目标是<code>ios 5</code>之前的设备或利用自定义可重用视图。 </p><p>如果您必须使用<code>xib</code>，请尽可能保持它们的简单性。如果视图控制器的视图层次结构需要创建多个<code>XIB</code>，那么为每个<code>XIB</code>构造一个。XIB中包含的任何图像也包含在内存负载中，应该予以考虑。删除当前不用于保存内存的所有视图。Storyboards防止了这种情况的发生，因为它们只在绝对必要的时候构建视图控制器。 </p><p>当加载包含对图像或声音资源的引用的<code>nib</code>文件时，<code>nib</code>加载进程将加载并缓存实际的图像或声音文件。OS X将图片和声音资源保存在临时缓存中，以便以后可以访问。在iOS上，命名缓存只存储图片资源，不存储其他类型的数据。根据你的平台，可以使用<code>NSImage</code>或<code>UIImage</code>的<code>imageNamed:</code>方法来获取图像。 </p><p>Sentry通过趋势来识别那些随着时间的推移其性能发生了显著变化的事务。当您有大量计数的事务时，此视图非常适合提供见解。您可以通过单击页面右上角的选项卡从性能主页访问趋势视图。随着时间的推移，这个页面突出显示了盈利能力发生显著变化的交易。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>尽管应用程序性能非常重要，但开发人员经常忽略它。因此，在开发应用程序时，我们倾向于只使用最强大的设备和最昂贵的数据计划。结果，我们对表现不佳的后果视而不见。 </p><p>在本文中，您了解了如何为UI、动画等提高iOS应用程序的性能。本文试图确保所有的UI更新、前端渲染、动画以及Sentry如何帮助您加速性能提升之旅。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【译】Improve Performance in Your iOS Applications 一</title>
      <link href="/2022/10/26/Improve%20Performance%20iOS%20%E2%85%A0/"/>
      <url>/2022/10/26/Improve%20Performance%20iOS%20%E2%85%A0/</url>
      
        <content type="html"><![CDATA[<p>翻译几篇iOS性能优化的文章 Ⅰ，在第一篇文章中，我们将专注于iOS性能提示，帮助您提高iOS应用程序的编译时间，更快地构建，并在构建系统中改进iOS性能。让我们开始吧。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自2007年成立以来，随着时间的推移，苹果和<code>iOS</code>生态系统进行了大量的变化和新功能的添加(或删除)，得到了极大的改善。与此同时，应用程序和数据的规模一直在增长。这对你手中的强大设备——<code>iOS</code>设备有自己的影响。 </p><p>开发人员努力设计最好的体验，常常在速度和性能上做出妥协。随着时间的推移，这最终会导致应用程序性能下降，导致糟糕的用户体验，甚至更糟糕的是——用户删除你的<code>iOS</code>应用程序。为了解决这个问题，我们将介绍一个由4部分组成的性能系列，重点介绍如何改进iOS应用程序。 </p><h2 id="只编译必要的部分"><a href="#只编译必要的部分" class="headerlink" title="只编译必要的部分"></a>只编译必要的部分</h2><p>让我们从一行调整开始，它可以将大部分构建时间减半。 </p><p>您知道您所有的文件都要构建多次吗?<code>Xcode</code>中的一个重要观察结果可以回答这个问题。这篇相对较老的<a href="https://stackoverflow.com/questions/29683136/xcode-6-3-builds-all-swift-files-twice">Stack Overflow</a>文章仍然适用于最新版本的Xcode。 </p><p>解决方案是:在你的<code>Xcode</code>中，<strong>对于所有非必要或非发布的构建类型</strong>，将<code>build Active Architectures Only</code>设置为<code>Yes</code>。因为构建设置通常不只是发布和调试设置(不像大多数项目)，您可能会看到默认情况下为开发使用的所有配置启用了此标志。 </p><p>要更新设置，您需要在项目导航器中导航到项目文件，然后在左边栏中选择您的项目并导航到<code>Build Settings</code>选项卡。在<code>Architectures</code>下，您将发现<code>Build Active Architectures Only</code>的设置，您需要将其更改为<code>YES</code>。 </p><p>在大多数情况下，这应该理想地将构建时间减少到<code>50%</code>，但可能根据应用程序架构和其他配置而有所不同。神奇,不是吗?让我们继续下一个。</p><h2 id="加快Swift的编译时间"><a href="#加快Swift的编译时间" class="headerlink" title="加快Swift的编译时间"></a>加快Swift的编译时间</h2><p>你知道吗，默认情况下，整个模块优化(Whole Module Optimization)也会影响你的构建生成和构建速度?默认情况下，这只在<code>release</code>时启用。 </p><p>下面是如何调整它: </p><p>对于<code>debug</code>模式，在设置<code>Swift Compiler-Code Generation</code>下开启<code>enable</code>整个模块优化模块(<code>Whole Module Optimization</code>)，然后在<code>Other Swift Flags,</code>下，为<code>debug</code>模式指定以下标志: </p><p><strong>-Onone</strong></p><p>此外，在<code>debug</code>构建设置下，将<code>Optimization Level</code> (优化级别)的值设置为<code>Fast</code>，<code>Optimization Level</code> (整个模块优化)。 </p><p>如果你使用<code>CocoaPods</code>，在<code>Podile</code>底部添加以下代码将有助于优化所有依赖项:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">post_install <span class="keyword">do</span> |<span class="params">installer</span>|</span><br><span class="line">  installer.pods_project.targets.each <span class="keyword">do</span> |<span class="params">target</span>|</span><br><span class="line">    target.build_configurations.each <span class="keyword">do</span> |<span class="params">config</span>|</span><br><span class="line">      <span class="keyword">if</span> config.name == <span class="string">&#x27;Debug&#x27;</span></span><br><span class="line">        config.build_settings[<span class="string">&#x27;OTHER_SWIFT_FLAGS&#x27;</span>] = [<span class="string">&#x27;$(inherited)&#x27;</span>, <span class="string">&#x27;-Onone&#x27;</span>]</span><br><span class="line">        config.build_settings[<span class="string">&#x27;SWIFT_OPTIMIZATION_LEVEL&#x27;</span>] = <span class="string">&#x27;-Owholemodule&#x27;</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这将确保一次编译整个模块，而无需为<code>debug</code>版本优化代码，以加快开发和节省时间</p><h3 id="实测"><a href="#实测" class="headerlink" title="实测"></a>实测</h3><img src="/2022/10/26/Improve%20Performance%20iOS%20%E2%85%A0/before.png" class="&#x3D;"><img src="/2022/10/26/Improve%20Performance%20iOS%20%E2%85%A0/after.png" class="&#x3D;"><p>左边未开启优化Podfile 右边开启</p><h2 id="分析你的iOS编译时间"><a href="#分析你的iOS编译时间" class="headerlink" title="分析你的iOS编译时间"></a>分析你的iOS编译时间</h2><p>许多开发人员面临的问题是，他们的代码的编译时间相对较长。更令人担忧的事实是，有时它会突然变得比以前的构建时间更慢。这可能会迅速升级。这种技术可以帮助您定位编译器难以处理的代码部分，并且您可以尝试重新排序它们以加快编译速度。</p><p>第一步是导航到你的<code>Swift Compiler</code>部分，在<code>Other Swift flags</code>下添加以下标志:</p><blockquote><p>-Xfrontend -debug-time-function-bodies</p></blockquote><p>使用上述标志，编译器将打印出每个函数所需的时间。下一步是收集所有这些日志数据点并对它们进行排序。输出将给出文件名和行号。在大多数情况下，只有少数几个函数(有时甚至少于5个)被重复打印—所以不用担心。</p><p>请记住，您不需要对编译器有太多了解就可以理解或理解日志输出。只要观察每行末尾的函数名和关键字就会明白了。 </p><p>重写几行代码可能会使整个项目的构建速度加快50%。这是因为在大多数情况下，错误线展示了特定于数据结构的改进，以及如何编写更合适的代码。 </p><p>只需将函数重写为尽可能基本的函数就可以解决问题——表面上不必要的类型定义、中间变量、可变变量等等。</p><p><a href="https://twitter.com/benjaminencz/status/685510563015741440">这是一个简单但极好的例子</a>。</p><h3 id="实测-1"><a href="#实测-1" class="headerlink" title="实测"></a>实测</h3><img src="/2022/10/26/Improve%20Performance%20iOS%20%E2%85%A0/swift-compiler-flags.png" class="&#x3D;"><p>调试日志在Xcode的报告导航器中可见，但只能手动展开每个单独的文件:</p><img src="/2022/10/26/Improve%20Performance%20iOS%20%E2%85%A0/xcode-build-reports.png" class="&#x3D;"><h2 id="升级系统配置"><a href="#升级系统配置" class="headerlink" title="升级系统配置"></a>升级系统配置</h2><p>在<code>Xcode 9.2</code>之上，新引入的架构允许项目并行运行Swift编译任务。如果您的计算机没有足够的<code>RAM</code>，那么构建时间可能会大大减慢。你可以做几件事来避免这种情况:</p><ul><li><p>使用以下命令禁用<code>Xcode</code>的并行任务执行:</p><blockquote><p>defaults write com.apple.dt.Xcode BuildSystemScheduleInherentlyParallelCommandsExclusively -bool NO</p></blockquote></li><li><p>有些项目会比其他项目运行得更快更好。另一件需要注意的事情是:如果您的机器没有很多<code>RAM</code>，这实际上可能会降低构建的速度。如果应用上述方法使构建变慢，最好使用以下命令禁用并发构建任务:</p><blockquote><p>defaults delete com.apple.dt.Xcode BuildSystemScheduleInherentlyParallelCommandsExclusively</p></blockquote></li><li><p>如果你在你的机器上有一个超快的配置，可以加快你的编译时间，你可能会考虑通过使用下面的命令分配一些额外的进程Xcode:</p><blockquote><p>defaults write com.apple.Xcode PBXNumberOfParallelBuildSubtasks 4</p></blockquote></li><li><p>在您的工作空间设置(workspace settings )或项目设置(project settings)中，在<code>Shared Workspace Settings</code>(共享工作空间设置)下启用<code>new build system</code>(新的生成系统)，以加快生成速度。一旦被选中，<code>new build system</code>(新的构建系统)将控制编译和构建生成，减少编译Swift代码所需的时间。</p></li><li><p>增加内存RAM或升级系统硬件(M1速度很快)。</p></li></ul><h2 id="改进iOS编译过程"><a href="#改进iOS编译过程" class="headerlink" title="改进iOS编译过程"></a>改进iOS编译过程</h2><p>如果为您的项目启用了并行编译，您将看到更好的编译性能，编译目标的顺序也不会那么重要。然而，如果使用上述技术关闭了并行编译生成，<code>Xcode</code>将尝试按照构建操作方案（the build action scheme）中指定的顺序构建目标依赖项（target dependencies）。 </p><p>在这种情况下，您可以声明输入和输出配置，以让构建系统知道哪些脚本任务可以避免不必要的重新运行。 </p><p>您可以在工作空间中采用的另一种技术是避免自动链接项目依赖项（ avoid auto linking project dependencies）。这个特定的设置允许编译器自动链接与您导入的模块相关的框架，而无需在链接库的构建阶段显式地链接它们。然而，自动链接本身并不在构建系统级别建立对指定框架的依赖。这意味着，在您尝试链接依赖项之前，构建系统或自动链接特性不能保证实际构建了项目所依赖的目标。 </p><p>相反，你应该添加显式依赖以让构建系统知道，你也可能更喜欢通过拖放技术将项目与其他Xcode项目引用到当前项目的文件导航器中，并捕获其他所需项目的目标。</p><h2 id="优化iOS崩溃报告生成"><a href="#优化iOS崩溃报告生成" class="headerlink" title="优化iOS崩溃报告生成"></a>优化iOS崩溃报告生成</h2><p><code>iOS</code>生成一个<code>dSYM</code>文件来维持原始代码和模糊堆栈跟踪之间的映射，以理解崩溃报告。由于生成<code>dSYM</code>文件需要大量的时间，所以在the debugger is not attached（没有附加调试器）的情况下，或者在调试构建生成期间，可以避免生成<code>dSYM</code>。 </p><p>在<code>Debug Information Format </code>（调试信息格式设置）下，确保您使用的是普通的<code>DWARF</code>而不是带有<code>dSYM</code>文件的<code>DWARF</code>。</p><h2 id="Objective-C头文件是罪魁祸首"><a href="#Objective-C头文件是罪魁祸首" class="headerlink" title="Objective-C头文件是罪魁祸首"></a>Objective-C头文件是罪魁祸首</h2><p>对于遗留项目，您可能已经注意到，许多项目文件都以详尽的头声明开始。您知道在项目中声明额外或不必要的头文件导入会大大降低生成构建的时间吗? </p><p>此外，大量的头文件还成倍增加了依赖项检查所需的时间。 </p><p>在这种情况下，以下策略就派上用场了: </p><ul><li><p>减少头文件的导入，只导入必要的头文件;你可以很容易地使用代码编译和检查工具，如SwiftLint </p></li><li><p>使用前向声明而不是递归头文件包含或头文件调用另一个头文件，以大幅减少依赖的数量，并最终提高构建生成时间(<a href="https://tyciphonedevelopment.blogspot.com/2008/11/objective-c-forward-declaration.html">这个链接应该很有帮助</a>)。</p></li></ul><h2 id="减少使用非透明视图"><a href="#减少使用非透明视图" class="headerlink" title="减少使用非透明视图"></a>减少使用非透明视图</h2><p>不透明视图（An opaque view）是不透明（transparency）的视图。这意味着处于不透明视图后面的任何元素在层后面都不可见。</p><blockquote><p>An opaque view is the view that does not have transparency.  This means that any elements placed behind the opaque view are hidden behind the layer.</p></blockquote><p>在关注iOS性能提升的同时，这也是每个人都需要理解的一个关键领域。将视图设置为<code>opaque</code>可以确保在框架绘制视图之前应用系统优化，肯定会有一些改进，特别是在呈现屏幕时绘制的性能。</p><p>如果任何视图的透明度或<code>alpha</code>通道低于<code>1.0</code>,iOS框架必须在处理视图层次结构时将不同的视图和层混合在一起，从而计算最终的显示渲染。相反，如果任何视图有一个不透明的属性设置，iOS框架就会把这个视图层叠加在之前的视图层之上，并避免任何额外的处理来混合视图层次结构。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.clear <span class="comment">// Original label.backgroundColor = UIColor.white // To be applied</span></span><br></pre></td></tr></table></figure><p>此外，要从图像中删除<code>alpha</code>通道，你可以使用预览应用程序(Preview app)。所有你需要做的是通过按<code>Shift + CMD + S</code>和取消<code>Alpha</code>复选框来复制图像，同时保存重复的图像。</p><h2 id="调整你的Swift扩展"><a href="#调整你的Swift扩展" class="headerlink" title="调整你的Swift扩展"></a>调整你的Swift扩展</h2><p>当你在Swift中编写自己的扩展时，默认情况下，它们被设置为<code>public access modifiers</code>(公共访问修饰符)。这增加了编译时间，因为每个Swift类都要使用它。</p><p>解决这个问题的最好方法是完全避免创建扩展。如果没有，那么您应该创建扩展并将访问修饰符设置为<code>private</code>，因为您只会在代码的一部分中使用它们。</p><h2 id="删除不必要和不使用的代码"><a href="#删除不必要和不使用的代码" class="headerlink" title="删除不必要和不使用的代码"></a>删除不必要和不使用的代码</h2><p>无论是<code>pods</code>还是在你的iOS应用程序中不再起任何作用的代码，删除不使用的代码、不使用的图像文件或<code>assets</code>(资产)，许多不再使用的<code>pods</code>甚至是函数，都将大大减少构建时间，同时减少发布版本的大小。</p><h2 id="让你的iOS应用模块化"><a href="#让你的iOS应用模块化" class="headerlink" title="让你的iOS应用模块化"></a>让你的iOS应用模块化</h2><p>对于相对大型的项目，根据需求，提高iOS应用性能最有效的解决方案之一是将庞大的iOS项目转化为模块化结构。对于这种包含多个特性和功能的大型项目，您可以考虑采用模块化体系结构，其中每个模块由统一的特性组成，这些特性在同一模块中彼此紧密相关。</p><p>其想法是用<code>workspace</code>(工作空间)替换<code>project</code>(项目)，并构建可以编译和注入到工作空间中以供利用的模块。一般来说，坚持关注点分离，你可以将你的iOS应用模块化在几个模块中，如数据库、网络、<code>utilities </code>(实用程序)、接口等。</p><p>模块化你的iOS应用程序的好处不仅是减少编译时间，而且你可以很容易地在整个项目和其他项目中重用模块，只需要导入它们，而不是每次都重写整个代码。</p><h2 id="利用缓存"><a href="#利用缓存" class="headerlink" title="利用缓存"></a>利用缓存</h2><p>通过“一次构建，处处重用”的方法——远程构建缓存策略有助于大幅减少构建时间，因为您不再需要重新构建任何机器上已经构建的任何东西。</p><p>在这种方法中，只要所有输入文件和编译设置相同，就可以下载从另一台计算机生成和共享的工件，而不是在本地生成目标。找到合适的缓存级别对于远程缓存的成功至关重要。过于细粒度的缓存单元(缓存编译过程的每个阶段)可能会导致严重的网络流量开销，超过所节省的CPU。另一方面，将整个软件放入一个可缓存单元，可能会显著降低缓存命中率;每一次本地更新都会使远程访问的缓存构件失效，强制在本地完成构建。</p><p>另一种充分利用缓存的方法是使用<code>Bazel build system</code>。对于iOS系统，<a href="https://bazel.build/">Bazel</a>提供了一套预定义的苹果规则，帮助你开始并构建一个完整的应用程序。然而，请注意，设置Bazel并使用Bazel成功运行你的iOS版本需要高级水平的理解，但在我看来这是值得的，特别是对于大型项目。包括<code>Lyft</code>、<code>Pinterest</code>和<code>LinkedIn</code>在内的一些重要机构也利用Bazel开发他们的iOS应用程序。</p><p>多亏了Bazel，构建只执行一次，而重构只在任何目标文件更改时执行。一旦您使用<code>-remote_http_cache</code>将其指向远程缓存，我们就可以在共享远程缓存中共享此构件。你可以在<a href="https://engineering.linecorp.com/en/blog/improving-build-performance-line-ios-bazel/">这里</a>和<a href="https://blog.allegro.tech/2020/12/speeding-up-ios-builds-with-bazel.html">这里</a>了解更多关于为iOS应用程序设置Bazel的信息。</p><h2 id="调整iOS应用程序测试设置"><a href="#调整iOS应用程序测试设置" class="headerlink" title="调整iOS应用程序测试设置"></a>调整iOS应用程序测试设置</h2><p>Apple iOS测试模拟器可以用于在各种软件和硬件组合上进行应用程序测试。通过为模拟器选择“Physical Size”或“Pixel Accurate window size”，可以减少运行的测试数量和执行测试所需的时间。这些配置更改使用更少的资源，并防止通过模拟永远不会看到的像素而降低测试速度。 </p><p>这里是<a href="https://stackoverflow.com/questions/18606926/adjusting-the-xcode-iphone-simulator-scale-and-size">Stack Overflow</a>的答案，关于如何配置您的iOS模拟器的物理大小或像素精确窗口大小，以利用iOS性能测试工具。</p><h2 id="用Sentry监控你的iOS性能"><a href="#用Sentry监控你的iOS性能" class="headerlink" title="用Sentry监控你的iOS性能"></a>用Sentry监控你的iOS性能</h2><p>Sentry的iOS SDK自动报告错误(s)或异常(s)未被捕获在您的应用程序中导致应用程序崩溃。在iOS上集成Sentry所需的最低版本是9.0。 </p><p>虽然使用Cocoapods安装SDK的推荐方法如下所示，但iOS应用也支持其他安装方法:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">platform <span class="symbol">:ios</span>, <span class="string">&#x27;9.0&#x27;</span></span><br><span class="line">use_frameworks! <span class="comment"># This is important</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;YourApp&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">&#x27;Sentry&#x27;</span>, <span class="symbol">:git</span> =&gt; <span class="string">&#x27;https://github.com/getsentry/sentry-cocoa.git&#x27;</span>, <span class="symbol">:tag</span> =&gt; <span class="string">&#x27;7.11.0&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#run pod install</span></span><br></pre></td></tr></table></figure><p>通过性能监视，Sentry可以跟踪您的软件性能，测量吞吐量和延迟等指标，并跨多个系统显示错误的影响。 </p><p>在Sentry的帮助下，iOS性能监控可以通过两种方式实现: </p><ul><li><p>自动检测允许您捕获Sentry已经指定和支持的标准跟踪，例如捕获应用程序加载时的事务，或当应用程序启动时(包括冷启动和热启动)，检测慢速和冻结帧、网络调用、文件和I&#x2F;O操作等。您可以按照这里给出的步骤启用自动检测。 </p></li><li><p>自定义插装允许您指定自己的实现并创建事务以捕获可能的每一个操作。这可能因情况的不同、特性的不同而有所不同，例如当用户在购物车上执行结帐、验证支付细节或首次注册时，等等。您可以按照这里给出的步骤启用自定义插装。</p></li></ul><p>Sentry支持大量的集成，通过不同的工作流程和提供程序来实现您的合适目标。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本文中，我们介绍了如何提高iOS应用程序性能、iOS性能测试工具、iOS性能监控等。我们主要关注构建过程和构建系统。虽然我们的努力是将所有内容集中在一个屋檐下，但iOS性能技巧的话题是广泛的，应该给予适当的公正。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.sentry.io/2022/04/07/improve-performance-in-your-ios-applications-part-1/">Improve Performance in Your iOS Applications</a><br><a href="">有道翻译</a><br><a href="https://irace.me/swift-profiling">Profiling your Swift compilation times</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>像素不对齐</title>
      <link href="/2022/10/19/%E5%83%8F%E7%B4%A0%E4%B8%8D%E5%AF%B9%E9%BD%90/"/>
      <url>/2022/10/19/%E5%83%8F%E7%B4%A0%E4%B8%8D%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<p>像素不对齐是指物理像素（pixel)不对齐；出现像素不对齐，会导致GPU在渲染时，对没对齐的边缘，进行插值计算，造成性能损耗了。</p><span id="more"></span><h2 id="Color-Misaligned-Images"><a href="#Color-Misaligned-Images" class="headerlink" title="Color Misaligned Images"></a>Color Misaligned Images</h2><p><code>Misaligned Image</code>表示要绘制的点无法直接映射到频幕上的像素点，此时系统需要对相邻的像素点做<code>anti-aliasing</code>反锯齿计算，增加了图形负担，通常这种问题出在对某些View的Frame重新计算和设置时产生的。</p><h3 id="像素不对齐"><a href="#像素不对齐" class="headerlink" title="像素不对齐"></a>像素不对齐</h3><p>iOS设备上，有逻辑像素（point）和 物理像素（pixel)之分，像素对齐指的是物理像素对齐，对齐就是像素点的值是整数，如某视图的宽高是100pixel * 100 pixel。</p><p>不对齐：视图或图片的点数(point)，不能换算成整数的像素值（pixel），导致显示视图的时候需要对没对齐的边缘进行额外混合计算，影响性能。</p><h3 id="像素对齐-VS-像素不对齐"><a href="#像素对齐-VS-像素不对齐" class="headerlink" title="像素对齐 VS 像素不对齐"></a>像素对齐 VS 像素不对齐</h3><ul><li>逻辑像素（point）乘以2（2x的视网膜屏） 或3（3x的视网膜屏）得到整数值，或者说得到的浮点数且小数点后都是0的，这就像素对齐了，否则就是像素不对齐。 </li><li>出现像素不对齐的情况，会导致在GPU渲染时，对没对齐的边缘，需要进行插值计算，这个插值计算的过程会有性能损耗。</li></ul><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><h3 id="图片像素不对齐"><a href="#图片像素不对齐" class="headerlink" title="图片像素不对齐"></a>图片像素不对齐</h3><ul><li>网络图片一般不会有<code>@2x</code>和<code>@3x</code>之分，通过<code>SDWebImage</code>库下载的图片不加以处理就直接显示。</li><li>当图片的size和显示图片View的size不同 或 图片的scale和屏幕的scale不同，就会发生像素不对齐的问题。</li><li>label的font大小和frame不匹配 字体太大 控件size放不下</li><li>section header height返回 0.01f    (<code>CGFLOAT_MIN</code>,<code>CGFloat.leastNormalMagnitude</code>)</li></ul><h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><p>iPhone模拟器中的<code>Debug -&gt; Color Misaligned Images</code>选项 </p><p><code>Core Animation-&gt;Display Settings-&gt;Color Misaligned Images</code>选项都可以将像素不对齐的部分显示出来</p><blockquote><p>视图会有黄色或洋红色（Magenta）的图层标记，代表其像素不对齐</p></blockquote><p>洋红色：UIView的frame像素不对齐，即不能换算成整数像素值。<br>黄色：UIImageView的图片像素大小与其frame.size不对齐，图片发生了缩放造成    &#x2F;黄色覆盖是由拉伸引起的</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>1.像素不对齐</p><p>要想像素对齐，必须保证image.size和显示图片view.size相等 且 image.scale和 [UIScreen mainScreen].scale相等。可以在网络图片下载完成后进行压缩裁剪等操作在进行渲染</p><p>针对frame像素不对齐，借助ceilf()、floorf()、CGRectIntegral()等将小数点后数据除去即可</p><p>像素不对称齐的元素一般为UILabel或UIImageView</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/432fea0232b8">解决iOS中像素不对齐问题</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> UI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>URL编码</title>
      <link href="/2022/10/08/URL%E7%BC%96%E7%A0%81/"/>
      <url>/2022/10/08/URL%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>在iOS程序中，访问一些HTTP&#x2F;HTTPS的资源服务时，如果url中存在中文或者特殊字符时，会导致无法正常的访问到资源或服务，想要解决这个问题，需要对url进行编码。</p><span id="more"></span><h2 id="URI-Uniform-Resource-Identifier"><a href="#URI-Uniform-Resource-Identifier" class="headerlink" title="URI(Uniform Resource Identifier)"></a>URI(Uniform Resource Identifier)</h2><p>URI：(Uniform Resource Identifier 的缩写，统一资源标识符)。 对于URI, 具体的结构如下:</p><p>URI 由一个 <code>scheme</code> 和一个 <code>hierarchical part</code> 组成，带有 query 和 fragment（后两者非必需）：</p><p><scheme name> : <hierarchical part> [ ? <query> ] [ # <fragment> ]</p><h2 id="URL-Uniform-Resource-Locator"><a href="#URL-Uniform-Resource-Locator" class="headerlink" title="URL(Uniform Resource Locator)"></a>URL(Uniform Resource Locator)</h2><p>URL 是Uniform Resource Locator 的缩写，统一资源定位符，对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。基本URL包含模式（或称协议）、服务器名称（或IP地址）、路径和文件名、参数，如“协议：&#x2F;&#x2F;授权&#x2F;路径查询？参数”。</p><blockquote><p>URI 属于 URL 更低层次的抽象，一种字符串文本标准。URL 是 URI 的一个子集。 URI 表示请求服务器的路径，定义这么一个资源。而 URL 同时说明要如何访问这个资源（http:&#x2F;&#x2F;）</p></blockquote><h3 id="URL组件"><a href="#URL组件" class="headerlink" title="URL组件"></a>URL组件</h3><blockquote><p><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></p></blockquote><p>如上URL，其基本构成</p><p>scheme: http</p><p>host:<a href="http://www.aspxfans.com/">www.aspxfans.com</a></p><p>port:8080</p><p>path:&#x2F;news&#x2F;index.asp</p><p>query:boardID&#x3D;5&amp;ID&#x3D;24618&amp;page&#x3D;1</p><p>fragment:name </p><img src="/2022/10/08/URL%E7%BC%96%E7%A0%81/url00.png" class="&#x3D;"><img src="/2022/10/08/URL%E7%BC%96%E7%A0%81/url03.png" class="&#x3D;"><img src="/2022/10/08/URL%E7%BC%96%E7%A0%81/url02.jpeg" class="&#x3D;"><ul><li>应用：<br>URL Scheme方式实现App之间跳转实现</li></ul><p>&#x2F;&#x2F; 打开邮箱<br>mailto:&#x2F;&#x2F;</p><p>&#x2F;&#x2F; 给110拨打电话<br>tel:&#x2F;&#x2F;110</p><h2 id="为什么要编码"><a href="#为什么要编码" class="headerlink" title="为什么要编码"></a>为什么要编码</h2><p>网络标准<a href="">RFC 1738</a>规定url中只能包含英文字母和阿拉伯数字，以及一些特殊字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;...Only alphanumerics [0-9a-zA-Z], the special characters &quot;$-_.+!*&#x27;(),&quot; [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL.&quot;</span><br></pre></td></tr></table></figure><blockquote><p>只有字母和数字[0-9a-zA-Z]、和特殊符号”$-_.+!*’(),”[不包括双引号]、及某些保留字，才可以不经过编码直接用于URL。</p></blockquote><p>此时如果url中包含如汉字或者其他特殊字符则需要对它进行编码，编码的意义在于，假如url的参数中的中文或特殊字符在发送到服务端时，服务端无法解析它的真正意义，会导致服务端不能理解客户端的请求。</p><h3 id="如："><a href="#如：" class="headerlink" title="如："></a>如：</h3><ol><li>url中的保留字?表示后面连接的是一些请求参数，而参数中如果也包含?，服务端就不知道从哪个?之后是参数；</li><li>url中的保留字&amp;用来连接并列的参数项，参数中包含&amp;时，服务端依然无法判断。</li></ol><h2 id="不需要编码的字符"><a href="#不需要编码的字符" class="headerlink" title="不需要编码的字符"></a>不需要编码的字符</h2><p><code>RFC3986</code> 文档规定，URL中只允许包含以下四种：</p><ol><li>英文字母（a-z A-Z）</li><li>数字（0-9）</li><li>-_.~ &#96;4个特殊字符</li><li>所有保留字符，RFC3986中指定了以下字符为保留字符（英文字符）:<code>! * &#39; ( ) ; : @ &amp; = + $ , / ? # [ ]</code></li><li>编码标记符号 <code>%</code></li></ol><blockquote><p>URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 的字符，中文是三个编码组合。十六进制格式用于在浏览器和插件中显示非标准的字母和字符。</p></blockquote><h2 id="保留字符"><a href="#保留字符" class="headerlink" title="保留字符"></a>保留字符</h2><p>URL 拼接参数或路径设置时，拼接的普通字符串中含有保留字符，会引起歧义的情况。URL 参数字符串中使用 <code>key=value</code> 这样的键值对形式来传参，键值对之间以 <code>&amp;</code> 符号分隔</p><img src="/2022/10/08/URL%E7%BC%96%E7%A0%81/url01.png" class="&#x3D;"><p>如果需要在URL中用到特殊字符或中文字符，需要将这些特殊字符换成相应的十六进制的值.</p><h2 id="URL编码规则"><a href="#URL编码规则" class="headerlink" title="URL编码规则"></a>URL编码规则</h2><p>Url编码通常也被称为百分号编码，使用%百分号加上两位的字符——0123456789ABCDEF——代表一个字节的十六进制形式。Url编码默认使用的字符集是US-ASCII。</p><h3 id="ASCII字符"><a href="#ASCII字符" class="headerlink" title="ASCII字符"></a>ASCII字符</h3><p>例如<br>a在US-ASCII码中对应的字节是0x61，那么Url编码之后得到的就是%61</p><p>在地址栏上输入 <code>http://g.cn/search?q=%61%62%63</code> ，实际上就等同于在google上搜索<code>abc</code>了</p><h3 id="非ASCII字符"><a href="#非ASCII字符" class="headerlink" title="非ASCII字符"></a>非ASCII字符</h3><p>需要使用ASCII字符集的超集进行编码得到相应的字节，然后对每个字节执行百分号编码。</p><h3 id="Unicode字符"><a href="#Unicode字符" class="headerlink" title="Unicode字符"></a>Unicode字符</h3><p>RFC文档建议使用utf-8对其进行编码得到相应的字节，然后对每个字节执行百分号编码。</p><ul><li>如”中文”</li></ul><p>使用UTF-8字符集得到的字节为<br><code>0xE4 0xB8 0xAD 0xE6 0x96 0x87</code>，<br>经过Url编码之后得到”<code>%E4%B8%AD%E6%96%87</code>“</p><h2 id="iOS端URL编解码"><a href="#iOS端URL编解码" class="headerlink" title="iOS端URL编解码"></a>iOS端URL编解码</h2><ol><li>URL编码和解码是成对，URL编码和解码是一个可逆的过程，编码和解码的逻辑是翻转对应的。</li><li>编码和解码的次数也要一一对应。</li></ol><h3 id="编解码API"><a href="#编解码API" class="headerlink" title="编解码API"></a>编解码API</h3><ul><li><p>iOS端在生成NSURL实例<br> <code>NSURL *url = [NSURL URLWithString:urlString];</code></p><blockquote><p>urlString 中含有超出中文字符等非定URL限定字符时，创建的NSURL对象会失败，url返回为nil</p></blockquote></li><li><p>stringByAddingPercentEncodingWithAllowedCharacters<br> 苹果对该方法的注解：将<code>AllowedCharacters</code>集中不包含的所有字符替换为百分比编码字符，返回从接收器生成的新字符串。<code>utf-8</code>编码用于确定正确的编码字符百分比。不能对整个URL字符串进行百分比编码。此方法用于对URL组件或子组件字符串进行百分比编码，而不是对整个URL字符串进行百分比编码。7位<code>ascii</code>范围之外的允许字符中的任何字符都将被忽略。</p></li></ul><h3 id="封装处理"><a href="#封装处理" class="headerlink" title="封装处理"></a>封装处理</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 对字符串的每个字符进行UTF-8编码</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @return 百分号编码后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)URLUTF8EncodingString</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSCharacterSet</span> *characterSet = [<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *encodeStr = [<span class="keyword">self</span> stringByAddingPercentEncodingWithAllowedCharacters:characterSet];</span><br><span class="line">    <span class="keyword">return</span> encodeStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 对字符串的每个字符进行彻底的 UTF-8 解码</span></span><br><span class="line"><span class="comment"> 连续编码2次，需要连续解码2次，第三次继续解码时，则返回为空</span></span><br><span class="line"><span class="comment"> @return 百分号编码解码后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)URLUTF8DecodingString</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> stringByRemovingPercentEncoding] == <span class="literal">nil</span></span><br><span class="line">        || [<span class="keyword">self</span> isEqualToString:[<span class="keyword">self</span> stringByRemovingPercentEncoding]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> *decodedStr = [<span class="keyword">self</span> stringByRemovingPercentEncoding];</span><br><span class="line">    <span class="keyword">while</span> ([decodedStr stringByRemovingPercentEncoding] != <span class="literal">nil</span>) &#123;</span><br><span class="line">        decodedStr = [decodedStr stringByRemovingPercentEncoding];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decodedStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意<br><code>URLUTF8EncodingString</code> UTF-8编码可以无限制调用多次，<code>stringByRemovingPercentEncoding</code>方法的特殊性是字符串不是UTF-8编码格式，调用时返回为nil，因此解码时只需调用一次URLUTF8DecodingString即可将所有字符彻底UTF-8解码。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1329400">iOS中URL编码那些事</a><br><a href="https://juejin.cn/post/6844903937364099079">全面深度解析iOS端URL编码和解码过程</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> URL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编码</title>
      <link href="/2022/10/08/%E7%BC%96%E7%A0%81/"/>
      <url>/2022/10/08/%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</p><span id="more"></span><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>ASCII码就是一种编码，字母A的编码是十六进制的0x41，字母B是0x42，ASCII编码最多只能有127个字符</p><h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF - 8"></a>UTF - 8</h2><p>有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p><p>Unicode 是互联网统一的符号集，只规定了符号唯一的二进制代码值，却没有规定这个二进制代码应该如何存储。UTF-8是一种针对Unicode的可变长度字符编码，UTF-8用1到4个字节编码Unicode字符，在互联网上使用最广的一种 Unicode 的实现方式。</p><p><strong>UTF-8 是 Unicode 的实现方式之一</strong></p><img src="/2022/10/08/%E7%BC%96%E7%A0%81/utf8.png" class="&#x3D;"><h2 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h2><p>Base64编码是对二进制数据进行编码，表示成文本格式，这样在很多文本协议（电子邮件协议）中就可以处理二进制数据</p><p>Base64编码可以把任意长度的二进制数据变为纯文本，且只包含A<del>Z、a</del>z、0~9、+、&#x2F;、&#x3D;这些字符</p><p>原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。</p><h3 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h3><p>3个byte数据分别是e4、b8、ad，按6bit分组得到39、0b、22和2d：</p><img src="/2022/10/08/%E7%BC%96%E7%A0%81/base4.png" class="&#x3D;"><p>因为6位整数的范围总是0<del>63，所以，能用64个字符表示：<br>字符A</del>Z对应索引0<del>25，<br>字符a</del>z对应索引26<del>51，<br>字符0</del>9对应索引52~61，<br>最后两个索引62、63分别用字符+和&#x2F;表示</p><p>因为标准的Base64编码会出现+、&#x2F;和&#x3D;，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把+变成-，&#x2F;变成_</p><p>Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1&#x2F;3</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unicode </tag>
            
            <tag> UTF-8 </tag>
            
            <tag> Base64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python入门</title>
      <link href="/2022/09/13/Python%E5%85%A5%E9%97%A8/"/>
      <url>/2022/09/13/Python%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>Python生态健全，在量化数据分析，机器学习等领域使用广泛</p><span id="more"></span><h2 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h2><h3 id="input函数"><a href="#input函数" class="headerlink" title="input函数"></a>input函数</h3><ul><li>语法:</li></ul><p><code>input([prompt])</code></p><ul><li>prompt: 提示信息</li></ul><p>Python3.x 中 input() 函数接受一个标准输入数据，返回为 string 类型</p><blockquote><p>注意：input() 和 raw_input() 这两个函数均能接收 字符串 ，但 raw_input() 直接读取控制台的输入（任何类型的输入它都可以接收）。而对于 input() ，它希望能够读取一个合法的 python 表达式，即你输入字符串的时候必须使用引号将它括起来，否则它会引发一个 SyntaxError 。<br>除非对 input() 有特别需要，否则一般情况下我们都是推荐使用 raw_input() 来与用户交互。</p></blockquote><blockquote><p>注意：python3 里 input() 默认接收到的是 str 类型。</p></blockquote><h3 id="print函数"><a href="#print函数" class="headerlink" title="print函数"></a>print函数</h3><ul><li>语法:</li></ul><p><code>print(*objects, sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout, flush=False)</code></p><ul><li>参数</li><li>objects – 复数，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔。</li><li>sep – 用来间隔多个对象，默认值是一个空格。</li><li>end – 用来设定以什么结尾。默认值是换行符 \n，我们可以换成其他字符串。</li><li>file – 要写入的文件对象。</li><li>flush – 输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新。</li></ul><p>返回值<br>无。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在<code>Python</code>中，函数的参数可以有默认值，也支持使用可变参数，所以Python没有重载的概念</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>可以使用<code>global</code>关键字来指示foo函数中的变量a来自于全局作用域，如果全局作用域中没有a，那么下面一行的代码就会定义变量a并将其置于全局作用域。<br>同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用<code>nonlocal</code>关键字来指示变量来自于嵌套作用域</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">*numbers</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, **kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, name, <span class="string">&#x27;age:&#x27;</span>, age, <span class="string">&#x27;other:&#x27;</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Michael&#x27;</span>, <span class="number">30</span>)</span><br><span class="line">name: Michael age: <span class="number">30</span> other: &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>导入的模块除了定义函数之外还有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是”<code>__main__</code>“</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="元组与列表"><a href="#元组与列表" class="headerlink" title="元组与列表"></a>元组与列表</h3><ul><li>已经有了列表这种数据结构，为什么还需要元组这样的类型呢？</li></ul><ol><li><p>元组中的元素是无法修改的，多线程环境中可能更喜欢使用的是那些不变对象，一个不变的对象要比可变的对象更加容易维护；一个不变对象自动就是线程安全的，如果一个方法要返回多个值，使用元组也是不错的选择</p></li><li><p>元组在创建时间和占用的空间上面都优于列表。</p></li></ol><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p> <code>__init__</code>是一个特殊方法用于在创建对象时进行初始化操作</p><h3 id="属性权限控制"><a href="#属性权限控制" class="headerlink" title="属性权限控制"></a>属性权限控制</h3><p>在<code>Python</code>中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, foo</span>):</span><br><span class="line">        self.__foo = foo</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.__foo)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    test = Test(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="comment"># AttributeError: &#x27;Test&#x27; object has no attribute &#x27;__bar&#x27;</span></span><br><span class="line">    test.__bar()</span><br><span class="line">    <span class="comment"># AttributeError: &#x27;Test&#x27; object has no attribute &#x27;__foo&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(test.__foo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, foo</span>):</span><br><span class="line">        self.__foo = foo</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.__foo)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    test = Test(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    test._Test__bar()</span><br><span class="line">    <span class="built_in">print</span>(test._Test__foo)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="property装饰器"><a href="#property装饰器" class="headerlink" title="@property装饰器"></a>@property装饰器</h3><p>使用<code>@property</code>包装器来包装getter和setter方法，使得对属性的访问既安全又方便</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问器 - getter方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问器 - getter方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改器 - setter方法</span></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self, age</span>):</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self._age &lt;= <span class="number">16</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s正在玩飞行棋.&#x27;</span> % self._name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s正在玩斗地主.&#x27;</span> % self._name)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    person = Person(<span class="string">&#x27;王大锤&#x27;</span>, <span class="number">12</span>)</span><br><span class="line">    person.play()</span><br><span class="line">    person.age = <span class="number">22</span></span><br><span class="line">    person.play()</span><br><span class="line">    <span class="comment"># person.name = &#x27;白元芳&#x27;  # AttributeError: can&#x27;t set attribute</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h3><p>Python是一门动态语言,动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。</p><p>限定自定义类型的对象只能绑定某些属性，可以通过在类中定义<code>__slots__</code>变量来进行限定。需要注意的是<code>__slots__</code>的限定只对当前类的对象生效，对子类并不起任何作用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 限定Person对象只能绑定_name, _age和_gender属性</span></span><br><span class="line">    __slots__ = (<span class="string">&#x27;_name&#x27;</span>, <span class="string">&#x27;_age&#x27;</span>, <span class="string">&#x27;_gender&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self, age</span>):</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self._age &lt;= <span class="number">16</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s正在玩飞行棋.&#x27;</span> % self._name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s正在玩斗地主.&#x27;</span> % self._name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    person = Person(<span class="string">&#x27;王大锤&#x27;</span>, <span class="number">22</span>)</span><br><span class="line">    person.play()</span><br><span class="line">    person._gender = <span class="string">&#x27;男&#x27;</span></span><br><span class="line">    <span class="comment"># AttributeError: &#x27;Person&#x27; object has no attribute &#x27;_is_gay&#x27;</span></span><br><span class="line">    <span class="comment"># person._is_gay = True</span></span><br></pre></td></tr></table></figure><h3 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h3><p>@staticmethod 静态方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_valid</span>(<span class="params">a, b, c</span>):</span><br><span class="line">        <span class="keyword">return</span> a + b &gt; c <span class="keyword">and</span> b + c &gt; a <span class="keyword">and</span> a + c &gt; b</span><br></pre></td></tr></table></figure><p>类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">now</span>(<span class="params">cls</span>):</span><br><span class="line">        ctime = localtime(time())</span><br><span class="line">        <span class="keyword">return</span> cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)</span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过<code>abc</code>模块的<code>ABCMeta</code>元类和<code>abstractmethod</code>包装器来达到抽象类的效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span>(<span class="built_in">object</span>, metaclass=ABCMeta):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;宠物&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nickname</span>):</span><br><span class="line">        self._nickname = nickname</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_voice</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;发出声音&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Pet</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;狗&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_voice</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: 汪汪汪...&#x27;</span> % self._nickname)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Pet</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;猫&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_voice</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: 喵...喵...&#x27;</span> % self._nickname)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    pets = [Dog(<span class="string">&#x27;旺财&#x27;</span>), Cat(<span class="string">&#x27;凯蒂&#x27;</span>), Dog(<span class="string">&#x27;大黄&#x27;</span>)]</span><br><span class="line">    <span class="keyword">for</span> pet <span class="keyword">in</span> pets:</span><br><span class="line">        pet.make_voice()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="文件和异常"><a href="#文件和异常" class="headerlink" title="文件和异常"></a>文件和异常</h2><p>将那些在运行时可能会出现状况的代码放在<code>try</code>代码块中，在try代码块的后面可以跟上一个或多个<code>except</code>来捕获可能出现的异常状况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    f = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(<span class="string">&#x27;致橡树.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(f.read())</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;无法打开指定的文件!&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> LookupError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;指定了未知的编码!&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;读取文件时解码错误!&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> f:</span><br><span class="line">            f.close()</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="读写json文件"><a href="#读写json文件" class="headerlink" title="读写json文件"></a>读写json文件</h3><p>把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？答案是将数据以JSON格式进行保存，json应用于跨平台跨语言的数据交换，原因很简单，因为JSON也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的</p><p>json模块主要有四个比较重要的函数，分别是：</p><ul><li>dump - 将Python对象按照JSON格式序列化到文件中</li><li>dumps - 将Python对象处理成JSON格式的字符串</li><li>load - 将文件中的JSON数据反序列化成对象</li><li>loads - 将字符串的内容反序列化成Python对象</li></ul><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>Python既支持多进程又支持多线程</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>Unix和Linux操作系统上提供了fork()系统调用来创建进程，调用fork()函数的是父进程，创建出的是子进程</p><p>fork()函数非常特殊它会返回两次，父进程中可以通过fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0</p><p>由于Windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用<code>multiprocessing</code>模块的<code>Process</code>类来创建子进程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">rom multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getpid</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_task</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;启动下载进程，进程号[%d].&#x27;</span> % getpid())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始下载%s...&#x27;</span> % filename)</span><br><span class="line">    time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    sleep(time_to_download)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s下载完成! 耗费了%d秒&#x27;</span> % (filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    start = time()</span><br><span class="line">    p1 = Process(target=download_task, args=(<span class="string">&#x27;Python从入门到住院.pdf&#x27;</span>, ))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2 = Process(target=download_task, args=(<span class="string">&#x27;Peking Hot.avi&#x27;</span>, ))</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;总共耗费了%.2f秒.&#x27;</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><blockquote><p>也可以使用<code>subprocess</code>模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信</p></blockquote><h4 id="两个进程间的通信"><a href="#两个进程间的通信" class="headerlink" title="两个进程间的通信"></a>两个进程间的通信</h4><p>使用<code>multiprocessing</code>模块中的<code>Queue</code>类，它是可以被多个进程共享的队列，底层是通过管道和信号量（<code>semaphore</code>）机制来实现的</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>多线程开发推荐使用<code>threading</code>模块</p><blockquote><p>Python的多线程并不能发挥CPU的多核特性,之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题</p></blockquote><h3 id="多进程还是多线程"><a href="#多进程还是多线程" class="headerlink" title="多进程还是多线程"></a>多进程还是多线程</h3><p>是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I&#x2F;O密集型</p><p>计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，Python中有嵌入<code>C/C++</code>代码的机制。</p><p>网络、存储介质I&#x2F;O的任务都可以视为I&#x2F;O密集型任务,这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I&#x2F;O操作完成(因为I&#x2F;O的速度远远低于CPU和内存的速度),对于I&#x2F;O密集型任务，如果启动多任务，就可以减少I&#x2F;O等待时间从而让CPU高效率的运转</p><h3 id="单线程-异步I-x2F-O"><a href="#单线程-异步I-x2F-O" class="headerlink" title="单线程 + 异步I&#x2F;O"></a>单线程 + 异步I&#x2F;O</h3><p>现代操作系统对I&#x2F;O操作的改进中最为重要的就是支持异步I&#x2F;O。如果充分利用操作系统提供的异步I&#x2F;O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I&#x2F;O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下并发编程的一种流行方案。</p><p>在Python语言中，<code>单线程+异步I/O的编程模型称为协程</code>，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p><h3 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a>yield关键字</h3><p>一个带有 yield 的函数就是一个 generator，它和普通函数不同，生成一个 generator 看起来像函数调用，但不会执行任何函数代码，直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行</p><p>如何判断一个函数是否是一个特殊的 generator 函数？可以利用 isgeneratorfunction 判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> inspect <span class="keyword">import</span> isgeneratorfunction </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isgeneratorfunction(fab) </span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/jackfrued/Python-100-Days">Python入门到精通</a><br><a href="https://docs.python.org/zh-cn/3/tutorial/index.html">Python 教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 文件上传</title>
      <link href="/2022/09/01/Swift%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2022/09/01/Swift%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>之前在项目中实现Swift文件上传时踩了一个坑，后面复盘分析原因，需求讲解时未在现场，不知道传入文件的参数name由后端接口返回，另外就是第三方后端在接口联调时不配合，导致浪费不少时间定位问题。本来想用原生方法实现，因为后端的不配合，无法定位具体的参数问题，后改用Alamofire封装APi调用，调通后才发现是之前传参的name问题，之前原生实现部分也可正常运行.</p><p>开发者前后端都会很有必要，可以减少沟通成本</p><span id="more"></span><h3 id="上传参数"><a href="#上传参数" class="headerlink" title="上传参数"></a>上传参数</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data =</span><br><span class="line"> <span class="punctuation">&#123;</span></span><br><span class="line">        filePath = <span class="string">&quot;/var/mobile/Containers/Data/Application/23076D0F-D012-4655-9921-EA4DE65FDDDE/Documents/fileShare/\U4e2d\U53bf\U5e72\U90e8.pdf&quot;</span>;</span><br><span class="line">        formData =         <span class="punctuation">&#123;</span></span><br><span class="line">            fileName = <span class="string">&quot;\U4e2d\U53bf\U5e72\U90e8.pdf&quot;</span>;</span><br><span class="line">        <span class="punctuation">&#125;</span>;</span><br><span class="line">        header =         <span class="punctuation">&#123;</span></span><br><span class="line">            Authorization = <span class="string">&quot;bearer 806b3975-28a5-4bc8-8fd9-f32e63b10fe0&quot;</span>;</span><br><span class="line">            <span class="string">&quot;client_id&quot;</span> = webApp;</span><br><span class="line">            <span class="string">&quot;client_secret&quot;</span> = webApp;</span><br><span class="line">        <span class="punctuation">&#125;</span>;</span><br><span class="line">        name = file;</span><br><span class="line">        url = <span class="string">&quot;https://newapi.bantbox.cn/api-poi/print/uploadFiles&quot;</span>;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="方式一-Alamofire"><a href="#方式一-Alamofire" class="headerlink" title="方式一 Alamofire"></a>方式一 Alamofire</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *jsResult = (<span class="built_in">NSDictionary</span> *)data;</span><br><span class="line">[[VKDocumentShareManager shared] uploadFileAlamoreWithParam:jsResult</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">uploadFileAlamore</span>(<span class="params">param</span>: [<span class="params">String</span>: <span class="keyword">Any</span>], <span class="params">successHandle</span>:<span class="keyword">@escaping</span>((<span class="keyword">Any</span>) -&gt; <span class="type">Void</span>), <span class="params">FailHandler</span>:<span class="keyword">@escaping</span>((<span class="type">String</span>) -&gt; <span class="type">Void</span>)) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">guard</span> <span class="keyword">let</span> header <span class="operator">=</span> param[<span class="string">&quot;header&quot;</span>] <span class="keyword">as?</span> [<span class="type">String</span>: <span class="keyword">Any</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="type">FailHandler</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">guard</span> <span class="keyword">let</span> formData <span class="operator">=</span> param[<span class="string">&quot;formData&quot;</span>] <span class="keyword">as?</span>[<span class="type">String</span>: <span class="keyword">Any</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="type">FailHandler</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">let</span> urlString <span class="operator">=</span> param[<span class="string">&quot;url&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span>,</span><br><span class="line">          <span class="keyword">let</span> filePath <span class="operator">=</span>  param[<span class="string">&quot;filePath&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span>,</span><br><span class="line">          <span class="keyword">let</span> autho <span class="operator">=</span> header[<span class="string">&quot;Authorization&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span>,</span><br><span class="line">          <span class="keyword">let</span> client_id <span class="operator">=</span> header[<span class="string">&quot;client_id&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span>,</span><br><span class="line">          <span class="keyword">let</span> client_secret <span class="operator">=</span> header[<span class="string">&quot;client_secret&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span>,</span><br><span class="line">          <span class="keyword">let</span> fileName <span class="operator">=</span> formData[<span class="string">&quot;fileName&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span>,</span><br><span class="line">          <span class="keyword">let</span> paramName <span class="operator">=</span> param[<span class="string">&quot;name&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">let</span> httpHeaders <span class="operator">=</span> <span class="type">HTTPHeaders</span>([<span class="string">&quot;Authorization&quot;</span>: autho, <span class="string">&quot;client_id&quot;</span>: client_id, <span class="string">&quot;client_secret&quot;</span>: client_secret])</span><br><span class="line">           <span class="keyword">let</span> fileUrl <span class="operator">=</span> <span class="type">URL</span>.<span class="keyword">init</span>(fileURLWithPath: filePath)</span><br><span class="line">           <span class="type">Alamofire</span>.<span class="type">AF</span>.upload(multipartFormData: &#123; multiPart <span class="keyword">in</span></span><br><span class="line">               multiPart.append(fileUrl, withName: paramName, fileName: fileName, mimeType: <span class="string">&quot;application/octet-stream&quot;</span>)</span><br><span class="line">               multiPart.append(fileName.data(using: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)<span class="operator">!</span>, withName: <span class="string">&quot;fileName&quot;</span>)</span><br><span class="line">           &#125;, to: urlString, method: .post, headers: httpHeaders).uploadProgress(queue: .main) &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">           &#125;.responseData &#123; response <span class="keyword">in</span></span><br><span class="line">               <span class="keyword">switch</span> response.result &#123;</span><br><span class="line">               <span class="keyword">case</span> .success(<span class="keyword">let</span> data):</span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       <span class="keyword">let</span> asJSON <span class="operator">=</span> <span class="keyword">try</span> <span class="type">JSONSerialization</span>.jsonObject(with: data)</span><br><span class="line">                       successHandle(asJSON)</span><br><span class="line">                   &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                       <span class="type">FailHandler</span>(error.localizedDescription)</span><br><span class="line">                   &#125;</span><br><span class="line">               <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">                   <span class="type">FailHandler</span>(error.localizedDescription)</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="方式二-原生"><a href="#方式二-原生" class="headerlink" title="方式二 原生"></a>方式二 原生</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *jsResult = (<span class="built_in">NSDictionary</span> *)data;</span><br><span class="line"> [[VKDocumentShareManager shared] startUploadWithParam:jsResult];</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">startUpload</span>(<span class="params">param</span>: [<span class="params">String</span>: <span class="keyword">Any</span>]) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">guard</span> <span class="keyword">let</span> header <span class="operator">=</span> param[<span class="string">&quot;header&quot;</span>] <span class="keyword">as?</span> [<span class="type">String</span>: <span class="keyword">Any</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">guard</span> <span class="keyword">let</span> formData <span class="operator">=</span> param[<span class="string">&quot;formData&quot;</span>] <span class="keyword">as?</span>[<span class="type">String</span>: <span class="keyword">Any</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> <span class="keyword">let</span> urlString <span class="operator">=</span> param[<span class="string">&quot;url&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span>,</span><br><span class="line">            <span class="keyword">let</span> filePath <span class="operator">=</span>  param[<span class="string">&quot;filePath&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span>,</span><br><span class="line">            <span class="keyword">let</span> autho <span class="operator">=</span> header[<span class="string">&quot;Authorization&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span>,</span><br><span class="line">            <span class="keyword">let</span> client_id <span class="operator">=</span> header[<span class="string">&quot;client_id&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span>,</span><br><span class="line">            <span class="keyword">let</span> client_secret <span class="operator">=</span> header[<span class="string">&quot;client_secret&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span>,</span><br><span class="line">            <span class="keyword">let</span> fileName <span class="operator">=</span> formData[<span class="string">&quot;fileName&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span>,</span><br><span class="line">            <span class="keyword">let</span> paramName <span class="operator">=</span> param[<span class="string">&quot;name&quot;</span>] <span class="keyword">as?</span> <span class="type">String</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> fileUrl <span class="operator">=</span> <span class="type">URL</span>.<span class="keyword">init</span>(fileURLWithPath: filePath)</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 分隔线</span></span><br><span class="line">           <span class="keyword">let</span> boundary <span class="operator">=</span> <span class="string">&quot;Boundary-<span class="subst">\(UUID().uuidString)</span>&quot;</span></span><br><span class="line">           <span class="comment">// 传递的参数</span></span><br><span class="line">           <span class="keyword">let</span> parameters <span class="operator">=</span> [</span><br><span class="line">               <span class="string">&quot;fileName&quot;</span>: fileName</span><br><span class="line">           ]</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 传递的文件</span></span><br><span class="line">           <span class="keyword">let</span> files <span class="operator">=</span> [</span><br><span class="line">               (</span><br><span class="line">                   name: paramName,</span><br><span class="line">                   path: fileUrl.path</span><br><span class="line">               )</span><br><span class="line">           ]</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 上传地址</span></span><br><span class="line">           <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: urlString)<span class="operator">!</span></span><br><span class="line">           <span class="keyword">var</span> request <span class="operator">=</span> <span class="type">URLRequest</span>(url: url)</span><br><span class="line">           <span class="comment">// 请求类型为POST</span></span><br><span class="line">           request.httpMethod <span class="operator">=</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">           request.setValue(<span class="string">&quot;multipart/form-data; boundary=<span class="subst">\(boundary)</span>&quot;</span>,</span><br><span class="line">               forHTTPHeaderField: <span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line"></span><br><span class="line">             request.setValue(autho, forHTTPHeaderField: <span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line">             request.setValue(client_id, forHTTPHeaderField: <span class="string">&quot;client_id&quot;</span>)</span><br><span class="line">             request.setValue(client_secret, forHTTPHeaderField: <span class="string">&quot;client_secret&quot;</span>)</span><br><span class="line">           <span class="comment">// 创建表单body</span></span><br><span class="line">           request.httpBody <span class="operator">=</span> <span class="keyword">try?</span> createBody(with: parameters, files: files, boundary: boundary)</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 创建一个表单上传任务</span></span><br><span class="line">           <span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>.shared</span><br><span class="line">           <span class="keyword">let</span> uploadTask <span class="operator">=</span> session.dataTask(with: request, completionHandler: &#123;</span><br><span class="line">               (data, <span class="keyword">_</span>, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">               <span class="comment">// 上传完毕后</span></span><br><span class="line">               <span class="keyword">if</span> error <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                   <span class="built_in">print</span>(error<span class="operator">!</span>)</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">let</span> str <span class="operator">=</span> <span class="type">String</span>(data: data<span class="operator">!</span>, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</span><br><span class="line">                   <span class="built_in">print</span>(<span class="string">&quot;--- 上传完毕 ---<span class="subst">\(str<span class="operator">!</span>)</span>&quot;</span>)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;)</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 使用resume方法启动任务</span></span><br><span class="line">           uploadTask.resume()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建表单body</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">createBody</span>(<span class="params">with</span> <span class="params">parameters</span>: [<span class="params">String</span>: <span class="type">String</span>]<span class="operator">?</span>,</span><br><span class="line">                               <span class="params">files</span>: [(name: <span class="type">String</span>, path: <span class="type">String</span>)],</span><br><span class="line">                               <span class="params">boundary</span>: <span class="type">String</span>) <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">           <span class="keyword">var</span> body <span class="operator">=</span> <span class="type">Data</span>()</span><br><span class="line">           <span class="comment">// 添加普通参数数据</span></span><br><span class="line">           <span class="keyword">if</span> parameters <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (key, value) <span class="keyword">in</span> parameters<span class="operator">!</span> &#123;</span><br><span class="line">                   <span class="comment">// 数据之前要用 --分隔线 来隔开 ，否则后台会解析失败</span></span><br><span class="line">                   body.append(<span class="string">&quot;--<span class="subst">\(boundary)</span><span class="subst">\r</span><span class="subst">\n</span>&quot;</span>)</span><br><span class="line">                   body.append(<span class="string">&quot;Content-Disposition: form-data; name=<span class="subst">\&quot;</span><span class="subst">\(key)</span><span class="subst">\&quot;</span><span class="subst">\r</span><span class="subst">\n</span><span class="subst">\r</span><span class="subst">\n</span>&quot;</span>)</span><br><span class="line">                   body.append(<span class="string">&quot;<span class="subst">\(value)</span><span class="subst">\r</span><span class="subst">\n</span>&quot;</span>)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 添加文件数据</span></span><br><span class="line">           <span class="keyword">for</span> file <span class="keyword">in</span> files &#123;</span><br><span class="line">               <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(fileURLWithPath: file.path)</span><br><span class="line">               <span class="keyword">let</span> filename <span class="operator">=</span> url.lastPathComponent</span><br><span class="line">               <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try</span> <span class="type">Data</span>(contentsOf: url)</span><br><span class="line">               <span class="keyword">let</span> mimetype <span class="operator">=</span> mimeType(pathExtension: url.pathExtension)</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 数据之前要用 --分隔线 来隔开 ，否则后台会解析失败</span></span><br><span class="line">               body.append(<span class="string">&quot;--<span class="subst">\(boundary)</span><span class="subst">\r</span><span class="subst">\n</span>&quot;</span>)</span><br><span class="line">               body.append(<span class="string">&quot;Content-Disposition: form-data; &quot;</span></span><br><span class="line">                   <span class="operator">+</span> <span class="string">&quot;name=<span class="subst">\&quot;</span><span class="subst">\(file.name)</span><span class="subst">\&quot;</span>; filename=<span class="subst">\&quot;</span><span class="subst">\(filename)</span><span class="subst">\&quot;</span><span class="subst">\r</span><span class="subst">\n</span>&quot;</span>)</span><br><span class="line">               body.append(<span class="string">&quot;Content-Type: <span class="subst">\(mimetype)</span><span class="subst">\r</span><span class="subst">\n</span><span class="subst">\r</span><span class="subst">\n</span>&quot;</span>) <span class="comment">// 文件类型</span></span><br><span class="line">               body.append(data) <span class="comment">// 文件主体</span></span><br><span class="line">               body.append(<span class="string">&quot;<span class="subst">\r</span><span class="subst">\n</span>&quot;</span>) <span class="comment">// 使用\r\n来表示这个这个值的结束符</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// --分隔线-- 为整个表单的结束符</span></span><br><span class="line">           body.append(<span class="string">&quot;--<span class="subst">\(boundary)</span>--<span class="subst">\r</span><span class="subst">\n</span>&quot;</span>)</span><br><span class="line">           <span class="keyword">return</span> body</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 根据后缀获取对应的Mime-Type</span></span><br><span class="line">       <span class="keyword">func</span> <span class="title function_">mimeType</span>(<span class="params">pathExtension</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> <span class="keyword">let</span> uti <span class="operator">=</span> <span class="type">UTTypeCreatePreferredIdentifierForTag</span>(kUTTagClassFilenameExtension,</span><br><span class="line">                                                              pathExtension <span class="keyword">as</span> <span class="type">NSString</span>,</span><br><span class="line">                                                              <span class="literal">nil</span>)<span class="operator">?</span>.takeRetainedValue() &#123;</span><br><span class="line">               <span class="keyword">if</span> <span class="keyword">let</span> mimetype <span class="operator">=</span> <span class="type">UTTypeCopyPreferredTagWithClass</span>(uti, kUTTagClassMIMEType)<span class="operator">?</span></span><br><span class="line">                   .takeRetainedValue() &#123;</span><br><span class="line">                   <span class="keyword">return</span> mimetype <span class="keyword">as</span> <span class="type">String</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 文件资源类型如果不知道，传万能类型application/octet-stream，服务器会自动解析文件类</span></span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;application/octet-stream&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 扩展Data</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="comment">// 增加直接添加String数据的方法</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">string</span>: <span class="type">String</span>, <span class="params">using</span> <span class="params">encoding</span>: <span class="type">String</span>.<span class="type">Encoding</span> <span class="operator">=</span> .utf8) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> data <span class="operator">=</span> string.data(using: encoding) &#123;</span><br><span class="line">            append(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://123.57.164.21/?p=3496">使用原生方式同时上传多个文件和参数</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议无状态</title>
      <link href="/2022/08/15/HTTP%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81/"/>
      <url>/2022/08/15/HTTP%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>http是<strong>无状态</strong>(HTTP&#x2F;1.0)的协议，HTTP&#x2F;1.0之后呢？</p><span id="more"></span><h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><p>HTTP协议本身是不对请求和响应之间的通信状态保存的。那为什么要这样呢？其实这主要是为了更快地处理大量的请求，确保协议的可伸缩性，特意将协议设计的这么简单。</p><img src="/2022/08/15/HTTP%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81/http_no_state.png" class=""><p>那如果要保存状态该怎么办？HTTP&#x2F;1.1就提出了解决方案，虽然还是无状态的，但是引入了<code>Cookie</code>技术，相比大家上网的话都应该碰到过“询问退出是否清除Cookie”，就是这个东西。当有了cookie之后，就可以管理状态了。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>访问国外的一些标准网站的话，可能经常会弹出一个对话框，说是本网站为了更好的体验和跟踪，需要访问你的cookies，问你同意不同意</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">根据服务端发送来的响应报文中，有个set-Cookie的首部字段，通知客户端保存cookie。</span><br><span class="line">等到下次客户端需要访问服务端的时候，将保存的cookie发送出去。</span><br><span class="line"></span><br><span class="line">服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请</span><br><span class="line">求，然后对比服务器上的记录，最后得到之前的状态信息</span><br></pre></td></tr></table></figure><p>第一次请求：</p><img src="/2022/08/15/HTTP%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81/keepalive04.jpeg" class=""><p>第二次请求:</p><img src="/2022/08/15/HTTP%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81/keepalive05.jpeg" class=""><p>上面的图不有趣看下面的</p><img src="/2022/08/15/HTTP%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81/coocie01.png" class=""><img src="/2022/08/15/HTTP%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81/coocie02.png" class=""><p>HTTP 请求报文和响应报文的内 容如下</p><ol><li>请求报文(没有 Cookie 信息的状态)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /reader/ HTTP/1.1</span><br><span class="line">Host: hackr.jp *首部字段内没有Cookie的相关信息</span><br></pre></td></tr></table></figure><ol start="2"><li>响应报文(服务器端生成 Cookie 信息)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 12 Jul 2012 07:12:20 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">&lt;Set-Cookie: sid=1342077140226724; path=/; expires=Wed, 10-Oct-12 </span><br><span class="line">07:12:20 GMT&gt;</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br></pre></td></tr></table></figure><ol start="3"><li>请求报文(自动发送保存着的 Cookie 信息)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /image/ HTTP/1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Cookie: sid=1342077140226724</span><br></pre></td></tr></table></figure><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><code>Cookie</code> 是服务器发送到用户浏览器并保存在本地的一小块数据，浏览器之后向同一服务器再次发起请求时会携带上该<code>cookie</code>，用于告知服务端两个请求是否来自同一浏览器</p><p>由于之后每次请求都会需要携带 <code>Cookie</code> 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p><code>Cookie</code> 曾一度用于客户端数据的存储，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ol><h3 id="Cookie的创建过程"><a href="#Cookie的创建过程" class="headerlink" title="Cookie的创建过程"></a>Cookie的创建过程</h3><p>1.服务器将<code>cookie</code>通过响应报文中的 <code>Set-Cookie</code> 首部字段发送给客户，客户端得到响应报文后把 <code>Cookie</code> 内容保存到浏览器中</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>yummy_cookie=choco</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line"><span class="language-angelscript"><span class="string">[page content]</span></span></span><br></pre></td></tr></table></figure><p>2.客户端之后对同一个服务器发送请求时，会从浏览器中取出 <code>Cookie</code> 信息并通过 <code>Cookie</code> 首部字段发送给服务器。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/sample_page.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.org</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><h3 id="Cookie的分类"><a href="#Cookie的分类" class="headerlink" title="Cookie的分类"></a>Cookie的分类</h3><p>会话期 Cookie： 浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。<br>持久性 Cookie： 指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>id=abcdef; Expires=Thu, 31 May 2021 08:00:00 GMT;</span><br></pre></td></tr></table></figure><p>其中Expires是HTTP1.0中定义的header，Max-Age是HTTP1.1中定义的header。</p><h3 id="Cookie的权限控制"><a href="#Cookie的权限控制" class="headerlink" title="Cookie的权限控制"></a>Cookie的权限控制</h3><h4 id="Secure-和-HttpOnly"><a href="#Secure-和-HttpOnly" class="headerlink" title="Secure 和 HttpOnly"></a>Secure 和 HttpOnly</h4><p>HTTP提供了两个属性来对cookies的权限进行控制，分别是<code>Secure</code>和<code>HttpOnly</code>。</p><p>如果cookies中带有Secure属性，那么cookies只会在使用HTTPS协议的时候发送给服务器。如果使用的是HTTP协议，则不会发送cookies信息。</p><p>如果cookies设置了HttpOnly，那么cookies是不允许被JavaScript访问的，通过设置HttpOnly，我们可以提升客户端数据的安全性：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>id=abcdef; Expires=Thu, 21 May 2021 08:00:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><h4 id="Domain和-Path"><a href="#Domain和-Path" class="headerlink" title="Domain和 Path"></a>Domain和 Path</h4><p>cookies还可以添加Domain和Path属性，用于标记cookies可以发送到的URL。</p><p>其中Domain表示域名，而Path表示路径。</p><p>如果Domain没有设置，则默认是设置cookies的host，这个host是不包含子domain的。如果手动指定了Domain，那么子domain是会包含在内的。</p><p>比如如果我们设置了Domain&#x3D;flydean.com，那么子domain：doc.flydean.com也会共享这个cookies。</p><p>Path用来匹配URL的路径，只有匹配到的URL才可以发送cookies。</p><h4 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h4><p>SameSite属性，表示如果是在CORS环境情况下，是否发送cookies到第三方网站，这样可以在一定程度上保护网站的信息。</p><p>SameSite有三个可能的值，分别是Strict, Lax, 和 None</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>name=flydean; SameSite=Strict</span><br></pre></td></tr></table></figure><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><code>session</code> 是一个抽象概念，开发者为了实现中断和继续等操作，将 <code>user agent</code> 和 <code>server</code> 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 <code>session</code> 的概念</p><p> <code>Cookie</code> 是一个实际存在的东西，http 协议中定义在 header 中的字段。可以认为是 session 的一种后端无状态实现。</p><p><code>Session</code> 因为 <code>Session id </code>的存在，通常要借助 <code>cookie</code> 实现，但这并非必要，只能说是通用性较好的一种实现方案</p><ul><li><code>session</code>将用户信息存储在服务器端，这样信息会更加安全。</li><li><code>Session</code> 可以存储在服务器上的文件、数据库或者内存中。也可以将 <code>Session</code> 存储在 <code>Redis</code> 这种内存型数据库中，效率会更高。</li></ul><h3 id="Session维护用户登录状态的过程"><a href="#Session维护用户登录状态的过程" class="headerlink" title="Session维护用户登录状态的过程"></a>Session维护用户登录状态的过程</h3><ol><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中。</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 <code>Session ID</code>。</li><li>服务器返回的响应报文的 <code>Set-Cookie</code> 首部字段包含了这个 <code>Session ID</code>，客户端收到响应报文之后将该 <code>Cookie</code> 值存入浏览器中。</li><li>客户端之后对同一个服务器进行请求时会包含该 <code>Cookie</code> 值，服务器收到之后提取出 <code>Session ID</code>，从 <code>Redis</code> 中取出用户信息，继续之前的业务操作。</li></ol><h3 id="使用session-ID要注意的问题："><a href="#使用session-ID要注意的问题：" class="headerlink" title="使用session ID要注意的问题："></a>使用session ID要注意的问题：</h3><ol><li>为了不让 Session ID 被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。</li><li>需要经常重新生成 Session ID。</li><li>在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</li></ol><blockquote><p>大多数的应用都是用 Cookie 来实现Session跟踪的 </p></blockquote><h2 id="Cookie-与-Session-选择"><a href="#Cookie-与-Session-选择" class="headerlink" title="Cookie 与 Session 选择"></a>Cookie 与 Session 选择</h2><p>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session。<br>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密。<br>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的。因此，不建议将所有的用户信息都存储到 Session 中。</p><h3 id="如果浏览器禁用cookie，怎么办？"><a href="#如果浏览器禁用cookie，怎么办？" class="headerlink" title="如果浏览器禁用cookie，怎么办？"></a>如果浏览器禁用cookie，怎么办？</h3><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。<br>除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术来进行会话跟踪，将 Session ID 作为 URL 的参数进行传递。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="https://blog.csdn.net/u014454538/article/details/96629309">计算机网之应用层</a><br>2.<a href="https://cloud.tencent.com/developer/article/1882218">HTTP系列之:HTTP中的cookies</a><br>3.<a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Cookies">HTTP cookies</a><br>4.<a href="https://www.zhihu.com/question/19786827">COOKIE和SESSION有什么区别？</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> Cookie </tag>
            
            <tag> Session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【读书笔记】Swift教程</title>
      <link href="/2022/05/20/Swift%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/05/20/Swift%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>随着第三代语言规范的崛起，Apple推出了Swift，以后也是大力支持的官方语言，作为iOS开发者，学习Swift是大势所趋，Swift相比于Obj-C，更简洁，语言自带支持的面相协议编程也是解耦的最佳实现。</p><span id="more"></span><h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><p>当你声明常量或者变量的时候可以加上类型注解（type annotation），说明常量或者变量中要存储的值的类型。如果要添加类型注解，需要<strong>在常量或者变量名后面加上一个冒号和空格</strong>，然后加上类型名称。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcomeMessage: <span class="type">String</span></span><br></pre></td></tr></table></figure><p>可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型注解：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> red, green, blue: <span class="type">Double</span></span><br></pre></td></tr></table></figure><h3 id="数值型字面量"><a href="#数值型字面量" class="headerlink" title="数值型字面量"></a>数值型字面量</h3><p>一个二进制数，前缀是 <code>0b</code><br>一个八进制数，前缀是 <code>0o</code><br>一个十六进制数，前缀是 <code>0x</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decimalInteger <span class="operator">=</span> <span class="number">17</span></span><br><span class="line"><span class="keyword">let</span> binaryInteger <span class="operator">=</span> <span class="number">0b10001</span>       <span class="comment">// 二进制的17</span></span><br><span class="line"><span class="keyword">let</span> octalInteger <span class="operator">=</span> <span class="number">0o21</span>           <span class="comment">// 八进制的17</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalInteger <span class="operator">=</span> <span class="number">0x11</span>     <span class="comment">// 十六进制的17</span></span><br></pre></td></tr></table></figure><h3 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h3><p><code>nil</code> 不能用于非可选的常量和变量</p><p>声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 <code>nil</code></p><blockquote><p>注意</p></blockquote><blockquote><p>Swift 的 <code>nil</code> 和 Objective-C 中的 <code>nil</code> 并不一样。在 Objective-C 中，<code>nil</code> 是一个指向不存在对象的指针。在 Swift 中，<code>nil</code> 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 <code>nil</code>，不只是对象类型</p></blockquote><h3 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h3><p>使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> constantName <span class="operator">=</span> someOptional &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以包含多个可选绑定或多个布尔条件在一个 <code>if</code> 语句中，只要使用<code>逗号</code>分开就行。只要有<strong>任意一个</strong>可选绑定的值为 <code>nil</code>，或者任意一个布尔条件为 <code>false</code>，则整个 <code>if</code> 条件判断为 <code>false</code>。下面的两个 if 语句是等价的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>), <span class="keyword">let</span> secondNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>), firstNumber <span class="operator">&lt;</span> secondNumber <span class="operator">&amp;&amp;</span> secondNumber <span class="operator">&lt;</span> <span class="number">100</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span> &lt; 100&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“4 &lt; 42 &lt; 100”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> secondNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> firstNumber <span class="operator">&lt;</span> secondNumber <span class="operator">&amp;&amp;</span> secondNumber <span class="operator">&lt;</span> <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span> &lt; 100&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“4 &lt; 42 &lt; 100”</span></span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><blockquote><p>在 <code>if</code> 条件语句中使用常量和变量来创建一个可选绑定，仅在 <code>if</code> 语句的<strong>句中</strong>（body）中才能获取到值。相反，在 <code>guard</code> 语句中使用常量和变量来创建一个可选绑定，仅在 <code>guard</code> 语句外且在<strong>语句后</strong>才能获取到值</p></blockquote><h2 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h2><p>把值转换成字符串的方法：把值写到括号中，并且在括号之前写一个反斜杠<code>（\）</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apples <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> oranges <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> appleSummary <span class="operator">=</span> <span class="string">&quot;I have <span class="subst">\(apples)</span> apples.&quot;</span></span><br></pre></td></tr></table></figure><p>使用三个双引号（<code>&quot;&quot;&quot;</code>）来包含多行字符串内容。每行行首的缩进会被去除，只要和结尾引号的缩进相匹配。举个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quotation <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">I said &quot;I have <span class="subst">\(apples)</span> apples.&quot;</span></span><br><span class="line"><span class="string">And then I said &quot;I have <span class="subst">\(apples <span class="operator">+</span> oranges)</span> pieces of fruit.&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>使用方括号 [] 来创建数组和字典，并使用下标或者键（key）来访问元素。最后一个元素后面允许有个逗号。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList <span class="operator">=</span> [<span class="string">&quot;catfish&quot;</span>, <span class="string">&quot;water&quot;</span>, <span class="string">&quot;tulips&quot;</span>, <span class="string">&quot;blue paint&quot;</span>]</span><br><span class="line">shoppingList[<span class="number">1</span>] <span class="operator">=</span> <span class="string">&quot;bottle of water&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> occupations <span class="operator">=</span> [</span><br><span class="line">    <span class="string">&quot;Malcolm&quot;</span>: <span class="string">&quot;Captain&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Kaylee&quot;</span>: <span class="string">&quot;Mechanic&quot;</span>,</span><br><span class="line">]</span><br><span class="line">occupations[<span class="string">&quot;Jayne&quot;</span>] <span class="operator">=</span> <span class="string">&quot;Public Relations&quot;</span></span><br></pre></td></tr></table></figure><p>使用初始化语法来创建一个空数组或者空字典</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyArray: [<span class="type">String</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">let</span> emptyDictionary: [<span class="type">String</span>: <span class="type">Float</span>] <span class="operator">=</span> [:]</span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>使用 <code>if</code> 和 <code>switch</code> 来进行条件操作，使用 <code>for-in</code>、<code>while</code> 和 <code>repeat-while</code> 来进行循环。包裹条件和循环变量的括号可以省略，但是语句体的大括号是必须的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> individualScores <span class="operator">=</span> [<span class="number">75</span>, <span class="number">43</span>, <span class="number">103</span>, <span class="number">87</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">var</span> teamScore <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> score <span class="keyword">in</span> individualScores &#123;</span><br><span class="line">    <span class="keyword">if</span> score <span class="operator">&gt;</span> <span class="number">50</span> &#123;</span><br><span class="line">        teamScore <span class="operator">+=</span> <span class="number">3</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        teamScore <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(teamScore)</span><br></pre></td></tr></table></figure><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>在 <code>if</code> 语句中，条件必须是一个布尔表达式——这意味着像<code>if score &#123; ... &#125;</code>这样的代码将报错，而不会隐形地与 0 做对比。</p><p>可以一起使用 <code>if </code>和<code> let</code> 一起来处理值缺失的情况。这些值可由可选值来代表。一个可选的值是一个具体的值或者是 <code>nil</code> 以表示值缺失。在类型后面加一个问号（<code>?</code>）来标记这个变量的值是可选的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalString: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(optionalString <span class="operator">==</span> <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> optionalName: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;John Appleseed&quot;</span></span><br><span class="line"><span class="keyword">var</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello!&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name <span class="operator">=</span> optionalName &#123;</span><br><span class="line">    greeting <span class="operator">=</span> <span class="string">&quot;Hello, <span class="subst">\(name)</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提前退出"><a href="#提前退出" class="headerlink" title="提前退出"></a>提前退出</h4><p>使用 <code>guard</code> 语句来要求条件必须为真时，以执行 <code>guard</code> 语句后的代码,一个 <code>guard</code> 语句总是有一个 <code>else</code> 从句，如果条件不为真则执行 <code>else</code> 从句中的代码</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: [<span class="params">String</span>: <span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name <span class="operator">=</span> person[<span class="string">&quot;name&quot;</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello <span class="subst">\(name)</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> location <span class="operator">=</span> person[<span class="string">&quot;location&quot;</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I hope the weather is nice near you.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I hope the weather is nice in <span class="subst">\(location)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(person: [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>])</span><br><span class="line"><span class="comment">// 输出“Hello John!”</span></span><br><span class="line"><span class="comment">// 输出“I hope the weather is nice near you.”</span></span><br><span class="line">greet(person: [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Jane&quot;</span>, <span class="string">&quot;location&quot;</span>: <span class="string">&quot;Cupertino&quot;</span>])</span><br><span class="line"><span class="comment">// 输出“Hello Jane!”</span></span><br><span class="line"><span class="comment">// 输出“I hope the weather is nice in Cupertino.”</span></span><br></pre></td></tr></table></figure><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p><code>switch</code> 支持任意类型的数据以及各种比较操作——不仅仅是整数以及测试相等</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vegetable <span class="operator">=</span> <span class="string">&quot;red pepper&quot;</span></span><br><span class="line"><span class="keyword">switch</span> vegetable &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;celery&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Add some raisins and make ants on a log.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;cucumber&quot;</span>, <span class="string">&quot;watercress&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;That would make a good tea sandwich.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x.hasSuffix(<span class="string">&quot;pepper&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Is it a spicy <span class="subst">\(x)</span>?&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Everything tastes good in soup.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>switch</code> 中匹配到的 <code>case</code> 语句之后，程序会退出 <code>switch</code> 语句，并不会继续向下运行，所以不需要在每个子句结尾写 <code>break</code></p><p>每一个 <code>case</code> 分支都必须包含至少一条语句。像下面这样书写代码是无效的，因为第一个 <code>case</code> 分支是空的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherCharacter: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> anotherCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;a&quot;</span>: <span class="comment">// 无效，这个分支下面没有语句</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The letter A&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not the letter A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码会报编译错误</span></span><br></pre></td></tr></table></figure><p>为了让单个 case 同时匹配 a 和 A，可以将这个两个值组合成一个复合匹配，并且用逗号分开：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherCharacter: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> anotherCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;a&quot;</span>, <span class="string">&quot;A&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The letter A&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not the letter A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“The letter A”</span></span><br></pre></td></tr></table></figure><p>case 分支的模式可以使用 where 语句来判断额外的条件</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yetAnotherPoint <span class="operator">=</span> (<span class="number">1</span>, <span class="operator">-</span><span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> yetAnotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x <span class="operator">==</span> y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == y&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x <span class="operator">==</span> <span class="operator">-</span>y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == -y&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is just some arbitrary point&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“(1, -1) is on the line x == -y”</span></span><br></pre></td></tr></table></figure><p>需要 C 风格的贯穿的特性，你可以在每个需要该特性的 case 分支中使用 fallthrough 关键字</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> integerToDescribe <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> description <span class="operator">=</span> <span class="string">&quot;The number <span class="subst">\(integerToDescribe)</span> is&quot;</span></span><br><span class="line"><span class="keyword">switch</span> integerToDescribe &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>:</span><br><span class="line">    description <span class="operator">+=</span> <span class="string">&quot; a prime number, and also&quot;</span></span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    description <span class="operator">+=</span> <span class="string">&quot; an integer.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(description)</span><br><span class="line"><span class="comment">// 输出“The number 5 is a prime number, and also an integer.”</span></span><br></pre></td></tr></table></figure><blockquote><p><code>fallthrough</code> 关键字不会检查它下一个将会落入执行的 case 中的匹配条件。<code>fallthrough</code> 简单地使代码继续连接到下一个 <code>case</code> 中的代码，这和 C 语言标准中的 <code>switch</code> 语句特性是一样的</p></blockquote><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>可以使用 <code>for-in</code> 来遍历字典，需要一对儿变量来表示每个键值对。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> interestingNumbers <span class="operator">=</span> [</span><br><span class="line">    <span class="string">&quot;Prime&quot;</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>],</span><br><span class="line">    <span class="string">&quot;Fibonacci&quot;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">    <span class="string">&quot;Square&quot;</span>: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> largest <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">_</span>, numbers) <span class="keyword">in</span> interestingNumbers &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="keyword">if</span> number <span class="operator">&gt;</span> largest &#123;</span><br><span class="line">            largest <span class="operator">=</span> number</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(largest)</span><br><span class="line"><span class="comment">// 输出 &quot;25&quot;</span></span><br></pre></td></tr></table></figure><p>每 5 分钟作为一个刻度。使用 <code>stride(from:to:by:)</code> 函数跳过不需要的标记</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> minutes <span class="operator">=</span> <span class="number">60</span></span><br><span class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>minutes &#123;</span><br><span class="line">    <span class="comment">// 每一分钟都渲染一个刻度线（60次）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> minuteInterval <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0</span>, to: minutes, by: minuteInterval) &#123;</span><br><span class="line">    <span class="comment">// 每5分钟渲染一个刻度线（0, 5, 10, 15 ... 45, 50, 55）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>while</code> 来重复运行一段代码直到条件改变。循环条件也可以在结尾，保证能至少循环一次</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> n <span class="operator">&lt;</span> <span class="number">100</span> &#123;</span><br><span class="line">    n <span class="operator">*=</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    m <span class="operator">*=</span> <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">while</span> m <span class="operator">&lt;</span> <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure><p>可以在循环中使用 <code>..&lt; </code>来表示下标范围</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">4</span> &#123;</span><br><span class="line">    total <span class="operator">+=</span> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(total)</span><br></pre></td></tr></table></figure><p>使用 <code>..&lt; </code>创建的范围不包含上界，如果想包含的话需要使用 <code>...</code></p><h2 id="函数和闭包"><a href="#函数和闭包" class="headerlink" title="函数和闭包"></a>函数和闭包</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>使用 <code>func</code> 来声明一个函数，使用名字和参数来调用函数。使用 <code>-&gt; </code>来指定函数返回值的类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: <span class="type">String</span>, <span class="params">day</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello <span class="subst">\(person)</span>, today is <span class="subst">\(day)</span>.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">greet(person:<span class="string">&quot;Bob&quot;</span>, day: <span class="string">&quot;Tuesday&quot;</span>)</span><br></pre></td></tr></table></figure><p>默认情况下，函数使用它们的参数名称作为它们参数的标签，在参数名称前可以自定义参数标签，或者使用<code>_</code>表示不使用参数标签</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="keyword">_</span> <span class="params">person</span>: <span class="type">String</span>, <span class="params">on</span> <span class="params">day</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello <span class="subst">\(person)</span>, today is <span class="subst">\(day)</span>.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">greet(<span class="string">&quot;John&quot;</span>, on: <span class="string">&quot;Wednesday&quot;</span>)</span><br></pre></td></tr></table></figure><p>使用元组来生成复合值，比如让一个函数返回多个值。该元组的元素可以用名称或数字来获取</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">calculateStatistics</span>(<span class="params">scores</span>: [<span class="type">Int</span>]) -&gt; (min: <span class="type">Int</span>, max: <span class="type">Int</span>, sum: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> min <span class="operator">=</span> scores[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> max <span class="operator">=</span> scores[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> sum <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> score <span class="keyword">in</span> scores &#123;</span><br><span class="line">        <span class="keyword">if</span> score <span class="operator">&gt;</span> max &#123;</span><br><span class="line">            max <span class="operator">=</span> score</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> score <span class="operator">&lt;</span> min &#123;</span><br><span class="line">            min <span class="operator">=</span> score</span><br><span class="line">        &#125;</span><br><span class="line">        sum <span class="operator">+=</span> score</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (min, max, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> statistics <span class="operator">=</span> calculateStatistics(scores:[<span class="number">5</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(statistics.sum)</span><br><span class="line"><span class="built_in">print</span>(statistics.<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="隐式返回的函数"><a href="#隐式返回的函数" class="headerlink" title="隐式返回的函数"></a>隐式返回的函数</h4><p>如果一个函数的整个函数体是一个单行表达式，这个函数可以隐式地返回这个表达式。举个例子，以下的函数有着同样的作用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greeting</span>(<span class="params">for</span> <span class="params">person</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="string">&quot;Hello, &quot;</span> <span class="operator">+</span> person <span class="operator">+</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greeting(for: <span class="string">&quot;Dave&quot;</span>))</span><br><span class="line"><span class="comment">// 打印 &quot;Hello, Dave!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">anotherGreeting</span>(<span class="params">for</span> <span class="params">person</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> <span class="operator">+</span> person <span class="operator">+</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(anotherGreeting(for: <span class="string">&quot;Dave&quot;</span>))</span><br><span class="line"><span class="comment">// 打印 &quot;Hello, Dave!&quot;</span></span><br></pre></td></tr></table></figure><p>何一个可以被写成一行 <code>return</code> 语句的函数都可以忽略 <code>return</code>,一个属性的 <code>getter</code> 也可以使用隐式返回的形式</p><h4 id="参数标签和参数名称"><a href="#参数标签和参数名称" class="headerlink" title="参数标签和参数名称"></a>参数标签和参数名称</h4><p>每个函数参数都有一个参数标签（<code>argument label</code>）以及一个参数名称（<code>parameter name</code>）。参数标签在调用函数的时候使用；调用的时候需要将函数的参数标签写在对应的参数前面。参数名称在函数的实现中使用。默认情况下，函数参数使用参数名称来作为它们的参数标签</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: <span class="type">String</span>, <span class="params">from</span> <span class="params">hometown</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello <span class="subst">\(person)</span>!  Glad you could visit from <span class="subst">\(hometown)</span>.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greet(person: <span class="string">&quot;Bill&quot;</span>, from: <span class="string">&quot;Cupertino&quot;</span>))</span><br><span class="line"><span class="comment">// 打印“Hello Bill!  Glad you could visit from Cupertino.”</span></span><br></pre></td></tr></table></figure><p>参数标签的使用能够让一个函数在调用时更有表达力，更类似自然语言，并且仍保持了函数内部的可读性以及清晰的意图。</p><h4 id="忽略参数标签"><a href="#忽略参数标签" class="headerlink" title="忽略参数标签"></a>忽略参数标签</h4><p>不希望为某个参数添加一个标签，可以使用一个下划线（<code>_</code>）来代替一个明确的参数标签</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="keyword">_</span> <span class="params">firstParameterName</span>: <span class="type">Int</span>, <span class="params">secondParameterName</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">     <span class="comment">// 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(<span class="number">1</span>, secondParameterName: <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>如果一个参数有一个标签，那么在调用的时候必须使用标签来标记这个参数。</p><h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><p>可以在函数体中通过给参数赋值来为任意一个参数定义默认值（<code>Deafult Value</code>）。当默认值被定义后，调用这个函数时可以忽略这个参数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">parameterWithoutDefault</span>: <span class="type">Int</span>, <span class="params">parameterWithDefault</span>: <span class="type">Int</span> <span class="operator">=</span> <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果你在调用时候不传第二个参数，parameterWithDefault 会值为 12 传入到函数体中。</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(parameterWithoutDefault: <span class="number">3</span>, parameterWithDefault: <span class="number">6</span>) <span class="comment">// parameterWithDefault = 6</span></span><br><span class="line">someFunction(parameterWithoutDefault: <span class="number">4</span>) <span class="comment">// parameterWithDefault = 12</span></span><br></pre></td></tr></table></figure><blockquote><p>将不带有默认值的参数放在函数参数列表的最前。</p></blockquote><h4 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h4><p>函数参数默认是常量。如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数（In-Out Parameters），定义一个输入输出参数时，在参数定义前加 <code>inout</code> 关键字。</p><p>当传入的参数作为输入输出参数时，需要在参数名前加 <code>&amp;</code> 符，表示这个值可以被函数修改</p><blockquote><p>输入输出参数不能有默认值，而且可变参数不能用 inout 标记</p></blockquote><h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>在 Swift 中，使用函数类型就像使用其他类型一样。例如，你可以定义一个类型为函数的常量或变量，并将适当的函数赋值给它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mathFunction: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="operator">=</span> addTwoInts</span><br></pre></td></tr></table></figure><p>”定义一个叫做 <code>mathFunction</code> 的变量，类型是‘一个有两个 Int 型的参数并返回一个 Int 型的值的函数’，并让这个新变量指向 <code>addTwoInts</code> 函数”。</p><h4 id="函数类型作为参数类型"><a href="#函数类型作为参数类型" class="headerlink" title="函数类型作为参数类型"></a>函数类型作为参数类型</h4><p>可以用<code>(Int, Int) -&gt; Int</code>这样的函数类型作为另一个函数的参数类型。这样你可以将函数的一部分实现留给函数的调用者来提供</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printMathResult</span>(<span class="keyword">_</span> <span class="params">mathFunction</span>: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">\(mathFunction(a, b))</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 打印“Result: 8”</span></span><br></pre></td></tr></table></figure><p><strong>函数可以嵌套,可以作为另一个函数的返回值,可以当做参数传入另一个函数</strong></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>函数实际上是一种特殊的闭包:它是一段能之后被调取的代码。闭包中的代码能访问闭包作用域中的变量和函数，即使闭包是在一个不同的作用域被执行的——你已经在嵌套函数的例子中看过了。你可以使用 <code>&#123;&#125; </code>来创建一个匿名闭包。使用 <code>in</code> 将参数和返回值类型的声明与闭包函数体进行分离。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers.map(&#123;</span><br><span class="line">    (number: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="number">3</span> <span class="operator">*</span> number</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果一个闭包的类型已知，比如作为一个代理的回调，你可以忽略参数，返回值，甚至两个都忽略。单个语句闭包会把它语句的值当做结果返回。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mappedNumbers <span class="operator">=</span> numbers.map(&#123; number <span class="keyword">in</span> <span class="number">3</span> <span class="operator">*</span> number &#125;)</span><br><span class="line"><span class="built_in">print</span>(mappedNumbers)</span><br></pre></td></tr></table></figure><p>可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。当一个闭包作为最后一个参数传给一个函数的时候，它可以直接跟在圆括号后面。当一个闭包是传给函数的唯一参数，你可以完全忽略圆括号</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sortedNumbers <span class="operator">=</span> numbers.sorted &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(sortedNumbers)</span><br></pre></td></tr></table></figure><h4 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h4><p>排序方法<br>使用 <code>sorted(by:)</code> 方法对一个 String 类型的数组进行字母逆序排序</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br></pre></td></tr></table></figure><p><code>sorted(by:)</code> 方法接受一个闭包，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值前面，排序闭包函数需要返回 <code>true</code>，反之返回 <code>false</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">backward</span>(<span class="keyword">_</span> <span class="params">s1</span>: <span class="type">String</span>, <span class="keyword">_</span> <span class="params">s2</span>: <span class="type">String</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reversedNames <span class="operator">=</span> names.sorted(by: backward)</span><br><span class="line"><span class="comment">// reversedNames 为 [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]</span></span><br></pre></td></tr></table></figure><p>闭包表达式语法<br>闭包表达式语法有如下的一般形式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; <span class="keyword">return</span> type <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包表达式参数 可以是<code>in-out</code> 参数，但不能设定默认值。如果你命名了可变参数，也可以使用此可变参数。元组也可以作为参数和返回值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>精简后</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125; )</span><br><span class="line"></span><br><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: <span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure><p>闭包的函数体部分由关键字 <code>in </code>引入。该关键字表示<strong>闭包的参数和返回值类型定义已经完成，闭包函数体即将开始</strong>。</p><h4 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h4><p>将一个很长的闭包表达式作为最后一个参数传递给函数，将这个闭包替换成为尾随闭包的形式很有用。尾随闭包是一个书写在函数圆括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，你不用写出它的参数标签：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionThatTakesAClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是不使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure(closure: &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上节字符串排序闭包可以作为尾随包的形式改写在 <code>sorted(by:)</code> 方法圆括号的外面：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted() &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure><p>如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 <code>() </code>省略掉：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure><p>当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> digitNames <span class="operator">=</span> [</span><br><span class="line">    <span class="number">0</span>: <span class="string">&quot;Zero&quot;</span>, <span class="number">1</span>: <span class="string">&quot;One&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Two&quot;</span>,   <span class="number">3</span>: <span class="string">&quot;Three&quot;</span>, <span class="number">4</span>: <span class="string">&quot;Four&quot;</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">&quot;Five&quot;</span>, <span class="number">6</span>: <span class="string">&quot;Six&quot;</span>, <span class="number">7</span>: <span class="string">&quot;Seven&quot;</span>, <span class="number">8</span>: <span class="string">&quot;Eight&quot;</span>, <span class="number">9</span>: <span class="string">&quot;Nine&quot;</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> numbers <span class="operator">=</span> [<span class="number">16</span>, <span class="number">58</span>, <span class="number">510</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strings <span class="operator">=</span> numbers.map &#123;</span><br><span class="line">    (number) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">var</span> number <span class="operator">=</span> number</span><br><span class="line">    <span class="keyword">var</span> output <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">repeat</span> &#123;</span><br><span class="line">        output <span class="operator">=</span> digitNames[number <span class="operator">%</span> <span class="number">10</span>]<span class="operator">!</span> <span class="operator">+</span> output</span><br><span class="line">        number <span class="operator">/=</span> <span class="number">10</span></span><br><span class="line">    &#125; <span class="keyword">while</span> number <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// strings 常量被推断为字符串类型数组，即 [String]</span></span><br><span class="line"><span class="comment">// 其值为 [&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</span></span><br></pre></td></tr></table></figure><blockquote><p>函数和闭包都是引用类型</p></blockquote><h4 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h4><p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。在参数名之前标注 <code>@escaping</code>，用来指明这个闭包是允许“逃逸”出这个函数的</p><p>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多启动异步操作的函数接受一个闭包参数作为 completion handler。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionWithEscapingClosure</span>(<span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将一个闭包标记为 @escaping 意味着你必须在闭包中显式地引用 self,非逃逸闭包，这意味着它可以隐式引用 self</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionWithNonescapingClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">doSomething</span>() &#123;</span><br><span class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x <span class="operator">=</span> <span class="number">100</span> &#125;</span><br><span class="line">        someFunctionWithNonescapingClosure &#123; x <span class="operator">=</span> <span class="number">200</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance <span class="operator">=</span> <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// 打印出“200”</span></span><br><span class="line"></span><br><span class="line">completionHandlers.first<span class="operator">?</span>()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// 打印出“100”</span></span><br></pre></td></tr></table></figure><h4 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h4><p>自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式，这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包。</p><p>自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。延迟求值对于那些有副作用（Side Effect）和高计算成本的代码来说是很有益处的，因为它使得你能控制代码的执行时机。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// 打印出“5”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> customerProvider <span class="operator">=</span> &#123; customersInLine.remove(at: <span class="number">0</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// 打印出“5”</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line"><span class="comment">// 打印出“Now serving Chris!”</span></span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// 打印出“4”</span></span><br></pre></td></tr></table></figure><p>尽管在闭包的代码中，<code>customersInLine</code> 的第一个元素被移除了，不过在闭包被调用之前，这个元素是不会被移除的。如果这个闭包永远不被调用，那么在闭包里面的表达式将永远不会执行，那意味着列表中的元素永远不会被移除。请注意，<code>customerProvider</code> 的类型不是 <code>String</code>，而是 <code>() -&gt; String</code>，一个没有参数且返回值为 <code>String</code> 的函数。</p><p>将闭包作为参数传递给函数时，你能获得同样的延时求值行为。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">serve(customer: &#123; customersInLine.remove(at: <span class="number">0</span>) &#125; )</span><br><span class="line"><span class="comment">// 打印出“Now serving Alex!”</span></span><br></pre></td></tr></table></figure><p>上面的 <code>serve(customer:)</code> 函数接受一个返回顾客名字的显式的闭包。下面这个版本的 <code>serve(customer:)</code> 完成了相同的操作，不过它并没有接受一个显式的闭包，而是通过将参数标记为 <code>@autoclosure</code> 来接收一个自动闭包。现在你可以将该函数当作接受 String 类型参数（而非闭包）的函数来调用。customerProvider 参数将自动转化为一个闭包，因为该参数被标记了 <code>@autoclosure</code> 特性</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">serve(customer: customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"><span class="comment">// 打印“Now serving Ewa!”</span></span><br></pre></td></tr></table></figure><p>想让一个自动闭包可以“逃逸”，则应该同时使用 <code>@autoclosure</code> 和 <code>@escaping</code> 属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine i= [&quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">var</span> customerProviders: [() -&gt; <span class="type">String</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">collectCustomerProviders</span>(<span class="keyword">_</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span> <span class="keyword">@escaping</span> () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    customerProviders.append(customerProvider)</span><br><span class="line">&#125;</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Collected <span class="subst">\(customerProviders.count)</span> closures.&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“Collected 2 closures.”</span></span><br><span class="line"><span class="keyword">for</span> customerProvider <span class="keyword">in</span> customerProviders &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Now serving Barry!”</span></span><br><span class="line"><span class="comment">// 打印“Now serving Daniella!”</span></span><br></pre></td></tr></table></figure><h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><p>getter 和 setter 的计算属性</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EquilateralTriangle</span>: <span class="title class_">NamedShape</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">sideLength</span>: <span class="type">Double</span>, <span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sideLength <span class="operator">=</span> sideLength</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        numberOfSides <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> perimeter: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.0</span> <span class="operator">*</span> sideLength</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            sideLength <span class="operator">=</span> newValue <span class="operator">/</span> <span class="number">3.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">simpleDescription</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;An equilateral triangle with sides of length <span class="subst">\(sideLength)</span>.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> triangle <span class="operator">=</span> <span class="type">EquilateralTriangle</span>(sideLength: <span class="number">3.1</span>, name: <span class="string">&quot;a triangle&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(triangle.perimeter)</span><br><span class="line">triangle.perimeter <span class="operator">=</span> <span class="number">9.9</span></span><br><span class="line"><span class="built_in">print</span>(triangle.sideLength)</span><br></pre></td></tr></table></figure><p>如果你不需要计算属性，但是仍然需要在设置一个新值之前或者之后运行代码，使用 willSet 和 didSet。写入的代码会在属性值发生改变时调用，但不包含构造器中发生值改变的情况。比如，下面的类确保三角形的边长总是和正方形的边长相同</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TriangleAndSquare</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> triangle: <span class="type">EquilateralTriangle</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            square.sideLength <span class="operator">=</span> newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> square: <span class="type">Square</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            triangle.sideLength <span class="operator">=</span> newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">size</span>: <span class="type">Double</span>, <span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        square <span class="operator">=</span> <span class="type">Square</span>(sideLength: size, name: name)</span><br><span class="line">        triangle <span class="operator">=</span> <span class="type">EquilateralTriangle</span>(sideLength: size, name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> triangleAndSquare <span class="operator">=</span> <span class="type">TriangleAndSquare</span>(size: <span class="number">10</span>, name: <span class="string">&quot;another test shape&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.square.sideLength)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</span><br><span class="line">triangleAndSquare.square <span class="operator">=</span> <span class="type">Square</span>(sideLength: <span class="number">50</span>, name: <span class="string">&quot;larger square&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</span><br></pre></td></tr></table></figure><p>处理变量的可选值时，你可以在操作（比如方法、属性和子脚本）之前加 <code>?</code>。如果 <code>?</code> 之前的值是 <code>nil</code>，<code>? </code>后面的东西都会被忽略，并且整个表达式返回 <code>nil</code>。否则，可选值会被解包，之后的所有代码都会按照解包后的值运行。在这两种情况下，整个表达式的值也是一个可选值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> optionalSquare: <span class="type">Square</span>? <span class="operator">=</span> <span class="type">Square</span>(sideLength: <span class="number">2.5</span>, name: <span class="string">&quot;optional square&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> sideLength <span class="operator">=</span> optionalSquare<span class="operator">?</span>.sideLength</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法是与某些特定类型相关联的函数。类、结构体、枚举都可以定义实例方法；实例方法为给定类型的实例封装了具体的任务与功能。类、结构体、枚举也可以定义类型方法；类型方法与类型本身相关联。类型方法与 Objective-C 中的类方法（class methods）相似。</p><p>结构体和枚举是值类型，默认情况下，值类型的属性不能在它的实例方法中被修改。可以为这个方法选择可变<code>mutating</code>行为，然后就可以从其方法内部改变它的属性。并且这个方法做的任何改变都会在方法执行结束时写回到原始结构中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">moveBy</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Double</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        x <span class="operator">+=</span> deltaX</span><br><span class="line">        y <span class="operator">+=</span> deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> somePoint <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line">somePoint.moveBy(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The point is now at (<span class="subst">\(somePoint.x)</span>, <span class="subst">\(somePoint.y)</span>)&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“The point is now at (3.0, 4.0)”</span></span><br></pre></td></tr></table></figure><blockquote><p>不能在结构体类型的常量（a constant of structure type）上调用可变方法，因为其属性不能被改变，即使属性是变量属性</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fixedPoint <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">3.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line">fixedPoint.moveBy(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="comment">// 这里将会报告一个错误</span></span><br></pre></td></tr></table></figure><h3 id="在可变方法中给self赋值"><a href="#在可变方法中给self赋值" class="headerlink" title="在可变方法中给self赋值"></a>在可变方法中给self赋值</h3><p>可变方法能够赋给隐含属性 self 一个全新的实例。上面 Point 的例子可以用下面的方式改写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">moveBy</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Double</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> <span class="type">Point</span>(x: x <span class="operator">+</span> deltaX, y: y <span class="operator">+</span> deltaY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举的可变方法可以把 <code>self</code> 设置为同一枚举类型中不同的成员：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TriStateSwitch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> off, low, high</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">next</span>() &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .off:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .low</span><br><span class="line">        <span class="keyword">case</span> .low:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .high</span><br><span class="line">        <span class="keyword">case</span> .high:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ovenLight <span class="operator">=</span> <span class="type">TriStateSwitch</span>.low</span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight 现在等于 .high</span></span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight 现在等于 .off</span></span><br></pre></td></tr></table></figure><h3 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h3><p>定义在类型本身上调用的方法，这种方法就叫做类型方法。在方法的 <code>func</code> 关键字之前加上关键字 <code>static</code>，来指定类型方法。类还可以用关键字 <code>class</code> 来指定，从而允许子类重写父类该方法的实现。</p><blockquote><p>在 <code>Swift</code> 中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">func</span> <span class="title class_">someTypeMethod</span>() &#123;</span><br><span class="line">        <span class="comment">// 在这里实现类型方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SomeClass</span>.someTypeMethod()</span><br></pre></td></tr></table></figure><p>下面的例子定义了一个名为 <code>LevelTracker</code> 结构体。它监测玩家的游戏发展情况（游戏的不同层次或阶段）。这是一个单人游戏，但也可以存储多个玩家在同一设备上的游戏信息。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LevelTracker</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> highestUnlockedLevel <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> currentLevel <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">unlock</span>(<span class="keyword">_</span> <span class="params">level</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> level <span class="operator">&gt;</span> highestUnlockedLevel &#123; highestUnlockedLevel <span class="operator">=</span> level &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">isUnlocked</span>(<span class="keyword">_</span> <span class="params">level</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> level <span class="operator">&lt;=</span> highestUnlockedLevel</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">advance</span>(<span class="params">to</span> <span class="params">level</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">LevelTracker</span>.isUnlocked(level) &#123;</span><br><span class="line">            currentLevel <span class="operator">=</span> level</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>允许在调用 <code>advance(to:)</code> 时候忽略返回值，不会产生编译警告，所以函数被标注为 <code>@discardableResult</code> 属性</p><h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p>下标可以定义在类、结构体和枚举中，一个类型可以定义多个下标，通过不同索引类型进行对应的重载。</p><h3 id="下标语法"><a href="#下标语法" class="headerlink" title="下标语法"></a>下标语法</h3><p>下标允许你通过在实例名称后面的方括号中传入一个或者多个索引值来对实例进行查询。定义下标使用 <code>subscript</code> 关键字</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(<span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="comment">// 返回一个适当的 Int 类型的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">      <span class="comment">// 执行适当的赋值操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>newValue</code> 的类型和下标操作的返回类型相同</p><h3 id="下标用法"><a href="#下标用法" class="headerlink" title="下标用法"></a>下标用法</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numberOfLegs <span class="operator">=</span> [<span class="string">&quot;spider&quot;</span>: <span class="number">8</span>, <span class="string">&quot;ant&quot;</span>: <span class="number">6</span>, <span class="string">&quot;cat&quot;</span>: <span class="number">4</span>]</span><br><span class="line">numberOfLegs[<span class="string">&quot;bird&quot;</span>] <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>注意<br>Swift 的 Dictionary 类型的下标接受并返回可选类型的值。上例中的 numberOfLegs 字典通过下标返回的是一个 Int? 或者说“可选的 int”。Dictionary 类型之所以如此实现下标，是因为不是每个键都有对应的值，同时这也提供了一种通过键删除对应值的方式，只需将键对应的值赋值为 nil 即可</p></blockquote><p><strong>下标不能使用 in-out 参数,支持重载</strong><br>定义了一个 Matrix 结构体，用于表示一个 Double 类型的二维矩阵。Matrix 结构体的下标接受两个整型参数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> rows: <span class="type">Int</span>, columns: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> grid: [<span class="type">Double</span>]</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">rows</span>: <span class="type">Int</span>, <span class="params">columns</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.rows <span class="operator">=</span> rows</span><br><span class="line">        <span class="keyword">self</span>.columns <span class="operator">=</span> columns</span><br><span class="line">        grid <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="number">0.0</span>, count: rows <span class="operator">*</span> columns)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">indexIsValid</span>(<span class="params">row</span>: <span class="type">Int</span>, <span class="params">column</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> row <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> row <span class="operator">&lt;</span> rows <span class="operator">&amp;&amp;</span> column <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> column <span class="operator">&lt;</span> columns</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">row</span>: <span class="type">Int</span>, <span class="params">column</span>: <span class="type">Int</span>) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">assert</span>(indexIsValid(row: row, column: column), <span class="string">&quot;Index out of range&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> grid[(row <span class="operator">*</span> columns) <span class="operator">+</span> column]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="built_in">assert</span>(indexIsValid(row: row, column: column), <span class="string">&quot;Index out of range&quot;</span>)</span><br><span class="line">            grid[(row <span class="operator">*</span> columns) <span class="operator">+</span> column] <span class="operator">=</span> newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过传入合适的 row 和 column 数值来构造一个新的 Matrix 实例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matrix <span class="operator">=</span> <span class="type">Matrix</span>(rows: <span class="number">2</span>, columns: <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>将 row 和 column 的值传入下标来为矩阵设值，下标的入参使用逗号分隔：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix[<span class="number">0</span>, <span class="number">1</span>] <span class="operator">=</span> <span class="number">1.5</span></span><br><span class="line">matrix[<span class="number">1</span>, <span class="number">0</span>] <span class="operator">=</span> <span class="number">3.2</span></span><br></pre></td></tr></table></figure><p>断言在下标越界时触发：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue <span class="operator">=</span> matrix[<span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">// 断言将会触发，因为 [2, 2] 已经超过了 matrix 的范围</span></span><br></pre></td></tr></table></figure><h3 id="类型下标"><a href="#类型下标" class="headerlink" title="类型下标"></a>类型下标</h3><p>通过在 <code>subscript</code> 关键字之前写下 <code>static</code> 关键字的方式来表示一个类型下标。类类型可以使用 <code>class</code> 关键字来代替 static，它允许子类重写父类中对那个下标的实现。下面的例子展示了如何定义和调用一个类型下标：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Planet</span>: <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mercury <span class="operator">=</span> <span class="number">1</span>, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">subscript</span>(<span class="params">n</span>: <span class="type">Int</span>) -&gt; <span class="type">Planet</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Planet</span>(rawValue: n)<span class="operator">!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mars <span class="operator">=</span> <span class="type">Planet</span>[<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(mars)</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h3><p>可以将一个继承来的只读属性重写为一个读写属性，只需要在重写版本的属性里提供 <code>getter</code> 和 <code>setter</code> 即可。但是，你不可以将一个继承来的读写属性重写为一个只读属性</p><blockquote><p>如果你在重写属性中提供了 <code>setter</code>，那么你也一定要提供 <code>getter</code>。如果你不想在重写版本中的 <code>getter</code> 里修改继承来的属性值，你可以直接通过 <code>super.someProperty</code> 来返回继承来的值，其中 <code>someProperty</code> 是你要重写的属性的名字</p></blockquote><h3 id="重写属性观察器"><a href="#重写属性观察器" class="headerlink" title="重写属性观察器"></a>重写属性观察器</h3><p>可以通过重写属性为一个继承来的属性添加属性观察器</p><blockquote><p>不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供 <code>willSet</code> 或 <code>didSet</code> 实现也是不恰当。 此外还要注意，你不可以同时提供重写的 <code>setter</code> 和重写的属性观察器。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的 <code>setter</code>，那么你在 setter 中就可以观察到任何值变化了</p></blockquote><h2 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h2><p>构造过程是使用类、结构体或枚举类型的实例之前的准备过程。包括设置实例中每个存储属性的初始值和执行其他必须的设置或构造过程。Swift 的构造器没有返回值。它们的主要任务是保证某种类型的新实例在第一次使用前完成正确的初始化</p><p>构造器并不像函数和方法那样在括号前有一个可辨别的方法名。因此在调用构造器时，主要通过构造器中形参命名和类型来确定应该被调用的构造器。</p><h3 id="可选属性类型"><a href="#可选属性类型" class="headerlink" title="可选属性类型"></a>可选属性类型</h3><p>如果你自定义的类型有一个逻辑上允许值为空的存储型属性，无论是因为它无法在初始化时赋值，还是因为它在之后某个时机可以赋值为空——都需要将它声明为 可选类型。可选类型的属性将自动初始化为 <code>nil</code>，表示这个属性是特意在构造过程设置为空。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SurveyQuestion</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">text</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">ask</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cheeseQuestion <span class="operator">=</span> <span class="type">SurveyQuestion</span>(text: <span class="string">&quot;Do you like cheese?&quot;</span>)</span><br><span class="line">cheeseQuestion.ask()</span><br><span class="line"><span class="comment">// 打印“Do you like cheese?”</span></span><br><span class="line">cheeseQuestion.response <span class="operator">=</span> <span class="string">&quot;Yes, I do like cheese.&quot;</span></span><br></pre></td></tr></table></figure><p>调查问题的答案在询问前是无法确定的，因此我们将属性 <code>response</code> 声明为 <code>String?</code> 类型，或者说是 “可选类型 <code>String</code>“。当 <code>SurveyQuestion</code> 的实例初始化时，它将自动赋值为 <code>nil</code>，表明“暂时还没有字符“。</p><h3 id="构造过程中常量属性的赋值"><a href="#构造过程中常量属性的赋值" class="headerlink" title="构造过程中常量属性的赋值"></a>构造过程中常量属性的赋值</h3><p>可以在构造过程中的任意时间点给常量属性赋值，只要在构造过程结束时它设置成确定的值。一旦常量属性被赋值，它将永远不可更改。</p><blockquote><p>对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SurveyQuestion</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">text</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">ask</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> beetsQuestion <span class="operator">=</span> <span class="type">SurveyQuestion</span>(text: <span class="string">&quot;How about beets?&quot;</span>)</span><br><span class="line">beetsQuestion.ask()</span><br><span class="line"><span class="comment">// 打印“How about beets?”</span></span><br><span class="line">beetsQuestion.response <span class="operator">=</span> <span class="string">&quot;I also like beets. (But not with cheese.)&quot;</span></span><br></pre></td></tr></table></figure><h3 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h3><p>如果结构体或类为所有属性提供了默认值，又没有提供任何自定义的构造器，那么 <code>Swift</code> 会给这些结构体或类提供一个默认构造器。这个默认构造器将简单地创建一个所有属性值都设置为它们默认值的实例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShoppingListItem</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> quantity <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> purchased <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> item <span class="operator">=</span> <span class="type">ShoppingListItem</span>()</span><br></pre></td></tr></table></figure><p>由于 <code>ShoppingListItem</code> 类中的所有属性都有默认值，且它是没有父类的基类，它将自动获得一个将为所有属性设置默认值的并创建实例的默认构造器（由于 <code>name</code> 属性是可选 <code>String</code> 类型，它将接收一个默认 <code>nil</code> 的默认值，尽管代码中没有写出这个值）</p><h3 id="结构体的逐一成员构造器"><a href="#结构体的逐一成员构造器" class="headerlink" title="结构体的逐一成员构造器"></a>结构体的逐一成员构造器</h3><p>结构体如果没有定义任何自定义构造器，它们将自动获得一个逐一成员构造器（memberwise initializer）。不像默认构造器，即使存储型属性没有默认值，结构体也能会获得逐一成员构造器。</p><p>结构体 <code>Size</code> 自动获得了一个逐一成员构造器 <code>init(width:height:)</code>。你可以用它来创建新的 Size 实例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> twoByTwo <span class="operator">=</span> <span class="type">Size</span>(width: <span class="number">2.0</span>, height: <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>调用一个逐一成员构造器（memberwise initializer）时，可以省略任何一个有默认值的属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zeroByTwo <span class="operator">=</span> <span class="type">Size</span>(height: <span class="number">2.0</span>)</span><br><span class="line"><span class="built_in">print</span>(zeroByTwo.width, zeroByTwo.height)</span><br><span class="line"><span class="comment">// 打印 &quot;0.0 2.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> zeroByZero <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line"><span class="built_in">print</span>(zeroByZero.width, zeroByZero.height)</span><br><span class="line"><span class="comment">// 打印 &quot;0.0 0.0&quot;</span></span><br></pre></td></tr></table></figure><h3 id="值类型的构造器代理"><a href="#值类型的构造器代理" class="headerlink" title="值类型的构造器代理"></a>值类型的构造器代理</h3><p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理</p><p>值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给自己的其它构造器。类则不同，它可以继承自其它类。这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。</p><blockquote><p>如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）。这种限制避免了在一个更复杂的构造器中做了额外的重要设置，但有人不小心使用自动生成的构造器而导致错误的情况。</p></blockquote><blockquote><p>假如你希望默认构造器、逐一成员构造器以及你自己的自定义构造器都能用来创建实例，可以将自定义的构造器写到扩展（extension）中，而不是写在值类型的原始定义中。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">origin</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.origin <span class="operator">=</span> origin</span><br><span class="line">        <span class="keyword">self</span>.size <span class="operator">=</span> size</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">center</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX <span class="operator">=</span> center.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY <span class="operator">=</span> center.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的继承和构造过程"><a href="#类的继承和构造过程" class="headerlink" title="类的继承和构造过程"></a>类的继承和构造过程</h3><p>类里面的所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值。</p><p>Swift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们被称为<code>指定构造器</code>和<code>便利构造器</code>。</p><p>指定构造器是类中最主要的构造器，一个指定构造器将初始化类中提供的所有属性，并调用合适的父类构造器让构造过程沿着父类链继续网上进行。</p><blockquote><p>每一个类都必须至少拥有一个指定构造器</p></blockquote><p><strong>便利构造器</strong>是类中比较次要的，辅助型的构造器，你可以定义便利构造器来调用同一个类中的指定构造器，并为部分形参提供默认值。</p><h4 id="类类型的构造器代理"><a href="#类类型的构造器代理" class="headerlink" title="类类型的构造器代理"></a>类类型的构造器代理</h4><p>为了简化指定构造器和便利构造器之间的调用关系，Swift 构造器之间的代理调用遵循以下三条规则：</p><p>规则 1​</p><pre><code>指定构造器必须调用其直接父类的的指定构造器。</code></pre><p>规则 2​</p><pre><code>便利构造器必须调用同类中定义的其它构造器。</code></pre><p>规则 3​</p><pre><code>便利构造器最后必须调用指定构造器。</code></pre><p>一个更方便记忆的方法是：</p><p>指定构造器必须总是向上代理<br>便利构造器必须总是横向代理</p><img src="/2022/05/20/Swift%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/swift_init_1.png" class="&#x3D;"><p>下面图例中展示了一种涉及四个类的更复杂的类层级结构。它演示了指定构造器是如何在类层级中充当“漏斗”的作用，在类的构造器链上简化了类之间的相互关系。</p><img src="/2022/05/20/Swift%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/swift_init_2.png" class="&#x3D;"><h4 id="两段式构造过程"><a href="#两段式构造过程" class="headerlink" title="两段式构造过程"></a>两段式构造过程</h4><p><code>Swift</code> 中类的构造过程包含两个阶段。第一个阶段，类中的每个存储型属性赋一个初始值。当每个存储型属性的初始值被赋值后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步自定义它们的存储型属性。</p><blockquote><p><code>Swift</code> 的两段式构造过程跟 <code>Objective-C</code> 中的构造过程类似。最主要的区别在于阶段 1，<code>Objective-C</code> 给每一个属性赋值 0 或空值（比如说 0 或 nil）。<code>Swift</code> 的构造流程则更加灵活，它允许你设置定制的初始值，并自如应对某些属性不能以 <code>0</code> 或 <code>nil</code> 作为合法默认值的情况。</p></blockquote><h5 id="4种安全检查，以确保两段式构造过程"><a href="#4种安全检查，以确保两段式构造过程" class="headerlink" title="4种安全检查，以确保两段式构造过程"></a>4种安全检查，以确保两段式构造过程</h5><ol><li>指定构造器必须保证它所在类的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器</li></ol><blockquote><p>一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器必须保证它所在类的属性在它往上代理之前先完成初始化。</p></blockquote><p>2.指定构造器必须在为继承的属性设置新值之前向上代理调用父类构造器。否则，指定构造器赋予新值将被父类中的构造器所覆盖。</p><p>3.便利构造器必须为任意属性（包括所有同类中定义的）赋新值之前代理调用其它构造器。否则便利构造器赋予的新值将被该类指定构造器所覆盖</p><p>4.构造器在第一阶段完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能饮用<code>self</code>作为一个值。</p><blockquote><p>类的实例在第一阶段结束以前并不是完全有效的，只有第一阶段完成之后，类的实例才是有效的，才能访问属性和调用方法。</p></blockquote><h5 id="两段式构造过程展示："><a href="#两段式构造过程展示：" class="headerlink" title="两段式构造过程展示："></a>两段式构造过程展示：</h5><h6 id="阶段-1​"><a href="#阶段-1​" class="headerlink" title="阶段 1​"></a>阶段 1​</h6><ul><li>类的某个指定构造器或便利构造器被调用。</li><li>完成类的新实例内存的分配，但此时内存还没有被初始化。</li><li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</li><li>指定构造器切换到父类的构造器，对其存储属性完成相同的任务。</li><li>这个过程沿着类的继承链一直往上执行，直到到达继承链的最顶部。</li><li>当到达了继承链最顶部，而且继承链的最后一个类已确保所有的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。</li></ul><img src="/2022/05/20/Swift%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/switf_init_safe_1.png" class="&#x3D;"><h6 id="阶段-2​"><a href="#阶段-2​" class="headerlink" title="阶段 2​"></a>阶段 2​</h6><ul><li>从继承链顶部往下，继承链中每个类的指定构造器都有机会进一步自定义实例。构造器此时可以访问 <code>self</code>、修改它的属性并调用实例方法等等。</li><li>最终，继承链中任意的便利构造器有机会自定义实例和使用 <code>self</code>。</li></ul><img src="/2022/05/20/Swift%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/swift_init_safe_2.png" class="&#x3D;"><h4 id="构造器的继承和重写"><a href="#构造器的继承和重写" class="headerlink" title="构造器的继承和重写"></a>构造器的继承和重写</h4><p>跟 <code>Objective-C</code> 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器，这种机制可以防止一个父类的简单构造器被一个更精细的子类继承，而在用来创建子类时的新实例时没有完全或错误被初始化。</p><p>重写父类的指定构造器，必须在定义子类构造器时带上 <code>override</code> 修饰符。即使你重写的是系统自动提供的默认构造器，也需要带上 <code>override</code> 修饰符。</p><p>重写属性，方法或者是下标，<code>override</code> 修饰符会让编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否被按预想中被指定。</p><p>子类不能直接调用父类的便利构造器（每个规则都在上文 类的构造器代理规则 有所描述）因此，在子类中“重写”一个父类便利构造器时，不需要加 <code>override</code> 修饰符</p><p>如果子类的构造器没有在阶段2过程中做自定义操作，并且父类有一个无参数的指定构造器，可以在所有子类的存储属性赋值之后省略<code>super.init()</code>的调用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfWheels <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(numberOfWheels)</span> wheel(s)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hoverboard</span>: <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">color</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.color <span class="operator">=</span> color</span><br><span class="line">        <span class="comment">// super.init() 在这里被隐式调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(<span class="keyword">super</span>.description)</span> in a beautiful <span class="subst">\(color)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hoverboard <span class="operator">=</span> <span class="type">Hoverboard</span>(color: <span class="string">&quot;silver&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hoverboard: <span class="subst">\(hoverboard.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Hoverboard: 0 wheel(s) in a beautiful silver</span></span><br></pre></td></tr></table></figure><blockquote><p>子类可以在构造过程修改继承来的变量属性，但是不能修改继承来的常量属性。</p></blockquote><h4 id="构造器的自动继承"><a href="#构造器的自动继承" class="headerlink" title="构造器的自动继承"></a>构造器的自动继承</h4><p>子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。</p><p>假设你为子类中引入的所有新属性都提供了默认值，以下 2 个规则将适用：</p><p>规则 1​</p><pre><code>如果子类没有定义任何指定构造器，它将自动继承父类所有的指定构造器。</code></pre><p>规则 2​</p><pre><code>如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承父类所有的便利构造器。</code></pre><blockquote><p>子类可以将父类的指定构造器实现为便利构造器来满足规则 2</p></blockquote><h4 id="指定构造器和便利构造器实践"><a href="#指定构造器和便利构造器实践" class="headerlink" title="指定构造器和便利构造器实践"></a>指定构造器和便利构造器实践</h4><p>例子定义了包含三个类 <code>Food</code>、<code>RecipeIngredient</code> 以及 <code>ShoppingListItem</code> 的层级结构，并将演示它们的构造器是如何相互作用的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: <span class="string">&quot;[Unnamed]&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/20/Swift%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/swift_init_demo_1.png" class="&#x3D;"><p>层级中的第二个类是 <code>Food</code> 的子类 <code>RecipeIngredient</code>。<code>RecipeIngredient</code> 类用来表示食谱中的一项原料。它引入了 <code>Int</code> 类型的属性 quantity（以及从 Food 继承过来的 name 属性），并且定义了两个构造器来创建 <code>RecipeIngredient</code> 实例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecipeIngredient</span>: <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> quantity: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">quantity</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.quantity <span class="operator">=</span> quantity</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, quantity: <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/20/Swift%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/swift_init_demo_2.png" class="&#x3D;"><p>类层级中第三个也是最后一个类是 <code>RecipeIngredient</code> 的子类，叫做 <code>ShoppingListItem</code>。这个类构建了购物单中出现的某一种食谱原料。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShoppingListItem</span>: <span class="title class_">RecipeIngredient</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> purchased <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> output <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(quantity)</span> x <span class="subst">\(name)</span>&quot;</span></span><br><span class="line">        output <span class="operator">+=</span> purchased <span class="operator">?</span> <span class="string">&quot; ✔&quot;</span> : <span class="string">&quot; ✘&quot;</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，ShoppingListItem 将自动继承所有父类中的指定构造器和便利构造器。</p><p>下图展示了这三个类的构造器链：</p><img src="/2022/05/20/Swift%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/swift_init_demo_3.png" class="&#x3D;"><p>可以使用三个继承来的构造器来创建 ShoppingListItem 的新实例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> breakfastList <span class="operator">=</span> [</span><br><span class="line">    <span class="type">ShoppingListItem</span>(),</span><br><span class="line">    <span class="type">ShoppingListItem</span>(name: <span class="string">&quot;Bacon&quot;</span>),</span><br><span class="line">    <span class="type">ShoppingListItem</span>(name: <span class="string">&quot;Eggs&quot;</span>, quantity: <span class="number">6</span>),</span><br><span class="line">]</span><br><span class="line">breakfastList[<span class="number">0</span>].name <span class="operator">=</span> <span class="string">&quot;Orange juice&quot;</span></span><br><span class="line">breakfastList[<span class="number">0</span>].purchased <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> breakfastList &#123;</span><br><span class="line">    <span class="built_in">print</span>(item.description)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 x orange juice ✔</span></span><br><span class="line"><span class="comment">// 1 x bacon ✘</span></span><br><span class="line"><span class="comment">// 6 x eggs ✘</span></span><br></pre></td></tr></table></figure><h4 id="可失败构造器"><a href="#可失败构造器" class="headerlink" title="可失败构造器"></a>可失败构造器</h4><p>处理这种构造过程中可能会失败的情况。可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在 init 关键字后面添加问号（<code>init?</code>）。</p><blockquote><p>可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。</p></blockquote><blockquote><p>注意<br>严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此你只是用 return nil 表明可失败构造器构造失败，而不要用关键字 return 来表明构造成功。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wholeNumber: <span class="type">Double</span> <span class="operator">=</span> <span class="number">12345.0</span></span><br><span class="line"><span class="keyword">let</span> pi <span class="operator">=</span> <span class="number">3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> valueMaintained <span class="operator">=</span> <span class="type">Int</span>(exactly: wholeNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(wholeNumber)</span> conversion to Int maintains value of <span class="subst">\(valueMaintained)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“12345.0 conversion to Int maintains value of 12345”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> valueChanged <span class="operator">=</span> <span class="type">Int</span>(exactly: pi)</span><br><span class="line"><span class="comment">// valueChanged 是 Int? 类型，不是 Int 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> valueChanged <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(pi)</span> conversion to Int does not maintain value&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“3.14159 conversion to Int does not maintain value”</span></span><br></pre></td></tr></table></figure><h5 id="枚举类型的可失败构造器"><a href="#枚举类型的可失败构造器" class="headerlink" title="枚举类型的可失败构造器"></a>枚举类型的可失败构造器</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TemperatureUnit</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Kelvin</span>, <span class="type">Celsius</span>, <span class="type">Fahrenheit</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">symbol</span>: <span class="type">Character</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> symbol &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;K&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Kelvin</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Celsius</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;F&quot;</span>:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Fahrenheit</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fahrenheitUnit <span class="operator">=</span> <span class="type">TemperatureUnit</span>(symbol: <span class="string">&quot;F&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> fahrenheitUnit <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is a defined temperature unit, so initialization succeeded.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“This is a defined temperature unit, so initialization succeeded.”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unknownUnit <span class="operator">=</span> <span class="type">TemperatureUnit</span>(symbol: <span class="string">&quot;X&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> unknownUnit <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is not a defined temperature unit, so initialization failed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“This is not a defined temperature unit, so initialization failed.”</span></span><br></pre></td></tr></table></figure><p>带原始值的枚举类型的可失败构造器​</p><p>带原始值的枚举类型会自带一个可失败构造器 <code>init?(rawValue:)</code>，该可失败构造器有一个合适的原始值类型的 <code>rawValue</code> 形参，选择找到的相匹配的枚举成员，找不到则构造失败。</p><p>上面的 TemperatureUnit 的例子可以用原始值类型的 Character 和进阶的 init?(rawValue:) 构造器重写为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TemperatureUnit</span>: <span class="title class_">Character</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Kelvin</span> <span class="operator">=</span> <span class="string">&quot;K&quot;</span>, <span class="type">Celsius</span> <span class="operator">=</span> <span class="string">&quot;C&quot;</span>, <span class="type">Fahrenheit</span> <span class="operator">=</span> <span class="string">&quot;F&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fahrenheitUnit <span class="operator">=</span> <span class="type">TemperatureUnit</span>(rawValue: <span class="string">&quot;F&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> fahrenheitUnit <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is a defined temperature unit, so initialization succeeded.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“This is a defined temperature unit, so initialization succeeded.”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unknownUnit <span class="operator">=</span> <span class="type">TemperatureUnit</span>(rawValue: <span class="string">&quot;X&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> unknownUnit <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is not a defined temperature unit, so initialization failed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“This is not a defined temperature unit, so initialization failed.”</span></span><br></pre></td></tr></table></figure><h5 id="重写可失败构造器"><a href="#重写可失败构造器" class="headerlink" title="重写可失败构造器"></a>重写可失败构造器</h5><p>以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。</p><p>当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包。</p><blockquote><p>可以用非可失败构造器重写可失败构造器，但反过来却不行。</p></blockquote><h4 id="必要构造器"><a href="#必要构造器" class="headerlink" title="必要构造器"></a>必要构造器</h4><p>在类的构造器前添加 <code>required</code> 修饰符表明所有该类的子类都必须实现该构造器：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类重写父类的必要构造器时，必须在子类的构造器前也添加 required 修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加 override 修饰符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSubclass</span>: <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果子类继承的构造器能满足必要构造器的要求，则无须在子类中显式提供必要构造器的实现</p></blockquote><h4 id="通过闭包或函数设置属性的默认值"><a href="#通过闭包或函数设置属性的默认值" class="headerlink" title="通过闭包或函数设置属性的默认值"></a>通过闭包或函数设置属性的默认值</h4><p>如果某个存储型属性的默认值需要一些自定义或设置，你可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被构造时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。</p><p>这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。</p><p>如何用闭包为属性提供默认值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> someProperty: <span class="type">SomeType</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="comment">// 在这个闭包中给 someProperty 创建一个默认值</span></span><br><span class="line">        <span class="comment">// someValue 必须和 SomeType 类型相同</span></span><br><span class="line">        <span class="keyword">return</span> someValue</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包结尾的花括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。</p><blockquote><p>如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的 self 属性，或者调用任何实例方法。</p></blockquote><p>下面例子中定义了一个结构体 <code>Chessboard</code>，它构建了西洋跳棋游戏的棋盘，西洋跳棋游戏在一副黑白格交替的 8 x 8 的棋盘中进行的：<br>为了呈现这副游戏棋盘，Chessboard 结构体定义了一个属性 <code>boardColors</code>，它是一个包含 64 个 <code>Bool</code> 值的数组。在数组中，值为 <code>true</code> 的元素表示一个黑格，值为 <code>false</code> 的元素表示一个白格。数组中第一个元素代表棋盘上左上角的格子，最后一个元素代表棋盘上右下角的格子。</p><p><code>boardColors</code> 数组是通过一个闭包来初始化并设置颜色值的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Chessboard</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> boardColors: [<span class="type">Bool</span>] <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> temporaryBoard: [<span class="type">Bool</span>] <span class="operator">=</span> []</span><br><span class="line">        <span class="keyword">var</span> isBlack <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">8</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">8</span> &#123;</span><br><span class="line">                temporaryBoard.append(isBlack)</span><br><span class="line">                isBlack <span class="operator">=</span> <span class="operator">!</span>isBlack</span><br><span class="line">            &#125;</span><br><span class="line">            isBlack <span class="operator">=</span> <span class="operator">!</span>isBlack</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temporaryBoard</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">squareIsBlackAt</span>(<span class="params">row</span>: <span class="type">Int</span>, <span class="params">column</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boardColors[(row <span class="operator">*</span> <span class="number">8</span>) <span class="operator">+</span> column]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当一个新的 Chessboard 实例被创建时，赋值闭包则会被执行，boardColors 的默认值会被计算出来并返回。上面例子中描述的闭包将计算出棋盘中每个格子对应的颜色，并将这些值保存到一个临时数组 temporaryBoard 中，最后在构建完成时将此数组作为闭包返回值返回。这个返回的数组会保存到 boardColors 中，并可以通过工具函数 squareIsBlackAtRow 来查询：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> board <span class="operator">=</span> <span class="type">Chessboard</span>()</span><br><span class="line"><span class="built_in">print</span>(board.squareIsBlackAt(row: <span class="number">0</span>, column: <span class="number">1</span>))</span><br><span class="line"><span class="comment">// 打印“true”</span></span><br><span class="line"><span class="built_in">print</span>(board.squareIsBlackAt(row: <span class="number">7</span>, column: <span class="number">7</span>))</span><br><span class="line"><span class="comment">// 打印“false”</span></span><br></pre></td></tr></table></figure><h2 id="析构过程"><a href="#析构过程" class="headerlink" title="析构过程"></a>析构过程</h2><p>析构器只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字 <code>deinit</code> 来标示</p><p>每个类最多只能有一个析构器，而且析构器不带任何参数和圆括号</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="comment">// 执行析构过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="析构器实践"><a href="#析构器实践" class="headerlink" title="析构器实践"></a>析构器实践</h3><p>这个例子描述了一个简单的游戏，这里定义了两种新类型，分别是 Bank 和 Player。Bank 类管理一种虚拟硬币，确保流通的硬币数量永远不可能超过 10,000。在游戏中有且只能有一个 Bank 存在，因此 Bank 用类来实现，并使用类型属性和类型方法来存储和管理其当前状态。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> coinsInBank <span class="operator">=</span> <span class="number">10_000</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">distribute</span>(<span class="params">coins</span> <span class="params">numberOfCoinsRequested</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> numberOfCoinsToVend <span class="operator">=</span> <span class="built_in">min</span>(numberOfCoinsRequested, coinsInBank)</span><br><span class="line">        coinsInBank <span class="operator">-=</span> numberOfCoinsToVend</span><br><span class="line">        <span class="keyword">return</span> numberOfCoinsToVend</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">receive</span>(<span class="params">coins</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        coinsInBank <span class="operator">+=</span> coins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Bank</code> 使用 <code>coinsInBank</code> 属性来跟踪它当前拥有的硬币数量。<code>Bank</code> 还提供了两个方法，<code>distribute(coins:)</code> 和 <code>receive(coins:)</code>，分别用来处理硬币的分发和收集</p><p>Player 类描述了游戏中的一个玩家。每一个玩家在任意时间都有一定数量的硬币存储在他们的钱包中。这通过玩家的 coinsInPurse 属性来表示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> coinsInPurse: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">coins</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        coinsInPurse <span class="operator">=</span> <span class="type">Bank</span>.distribute(coins: coins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">win</span>(<span class="params">coins</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        coinsInPurse <span class="operator">+=</span> <span class="type">Bank</span>.distribute(coins: coins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="type">Bank</span>.receive(coins: coinsInPurse)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 Player 实例在初始化的过程中，都从 Bank 对象获取指定数量的硬币。如果没有足够的硬币可用，Player 实例可能会收到比指定数量少的硬币。</p><p>Player 类定义了一个 win(coins:) 方法，该方法从 Bank 对象获取一定数量的硬币，并把它们添加到玩家的钱包。Player 类还实现了一个析构器，这个析构器在 Player 实例释放前被调用。在这里，析构器的作用只是将玩家的所有硬币都返还给 Bank 对象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> playerOne: <span class="type">Player</span>? <span class="operator">=</span> <span class="type">Player</span>(coins: <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A new player has joined the game with <span class="subst">\(playerOne<span class="operator">!</span>.coinsInPurse)</span> coins&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“A new player has joined the game with 100 coins”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;There are now <span class="subst">\(Bank.coinsInBank)</span> coins left in the bank&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“There are now 9900 coins left in the bank”</span></span><br></pre></td></tr></table></figure><p>创建一个 Player 实例的时候，会向 Bank 对象申请得到 100 个硬币，前提是有足够的硬币可用。这个 Player 实例存储在一个名为 playerOne 的可选类型的变量中。这里使用了一个可选类型的变量，是因为玩家可以随时离开游戏，设置为可选使你可以追踪玩家当前是否在游戏中。</p><p>因为 playerOne 是可选的，所以在访问其 coinsInPurse 属性来打印钱包中的硬币数量和调用 win(coins:) 方法时，使用感叹号（!）强制解包：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">playerOne<span class="operator">!</span>.win(coins: <span class="number">2_000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;PlayerOne won 2000 coins &amp; now has <span class="subst">\(playerOne<span class="operator">!</span>.coinsInPurse)</span> coins&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“PlayerOne won 2000 coins &amp; now has 2100 coins”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The bank now only has <span class="subst">\(Bank.coinsInBank)</span> coins left&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“The bank now only has 7900 coins left”</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">playerOne <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;PlayerOne has left the game&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“PlayerOne has left the game”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The bank now has <span class="subst">\(Bank.coinsInBank)</span> coins&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“The bank now has 10000 coins”</span></span><br></pre></td></tr></table></figure><p>玩家现在已经离开了游戏。这通过将可选类型的 playerOne 变量设置为 nil 来表示，意味着“没有 Player 实例”。当这一切发生时，playerOne 变量对 Player 实例的引用被破坏了。没有其它属性或者变量引用 Player 实例，因此该实例会被释放，以便回收内存。在这之前，该实例的析构器被自动调用，玩家的硬币被返还给银行。</p><h2 id="可选链式调用"><a href="#可选链式调用" class="headerlink" title="可选链式调用"></a>可选链式调用</h2><p>可选链式调用是一种可以在当前值可能为 <code>nil</code> 的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是 nil，那么调用将返回 nil。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为 nil，整个调用链都会失败，即返回 nil。</p><blockquote><p>注意<br>Swift 的可选链式调用和 Objective-C 中向 nil 发送消息有些相像，但是 Swift 的可选链式调用可以应用于任意类型，并且能检查调用是否成功。</p></blockquote><h3 id="可选链式调用代替强制解包"><a href="#可选链式调用代替强制解包" class="headerlink" title="可选链式调用代替强制解包"></a>可选链式调用代替强制解包</h3><p>通过在想调用的属性、方法，或下标的可选值后面放一个问号（?），可以定义一个可选链。这一点很像在可选值后面放一个叹号（!）来强制解包它的值。主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制解包将会触发运行时错误</p><h3 id="为可选链式调用定义模型类"><a href="#为可选链式调用定义模型类" class="headerlink" title="为可选链式调用定义模型类"></a>为可选链式调用定义模型类</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> residence: <span class="type">Residence</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Residence</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> rooms: [<span class="type">Room</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">var</span> numberOfRooms: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rooms.count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Room</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rooms[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            rooms[i] <span class="operator">=</span> newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">printNumberOfRooms</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The number of rooms is <span class="subst">\(numberOfRooms)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> address: <span class="type">Address</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name <span class="operator">=</span> name &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buildingName: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> buildingNumber: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> street: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">buildingIdentifier</span>() -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> buildingName <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> buildingName</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> buildingNumber <span class="operator">=</span> buildingNumber, <span class="keyword">let</span> street <span class="operator">=</span> street &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(buildingNumber)</span> <span class="subst">\(street)</span>&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 <code>Residence</code> 有了一个存储 <code>Room</code> 实例的数组，<code>numberOfRooms</code> 属性被实现为计算型属性，而不是存储型属性。<code>numberOfRooms</code> 属性简单地返回 <code>rooms</code> 数组的 <code>count</code> 属性的值。</p><blockquote><p>在可选值上通过可选链式调用来调用这个方法，该方法的返回类型会是 <code>Void?</code>，而不是 <code>Void</code>，因为通过可选链式调用得到的返回值都是可选的。</p></blockquote><p>通过判断返回值是否为<code>nil</code>可以判断方法调用是否成功：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> john.residence<span class="operator">?</span>.printNumberOfRooms() <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was possible to print the number of rooms.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was not possible to print the number of rooms.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“It was not possible to print the number of rooms.”</span></span><br></pre></td></tr></table></figure><p>同样的，可以据此判断通过可选链式调用为属性赋值是否成功。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (john.residence<span class="operator">?</span>.address <span class="operator">=</span> someAddress) <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was possible to set the address.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was not possible to set the address.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“It was not possible to set the address.”</span></span><br></pre></td></tr></table></figure><h3 id="可选链调用下标"><a href="#可选链调用下标" class="headerlink" title="可选链调用下标"></a>可选链调用下标</h3><blockquote><p>注意<br>通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面。可选链式调用的问号一般直接跟在可选表达式的后面。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstRoomName <span class="operator">=</span> john.residence<span class="operator">?</span>[<span class="number">0</span>].name &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The first room name is <span class="subst">\(firstRoomName)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the first room name.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Unable to retrieve the first room name.”</span></span><br></pre></td></tr></table></figure><h4 id="访问可选类型的下标"><a href="#访问可选类型的下标" class="headerlink" title="访问可选类型的下标"></a>访问可选类型的下标</h4><p>如果下标返回可选类型值，比如 Swift 中 <code>Dictionary</code> 类型的键的下标，可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var testScores = [&quot;Dave&quot;: [86, 82, 84], &quot;Bev&quot;: [79, 94, 81]]</span><br><span class="line">testScores[&quot;Dave&quot;]?[0] = 91</span><br><span class="line">testScores[&quot;Bev&quot;]?[0] += 1</span><br><span class="line">testScores[&quot;Brian&quot;]?[0] = 72</span><br><span class="line">// &quot;Dave&quot; 数组现在是 [91, 82, 84]，&quot;Bev&quot; 数组现在是 [80, 94, 81]</span><br></pre></td></tr></table></figure><h4 id="多层可选链式调用"><a href="#多层可选链式调用" class="headerlink" title="多层可选链式调用"></a>多层可选链式调用</h4><p>多层可选链式调用不会增加返回值的可选层级。</p><ul><li><p>如果你访问的值不是可选的，可选链式调用将会返回可选值。</p></li><li><p>如果你访问的值就是可选的，可选链式调用不会让可选返回值变得“更可选”。</p></li><li><p>通过可选链式调用访问一个 <code>Int</code> 值，将会返回<code> Int?</code>，无论使用了多少层可选链式调用。</p></li><li><p>类似的，通过可选链式调用访问 <code>Int? </code>值，依旧会返回 <code>Int?</code> 值，并不会返回<code> Int??</code>。</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> johnsStreet <span class="operator">=</span> john.residence<span class="operator">?</span>.address<span class="operator">?</span>.street &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s street name is <span class="subst">\(johnsStreet)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the address.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Unable to retrieve the address.”</span></span><br></pre></td></tr></table></figure><h4 id="在方法的可选返回值上进行可选链式调用"><a href="#在方法的可选返回值上进行可选链式调用" class="headerlink" title="在方法的可选返回值上进行可选链式调用"></a>在方法的可选返回值上进行可选链式调用</h4><p>通过可选链式调用来调用 Address 的 buildingIdentifier() 方法。这个方法返回 String? 类型的值。如上所述，通过可选链式调用来调用该方法，最终的返回值依旧会是 <code>String?</code> 类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> buildingIdentifier <span class="operator">=</span> john.residence<span class="operator">?</span>.address<span class="operator">?</span>.buildingIdentifier() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s building identifier is <span class="subst">\(buildingIdentifier)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“John&#x27;s building identifier is The Larches.”</span></span><br></pre></td></tr></table></figure><p>如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> beginsWithThe <span class="operator">=</span></span><br><span class="line">    john.residence<span class="operator">?</span>.address<span class="operator">?</span>.buildingIdentifier()<span class="operator">?</span>.hasPrefix(<span class="string">&quot;The&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> beginsWithThe &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s building identifier begins with <span class="subst">\&quot;</span>The<span class="subst">\&quot;</span>.&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s building identifier does not begin with <span class="subst">\&quot;</span>The<span class="subst">\&quot;</span>.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“John&#x27;s building identifier begins with &quot;The&quot;.”</span></span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><p>在上面的例子中，在方法的圆括号后面加上问号是因为你要在 buildingIdentifier() 方法的可选返回值上进行可选链式调用，而不是 buildingIdentifier() 方法本身</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换在 <code>Swift</code> 中使用 <code>is</code> 和 <code>as</code> 操作符实现。</p><p>用类型检查操作符（<code>is</code>）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 <code>true</code>，否则返回 <code>false</code>。</p><h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><p>某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，你可以尝试用类型转换操作符（<code>as? </code>或 <code>as!</code>）向下转到它的子类型。</p><p>因为向下转型可能会失败，类型转型操作符带有两种不同形式。条件形式 <code>as? </code>返回一个你试图向下转成的类型的可选值。强制形式 <code>as!</code> 把试图向下转型和强制解包转换结果结合为一个操作。</p><p>只有你可以确定向下转型一定会成功时，才使用强制形式（as!）。当你试图向下转型为一个不正确的类型时，强制形式的类型转换会触发一个运行时错误。</p><h3 id="Any和AnyObject的类型转换"><a href="#Any和AnyObject的类型转换" class="headerlink" title="Any和AnyObject的类型转换"></a>Any和AnyObject的类型转换</h3><p>Swift 为不确定类型提供了两种特殊的类型别名：</p><ul><li><code>Any</code> 可以表示任何类型，包括函数类型。</li><li><code>AnyObject</code> 可以表示任何类类型的实例。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>使用 Any 类型来和混合的不同类型一起工作，包括函数类型和非类类型。它创建了一个可以存储 Any 类型的数组 things：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> things: [<span class="keyword">Any</span>] <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line">things.append(<span class="number">0</span>)</span><br><span class="line">things.append(<span class="number">0.0</span>)</span><br><span class="line">things.append(<span class="number">42</span>)</span><br><span class="line">things.append(<span class="number">3.14159</span>)</span><br><span class="line">things.append(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">things.append((<span class="number">3.0</span>, <span class="number">5.0</span>))</span><br><span class="line">things.append(<span class="type">Movie</span>(name: <span class="string">&quot;Ghostbusters&quot;</span>, director: <span class="string">&quot;Ivan Reitman&quot;</span>))</span><br><span class="line">things.append(&#123; (name: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span> <span class="string">&quot;Hello, <span class="subst">\(name)</span>&quot;</span> &#125;)</span><br></pre></td></tr></table></figure><p>可以在 <code>switch</code> 表达式的 <code>case</code> 中使用 <code>is</code> 和 <code>as</code> 操作符来找出只知道是 <code>Any</code> 或 <code>AnyObject</code> 类型的常量或变量的具体类型。下面的示例迭代 <code>things</code> 数组中的每一项，并用 <code>switch</code> 语句查找每一项的类型。有几个 <code>switch</code> 语句的 <code>case</code> 绑定它们匹配到的值到一个指定类型的常量，从而可以打印这些值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> things &#123;</span><br><span class="line">    <span class="keyword">switch</span> thing &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> <span class="keyword">as</span> <span class="type">Int</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;zero as an Int&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> <span class="keyword">as</span> <span class="type">Double</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;zero as a Double&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someInt <span class="keyword">as</span> <span class="type">Int</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;an integer value of <span class="subst">\(someInt)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someDouble <span class="keyword">as</span> <span class="type">Double</span> <span class="keyword">where</span> someDouble <span class="operator">&gt;</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;a positive double value of <span class="subst">\(someDouble)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">is</span> <span class="type">Double</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;some other double value that I don&#x27;t want to print&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someString <span class="keyword">as</span> <span class="type">String</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;a string value of <span class="subst">\&quot;</span><span class="subst">\(someString)</span><span class="subst">\&quot;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">as</span> (<span class="type">Double</span>, <span class="type">Double</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;an (x, y) point at <span class="subst">\(x)</span>, <span class="subst">\(y)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> movie <span class="keyword">as</span> <span class="type">Movie</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;a movie called <span class="subst">\(movie.name)</span>, dir. <span class="subst">\(movie.director)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> stringConverter <span class="keyword">as</span> (<span class="type">String</span>) -&gt; <span class="type">String</span>:</span><br><span class="line">        <span class="built_in">print</span>(stringConverter(<span class="string">&quot;Michael&quot;</span>))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;something else&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zero as an Int</span></span><br><span class="line"><span class="comment">// zero as a Double</span></span><br><span class="line"><span class="comment">// an integer value of 42</span></span><br><span class="line"><span class="comment">// a positive double value of 3.14159</span></span><br><span class="line"><span class="comment">// a string value of &quot;hello&quot;</span></span><br><span class="line"><span class="comment">// an (x, y) point at 3.0, 5.0</span></span><br><span class="line"><span class="comment">// a movie called Ghostbusters, dir. Ivan Reitman</span></span><br><span class="line"><span class="comment">// Hello, Michael</span></span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><p>Any 类型可以表示所有类型的值，包括可选类型。Swift 会在你用 Any 类型来表示一个可选值的时候，给你一个警告。如果你确实想使用 Any 类型来承载可选值，你可以使用 as 操作符显式转换为 Any，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let optionalNumber: Int? = 3</span><br><span class="line">things.append(optionalNumber)        // 警告</span><br><span class="line">things.append(optionalNumber as Any) // 没有警告</span><br></pre></td></tr></table></figure><h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>嵌套类型，可以在支持的类型中定义嵌套的枚举、类和结构体。</p><p>要在一个类型中嵌套另一个类型，将嵌套类型的定义写在其外部类型的<code>&#123;&#125;</code>内，而且可以根据需要定义多级嵌套。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>定义了一个结构体 <code>BlackjackCard</code>（二十一点），用来模拟 <code>BlackjackCard</code> 中的扑克牌点数。<code>BlackjackCard</code> 结构体包含两个嵌套定义的枚举类型 <code>Suit</code> 和 <code>Rank</code>。</p><p>在 <code>BlackjackCard</code> 中，<code>Ace</code> 牌可以表示 1 或者 11，<code>Ace</code> 牌的这一特征通过一个嵌套在 <code>Rank</code> 枚举中的结构体 <code>Values</code> 来表示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BlackjackCard</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 嵌套的 Suit 枚举</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Suit</span>: <span class="title class_">Character</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> spades <span class="operator">=</span> <span class="string">&quot;♠&quot;</span>, hearts <span class="operator">=</span> <span class="string">&quot;♡&quot;</span>, diamonds <span class="operator">=</span> <span class="string">&quot;♢&quot;</span>, clubs <span class="operator">=</span> <span class="string">&quot;♣&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 嵌套的 Rank 枚举</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Rank</span>: <span class="title class_">Int</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> two <span class="operator">=</span> <span class="number">2</span>, three, four, five, six, seven, eight, nine, ten</span><br><span class="line">        <span class="keyword">case</span> jack, queen, king, ace</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Values</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> first: <span class="type">Int</span>, second: <span class="type">Int</span>?</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> values: <span class="type">Values</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .ace:</span><br><span class="line">                <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="number">1</span>, second: <span class="number">11</span>)</span><br><span class="line">            <span class="keyword">case</span> .jack, .queen, .king:</span><br><span class="line">                <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="number">10</span>, second: <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="keyword">self</span>.rawValue, second: <span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// BlackjackCard 的属性和方法</span></span><br><span class="line">    <span class="keyword">let</span> rank: <span class="type">Rank</span>, suit: <span class="type">Suit</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> output <span class="operator">=</span> <span class="string">&quot;suit is <span class="subst">\(suit.rawValue)</span>,&quot;</span></span><br><span class="line">        output <span class="operator">+=</span> <span class="string">&quot; value is <span class="subst">\(rank.values.first)</span>&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> second <span class="operator">=</span> rank.values.second &#123;</span><br><span class="line">            output <span class="operator">+=</span> <span class="string">&quot; or <span class="subst">\(second)</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 BlackjackCard 是一个没有自定义构造器的结构体，所以结构体有默认的成员构造器，所以你可以用默认的构造器去初始化新常量 <code>theAceOfSpades</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> theAceOfSpades <span class="operator">=</span> <span class="type">BlackjackCard</span>(rank: .ace, suit: .spades)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;theAceOfSpades: <span class="subst">\(theAceOfSpades.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“theAceOfSpades: suit is ♠, value is 1 or 11”</span></span><br></pre></td></tr></table></figure><h3 id="引用嵌套类型"><a href="#引用嵌套类型" class="headerlink" title="引用嵌套类型"></a>引用嵌套类型</h3><p>在外部引用嵌套类型时，在嵌套类型的类型名前加上其外部类型的类型名作为前缀：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> heartsSymbol <span class="operator">=</span> <span class="type">BlackjackCard</span>.<span class="type">Suit</span>.hearts.rawValue</span><br><span class="line"><span class="comment">// 红心符号为“♡”</span></span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>扩展可以给一个现有的类，结构体，枚举，还有协议添加新的功能。它还拥有不需要访问被扩展类型源代码就能完成扩展的能力（即逆向建模）</p><p>Swift 中的扩展可以：</p><ul><li>添加计算型实例属性和计算型类属性</li><li>定义实例方法和类方法</li><li>提供新的构造器</li><li>定义下标</li><li>定义和使用新的嵌套类型</li><li>使已经存在的类型遵循（conform）一个协议</li></ul><p>在 Swift 中，你甚至可以扩展协议以提供其需要的实现，或者添加额外功能给遵循的类型所使用。</p><blockquote><p>注意<br>扩展可以给一个类型添加新的功能，但是不能重写已经存在的功能。</p></blockquote><p>使用 <code>extension</code> 关键字声明扩展：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">SomeType</span> &#123;</span><br><span class="line">  <span class="comment">// 在这里给 SomeType 添加新的功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩充一个现有的类型，给它添加一个或多个协议。协议名称的写法和类或者结构体一样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">SomeType</span>: <span class="title class_">SomeProtocol</span>, <span class="title class_">AnotherProtocol</span> &#123;</span><br><span class="line">  <span class="comment">// 协议所需要的实现写在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算型属性"><a href="#计算型属性" class="headerlink" title="计算型属性"></a>计算型属性</h3><p>扩展可以给现有类型添加计算型实例属性和计算型类属性。</p><p>这个例子给 Swift 内建的 <code>Double</code> 类型添加了五个计算型实例属性，从而提供与距离单位相关工作的基本支持：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> km: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> m: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> cm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">100.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> mm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> ft: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">3.28084</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> oneInch <span class="operator">=</span> <span class="number">25.4</span>.mm</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;One inch is <span class="subst">\(oneInch)</span> meters&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“One inch is 0.0254 meters”</span></span><br><span class="line"><span class="keyword">let</span> threeFeet <span class="operator">=</span> <span class="number">3</span>.ft</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Three feet is <span class="subst">\(threeFeet)</span> meters&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“Three feet is 0.914399970739201 meters”</span></span><br></pre></td></tr></table></figure><p>这些计算型属性表示的含义是把一个 <code>Double</code> 值看作是某单位下的长度值。即使它们被实现为计算型属性，但这些属性的名字仍可紧接一个浮点型字面值，从而通过点语法来使用，并以此实现距离转换。</p><p>这些属性都是只读的计算型属性，所以为了简便，它们的表达式里面都不包含 get 关键字。它们使用 Double 作为返回值类型，并可用于所有接受 Double 类型的数学计算中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aMarathon <span class="operator">=</span> <span class="number">42</span>.km <span class="operator">+</span> <span class="number">195</span>.m</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A marathon is <span class="subst">\(aMarathon)</span> meters long&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“A marathon is 42195.0 meters long”</span></span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><p>扩展可以添加新的计算属性，但是它们不能添加存储属性，或向现有的属性添加属性观察者。</p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>扩展可以给现有的类型添加新的构造器。它使你可以把自定义类型作为参数来供其他类型的构造器使用，或者在类型的原始实现上添加额外的构造选项。</p><p>扩展可以给一个类添加新的<code>便利构造器</code>，但是它们不能给类添加新的<code>指定构造器</code>或者<code>析构器</code>。指定构造器和析构器必须始终由类的原始实现提供。</p><p>如果你使用扩展给另一个模块中定义的结构体添加构造器，那么新的构造器直到定义模块中使用一个构造器之前，不能访问 <code>self</code>。</p><blockquote><p>注意</p></blockquote><p>如果你通过扩展提供一个新的构造器，你有责任确保每个通过该构造器创建的实例都是初始化完整的。</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>扩展可以给现有类型添加新的实例方法和类方法。在下面的例子中，给 Int 类型添加了一个新的实例方法叫做 repetitions：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">repetitions</span>(<span class="params">task</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="keyword">self</span> &#123;</span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>repetitions(task:) </code>方法仅接收一个<code> () -&gt; Void</code> 类型的参数，它表示一个没有参数没有返回值的方法。<br>以对任意整形数值调用 repetitions(task:) 方法，来执行对应次数的任务：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>.repetitions &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure><h4 id="可变实例方法"><a href="#可变实例方法" class="headerlink" title="可变实例方法"></a>可变实例方法</h4><p>通过扩展添加的实例方法同样也可以修改（或 <code>mutating</code>（改变））实例本身。结构体和枚举的方法，若是可以修改 self 或者它自己的属性，则必须将这个实例方法标记为 <code>mutating</code>，就像是改变了方法的原始实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">square</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">someInt.square()</span><br><span class="line"><span class="comment">// someInt 现在是 9</span></span><br></pre></td></tr></table></figure><h4 id="下标-1"><a href="#下标-1" class="headerlink" title="下标"></a>下标</h4><p>展可以给现有的类型添加新的下标。下面的例子中，对 Swift 的 Int 类型添加了一个整数类型的下标。下标 [n] 从数字右侧开始，返回小数点后的第 n 位：</p><ul><li>123456789[0] 返回 9</li><li>123456789[1] 返回 8</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">digitIndex</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> decimalBase <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>digitIndex &#123;</span><br><span class="line">            decimalBase <span class="operator">*=</span> <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">self</span> <span class="operator">/</span> decimalBase) <span class="operator">%</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">746381295</span>[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 返回 5</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 返回 9</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">2</span>]</span><br><span class="line"><span class="comment">// 返回 2</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">8</span>]</span><br><span class="line"><span class="comment">// 返回 7</span></span><br></pre></td></tr></table></figure><p>如果操作的 Int 值没有足够的位数满足所请求的下标，那么下标的现实将返回 0，将好像在数字的左边补上了 0：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">746381295</span>[<span class="number">9</span>]</span><br><span class="line"><span class="comment">// 返回 0，就好像你进行了这个请求：</span></span><br><span class="line"><span class="number">0746381295</span>[<span class="number">9</span>]</span><br></pre></td></tr></table></figure><h4 id="嵌套类型-1"><a href="#嵌套类型-1" class="headerlink" title="嵌套类型"></a>嵌套类型</h4><p>扩展可以给现有的类，结构体，还有枚举添加新的嵌套类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Kind</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> negative, zero, positive</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> kind: <span class="type">Kind</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .zero</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x <span class="operator">&gt;</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .positive</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> .negative</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printIntegerKinds</span>(<span class="keyword">_</span> <span class="params">numbers</span>: [<span class="type">Int</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="keyword">switch</span> number.kind &#123;</span><br><span class="line">        <span class="keyword">case</span> .negative:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;- &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> .zero:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;0 &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> .positive:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;+ &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">printIntegerKinds([<span class="number">3</span>, <span class="number">19</span>, <span class="operator">-</span><span class="number">27</span>, <span class="number">0</span>, <span class="operator">-</span><span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>])</span><br><span class="line"><span class="comment">// 打印“+ + - 0 - 0 + ”</span></span><br></pre></td></tr></table></figure><blockquote><p>注意<br>number.kind 已经被认为是 Int.Kind 类型。所以，在 switch 语句中所有的 Int.Kind case 分支可以被缩写，就像使用 .negative 替代 Int.Kind.negative.。</p></blockquote><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>协议 定义了一个蓝图，规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。类、结构体或枚举都可以遵循协议，并为协议定义的这些要求提供具体实现。某个类型能够满足某个协议的要求，就可以说该类型遵循这个协议。</p><p>除了遵循协议的类型必须实现的要求外，还可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能，这样遵循协议的类型就能够使用这些功能。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是协议的定义部分</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个类拥有父类，应该将父类名放在遵循的协议名之前，以逗号分隔：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>: <span class="title class_">SomeSuperClass</span>, <span class="title class_">FirstProtocol</span>, <span class="title class_">AnotherProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是类的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性要求"><a href="#属性要求" class="headerlink" title="属性要求"></a>属性要求</h3><p>协议可以要求遵循协议的类型提供特定名称和类型的实例属性或类型属性。协议不指定属性是存储属性还是计算属性，它只指定属性的名称和类型。此外，协议还指定属性是可读的还是可读可写的。</p><p>协议总是用 var 关键字来声明变量属性，在类型声明后加上<code>&#123; set get &#125;</code>来表示属性是可读可写的，可读属性则用<code>&#123; get &#125;</code>来表示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mustBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> doesNotNeedToBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法要求"><a href="#方法要求" class="headerlink" title="方法要求"></a>方法要求</h3><p>协议可以要求遵循协议的类型实现某些指定的实例方法或类方法。这些方法作为协议的一部分，像普通方法一样放在协议的定义中，但是不需要大括号和方法体。不支持为协议中的方法提供默认参数。</p><h3 id="异变方法要求"><a href="#异变方法要求" class="headerlink" title="异变方法要求"></a>异变方法要求</h3><p>有时需要在方法中改变（或异变）方法所属的实例。例如，在值类型（即结构体和枚举）的实例方法中，将 <code>mutating</code> 关键字作为方法的前缀，写在 <code>func</code> 关键字之前，表示可以在该方法中修改它所属的实例以及实例的任意属性的值。</p><blockquote><p>注意<br>实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Togglable</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">toggle</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">OnOffSwitch</span>: <span class="title class_">Togglable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> off, on</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">toggle</span>() &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .off:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .on</span><br><span class="line">        <span class="keyword">case</span> .on:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lightSwitch <span class="operator">=</span> <span class="type">OnOffSwitch</span>.off</span><br><span class="line">lightSwitch.toggle()</span><br><span class="line"><span class="comment">// lightSwitch 现在的值为 .on</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Togglable</code> 协议只定义了一个名为 <code>toggle</code> 的实例方法。顾名思义，<code>toggle()</code> 方法将改变实例属性，从而切换遵循该协议类型的实例的状态。</p><h3 id="构造器要求"><a href="#构造器要求" class="headerlink" title="构造器要求"></a>构造器要求</h3><p>协议可以要求遵循协议的类型实现指定的构造器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">someParameter</span>: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="协议构造器要求的类实现"><a href="#协议构造器要求的类实现" class="headerlink" title="协议构造器要求的类实现"></a>协议构造器要求的类实现</h4><p>可以在遵循协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 <code>required</code> 修饰符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>: <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="params">someParameter</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>required</code> 修饰符可以确保所有子类也必须提供此构造器实现，从而也能遵循协议。</p><blockquote><p>注意<br>如果类已经被标记为 <code>final</code>，那么不需要在协议构造器的实现中使用 <code>required</code> 修饰符，因为 <code>final</code> 类不能有子类。</p></blockquote><p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 required 和 override 修饰符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSubClass</span>: <span class="title class_">SomeSuperClass</span>, <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 因为遵循协议，需要加上 required</span></span><br><span class="line">    <span class="comment">// 因为继承自父类，需要加上 override</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协议作为类型"><a href="#协议作为类型" class="headerlink" title="协议作为类型"></a>协议作为类型</h3><p>协议作为类型使用，有时被称作「存在类型」，这个名词来自「存在着一个类型 T，该类型遵循协议 T」。</p><p>协议可以像其他普通类型一样使用，使用场景如下：</p><ul><li>作为函数、方法或构造器中的参数类型或返回值类型</li><li>作为常量、变量或属性的类型</li><li>作为数组、字典或其他容器中的元素类型</li></ul><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。</p><p>两个基于骰子游戏的协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">DiceGame</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dice: <span class="type">Dice</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">play</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">DiceGameDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">gameDidStart</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">game</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>, <span class="params">didStartNewTurnWithDiceRoll</span> <span class="params">diceRoll</span>: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">gameDidEnd</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DiceGame 协议可以被任意涉及骰子的游戏遵循。DiceGameDelegate 协议可以被任意类型遵循，用来追踪 DiceGame 的游戏过程。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SnakesAndLadders</span>: <span class="title class_">DiceGame</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> finalSquare <span class="operator">=</span> <span class="number">25</span></span><br><span class="line">    <span class="keyword">let</span> dice <span class="operator">=</span> <span class="type">Dice</span>(sides: <span class="number">6</span>, generator: <span class="type">LinearCongruentialGenerator</span>())</span><br><span class="line">    <span class="keyword">var</span> square <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> board: [<span class="type">Int</span>]</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        board <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="number">0</span>, count: finalSquare <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">        board[<span class="number">03</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">08</span>; board[<span class="number">06</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">11</span>; board[<span class="number">09</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">09</span>; board[<span class="number">10</span>] <span class="operator">=</span> <span class="operator">+</span><span class="number">02</span></span><br><span class="line">        board[<span class="number">14</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">10</span>; board[<span class="number">19</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">11</span>; board[<span class="number">22</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">02</span>; board[<span class="number">24</span>] <span class="operator">=</span> <span class="operator">-</span><span class="number">08</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> delegate: <span class="type">DiceGameDelegate</span>?</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">play</span>() &#123;</span><br><span class="line">        square <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        delegate<span class="operator">?</span>.gameDidStart(<span class="keyword">self</span>)</span><br><span class="line">        gameLoop: <span class="keyword">while</span> square <span class="operator">!=</span> finalSquare &#123;</span><br><span class="line">            <span class="keyword">let</span> diceRoll <span class="operator">=</span> dice.roll()</span><br><span class="line">            delegate<span class="operator">?</span>.game(<span class="keyword">self</span>, didStartNewTurnWithDiceRoll: diceRoll)</span><br><span class="line">            <span class="keyword">switch</span> square <span class="operator">+</span> diceRoll &#123;</span><br><span class="line">            <span class="keyword">case</span> finalSquare:</span><br><span class="line">                <span class="keyword">break</span> gameLoop</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> newSquare <span class="keyword">where</span> newSquare <span class="operator">&gt;</span> finalSquare:</span><br><span class="line">                <span class="keyword">continue</span> gameLoop</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                square <span class="operator">+=</span> diceRoll</span><br><span class="line">                square <span class="operator">+=</span> board[square]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        delegate<span class="operator">?</span>.gameDidEnd(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DiceGameTracker</span>: <span class="title class_">DiceGameDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfTurns <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">gameDidStart</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>) &#123;</span><br><span class="line">        numberOfTurns <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> game <span class="keyword">is</span> <span class="type">SnakesAndLadders</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Started a new game of Snakes and Ladders&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The game is using a <span class="subst">\(game.dice.sides)</span>-sided dice&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">game</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>, <span class="params">didStartNewTurnWithDiceRoll</span> <span class="params">diceRoll</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        numberOfTurns <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Rolled a <span class="subst">\(diceRoll)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">gameDidEnd</span>(<span class="keyword">_</span> <span class="params">game</span>: <span class="type">DiceGame</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The game lasted for <span class="subst">\(numberOfTurns)</span> turns&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DiceGameTracker</code> 的运行情况如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tracker <span class="operator">=</span> <span class="type">DiceGameTracker</span>()</span><br><span class="line"><span class="keyword">let</span> game <span class="operator">=</span> <span class="type">SnakesAndLadders</span>()</span><br><span class="line">game.delegate <span class="operator">=</span> tracker</span><br><span class="line">game.play()</span><br><span class="line"><span class="comment">// Started a new game of Snakes and Ladders</span></span><br><span class="line"><span class="comment">// The game is using a 6-sided dice</span></span><br><span class="line"><span class="comment">// Rolled a 3</span></span><br><span class="line"><span class="comment">// Rolled a 5</span></span><br><span class="line"><span class="comment">// Rolled a 4</span></span><br><span class="line"><span class="comment">// Rolled a 5</span></span><br><span class="line"><span class="comment">// The game lasted for 4 turns</span></span><br></pre></td></tr></table></figure><h3 id="有条件地遵循协议"><a href="#有条件地遵循协议" class="headerlink" title="有条件地遵循协议"></a>有条件地遵循协议</h3><p>泛型类型可能只在某些情况下满足一个协议的要求，比如当类型的泛型形式参数遵循对应协议时。你可以通过在扩展类型时列出限制让泛型类型有条件地遵循某协议。在你采纳协议的名字后面写泛型 where 分句。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_">TextRepresentable</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">TextRepresentable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> itemsAsText <span class="operator">=</span> <span class="keyword">self</span>.map &#123; <span class="variable">$0</span>.textualDescription &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> <span class="operator">+</span> itemsAsText.joined(separator: <span class="string">&quot;, &quot;</span>) <span class="operator">+</span> <span class="string">&quot;]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myDice <span class="operator">=</span> [d6, d12]</span><br><span class="line"><span class="built_in">print</span>(myDice.textualDescription)</span><br><span class="line"><span class="comment">// 打印 &quot;[A 6-sided dice, A 12-sided dice]&quot;</span></span><br></pre></td></tr></table></figure><p>让 Array 类型只要在存储遵循 TextRepresentable 协议的元素时就遵循 TextRepresentable 协议</p><h3 id="在扩展里声明采纳协议"><a href="#在扩展里声明采纳协议" class="headerlink" title="在扩展里声明采纳协议"></a>在扩展里声明采纳协议</h3><p>当一个类型已经遵循了某个协议中的所有要求，却还没有声明采纳该协议时，可以通过空的扩展来让它采纳该协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Hamster</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A hamster named <span class="subst">\(name)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Hamster</span>: <span class="title class_">TextRepresentable</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> simonTheHamster <span class="operator">=</span> <span class="type">Hamster</span>(name: <span class="string">&quot;Simon&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> somethingTextRepresentable: <span class="type">TextRepresentable</span> <span class="operator">=</span> simonTheHamster</span><br><span class="line"><span class="built_in">print</span>(somethingTextRepresentable.textualDescription)</span><br><span class="line"><span class="comment">// 打印 “A hamster named Simon”</span></span><br></pre></td></tr></table></figure><blockquote><p>注意<br>即使满足了协议的所有要求，类型也不会自动遵循协议，必须显式地遵循协议。</p></blockquote><h3 id="使用合成实现来采纳协议"><a href="#使用合成实现来采纳协议" class="headerlink" title="使用合成实现来采纳协议"></a>使用合成实现来采纳协议</h3><p>Swift 可以自动提供一些简单场景下遵循 Equatable、Hashable 和 Comparable 协议的实现。在使用这些合成实现之后，无需再编写重复的代码来实现这些协议所要求的方法。</p><p>Swift 为以下几种自定义类型提供了 <code>Equatable</code> 协议的合成实现：</p><ul><li>遵循 Equatable 协议且只有存储属性的结构体。</li><li>遵循 Equatable 协议且只有关联类型的枚举</li><li>没有任何关联类型的枚举</li></ul><p>在包含类型原始声明的文件中声明对 Equatable 协议的遵循，可以得到 <code>==</code> 操作符的合成实现，且无需自己编写任何关于 &#x3D;&#x3D; 的实现代码。Equatable 协议同时包含 <code>!=</code> 操作符的默认实现。</p><p>Swift 为以下几种自定义类型提供了 <code>Hashable</code> 协议的合成实现：</p><ul><li>遵循 Hashable 协议且只有存储属性的结构体。</li><li>遵循 Hashable 协议且只有关联类型的枚举</li><li>没有任何关联类型的枚举</li></ul><p>在包含类型原始声明的文件中声明对 Hashable 协议的遵循，可以得到 hash(into:) 的合成实现，且无需自己编写任何关于 hash(into:) 的实现代码。</p><p><code>Swift</code> 为没有原始值的枚举类型提供了 <code>Comparable</code> 协议的合成实现。如果枚举类型包含关联类型，那这些关联类型也必须同时遵循 <code>Comparable</code> 协议。在包含原始枚举类型声明的文件中声明其对 <code>Comparable</code> 协议的遵循，可以得到 <code>&lt;</code> 操作符的合成实现，且无需自己编写任何关于 <code>&lt;</code> 的实现代码。<code>Comparable</code> 协议同时包含 <code>&lt;=</code>、<code>&gt;</code> 和 <code>&gt;= </code>操作符的默认实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SkillLevel</span>: <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> beginner</span><br><span class="line">    <span class="keyword">case</span> intermediate</span><br><span class="line">    <span class="keyword">case</span> expert(stars: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> levels <span class="operator">=</span> [<span class="type">SkillLevel</span>.intermediate, <span class="type">SkillLevel</span>.beginner,</span><br><span class="line">              <span class="type">SkillLevel</span>.expert(stars: <span class="number">5</span>), <span class="type">SkillLevel</span>.expert(stars: <span class="number">3</span>)]</span><br><span class="line"><span class="keyword">for</span> level <span class="keyword">in</span> levels.sorted() &#123;</span><br><span class="line">    <span class="built_in">print</span>(level)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &quot;beginner&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;intermediate&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;expert(stars: 3)&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;expert(stars: 5)&quot;</span></span><br></pre></td></tr></table></figure><h3 id="类专属的协议"><a href="#类专属的协议" class="headerlink" title="类专属的协议"></a>类专属的协议</h3><p>通过添加 AnyObject 关键字到协议的继承列表，就可以限制协议只能被类类型采纳（以及非结构体或者非枚举的类型）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeClassOnlyProtocol</span>: <span class="title class_">AnyObject</span>, <span class="title class_">SomeInheritedProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是类专属协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意<br>当协议定义的要求需要遵循协议的类型必须是引用语义而非值语义时，应该采用类类型专属协议</p></blockquote><h3 id="协议合成"><a href="#协议合成" class="headerlink" title="协议合成"></a>协议合成</h3><p>可以使用协议组合来复合多个协议到一个要求里。协议组合行为就和你定义的临时局部协议一样拥有构成中所有协议的需求。协议组合不定义任何新的协议类型。</p><p>协议组合使用 <code>SomeProtocol</code> &amp; <code>AnotherProtocol</code> 的形式。你可以列举任意数量的协议，用和符号（<code>&amp;</code>）分开。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Named</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">Aged</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>: <span class="title class_">Named</span>, <span class="title class_">Aged</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">wishHappyBirthday</span>(<span class="params">to</span> <span class="params">celebrator</span>: <span class="type">Named</span> &amp; <span class="type">Aged</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Happy birthday, <span class="subst">\(celebrator.name)</span>, you&#x27;re <span class="subst">\(celebrator.age)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> birthdayPerson <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Malcolm&quot;</span>, age: <span class="number">21</span>)</span><br><span class="line">wishHappyBirthday(to: birthdayPerson)</span><br><span class="line"><span class="comment">// 打印 “Happy birthday Malcolm - you&#x27;re 21!”</span></span><br></pre></td></tr></table></figure><h3 id="检查协议一致性"><a href="#检查协议一致性" class="headerlink" title="检查协议一致性"></a>检查协议一致性</h3><p>可以使用 类型转换 中描述的 is 和 as 操作符来检查协议一致性，即是否遵循某协议，并且可以转换到指定的协议类型。检查和转换协议的语法与检查和转换类型是完全一样的：</p><ul><li>is 用来检查实例是否遵循某个协议，若遵循则返回 true，否则返回 false；</li><li>as? 返回一个可选值，当实例遵循某个协议时，返回类型为协议类型的可选值，否则返回 nil；</li><li>as! 将实例强制向下转换到某个协议类型，如果强转失败，将触发运行时错误</li></ul><h3 id="可选的协议要求"><a href="#可选的协议要求" class="headerlink" title="可选的协议要求"></a>可选的协议要求</h3><p>在协议中使用 <code>optional</code> 关键字作为前缀来定义可选要求。可选要求用在你需要和 <code>Objective-C</code> 打交道的代码中。协议和可选要求都必须带上 <code>@objc</code> 属性。标记 <code>@objc</code> 特性的协议只能被继承自 <code>Objective-C</code> 类的类或者 <code>@objc</code> 类遵循，其他类以及结构体和枚举均不能遵循这种协议。</p><p>使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 (Int) -&gt; String 的方法会变成 ((Int) -&gt; String)?。需要注意的是整个函数类型是可选的，而不是函数的返回值。</p><h3 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h3><p>协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。</p><h3 id="提供默认实现"><a href="#提供默认实现" class="headerlink" title="提供默认实现"></a>提供默认实现</h3><p>可以通过协议扩展来为协议要求的方法、计算属性提供默认的实现。如果遵循协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。</p><blockquote><p>注意<br>通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">PrettyTextRepresentable</span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> textualDescription</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为协议扩展添加限制条件"><a href="#为协议扩展添加限制条件" class="headerlink" title="为协议扩展添加限制条件"></a>为协议扩展添加限制条件</h3><p>在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 where 子句来描述</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Collection</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">allEqual</span>() -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> element <span class="operator">!=</span> <span class="keyword">self</span>.first &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> equalNumbers <span class="operator">=</span> [<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>]</span><br><span class="line"><span class="keyword">let</span> differentNumbers <span class="operator">=</span> [<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(equalNumbers.allEqual())</span><br><span class="line"><span class="comment">// 打印 &quot;true&quot;</span></span><br><span class="line"><span class="built_in">print</span>(differentNumbers.allEqual())</span><br><span class="line"><span class="comment">// 打印 &quot;false&quot;</span></span><br></pre></td></tr></table></figure><h2 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h2><h3 id="范型函数"><a href="#范型函数" class="headerlink" title="范型函数"></a>范型函数</h3><p>交换两个变量的范型版本</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoValues</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">T</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型版本的函数使用占位符类型名（这里叫做 T ），而不是 实际类型名（例如 <code>Int</code>、<code>String </code>或 <code>Double</code>）,占位符类型名并不关心 T 具体的类型，但它要求 a 和 b 必须是相同的类型，T 的实际类型由每次调用 <code>swapTwoValues(_:_:)</code> 来决定,这个尖括号告诉 Swift 那个 T 是 <code>swapTwoValues(_:_:)</code> 函数定义内的一个占位类型名，因此 Swift 不会去查找名为 T 的实际类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt <span class="operator">=</span> <span class="number">107</span></span><br><span class="line">swapTwoValues(<span class="operator">&amp;</span>someInt, <span class="operator">&amp;</span>anotherInt)</span><br><span class="line"><span class="comment">// someInt 现在是 107，anotherInt 现在是 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someString <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> anotherString <span class="operator">=</span> <span class="string">&quot;world&quot;</span></span><br><span class="line">swapTwoValues(<span class="operator">&amp;</span>someString, <span class="operator">&amp;</span>anotherString)</span><br><span class="line"><span class="comment">// someString 现在是“world”，anotherString 现在是“hello”</span></span><br></pre></td></tr></table></figure><h3 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h3><p>占位类型 T 是一个类型参数的例子，类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（例如 <T>）</p><p>字典 <code>Dictionary&lt;Key, Value&gt;</code> 中的 <code>Key</code> 和 <code>Value</code> 及数组 <code>Array&lt;Element&gt;</code> 中的 <code>Element</code>，这能告诉阅读代码的人这些参数类型与泛型类型或函数之间的关系。然而，当它们之间没有有意义的关系时，通常使用单个字符来表示，例如 <code>T</code>、<code>U</code>、<code>V</code>，例如上面演示函数 <code>swapTwoValues(_:_:) </code>中的 <code>T</code></p><h3 id="范型类型"><a href="#范型类型" class="headerlink" title="范型类型"></a>范型类型</h3><p>Swift 还允许自定义泛型类型。这些自定义类、结构体和枚举可以适用于任意类型，类似于 <code>Array</code> 和 <code>Dictionary</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;<span class="title class_">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">Element</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stackOfStrings <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;uno&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;dos&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;tres&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;cuatro&quot;</span>)</span><br><span class="line"><span class="comment">// 栈中现在有 4 个字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fromTheTop <span class="operator">=</span> stackOfStrings.pop()</span><br><span class="line"><span class="comment">// fromTheTop 的值为“cuatro”，现在栈中还有 3 个字符串</span></span><br></pre></td></tr></table></figure><h3 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h3><p>对泛型函数或泛型类型中添加特定的类型约束，这将在某些情况下非常有用。类型约束指定类型参数必须继承自指定类、遵循特定的协议或协议组合</p><h4 id="类型约束语法"><a href="#类型约束语法" class="headerlink" title="类型约束语法"></a>类型约束语法</h4><p>在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>&lt;<span class="type">T</span>: <span class="type">SomeClass</span>, <span class="type">U</span>: <span class="type">SomeProtocol</span>&gt;(<span class="params">someT</span>: <span class="type">T</span>, <span class="params">someU</span>: <span class="type">U</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里是泛型函数的函数体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个函数有两个类型参数。第一个类型参数 T 必须是 <code>SomeClass</code> 子类；第二个类型参数 U 必须符合 <code>SomeProtocol</code> 协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>&lt;<span class="type">T</span>: <span class="type">Equatable</span>&gt;(<span class="params">of</span> <span class="params">valueToFind</span>: <span class="type">T</span>, <span class="params">in</span> <span class="params">array</span>:[<span class="type">T</span>]) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 标准库中定义了一个 <code>Equatable</code> 协议，该协议要求任何遵循该协议的类型必须实现等式符（<code>==</code>）及不等符（<code>!=</code>），从而能对该类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 <code>Equatable</code> 协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doubleIndex <span class="operator">=</span> findIndex(of: <span class="number">9.3</span>, in: [<span class="number">3.14159</span>, <span class="number">0.1</span>, <span class="number">0.25</span>])</span><br><span class="line"><span class="comment">// doubleIndex 类型为 Int?，其值为 nil，因为 9.3 不在数组中</span></span><br><span class="line"><span class="keyword">let</span> stringIndex <span class="operator">=</span> findIndex(of: <span class="string">&quot;Andrea&quot;</span>, in: [<span class="string">&quot;Mike&quot;</span>, <span class="string">&quot;Malcolm&quot;</span>, <span class="string">&quot;Andrea&quot;</span>])</span><br><span class="line"><span class="comment">// stringIndex 类型为 Int?，其值为 2</span></span><br></pre></td></tr></table></figure><h3 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h3><p><code>定义一个协议时</code>，声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位符名称，其代表的实际类型在协议被遵循时才会被指定。关联类型通过 <code>associatedtype</code> 关键字来指定。</p><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>定义了一个 <code>Container</code> 协议，该协议定义了一个关联类型 <code>Item</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让泛型 Stack 结构体遵循 Container 协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;<span class="title class_">Element</span>&gt;: <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="comment">// Stack&lt;Element&gt; 的原始实现部分</span></span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">Element</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Container 协议的实现部分</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="给关联类型添加约束"><a href="#给关联类型添加约束" class="headerlink" title="给关联类型添加约束"></a>给关联类型添加约束</h4><p>可以在协议里给关联类型添加约束来要求遵循的类型满足约束。例如，下面的代码定义了 <code>Container</code> 协议， 要求关联类型 <code>Item</code> 必须遵循 <code>Equatable</code> 协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span>: <span class="type">Equatable</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在关联类型约束里使用协议"><a href="#在关联类型约束里使用协议" class="headerlink" title="在关联类型约束里使用协议"></a>在关联类型约束里使用协议</h4><p>有一个协议细化了 <code>Container</code> 协议，添加了一个 <code>suffix(_:) </code>方法。<code>suffix(_:) </code>方法返回容器中从后往前给定数量的元素，并把它们存储在一个 <code>Suffix</code> 类型的实例里</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SuffixableContainer</span>: <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Suffix</span>: <span class="type">SuffixableContainer</span> <span class="keyword">where</span> <span class="type">Suffix</span>.<span class="type">Item</span> <span class="operator">==</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">suffix</span>(<span class="keyword">_</span> <span class="params">size</span>: <span class="type">Int</span>) -&gt; <span class="type">Suffix</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Suffix 是一个关联类型，Suffix 拥有两个约束：它必须遵循 SuffixableContainer 协议（就是当前定义的协议），以及它的 Item 类型必须是和容器里的 Item 类型相同。</p><p>Stack 类型的扩展，它遵循了 SuffixableContainer 协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span>: <span class="title class_">SuffixableContainer</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">suffix</span>(<span class="keyword">_</span> <span class="params">size</span>: <span class="type">Int</span>) -&gt; <span class="type">Stack</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="operator">=</span> <span class="type">Stack</span>()</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> (count<span class="operator">-</span>size)<span class="operator">..&lt;</span>count &#123;</span><br><span class="line">            result.append(<span class="keyword">self</span>[index])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 推断 suffix 结果是Stack。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stackOfInts <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">stackOfInts.append(<span class="number">10</span>)</span><br><span class="line">stackOfInts.append(<span class="number">20</span>)</span><br><span class="line">stackOfInts.append(<span class="number">30</span>)</span><br><span class="line"><span class="keyword">let</span> suffix <span class="operator">=</span> stackOfInts.suffix(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// suffix 包含 20 和 30</span></span><br></pre></td></tr></table></figure><h3 id="范型where语句"><a href="#范型where语句" class="headerlink" title="范型where语句"></a>范型where语句</h3><p>通过泛型 <code>where</code> 子句让关联类型遵从某个特定的协议，以及某个特定的类型参数和关联类型必须类型相同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">allItemsMatch</span>&lt;<span class="type">C1</span>: <span class="type">Container</span>, <span class="type">C2</span>: <span class="type">Container</span>&gt;</span><br><span class="line">    (<span class="keyword">_</span> <span class="params">someContainer</span>: <span class="type">C1</span>, <span class="keyword">_</span> <span class="params">anotherContainer</span>: <span class="type">C2</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">where</span> <span class="type">C1</span>.<span class="type">Item</span> <span class="operator">==</span> <span class="type">C2</span>.<span class="type">Item</span>, <span class="type">C1</span>.<span class="type">Item</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查两个容器含有相同数量的元素</span></span><br><span class="line">        <span class="keyword">if</span> someContainer.count <span class="operator">!=</span> anotherContainer.count &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查每一对元素是否相等</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>someContainer.count &#123;</span><br><span class="line">            <span class="keyword">if</span> someContainer[i] <span class="operator">!=</span> anotherContainer[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有元素都匹配，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个名为 <code>allItemsMatch</code> 的泛型函数，用来检查两个 <code>Container</code> 实例是否包含相同顺序的相同元素。</p><p>这个函数的类型参数列表还定义了对两个类型参数的要求：</p><ul><li>C1 必须符合 Container 协议（写作 C1: Container）。</li><li>C2 必须符合 Container 协议（写作 C2: Container）。</li><li>C1 的 Item 必须和 C2 的 Item 类型相同（写作 C1.Item &#x3D;&#x3D; C2.Item）。</li><li>C1 的 Item 必须符合 Equatable 协议（写作 C1.Item: Equatable）。</li></ul><p>这些要求意味着：</p><ul><li>someContainer 是一个 C1 类型的容器。</li><li>anotherContainer 是一个 C2 类型的容器。</li><li>someContainer 和 anotherContainer 包含相同类型的元素。</li><li>someContainer 中的元素可以通过不等于操作符（!&#x3D;）来检查它们是否相同。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stackOfStrings <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;uno&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;dos&quot;</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">&quot;tres&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrayOfStrings <span class="operator">=</span> [<span class="string">&quot;uno&quot;</span>, <span class="string">&quot;dos&quot;</span>, <span class="string">&quot;tres&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> allItemsMatch(stackOfStrings, arrayOfStrings) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All items match.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not all items match.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“All items match.”</span></span><br></pre></td></tr></table></figure><h3 id="范型where子句的扩展"><a href="#范型where子句的扩展" class="headerlink" title="范型where子句的扩展"></a>范型where子句的扩展</h3><p>可以使用泛型 where 子句作为扩展的一部分。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isTop</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> topItem <span class="operator">=</span> items.last <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> topItem <span class="operator">==</span> item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> stackOfStrings.isTop(<span class="string">&quot;tres&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Top element is tres.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Top element is something else.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Top element is tres.”</span></span><br></pre></td></tr></table></figure><p>可以使用泛型 where 子句去扩展一个协议</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Container</span> <span class="title class_">where</span> <span class="title class_">Item</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">startsWith</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count <span class="operator">&gt;=</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> <span class="keyword">self</span>[<span class="number">0</span>] <span class="operator">==</span> item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>startsWith(_:) </code>方法首先确保容器至少有一个元素，然后检查容器中的第一个元素是否与给定的元素相等。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>].startsWith(<span class="number">42</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starts with 42.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starts with something else.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Starts with something else.”</span></span><br></pre></td></tr></table></figure><p>可以编写一个泛型 where 子句去要求 Item 为特定类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Container</span> <span class="title class_">where</span> <span class="title class_">Item</span> == <span class="title class_">Double</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">average</span>() -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sum <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>count &#123;</span><br><span class="line">            sum <span class="operator">+=</span> <span class="keyword">self</span>[index]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum <span class="operator">/</span> <span class="type">Double</span>(count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>([<span class="number">1260.0</span>, <span class="number">1200.0</span>, <span class="number">98.6</span>, <span class="number">37.0</span>].average())</span><br><span class="line"><span class="comment">// 打印“648.9”</span></span><br></pre></td></tr></table></figure><h3 id="包含上下文关系的where分句"><a href="#包含上下文关系的where分句" class="headerlink" title="包含上下文关系的where分句"></a>包含上下文关系的where分句</h3><p>当你使用泛型时，可以为没有独立类型约束的声明添加 where 分句。例如，你可以使用 where 分句为泛型添加下标，或为扩展方法添加泛型约束。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">average</span>() -&gt; <span class="type">Double</span> <span class="keyword">where</span> <span class="type">Item</span> <span class="operator">==</span> <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sum <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>count &#123;</span><br><span class="line">            sum <span class="operator">+=</span> <span class="type">Double</span>(<span class="keyword">self</span>[index])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum <span class="operator">/</span> <span class="type">Double</span>(count)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">endsWith</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>) -&gt; <span class="type">Bool</span> <span class="keyword">where</span> <span class="type">Item</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count <span class="operator">&gt;=</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> <span class="keyword">self</span>[count<span class="operator">-</span><span class="number">1</span>] <span class="operator">==</span> item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numbers <span class="operator">=</span> [<span class="number">1260</span>, <span class="number">1200</span>, <span class="number">98</span>, <span class="number">37</span>]</span><br><span class="line"><span class="built_in">print</span>(numbers.average())</span><br><span class="line"><span class="comment">// 输出 &quot;648.75&quot;</span></span><br><span class="line"><span class="built_in">print</span>(numbers.endsWith(<span class="number">37</span>))</span><br><span class="line"><span class="comment">// 输出 &quot;true&quot;</span></span><br></pre></td></tr></table></figure><p>下面的例子和上面的具有相同效果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Container</span> <span class="title class_">where</span> <span class="title class_">Item</span> == <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">average</span>() -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> sum <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>count &#123;</span><br><span class="line">            sum <span class="operator">+=</span> <span class="type">Double</span>(<span class="keyword">self</span>[index])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum <span class="operator">/</span> <span class="type">Double</span>(count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Container</span> <span class="title class_">where</span> <span class="title class_">Item</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">endsWith</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count <span class="operator">&gt;=</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> <span class="keyword">self</span>[count<span class="operator">-</span><span class="number">1</span>] <span class="operator">==</span> item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在包含上下文关系的 where 分句的例子中，由于每个方法的 where 分句各自声明了需要满足的条件，因此 <code>average()</code> 和 <code>endsWith(_:)</code> 的实现能放在同一个扩展里。而将 where 分句放在扩展进行声明也能起到同样的效果，但每一个扩展只能有一个必备条件。</p><h3 id="具有范型where子句的关联类型"><a href="#具有范型where子句的关联类型" class="headerlink" title="具有范型where子句的关联类型"></a>具有范型where子句的关联类型</h3><p>可以在关联类型后面加上具有泛型 where 的子句。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Iterator</span>: <span class="type">IteratorProtocol</span> <span class="keyword">where</span> <span class="type">Iterator</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">makeIterator</span>() -&gt; <span class="type">Iterator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器（Iterator）的泛型 where 子句要求：无论迭代器是什么类型，迭代器中的元素类型，必须和容器项目的类型保持一致。makeIterator() 则提供了容器的迭代器的访问接口。</p><p>一个协议继承了另一个协议，你通过在协议声明的时候，包含泛型 where 子句，来添加了一个约束到被继承协议的关联类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">ComparableContainer</span>: <span class="title class_">Container</span> <span class="title class_">where</span> <span class="title class_">Item</span>: <span class="title class_">Comparable</span> &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="范型下标"><a href="#范型下标" class="headerlink" title="范型下标"></a>范型下标</h3><p>下标可以是泛型，它们能够包含泛型 where 子句。你可以在 subscript 后用尖括号来写占位符类型，你还可以在下标代码块花括号前写 where 子句。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">subscript</span>&lt;<span class="type">Indices</span>: <span class="type">Sequence</span>&gt;(<span class="params">indices</span>: <span class="type">Indices</span>) -&gt; [<span class="type">Item</span>]</span><br><span class="line">        <span class="keyword">where</span> <span class="type">Indices</span>.<span class="type">Iterator</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Int</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> result: [<span class="type">Item</span>] <span class="operator">=</span> []</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> indices &#123;</span><br><span class="line">                result.append(<span class="keyword">self</span>[index])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Container 协议的扩展添加了一个下标方法，接收一个索引的集合，返回每一个索引所在的值的数组。这个泛型下标的约束如下：</p><ul><li>在尖括号中的泛型参数 Indices，必须是符合标准库中的 Sequence 协议的类型。</li><li>下标使用的单一的参数，indices，必须是 Indices 的实例。</li><li>泛型 where 子句要求 Sequence（Indices）的迭代器，其所有的元素都是 Int 类型。这样就能确保在序列（Sequence）中的索引和容器（Container）里面的索引类型是一致的。</li></ul><p>综合一下，这些约束意味着，传入到 indices 下标，是一个整型的序列。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>使用 <code>enum</code> 来创建一个枚举。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CompassPoint</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> north</span><br><span class="line">    <span class="keyword">case</span> south</span><br><span class="line">    <span class="keyword">case</span> east</span><br><span class="line">    <span class="keyword">case</span> west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与 C 和 Objective-C 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。在上面的 CompassPoint 例子中，north，south，east 和 west 不会被隐式地赋值为 0，1，2 和 3。相反，这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的 CompassPoint 类型。</p></blockquote><h3 id="枚举成员的遍历"><a href="#枚举成员的遍历" class="headerlink" title="枚举成员的遍历"></a>枚举成员的遍历</h3><p>令枚举遵循 <code>CaseIterable</code> 协议。<code>Swift</code> 会生成一个 <code>allCases</code> 属性，用于表示一个包含枚举所有成员的集合。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Beverage</span>: <span class="title class_">CaseIterable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> coffee, tea, juice</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numberOfChoices <span class="operator">=</span> <span class="type">Beverage</span>.allCases.count</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(numberOfChoices)</span> beverages available&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“3 beverages available”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> beverage <span class="keyword">in</span> <span class="type">Beverage</span>.allCases &#123;</span><br><span class="line">    <span class="built_in">print</span>(beverage)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// coffee</span></span><br><span class="line"><span class="comment">// tea</span></span><br><span class="line"><span class="comment">// juice</span></span><br></pre></td></tr></table></figure><h3 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h3><p>把其他类型的值和成员值一起存储起来会很有用。这额外的信息称为关联值，并且你每次在代码中使用该枚举成员时，还可以修改这个关联值</p><p>有些商品上标有使用 0 到 9 的数字的 UPC 格式的一维条形码。每一个条形码都有一个代表数字系统的数字，该数字后接五位代表厂商代码的数字，接下来是五位代表“产品代码”的数字。最后一个数字是检查位，用来验证代码是否被正确扫描</p><p>其他商品上标有 QR 码格式的二维码，它可以使用任何 ISO 8859-1 字符，并且可以编码一个最多拥有 2,953 个字符的字符串</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Barcode</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> upc(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> qrCode(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用任意一种条形码类型创建新的条形码</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productBarcode <span class="operator">=</span> <span class="type">Barcode</span>.upc(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">//同一个商品可以被分配一个不同类型的条形码</span></span><br><span class="line">productBarcode <span class="operator">=</span> .qrCode(<span class="string">&quot;ABCDEFGHIJKLMNOP&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>Barcode</code> 类型的常量和变量可以存储一个 <code>.upc</code> 或者一个 <code>.qrCode</code>（连同它们的关联值），但是在同一时间只能存储这两个值中的一个。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> .upc(<span class="keyword">let</span> numberSystem, <span class="keyword">let</span> manufacturer, <span class="keyword">let</span> product, <span class="keyword">let</span> check):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;UPC: <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .qrCode(<span class="keyword">let</span> productCode):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;QR code: <span class="subst">\(productCode)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“QR code: ABCDEFGHIJKLMNOP.”</span></span><br></pre></td></tr></table></figure><p>如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个 let 或者 var：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .upc(numberSystem, manufacturer, product, check):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;UPC: <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .qrCode(productCode):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;QR code: <span class="subst">\(productCode)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“QR code: ABCDEFGHIJKLMNOP.”</span></span><br></pre></td></tr></table></figure><h3 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h3><p>枚举成员可以被默认值（称为原始值）预填充，这些原始值的类型必须相同</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ASCIIControlCharacter</span>: <span class="title class_">Character</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> tab <span class="operator">=</span> <span class="string">&quot;<span class="subst">\t</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> lineFeed <span class="operator">=</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> carriageReturn <span class="operator">=</span> <span class="string">&quot;<span class="subst">\r</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始值可以是字符串、字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。</p><blockquote><p>注意<br>原始值和关联值是不同的。原始值是在定义枚举时被预先填充的值，像上述三个 ASCII 码。对于一个特定的枚举成员，它的原始值始终不变。关联值是创建一个基于枚举成员的常量或变量时才设置的值，枚举成员的关联值可以变化。</p></blockquote><p>原始值的隐式赋值<br>在使用原始值为整数或者字符串类型的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift 将会自动为你赋值。</p><p>当使用整数作为原始值时，隐式赋值的值依次递增 1<br>当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CompassPoint</span>: <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> north, south, east, west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CompassPoint.south</code> 拥有隐式原始值 <code>south</code>，依次类推</p><p>使用枚举成员的 rawValue 属性可以访问该枚举成员的原始值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> earthsOrder <span class="operator">=</span> <span class="type">Planet</span>.earth.rawValue</span><br><span class="line"><span class="comment">// earthsOrder 值为 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sunsetDirection <span class="operator">=</span> <span class="type">CompassPoint</span>.west.rawValue</span><br><span class="line"><span class="comment">// sunsetDirection 值为 &quot;west&quot;</span></span><br></pre></td></tr></table></figure><h3 id="原始值初始化枚举实例"><a href="#原始值初始化枚举实例" class="headerlink" title="原始值初始化枚举实例"></a>原始值初始化枚举实例</h3><p>如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做 rawValue 的参数，参数类型即为原始值类型，返回值则是枚举成员或 <code>nil</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblePlanet <span class="operator">=</span> <span class="type">Planet</span>(rawValue: <span class="number">7</span>)</span><br><span class="line"><span class="comment">// possiblePlanet 类型为 Planet? 值为 Planet.uranus</span></span><br></pre></td></tr></table></figure><blockquote><p>注意<br>原始值构造器是一个可失败构造器，因为并不是每一个原始值都有与之对应的枚举成员。</p></blockquote><p>就像类和其他所有命名类型一样，枚举可以包含方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Rank</span>: <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ace <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> two, three, four, five, six, seven, eight, nine, ten</span><br><span class="line">    <span class="keyword">case</span> jack, queen, king</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">simpleDescription</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .ace:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ace&quot;</span></span><br><span class="line">        <span class="keyword">case</span> .jack:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;jack&quot;</span></span><br><span class="line">        <span class="keyword">case</span> .queen:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;queen&quot;</span></span><br><span class="line">        <span class="keyword">case</span> .king:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;king&quot;</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>.rawValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ace <span class="operator">=</span> <span class="type">Rank</span>.ace</span><br><span class="line"><span class="keyword">let</span> aceRawValue <span class="operator">=</span> ace.rawValue</span><br></pre></td></tr></table></figure><p>可以使用字符串或者浮点数作为枚举的原始值。使用 <code>rawValue</code> 属性来访问一个枚举成员的原始值。</p><p>使用 <code>init?(rawValue:) </code>初始化构造器来从原始值创建一个枚举实例。如果存在与原始值相应的枚举成员就返回该枚举成员，否则就返回 <code>nil</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> convertedRank <span class="operator">=</span> <span class="type">Rank</span>(rawValue: <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> threeDescription <span class="operator">=</span> convertedRank.simpleDescription()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果枚举成员的实例有原始值，那么这些值是在声明的时候就已经决定了，这意味着不同枚举实例的枚举成员总会有一个相同的原始值。当然我们也可以为枚举成员设定关联值，关联值是在创建实例时决定的。这意味着同一枚举成员不同实例的关联值可以不相同。你可以把关联值想象成枚举成员实例的存储属性。例如，考虑从服务器获取日出和日落的时间的情况。服务器会返回正常结果或者错误信息。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ServerResponse</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> result(<span class="type">String</span>, <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> success <span class="operator">=</span> <span class="type">ServerResponse</span>.result(<span class="string">&quot;6:00 am&quot;</span>, <span class="string">&quot;8:09 pm&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> failure <span class="operator">=</span> <span class="type">ServerResponse</span>.failure(<span class="string">&quot;Out of cheese.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> success &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .result(sunrise, sunset):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sunrise is at <span class="subst">\(sunrise)</span> and sunset is at <span class="subst">\(sunset)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .failure(message):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Failure...  <span class="subst">\(message)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>ServerResponse</code> 的值在与 <code>switch</code> 的分支匹配时，日升和日落时间是如何从该值中提取出来的</p><h2 id="结构体和类"><a href="#结构体和类" class="headerlink" title="结构体和类"></a>结构体和类</h2><p><strong>一个类的实例被称为对象</strong></p><p>与结构体相比，类还有如下的附加功能：</p><ul><li>继承允许一个类继承另一个类的特征</li><li>类型转换允许在运行时检查和解释一个类实例的类型</li><li>析构器允许一个类实例释放任何其所被分配的资源</li><li>引用计数允许对一个类的多次引用</li></ul><p>所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。与结构体不同，类实例没有默认的成员逐一构造器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Resolution</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoMode</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resolution <span class="operator">=</span> <span class="type">Resolution</span>()</span><br><span class="line">    <span class="keyword">var</span> interlaced <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> frameRate <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vga <span class="operator">=</span> <span class="type">Resolution</span>(width: <span class="number">640</span>, height: <span class="number">480</span>)</span><br></pre></td></tr></table></figure><p>结构体和枚举是<code>值类型</code>,值类型是这样一种类型，当它被赋值给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。</p><p>类是引用类型，与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，使用的是已存在实例的引用，而不是其拷贝。</p><p>判定两个常量或者变量是否引用同一个类实例有时很有用，恒等运算符：<br>相同（<code>===</code>）<br>不相同（<code>!==</code>）<br>使用这两个运算符检测两个常量或者变量是否引用了同一个实例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> tenEighty <span class="operator">===</span> alsoTenEighty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>“相同”表示两个类类型（class type）的常量或者变量引用同一个类实例。“等于”表示两个实例的值“相等”或“等价”</p></blockquote><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性将值与特定的类、结构体或枚举关联。存储属性会将常量和变量存储为实例的一部分，而计算属性则是直接计算（而不是存储）值。<code>计算属性</code>可以用于类、结构体和枚举，而<code>存储属性</code>只能用于类和结构体。</p><h4 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h4><p>一个存储属性就是存储在特定类或结构体实例里的一个常量或变量</p><p>延时加载存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 <code>lazy</code> 来标示一个延时加载存储属性。</p><blockquote><p>必须将延时加载属性声明成变量（使用 <code>var</code> 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延时加载。</p></blockquote><p>延时加载属性使用场景</p><p>当属性的值依赖于一些外部因素且这些外部因素只有在构造过程结束之后才会知道的时候<br>当获得属性的值因为需要复杂或者大量的计算，而需要采用需要的时候再计算的方式</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataImporter</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    DataImporter 是一个负责将外部文件中的数据导入的类。</span></span><br><span class="line"><span class="comment">    这个类的初始化会消耗不少时间。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> fileName <span class="operator">=</span> <span class="string">&quot;data.txt&quot;</span></span><br><span class="line">    <span class="comment">// 这里会提供数据导入功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataManager</span> &#123;</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> importer <span class="operator">=</span> <span class="type">DataImporter</span>()</span><br><span class="line">    <span class="keyword">var</span> data: [<span class="type">String</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="comment">// 这里会提供数据管理功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager <span class="operator">=</span> <span class="type">DataManager</span>()</span><br><span class="line">manager.data.append(<span class="string">&quot;Some data&quot;</span>)</span><br><span class="line">manager.data.append(<span class="string">&quot;Some more data&quot;</span>)</span><br><span class="line"><span class="comment">// DataImporter 实例的 importer 属性还没有被创建</span></span><br></pre></td></tr></table></figure><p><code>DataManager</code> 管理数据时也可能不从文件中导入数据。所以当 <code>DataManager</code> 的实例被创建时，没必要创建一个 <code>DataImporter</code> 的实例，更明智的做法是第一次用到 <code>DataImporter</code> 的时候才去创建它。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(manager.importer.fileName)</span><br><span class="line"><span class="comment">// DataImporter 实例的 importer 属性现在被创建了</span></span><br><span class="line"><span class="comment">// 输出“data.txt”</span></span><br></pre></td></tr></table></figure><blockquote><p>如果一个被标记为 <code>lazy</code> 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。</p></blockquote><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个 <code>getter</code> 和一个<code>可选的 setter</code>，来间接获取和设置其他属性或变量的值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX <span class="operator">=</span> origin.x <span class="operator">+</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY <span class="operator">=</span> origin.y <span class="operator">+</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newCenter) &#123;</span><br><span class="line">            origin.x <span class="operator">=</span> newCenter.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            origin.y <span class="operator">=</span> newCenter.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> square <span class="operator">=</span> <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">10.0</span>, height: <span class="number">10.0</span>))</span><br><span class="line"><span class="keyword">let</span> initialSquareCenter <span class="operator">=</span> square.center</span><br><span class="line">square.center <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">15.0</span>, y: <span class="number">15.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;square.origin is now at (<span class="subst">\(square.origin.x)</span>, <span class="subst">\(square.origin.y)</span>)&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“square.origin is now at (10.0, 10.0)”</span></span><br></pre></td></tr></table></figure><h5 id="简化-Setter-Getter-声明"><a href="#简化-Setter-Getter-声明" class="headerlink" title="简化 Setter , Getter 声明"></a>简化 Setter , Getter 声明</h5><p>如果计算属性的 <code>setter</code> 没有定义表示新值的参数名，则可以使用默认名称 <code>newValue</code>,如果整个 <code>getter</code> 是单一表达式，<code>getter</code> 会隐式地返回这个表达式结果</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CompactRect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="type">Point</span>(x: origin.x <span class="operator">+</span> (size.width <span class="operator">/</span> <span class="number">2</span>),</span><br><span class="line">                  y: origin.y <span class="operator">+</span> (size.height <span class="operator">/</span> <span class="number">2</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            origin.x <span class="operator">=</span> newValue.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            origin.y <span class="operator">=</span> newValue.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>必须使用 <code>var</code> 关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。let 关键字只用来声明常量属性，表示初始化后再也无法修改的值。</p></blockquote><h5 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h5><p>只有 <code>getter</code> 没有 <code>setter</code> 的计算属性叫只读计算属性。只读计算属性的声明可以去掉 get 关键字和花括号：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cuboid</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span>, depth <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> volume: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width <span class="operator">*</span> height <span class="operator">*</span> depth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fourByFiveByTwo <span class="operator">=</span> <span class="type">Cuboid</span>(width: <span class="number">4.0</span>, height: <span class="number">5.0</span>, depth: <span class="number">2.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the volume of fourByFiveByTwo is <span class="subst">\(fourByFiveByTwo.volume)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“the volume of fourByFiveByTwo is 40.0”</span></span><br></pre></td></tr></table></figure><h4 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h4><blockquote><p>注意<br>在父类初始化方法调用之后，在子类构造器中给父类的属性赋值时，会调用父类属性的 willSet 和 didSet 观察器。而在父类初始化方法调用之前，给子类的属性赋值时不会调用子类属性的观察器。</p></blockquote><blockquote><p>注意<br>如果将带有观察器的属性通过 in-out 方式传入函数，willSet 和 didSet 也会调用。这是因为 in-out 参数采用了拷入拷出内存模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。</p></blockquote><h4 id="属性包装器"><a href="#属性包装器" class="headerlink" title="属性包装器"></a>属性包装器</h4><p>属性包装器在管理属性如何存储和定义属性的代码之间添加了一个分隔层。举例来说，如果你的属性需要线程安全性检查或者需要在数据库中存储它们的基本数据，那么必须给每个属性添加同样的逻辑代码。当使用属性包装器时，你只需在定义属性包装器时编写一次管理代码，然后应用到多个属性上来进行复用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TwelveOrLess</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> number <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> number &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; number <span class="operator">=</span> <span class="built_in">min</span>(newValue, <span class="number">12</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TwelveOrLess</code> 结构体确保它包装的值始终是小于等于 12 的数字</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SmallRectangle</span> &#123;</span><br><span class="line">    <span class="meta">@TwelveOrLess</span> <span class="keyword">var</span> height: <span class="type">Int</span></span><br><span class="line">    <span class="meta">@TwelveOrLess</span> <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rectangle <span class="operator">=</span> <span class="type">SmallRectangle</span>()</span><br><span class="line"><span class="built_in">print</span>(rectangle.height)</span><br><span class="line"><span class="comment">// 打印 &quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">rectangle.height <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(rectangle.height)</span><br><span class="line"><span class="comment">// 打印 &quot;10&quot;</span></span><br><span class="line"></span><br><span class="line">rectangle.height <span class="operator">=</span> <span class="number">24</span></span><br><span class="line"><span class="built_in">print</span>(rectangle.height)</span><br><span class="line"><span class="comment">// 打印 &quot;12&quot;</span></span><br></pre></td></tr></table></figure><p>通过 <code>TwelveOrLess</code> 属性包装器来确保它的长宽均小于等于 12</p><p>当你把一个包装器应用到一个属性上时，编译器将合成提供包装器存储空间和通过包装器访问属性的代码。（属性包装器只负责存储被包装值，所以没有合成这些代码。）不利用这个特性语法的情况下，你可以写出使用属性包装器行为的代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SmallRectangle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _height <span class="operator">=</span> <span class="type">TwelveOrLess</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _width <span class="operator">=</span> <span class="type">TwelveOrLess</span>()</span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _height.wrappedValue &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _height.wrappedValue <span class="operator">=</span> newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _width.wrappedValue &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _width.wrappedValue <span class="operator">=</span> newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_height</code> 和 <code>_width</code> 属性存着这个属性包装器的一个实例，即 <code>TwelveOrLess</code>。<code>height</code> 和 <code>width</code> 的 <code>getter</code> 和 <code>setter</code> 把对 <code>wrappedValue</code> 属性的访问包装起来。</p><ul><li>设置被包装属性的初始值<br>能设置被包装值和最大值的构造器：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SmallNumber</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> maximum: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> number: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> number &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; number <span class="operator">=</span> <span class="built_in">min</span>(newValue, maximum) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        maximum <span class="operator">=</span> <span class="number">12</span></span><br><span class="line">        number <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">wrappedValue</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        maximum <span class="operator">=</span> <span class="number">12</span></span><br><span class="line">        number <span class="operator">=</span> <span class="built_in">min</span>(wrappedValue, maximum)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">wrappedValue</span>: <span class="type">Int</span>, <span class="params">maximum</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.maximum <span class="operator">=</span> maximum</span><br><span class="line">        number <span class="operator">=</span> <span class="built_in">min</span>(wrappedValue, maximum)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你把包装器应用于属性且没有设定初始值时，Swift 使用<code>init()</code>构造器来设置包装器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ZeroRectangle</span> &#123;</span><br><span class="line">    <span class="meta">@SmallNumber</span> <span class="keyword">var</span> height: <span class="type">Int</span></span><br><span class="line">    <span class="meta">@SmallNumber</span> <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zeroRectangle <span class="operator">=</span> <span class="type">ZeroRectangle</span>()</span><br><span class="line"><span class="built_in">print</span>(zeroRectangle.height, zeroRectangle.width)</span><br><span class="line"><span class="comment">// 打印 &quot;0 0&quot;</span></span><br></pre></td></tr></table></figure><p>当你为属性指定初始值时，Swift 使用 init(wrappedValue:) 构造器来设置包装器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UnitRectangle</span> &#123;</span><br><span class="line">    <span class="meta">@SmallNumber</span> <span class="keyword">var</span> height: <span class="type">Int</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="meta">@SmallNumber</span> <span class="keyword">var</span> width: <span class="type">Int</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> unitRectangle <span class="operator">=</span> <span class="type">UnitRectangle</span>()</span><br><span class="line"><span class="built_in">print</span>(unitRectangle.height, unitRectangle.width)</span><br><span class="line"><span class="comment">// 打印 &quot;1 1&quot;</span></span><br></pre></td></tr></table></figure><p>当你在自定义特性后面把实参写在括号里时，Swift 使用接受这些实参的构造器来设置包装器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NarrowRectangle</span> &#123;</span><br><span class="line">    <span class="meta">@SmallNumber</span>(wrappedValue: <span class="number">2</span>, maximum: <span class="number">5</span>) <span class="keyword">var</span> height: <span class="type">Int</span></span><br><span class="line">    <span class="meta">@SmallNumber</span>(wrappedValue: <span class="number">3</span>, maximum: <span class="number">4</span>) <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> narrowRectangle <span class="operator">=</span> <span class="type">NarrowRectangle</span>()</span><br><span class="line"><span class="built_in">print</span>(narrowRectangle.height, narrowRectangle.width)</span><br><span class="line"><span class="comment">// 打印 &quot;2 3&quot;</span></span><br><span class="line"></span><br><span class="line">narrowRectangle.height <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">narrowRectangle.width <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(narrowRectangle.height, narrowRectangle.width)</span><br><span class="line"><span class="comment">// 打印 &quot;5 4&quot;</span></span><br></pre></td></tr></table></figure><ul><li>从属性包装器中呈现一个值<br>属性包装器可以通过定义被呈现值暴露出其他功能。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SmallNumber</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> number: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> projectedValue: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> number &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> newValue <span class="operator">&gt;</span> <span class="number">12</span> &#123;</span><br><span class="line">                number <span class="operator">=</span> <span class="number">12</span></span><br><span class="line">                projectedValue <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                number <span class="operator">=</span> newValue</span><br><span class="line">                projectedValue <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.number <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>.projectedValue <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeStructure</span> &#123;</span><br><span class="line">    <span class="meta">@SmallNumber</span> <span class="keyword">var</span> someNumber: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someStructure <span class="operator">=</span> <span class="type">SomeStructure</span>()</span><br><span class="line"></span><br><span class="line">someStructure.someNumber <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(someStructure.<span class="variable">$someNumber</span>)</span><br><span class="line"><span class="comment">// 打印 &quot;false&quot;</span></span><br><span class="line"></span><br><span class="line">someStructure.someNumber <span class="operator">=</span> <span class="number">55</span></span><br><span class="line"><span class="built_in">print</span>(someStructure.<span class="variable">$someNumber</span>)</span><br><span class="line"><span class="comment">// 打印 &quot;true&quot;</span></span><br></pre></td></tr></table></figure><p>写下 <code>someStructure.$someNumber</code> 即可访问包装器的被呈现值。属性包装器可以返回任何类型的值作为它的被呈现值。<br>用 <code>$height</code> 和 <code>$width</code> 引用包装器 <code>height</code> 和 <code>width</code> 的被呈现值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> small, large</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SizedRectangle</span> &#123;</span><br><span class="line">    <span class="meta">@SmallNumber</span> <span class="keyword">var</span> height: <span class="type">Int</span></span><br><span class="line">    <span class="meta">@SmallNumber</span> <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">resize</span>(<span class="params">to</span> <span class="params">size</span>: <span class="type">Size</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> size &#123;</span><br><span class="line">        <span class="keyword">case</span> .small:</span><br><span class="line">            height <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">            width <span class="operator">=</span> <span class="number">20</span></span><br><span class="line">        <span class="keyword">case</span> .large:</span><br><span class="line">            height <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">            width <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$height</span> <span class="operator">||</span> <span class="variable">$width</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>属性包装器语法只是具有 getter 和 setter 的属性的语法糖，所以访问 height 和 width 的行为与访问任何其他属性的行为相同。</p></blockquote><h4 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h4><p>实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。</p><p>可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是类型属性。</p><blockquote><p>注意</p></blockquote><p>跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。</p><blockquote><p>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 lazy 修饰符。</p></blockquote><p>使用关键字 <code>static</code> 来定义类型属性。在为类定义计算型类型属性时，可以改用关键字 <code>class</code> 来支持子类对父类的实现进行重写。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeStructure</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty <span class="operator">=</span> <span class="string">&quot;Some value.&quot;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SomeEnumeration</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty <span class="operator">=</span> <span class="string">&quot;Some value.&quot;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty <span class="operator">=</span> <span class="string">&quot;Some value.&quot;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">27</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">var</span> <span class="title class_">overrideableComputedTypeProperty</span>: <span class="title class_">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">107</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型属性是通过类型本身来访问，而不是通过实例。比如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">SomeStructure</span>.storedTypeProperty)</span><br><span class="line"><span class="comment">// 打印“Some value.”</span></span><br><span class="line"><span class="type">SomeStructure</span>.storedTypeProperty <span class="operator">=</span> <span class="string">&quot;Another value.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeStructure</span>.storedTypeProperty)</span><br><span class="line"><span class="comment">// 打印“Another value.”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeEnumeration</span>.computedTypeProperty)</span><br><span class="line"><span class="comment">// 打印“6”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeClass</span>.computedTypeProperty)</span><br><span class="line"><span class="comment">// 打印“27”</span></span><br></pre></td></tr></table></figure><h2 id="协议和扩展"><a href="#协议和扩展" class="headerlink" title="协议和扩展"></a>协议和扩展</h2><h3 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h3><p>使用 <code>protocol</code> 来声明一个协议</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">ExampleProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">adjust</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类、枚举和结构体都可以遵循协议</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span>: <span class="title class_">ExampleProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;A very simple class.&quot;</span></span><br><span class="line">    <span class="keyword">var</span> anotherProperty: <span class="type">Int</span> <span class="operator">=</span> <span class="number">69105</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">adjust</span>() &#123;</span><br><span class="line">        simpleDescription <span class="operator">+=</span> <span class="string">&quot;  Now 100% adjusted.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="type">SimpleClass</span>()</span><br><span class="line">a.adjust()</span><br><span class="line"><span class="keyword">let</span> aDescription <span class="operator">=</span> a.simpleDescription</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SimpleStructure</span>: <span class="title class_">ExampleProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;A simple structure&quot;</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">adjust</span>() &#123;</span><br><span class="line">        simpleDescription <span class="operator">+=</span> <span class="string">&quot; (adjusted)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b <span class="operator">=</span> <span class="type">SimpleStructure</span>()</span><br><span class="line">b.adjust()</span><br><span class="line"><span class="keyword">let</span> bDescription <span class="operator">=</span> b.simpleDescription</span><br></pre></td></tr></table></figure><p>注意声明 <code>SimpleStructure</code> 时候 <code>mutating</code> 关键字用来标记一个会修改结构体的方法。<code>SimpleClass</code> 的声明不需要标记任何方法，因为类中的方法通常可以修改类属性（类的性质）</p><h3 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h3><p>使用 <code>extension</code> 来为现有的类型添加功能，比如新的方法和计算属性。你可以使用扩展让某个在别处声明的类型来遵守某个协议，这同样适用于从外部库或者框架引入的类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span>: <span class="title class_">ExampleProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The number <span class="subst">\(<span class="keyword">self</span>)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">adjust</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">+=</span> <span class="number">42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">7</span>.simpleDescription)</span><br></pre></td></tr></table></figure><p>可以像使用其他命名类型一样使用协议名——例如，创建一个有不同类型但是都实现一个协议的对象集合。当你处理类型是协议的值时，协议外定义的方法不可用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> protocolValue: <span class="type">ExampleProtocol</span> <span class="operator">=</span> a</span><br><span class="line"><span class="built_in">print</span>(protocolValue.simpleDescription)</span><br><span class="line"><span class="comment">// print(protocolValue.anotherProperty)  // 去掉注释可以看到错误</span></span><br></pre></td></tr></table></figure><p>即使 <code>protocolValue</code> 变量运行时的类型是 <code>simpleClass</code> ，编译器还是会把它的类型当做 <code>ExampleProtocol</code>。这表示你不能调用在协议之外的方法或者属性。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>使用采用 <code>Error</code> 协议的类型来表示错误</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">PrinterError</span>: <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> outOfPaper</span><br><span class="line">    <span class="keyword">case</span> noToner</span><br><span class="line">    <span class="keyword">case</span> onFire</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>throw</code> 来抛出一个错误和使用 <code>throws</code> 来表示一个可以抛出错误的函数。如果在函数中抛出一个错误，这个函数会立刻返回并且调用该函数的代码会进行错误处理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">send</span>(<span class="params">job</span>: <span class="type">Int</span>, <span class="params">toPrinter</span> <span class="params">printerName</span>: <span class="type">String</span>) <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> printerName <span class="operator">==</span> <span class="string">&quot;Never Has Toner&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">PrinterError</span>.noToner</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Job sent&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有多种方式可以用来进行错误处理。一种方式是使用 <code>do-catch</code> 。在 <code>do </code>代码块中，使用 <code>try</code> 来标记可以抛出错误的代码。在 <code>catch</code> 代码块中，除非你另外命名，否则错误会自动命名为 <code>error</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> printerResponse <span class="operator">=</span> <span class="keyword">try</span> send(job: <span class="number">1040</span>, toPrinter: <span class="string">&quot;Bi Sheng&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(printerResponse)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用多个 catch 块来处理特定的错误。参照 switch 中的 case 风格来写 catch</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> printerResponse <span class="operator">=</span> <span class="keyword">try</span> send(job: <span class="number">1440</span>, toPrinter: <span class="string">&quot;Gutenberg&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(printerResponse)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">PrinterError</span>.onFire &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I&#x27;ll just put this over here, with the rest of the fire.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> printerError <span class="keyword">as</span> <span class="type">PrinterError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Printer error: <span class="subst">\(printerError)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种处理错误的方式使用 try? 将结果转换为可选的。如果函数抛出错误，该错误会被抛弃并且结果为 nil。否则，结果会是一个包含函数返回值的可选值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> printerSuccess <span class="operator">=</span> <span class="keyword">try?</span> send(job: <span class="number">1884</span>, toPrinter: <span class="string">&quot;Mergenthaler&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> printerFailure <span class="operator">=</span> <span class="keyword">try?</span> send(job: <span class="number">1885</span>, toPrinter: <span class="string">&quot;Never Has Toner&quot;</span>)</span><br></pre></td></tr></table></figure><p>使用 <code>defer</code> 代码块来表示在函数返回前，函数中最后执行的代码。无论函数是否会抛出错误，这段代码都将执行。使用 <code>defer</code>，可以把函数调用之初就要执行的代码和函数调用结束时的扫尾代码写在一起，虽然这两者的执行时机截然不同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fridgeIsOpen <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> fridgeContent <span class="operator">=</span> [<span class="string">&quot;milk&quot;</span>, <span class="string">&quot;eggs&quot;</span>, <span class="string">&quot;leftovers&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">fridgeContains</span>(<span class="keyword">_</span> <span class="params">food</span>: <span class="type">String</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    fridgeIsOpen <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        fridgeIsOpen <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> fridgeContent.contains(food)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">fridgeContains(<span class="string">&quot;banana&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(fridgeIsOpen)</span><br></pre></td></tr></table></figure><h2 id="范型-1"><a href="#范型-1" class="headerlink" title="范型"></a>范型</h2><p>在尖括号里写一个名字来创建一个泛型函数或者类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeArray</span>&lt;<span class="type">Item</span>&gt;(<span class="params">repeating</span> <span class="params">item</span>: <span class="type">Item</span>, <span class="params">numberOfTimes</span>: <span class="type">Int</span>) -&gt; [<span class="type">Item</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result: [<span class="type">Item</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>numberOfTimes &#123;</span><br><span class="line">        result.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">makeArray(repeating: <span class="string">&quot;knock&quot;</span>, numberOfsTimes: <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>可以创建泛型函数、方法、类、枚举和结构体</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新实现 Swift 标准库中的可选类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">OptionalValue</span>&lt;<span class="title class_">Wrapped</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> none</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">some</span>(<span class="type">Wrapped</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> possibleInteger: <span class="type">OptionalValue</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> .none</span><br><span class="line">possibleInteger <span class="operator">=</span> .some(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>在类型名后面使用 <code>where</code> 来指定对类型的一系列需求，比如，限定类型实现某一个协议，限定两个类型是相同的，或者限定某个类必须有一个特定的父类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">anyCommonElements</span>&lt;<span class="type">T</span>: <span class="type">Sequence</span>, <span class="type">U</span>: <span class="type">Sequence</span>&gt;(<span class="keyword">_</span> <span class="params">lhs</span>: <span class="type">T</span>, <span class="keyword">_</span> <span class="params">rhs</span>: <span class="type">U</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">where</span> <span class="type">T</span>.<span class="type">Element</span>: <span class="type">Equatable</span>, <span class="type">T</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">U</span>.<span class="type">Element</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> lhsItem <span class="keyword">in</span> lhs &#123;</span><br><span class="line">        <span class="keyword">for</span> rhsItem <span class="keyword">in</span> rhs &#123;</span><br><span class="line">            <span class="keyword">if</span> lhsItem <span class="operator">==</span> rhsItem &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">anyCommonElements([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>])</span><br></pre></td></tr></table></figure><h2 id="断言和先决条件"><a href="#断言和先决条件" class="headerlink" title="断言和先决条件"></a>断言和先决条件</h2><p>断言和先决条件是在运行时所做的检查。如果断言或者先决条件中的布尔条件评估的结果为 true（真），则代码像往常一样继续执行。如果<strong>布尔条件评估结果为 false（假）</strong>，程序的当前状态是无效的，则代码执行结束，<strong>应用程序中止</strong>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age <span class="operator">=</span> <span class="operator">-</span><span class="number">3</span></span><br><span class="line"><span class="built_in">assert</span>(age <span class="operator">&gt;=</span> <span class="number">0</span>, <span class="string">&quot;A person&#x27;s age cannot be less than zero&quot;</span>)</span><br><span class="line"><span class="comment">// 因为 age &lt; 0，所以断言会触发</span></span><br></pre></td></tr></table></figure><h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><p>Swift 的赋值操作并不返回任何值，所以下面语句是无效的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x <span class="operator">=</span> y &#123;</span><br><span class="line">    <span class="comment">// 此句错误，因为 x = y 并不返回任何值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能帮你避免把 （<code>==</code>）错写成（<code>=</code>）这类错误的出现</p><p>Swift 也提供恒等（<code>===</code>）和不恒等（<code>!==</code>）这两个比较符来判断两个对象是否引用同一个对象实例。</p><p>如果两个元组的元素相同，且长度相同的话，元组就可以被比较。比较元组大小会按照从左到右、逐值比较的方式，直到发现有两个值不等时停止。如果所有的值都相等，那么这一对元组我们就称它们是相等的。例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="string">&quot;zebra&quot;</span>) <span class="operator">&lt;</span> (<span class="number">2</span>, <span class="string">&quot;apple&quot;</span>)   <span class="comment">// true，因为 1 小于 2</span></span><br><span class="line">(<span class="number">3</span>, <span class="string">&quot;apple&quot;</span>) <span class="operator">&lt;</span> (<span class="number">3</span>, <span class="string">&quot;bird&quot;</span>)    <span class="comment">// true，因为 3 等于 3，但是 apple 小于 bird</span></span><br><span class="line">(<span class="number">4</span>, <span class="string">&quot;dog&quot;</span>) <span class="operator">==</span> (<span class="number">4</span>, <span class="string">&quot;dog&quot;</span>)      <span class="comment">// true，因为 4 等于 4，dog 等于 dog</span></span><br></pre></td></tr></table></figure><h3 id="空合运算符"><a href="#空合运算符" class="headerlink" title="空合运算符"></a>空合运算符</h3><p>空合运算符（<code>a ?? b</code>）将对可选类型 <code>a</code> 进行空判断，如果 <code>a</code> 包含一个值就进行解包，否则就返回一个默认值 <code>b</code></p><blockquote><p>如果 a 为非空值（non-nil），那么值 b 将不会被计算。这也就是所谓的短路求值</p></blockquote><h3 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h3><p>闭区间运算符（<code>a...b</code>）定义一个包含从<code>a</code>到 <code>b</code>（包括 <code>a</code> 和 <code>b</code>）的所有值的区间。<code>a</code> 的值不能超过 <code>b</code><br>闭区间运算符在迭代一个区间的所有值时是非常有用的，如在 for-in 循环中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(index)</span> * 5 = <span class="subst">\(index <span class="operator">*</span> <span class="number">5</span>)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 * 5 = 5</span></span><br><span class="line"><span class="comment">// 2 * 5 = 10</span></span><br><span class="line"><span class="comment">// 3 * 5 = 15</span></span><br><span class="line"><span class="comment">// 4 * 5 = 20</span></span><br><span class="line"><span class="comment">// 5 * 5 = 25</span></span><br></pre></td></tr></table></figure><p>半开区间运算符（<code>a..&lt;b</code>）定义一个从 <code>a</code> 到 <code>b</code> 但不包括 <code>b</code> 的区间。 之所以称为半开区间，是因为该区间包含第一个值而不包括最后的值。<br>半开区间的实用性在于当你使用一个从 0 开始的列表（如数组）时，非常方便地从0数到列表的长度</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Brian&quot;</span>, <span class="string">&quot;Jack&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> count <span class="operator">=</span> names.count</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>count &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第 <span class="subst">\(i <span class="operator">+</span> <span class="number">1</span>)</span> 个人叫 <span class="subst">\(names[i])</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第 1 个人叫 Anna</span></span><br><span class="line"><span class="comment">// 第 2 个人叫 Alex</span></span><br><span class="line"><span class="comment">// 第 3 个人叫 Brian</span></span><br><span class="line"><span class="comment">// 第 4 个人叫 Jack</span></span><br></pre></td></tr></table></figure><p>单侧区间,表达往一侧无限延伸的区间,一个包含了数组从索引 2 到结尾的所有值的区间</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="number">2</span><span class="operator">...</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Brian</span></span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="operator">...</span><span class="number">2</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Anna</span></span><br><span class="line"><span class="comment">// Alex</span></span><br><span class="line"><span class="comment">// Brian</span></span><br></pre></td></tr></table></figure><p>半开区间操作符也有单侧表达形式，附带上它的最终值。就像你使用区间去包含一个值，最终值并不会落在区间内。例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="operator">..&lt;</span><span class="number">2</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Anna</span></span><br><span class="line"><span class="comment">// Alex</span></span><br></pre></td></tr></table></figure><h2 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h2><p>在 Swift 中 <code>String</code> 类型是值类型 ，Swift 的 <code>String</code> 和 <code>Character</code> 类型是完全兼容 Unicode 标准的。</p><blockquote><p>Unicode是一个用于在不同书写系统中对文本进行编码、表示和处理的国际标准。</p></blockquote><p>每一个 Swift 的 Character 类型代表一个可扩展的字形群,而一个可扩展的字形群构成了人类可读的单个字符，它由一个或多个（当组合时） Unicode 标量的序列组成。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eAcute: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;E9&#125;</span>&quot;</span>                         <span class="comment">// é</span></span><br><span class="line"><span class="keyword">let</span> combinedEAcute: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\u&#123;65&#125;</span><span class="subst">\u&#123;301&#125;</span>&quot;</span>          <span class="comment">// e 后面加上  ́</span></span><br><span class="line"><span class="comment">// eAcute 是 é, combinedEAcute 是 é</span></span><br></pre></td></tr></table></figure><p>可扩展的字形集是一个将许多复杂的脚本字符表示为单个字符值的灵活方式。</p><p>获得一个字符串中 Character 值的数量，可以使用 <code>count</code> 属性</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusualMenagerie <span class="operator">=</span> <span class="string">&quot;Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;unusualMenagerie has <span class="subst">\(unusualMenagerie.count)</span> characters&quot;</span>)</span><br><span class="line"><span class="comment">// 打印输出“unusualMenagerie has 40 characters”</span></span><br></pre></td></tr></table></figure><blockquote><p>通过 count 属性返回的字符数量并不总是与包含相同字符的 NSString 的 length 属性相同。NSString 的 length 属性是利用 UTF-16 表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集</p></blockquote><p>每一个 String 值都有一个关联的索引（index）类型，String.Index，它对应着字符串中的每一个 Character 的位置</p><p>使用 indices 属性会创建一个包含全部索引的范围（Range），用来在一个字符串中访问单个字符。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Guten Tag!&quot;</span></span><br><span class="line">greeting[greeting.startIndex]</span><br><span class="line"><span class="comment">// G</span></span><br><span class="line">greeting[greeting.index(before: greeting.endIndex)]</span><br><span class="line"><span class="comment">// !</span></span><br><span class="line">greeting[greeting.index(after: greeting.startIndex)]</span><br><span class="line"><span class="comment">// u</span></span><br><span class="line"><span class="keyword">let</span> index <span class="operator">=</span> greeting.index(greeting.startIndex, offsetBy: <span class="number">7</span>)</span><br><span class="line">greeting[index]</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> greeting.indices &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(greeting[index])</span> &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出“G u t e n   T a g ! ”</span></span><br></pre></td></tr></table></figure><p>调用 remove(at:) 方法可以在一个字符串的指定索引删除一个字符，调用 removeSubrange(_:) 方法可以在一个字符串的指定索引删除一个子字符串。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcome <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">welcome.insert(<span class="string">&quot;!&quot;</span>, at: welcome.endIndex)</span><br><span class="line"><span class="comment">// welcome 变量现在等于 &quot;hello!&quot;</span></span><br><span class="line"></span><br><span class="line">welcome.insert(contentsOf:<span class="string">&quot; there&quot;</span>, at: welcome.index(before: welcome.endIndex))</span><br><span class="line"><span class="comment">// welcome 变量现在等于 &quot;hello there!&quot;</span></span><br><span class="line"></span><br><span class="line">welcome.remove(at: welcome.index(before: welcome.endIndex))</span><br><span class="line"><span class="comment">// welcome 现在等于 &quot;hello there&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> range <span class="operator">=</span> welcome.index(welcome.endIndex, offsetBy: <span class="operator">-</span><span class="number">6</span>)<span class="operator">..&lt;</span>welcome.endIndex</span><br><span class="line">welcome.removeSubrange(range)</span><br><span class="line"><span class="comment">// welcome 现在等于 &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h3 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h3><p>使用下标或者 <code>prefix(_:) </code>之类的方法 —— 就可以得到一个 <code>Substring</code> 的实例</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="keyword">let</span> index <span class="operator">=</span> greeting.firstIndex(of: <span class="string">&quot;,&quot;</span>) <span class="operator">??</span> greeting.endIndex</span><br><span class="line"><span class="keyword">let</span> beginning <span class="operator">=</span> greeting[<span class="operator">..&lt;</span>index]</span><br><span class="line"><span class="comment">// beginning 的值为 &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把结果转化为 String 以便长期存储。</span></span><br><span class="line"><span class="keyword">let</span> newString <span class="operator">=</span> <span class="type">String</span>(beginning)</span><br></pre></td></tr></table></figure><h3 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h3><p>字符串&#x2F;字符可以用等于操作符（<code>==</code>）和不等于操作符（<code>!=</code>）</p><p>调用字符串的<code> hasPrefix(_:)/hasSuffix(_:)</code> 方法来检查字符串是否拥有特定前缀&#x2F;后缀，两个方法均接收一个 String 类型的参数，并返回一个布尔值。</p><h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>一个类型为了存储在集合中，该类型必须是可哈希化的——也就是说，该类型必须提供一个方法来计算它的哈希值。一个哈希值是 <code>Int</code> 类型的，<code>相等的对象哈希值必须相同</code>，比如 <code>a == b</code>,因此必须 <code>a.hashValue == b.hashValue</code></p><p>Swift 的所有基本类型（比如 <code>String</code>、<code>Int</code>、<code>Double</code> 和 <code>Bool</code>）默认都是可哈希化的，可以作为集合值的类型或者字典键的类型。没有关联值的枚举成员值（在 枚举 有讲述）默认也是可哈希化的。</p><h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><p>使用 <code>intersection(_:)</code> 方法根据两个集合的交集创建一个新的集合。<br>使用 <code>symmetricDifference(_:) </code>方法根据两个集合不相交的值创建一个新的集合。<br>使用 <code>union(_:)</code> 方法根据两个集合的所有值创建一个新的集合。<br>使用 <code>subtracting(_:)</code> 方法根据不在另一个集合中的值创建一个新的集合</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oddDigits: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> evenDigits: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">let</span> singleDigitPrimeNumbers: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">oddDigits.union(evenDigits).sorted()</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">oddDigits.intersection(evenDigits).sorted()</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line">oddDigits.subtracting(singleDigitPrimeNumbers).sorted()</span><br><span class="line"><span class="comment">// [1, 9]</span></span><br><span class="line">oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()</span><br><span class="line"><span class="comment">// [1, 2, 9]</span></span><br></pre></td></tr></table></figure><h4 id="集合成员关系和相等"><a href="#集合成员关系和相等" class="headerlink" title="集合成员关系和相等"></a>集合成员关系和相等</h4><p>使用“是否相等”运算符（<code>==</code>）来判断两个集合包含的值是否全部相同。<br>使用 <code>isSubset(of:)</code> 方法来判断一个集合中的所有值是否也被包含在另外一个集合中。<br>使用 <code>isSuperset(of:) </code>方法来判断一个集合是否包含另一个集合中所有的值。<br>使用 <code>isStrictSubset(of:) </code>或者 <code>isStrictSuperset(of:)</code> 方法来判断一个集合是否是另外一个集合的子集合或者父集合并且两个集合并不相等。<br>使用 <code>isDisjoint(with:)</code> 方法来判断两个集合是否不含有相同的值（是否没有交集）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> houseAnimals: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;🐶&quot;</span>, <span class="string">&quot;🐱&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> farmAnimals: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;🐮&quot;</span>, <span class="string">&quot;🐔&quot;</span>, <span class="string">&quot;🐑&quot;</span>, <span class="string">&quot;🐶&quot;</span>, <span class="string">&quot;🐱&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> cityAnimals: <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;🐦&quot;</span>, <span class="string">&quot;🐭&quot;</span>]</span><br><span class="line"></span><br><span class="line">houseAnimals.isSubset(of: farmAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">farmAnimals.isSuperset(of: houseAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">farmAnimals.isDisjoint(with: cityAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://swift.bootcss.com/">Swift 编程语言中文教程</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发中的 Self-Manager 模式</title>
      <link href="/2022/03/07/Self-Manager%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/03/07/Self-Manager%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>赋予一个 Widget 更大的权利，让其自己负责自己的事件</p></blockquote><span id="more"></span><h2 id="负责展示头像的视图"><a href="#负责展示头像的视图" class="headerlink" title="负责展示头像的视图"></a>负责展示头像的视图</h2><h3 id="职责包括"><a href="#职责包括" class="headerlink" title="职责包括"></a>职责包括</h3><ol><li>通过传入的 URL，加载并展示头像图片</li><li>显示一些附属信息，比如大V的标志</li><li>将用户点击头像的事件传递给外层的 View Controller 跳转到用户信息页面</li></ol><h3 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h3><p>这个 Widget 的 API 可以长这个样子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FDAvatarView</span> : <span class="title">UIView</span></span></span><br><span class="line"><span class="comment">// 假设 VIPInfo 是某个 Entity</span></span><br><span class="line">- (<span class="type">void</span>)configureWithAvatarURL:(<span class="built_in">NSURL</span> *)URL VIPInfo:(<span class="type">id</span>)info tapped:(<span class="type">void</span> (^)(<span class="type">void</span>))block;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用这个控件的人只需要调用这个 configure 方法就可以配置入参和事件处理。但随之而来的就是一些蛋疼的问题：</p><ol><li>configure 的调用者是 <code>superview</code>，上面的例子中也就是一个 UITableViewCell，但 Cell 这层并不知道自己的 ViewController 是谁，于是乎还得向上一级传递这个点击事件，直到能获取到 NavigationController，然后 Push 一个用户信息的页面。</li><li>这个 Avatar View 在 App 的各个地方都可能粗线，而且行为一致，那就意味着事件处理的 block，要散落在各个页面中，同时也带来了很多“只是为向上一层级转发事件”的 “Middle Man”</li></ol><p>为解决这个问题，就需要<code>给这个 View 放权</code>，让其自己 Handle 自己的事件，也就是 Self-Managed，为了不破坏 View 的纯洁性，比较好的实践是在 Category 中实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FDAvatarView</span> (<span class="title">FDAvatarViewSelfManager</span>)</span></span><br><span class="line">- (<span class="type">void</span>)selfManagedConfigureWithAvatarURL:(<span class="built_in">NSURL</span> *)URL VIPInfo:(<span class="type">id</span>)info uid:(<span class="built_in">NSString</span> *)uid;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>实现时最好要调用 View 主类提供的 API：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FDAvatarView</span> (<span class="title">FDAvatarViewSelfManager</span>)</span></span><br><span class="line"><span class="comment">// 为后一个页面的创建增加了个 UID 参数</span></span><br><span class="line">- (<span class="type">void</span>)selfManagedConfigureWithAvatarURL:(<span class="built_in">NSURL</span> *)URL VIPInfo:(<span class="type">id</span>)info <span class="built_in">UID</span>:(<span class="built_in">NSString</span> *)<span class="built_in">UID</span> &#123;</span><br><span class="line">    [<span class="keyword">self</span> configureWithAvatarURL:URL VIPInfo:info tapped:^&#123;</span><br><span class="line">    <span class="comment">// 假设 App 结构是 Root -&gt; TabBar -&gt; Navigation -&gt; ViewController</span></span><br><span class="line">        <span class="built_in">UITabBarController</span> *tabBarControler = (<span class="type">id</span>)[<span class="built_in">UIApplication</span>.sharedApplication.delegate.window.rootViewController;</span><br><span class="line">        <span class="built_in">UINavigationController</span> *navigationController = tabBarControler.selectedViewController;</span><br><span class="line">        <span class="comment">// 创建用户信息 View Controller</span></span><br><span class="line">        FDUserProfileViewController *profileViewController = [FDUserProfileViewController viewControllerWithUID:<span class="built_in">UID</span>];</span><br><span class="line">        [navigationController pushViewController:profileViewController animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这里用到了类似 AOP 的思路，添加了对 App 层级的耦合，如果觉得这样的耦合方式不妥的话，也可以封装个全局方法去取到当前顶层的 Navigation Controller。<br>这样，FDAvatarView 的调用者只需要配置入参，其余的它自己全能搞定了，即使 App 内很多处出现头像，逻辑代码也只有一份。</p><h2 id="点赞的按钮"><a href="#点赞的按钮" class="headerlink" title="点赞的按钮"></a>点赞的按钮</h2><h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><ol><li>显示已有的点赞数</li><li>点击按钮后执行一个小动画，点赞数 +1，同时发送网络请求。</li><li>若已经点赞，点击执行反向操作</li><li>若网络请求发送失败，则回退成点击前的状态</li></ol><h3 id="API设计-1"><a href="#API设计-1" class="headerlink" title="API设计"></a>API设计</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FDLikeButton</span> : <span class="title">UIButton</span></span></span><br><span class="line">- (<span class="type">void</span>)configureLikeStatus:(<span class="type">BOOL</span>)likeOrNot count:(<span class="built_in">NSInteger</span>)count animated:(<span class="type">BOOL</span>)animated;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>因为继承自 UIButton，所以外部可以直接设置其 action，就不增加 tappedHandler 的参数了。外部在点击事件中需要调用这个配置方法，播放点赞动画，紧接着发送一个网络请求，若网络请求失败，可以再次调用这个 API 的无动画版本回滚状态。但像上一个例子一样，网络请求和事件处理逻辑相同，但代码却分部在各个页面中，于是给这个 View 增加 Self-Managed 模式的 Category：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FDLikeButton</span> (<span class="title">FDLikeButtonSelfManager</span>)</span></span><br><span class="line">- (<span class="type">void</span>)selfManagedConfigureWithLikeStatus:(<span class="type">BOOL</span>)likeOrNot count:(<span class="built_in">NSInteger</span>)count;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>伪代码的实现如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FDLikeButton</span> (<span class="title">FDLikeButtonSelfManager</span>)</span></span><br><span class="line">- (<span class="type">void</span>)selfManagedConfigureWithLikeStatus:(<span class="type">BOOL</span>)likeOrNot count:(<span class="built_in">NSInteger</span>)count &#123;</span><br><span class="line">    [<span class="keyword">self</span> configureLikeStatus:likeOrNot count:count animated:<span class="literal">NO</span>];</span><br><span class="line">    [<span class="keyword">self</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(likeButtonTapped:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)likeButtonTapped:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="comment">// +1 or -1 with animation</span></span><br><span class="line">    <span class="comment">// Network request ^(NSError *error) &#123;</span></span><br><span class="line">    <span class="comment">//     if (error) &#123;</span></span><br><span class="line">    <span class="comment">//         rollback</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>从设计上，Self-Manager 模式并没有破坏原有的 MVC 结构，上面两个例子中的 View 依然可以不耦合具体业务逻辑的单拿出来用。使用 Category 的方式把应该写在 ViewController 中的代码移动到 View 的文件中，让功能更加的内聚。</p><p><strong>程序的复杂度并不会因哪种酷炫的设计模式所减少，能做到的只是对复杂度的切分和控制</strong>，即：</p><ol><li>让一大坨恶心的代码变成几小坨不那么恶心的代码。</li><li>让恶心的代码只在一个地方恶心。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.sunnyxx.com/2015/12/19/self-manager-pattern-in-ios/">iOS 开发中的 Self-Manager 模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于KVC的一些总结</title>
      <link href="/2022/03/07/%E5%85%B3%E4%BA%8EKVC%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
      <url>/2022/03/07/%E5%85%B3%E4%BA%8EKVC%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<img src="/2022/03/07/%E5%85%B3%E4%BA%8EKVC%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/kvc.png" class="&#x3D;"><span id="more"></span><h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><p>KVC的全称是Key-Value Coding（键值编码），是由<code>NSKeyValueCoding</code>非正式协议启用的一种机制，对象采用这种机制来提供<code>对其属性的间接访问</code>，可以通过字符串来访问一个对象的成员变量或其关联的存取方法（<code>getter</code> or <code>setter</code>）</p><p>KVC还可以访问私有变量</p><p>KVC是许多其他 Cocoa 技术的基础概念，比如 KVO、Cocoa bindings、Core Data、AppleScript-ability 等等</p><h2 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h2><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;         <span class="comment">// 通过 key 来取值</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath; <span class="comment">// 通过 keyPath 来取值</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setValue:(<span class="keyword">nullable</span> <span class="type">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;         <span class="comment">// 通过 key 来赋值</span></span><br><span class="line">- (<span class="type">void</span>)setValue:(<span class="keyword">nullable</span> <span class="type">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath; <span class="comment">// 通过 keyPath 来赋值</span></span><br></pre></td></tr></table></figure><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BankAccount</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span>* currentBalance;              <span class="comment">// An attribute</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) Person* owner;                         <span class="comment">// A to-one relation</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span>&lt; Transaction* &gt;* transactions; <span class="comment">// A to-many relation</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>对于 BankAccount 的实例对象myAccount</p><h4 id="KeyPath"><a href="#KeyPath" class="headerlink" title="KeyPath"></a>KeyPath</h4><p>KVC还支持多级访问，KeyPath用法跟点语法相同。 例如：我们想对myAccount的<code>owner</code>属性的<code>address</code>属性的<code>street</code>属性赋值，其KeyPath为<code>owner.address.street</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myAccount setValue:<span class="string">@&quot;地址&quot;</span> forKeyPath:<span class="string">@&quot;owner.address.street&quot;</span>];</span><br></pre></td></tr></table></figure><h4 id="多值操作"><a href="#多值操作" class="headerlink" title="多值操作"></a>多值操作</h4><p>给定一组Key，获得一组value，以字典的形式返回。该方法为数组中的每个Key调用<code>valueForKey:</code>方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="type">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br></pre></td></tr></table></figure><p>将指定字典中的值设置到消息接收者的属性中，使用字典的Key标识属性。默认实现是为每个键值对调用setValue:forKey:方法 ，会根据需要用nil替换NSNull对象</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setValuesForKeysWithDictionary:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="type">id</span>&gt; *)keyedValues;</span><br></pre></td></tr></table></figure><h2 id="访问集合属性"><a href="#访问集合属性" class="headerlink" title="访问集合属性"></a>访问集合属性</h2><p>可以像访问其它对象一样使用<code>valueForKey:</code>或<code>setValue:forKey:</code>方法来获取或设置集合对象（主要指NSArray和NSSet），当我们要操作集合对象的内容，比如添加或者删除元素时，通过<code>KVC的可变代理方法</code>获取集合代理对象是最有效的。</p><p>根据KVO的实现原理，是在运行时动态生成子类并重写setter方法来达到可以通知所有观察者对象的目的，因此我们<code>对集合对象进行操作是不会触发KVO的</code>。当我们要使用KVO监听集合对象变化时，需要通过KVC的可变代理方法获取集合代理对象，然后对代理对象进行操作。当<code>代理对象的内部对象发生改变时，会触发KVO的监听方法</code>。</p><p>三种不同的代理对象访问的代理方法，每种都有Key和KeyPath两种方法</p><ol><li><p><code>mutableArrayValueForKey</code>: 和 <code>mutableArrayValueForKeyPath</code>:  返回NSMutableArray对象的代理对象。</p></li><li><p><code>mutableSetValueForKey</code>: 和 <code>mutableSetValueForKeyPath</code>: 返回NSMutableSet对象的代理对象。</p></li><li><p><code>mutableOrderedSetValueForKey</code>: 和 <code>mutableOrderedSetValueForKeyPath</code>: 返回NSMutableOrderedSet对象的代理对象</p></li></ol><h2 id="使用集合运算符"><a href="#使用集合运算符" class="headerlink" title="使用集合运算符"></a>使用集合运算符</h2><p>KVC的valueForKeyPath:方法除了可以取出属性值以外，还可以在KeyPath中嵌套集合运算符，来对集合对象进行操作。</p><p>以下是KeyPath集合运算符的格式，主要分为 3 个部分。</p><ul><li>Left key path：左键路径，要操作的集合对象，如果消息接收者就是集合对象，则可以省略 Left 部分；</li><li>Collection operator：集合运算符；</li><li>Right key path：右键路径，要进行运算的集合中的属性。</li></ul><img src="/2022/03/07/%E5%85%B3%E4%BA%8EKVC%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/collectionCal.png" class="&#x3D;"><h3 id="集合运算符主要分为三类："><a href="#集合运算符主要分为三类：" class="headerlink" title="集合运算符主要分为三类："></a>集合运算符主要分为三类：</h3><p>① 聚合运算符：以某种方式合并集合中的对象，并返回右键路径中指定的属性的数据类型匹配的一个对象，一般返回NSNumber实例。<br>② 数组运算符：根据运算符的条件，将符合条件的对象以一个NSArray实例返回。<br>③ 嵌套运算符：处理集合对象中嵌套其他集合对象的情况，并根据运算符返回一个NSArray或NSSet实例。</p><h4 id="聚合运算符"><a href="#聚合运算符" class="headerlink" title="聚合运算符"></a>聚合运算符</h4><p>以某种方式合并集合中的对象，并返回右键路径中指定的属性的数据类型匹配的一个对象，一般返回NSNumber实例</p><p>@avg<br>读取集合中每个元素的右键路径指定的属性，将其转换为double类型 (nil用 0 替代)，并计算这些值的算术平均值。然后将结果以NSNumber实例返回</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算上表中 amount 的平均值。</span></span><br><span class="line"><span class="built_in">NSNumber</span> *transactionAverage = [<span class="keyword">self</span>.transactions valueForKeyPath:<span class="string">@&quot;@avg.amount&quot;</span>];</span><br><span class="line"><span class="comment">// transactionAverage 格式化的结果为 $ 456.54。</span></span><br></pre></td></tr></table></figure><p>@count</p><p>计算集合中的元素个数，以NSNumber实例返回。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算 transactions 集合中的元素个数。</span></span><br><span class="line"><span class="built_in">NSNumber</span> *numberOfTransactions = [<span class="keyword">self</span>.transactions valueForKeyPath:<span class="string">@&quot;@count&quot;</span>];</span><br><span class="line"><span class="comment">// numberOfTransactions 的值为 13。</span></span><br></pre></td></tr></table></figure><blockquote><p>@count运算符比较特别，它不需要写右键路径，即使写了也会被忽略。</p></blockquote><p>@max,@min</p><blockquote><p>@max和@min根据右键路径指定的属性在集合中搜索，搜索使用compare:方法进行比较，许多基础类 (如NSNumber类) 中都有定义。因此，右键路径指定的属性必须能响应compare:消息。搜索忽略值为nil的集合项。可以通过重写compare:方法对搜索过程进行控制。</p></blockquote><h4 id="数组运算符"><a href="#数组运算符" class="headerlink" title="数组运算符"></a>数组运算符</h4><p>根据运算符的条件，将符合条件的对象以一个NSArray实例返回。</p><p>@unionOfObjects</p><p>读取数组中每个元素的右键路径指定的属性，放在一个NSArray实例中并返回。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取集合中的所有 payee 对象。</span></span><br><span class="line"><span class="built_in">NSArray</span> *payees = [<span class="keyword">self</span>.transactions valueForKeyPath:<span class="string">@&quot;@unionOfObjects.payee&quot;</span>];</span><br><span class="line"><span class="comment">// payees 数组包含以下字符串：Green Power, Green Power, Green Power, Car Loan, Car Loan, Car Loan, General Cable, General Cable, General Cable, Mortgage, Mortgage, Mortgage, Animal Hospital。</span></span><br></pre></td></tr></table></figure><p>@distinctUnionOfObjects<br>读取数组中每个元素的右键路径指定的属性，放在一个NSArray实例中，将数组进行去重后返回。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取集合中的所有不同的 payee 对象。</span></span><br><span class="line"><span class="built_in">NSArray</span> *distinctPayees = [<span class="keyword">self</span>.transactions valueForKeyPath:<span class="string">@&quot;@distinctUnionOfObjects.payee&quot;</span>];</span><br><span class="line"><span class="comment">// distinctPayees 数组包含以下字符串：Car Loan, General Cable, Animal Hospital, Green Power, Mortgage。</span></span><br></pre></td></tr></table></figure><blockquote><p>注意： 在使用数组运算符时，如果有任何操作的对象为nil，则valueForKeyPath:方法将引发异常。</p></blockquote><h4 id="嵌套运算符"><a href="#嵌套运算符" class="headerlink" title="嵌套运算符"></a>嵌套运算符</h4><p>处理集合对象中嵌套其他集合对象的情况，并根据运算符返回一个NSArray或NSSet实例</p><p>@unionOfArrays,@distinctUnionOfArrays,@distinctUnionOfSets</p><h3 id="自定义集合运算符"><a href="#自定义集合运算符" class="headerlink" title="自定义集合运算符"></a>自定义集合运算符</h3><h4 id="使用Runtime打印NSArray类的方法列表"><a href="#使用Runtime打印NSArray类的方法列表" class="headerlink" title="使用Runtime打印NSArray类的方法列表"></a>使用Runtime打印NSArray类的方法列表</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)printNSArrayMethods</span><br><span class="line">&#123;</span><br><span class="line">    u_int count;</span><br><span class="line">    Method *methods = class_copyMethodList([<span class="built_in">NSArray</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Method method = methods[i];</span><br><span class="line">        SEL sel = method_getName(method);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%d---%@&quot;</span>, i, <span class="built_in">NSStringFromSelector</span>(sel));</span><br><span class="line">    &#125;</span><br><span class="line">    free(methods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0---mr_isEqualToOutputDevicesArray:</span><br><span class="line">1---mr_containsAnyOf:</span><br><span class="line">2---mr_map:</span><br><span class="line">3---sg_enumerateChunksOfSize:usingBlock:</span><br><span class="line">4---_pas_mappedArrayWithTransform:</span><br><span class="line">5---_pas_shuffledArrayUsingRng:</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h4 id="获取NSArray中的中位数"><a href="#获取NSArray中的中位数" class="headerlink" title="获取NSArray中的中位数"></a>获取NSArray中的中位数</h4><p>为NSArray添加一个分类，并定义一个_medianForKeyPath:方法，用来获取NSArray中的中位数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span> (<span class="title">HTOperator</span>)</span></span><br><span class="line">- (<span class="built_in">NSNumber</span> *)_medianForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;NSArray+HTOperator.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSArray</span> (<span class="title">HTOperator</span>)</span></span><br><span class="line">- (<span class="built_in">NSNumber</span> *)_medianForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="built_in">NSArray</span> *sortedArray = [<span class="keyword">self</span> sortedArrayUsingSelector:<span class="keyword">@selector</span>(compare:)];</span><br><span class="line">    <span class="type">double</span> median;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSInteger</span> index1 = sortedArray.count * <span class="number">0.5</span>;</span><br><span class="line">        <span class="built_in">NSInteger</span> index2 = sortedArray.count * <span class="number">0.5</span> - <span class="number">1</span>;</span><br><span class="line">        median = ([[sortedArray objectAtIndex:index1] doubleValue] + [[sortedArray objectAtIndex:index2] doubleValue]) * <span class="number">0.5</span>;        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSInteger</span> index = (sortedArray.count<span class="number">-1</span>) * <span class="number">0.5</span>;</span><br><span class="line">        median = [[sortedArray objectAtIndex:index] doubleValue];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSNumber</span> numberWithDouble:median];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[@<span class="number">9</span>, @<span class="number">7</span>, @<span class="number">8</span>, @<span class="number">2</span>, @<span class="number">6</span>, @<span class="number">3</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *num = [array valueForKeyPath:<span class="string">@&quot;@median.self&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%f&quot;</span>,[num doubleValue]);</span><br><span class="line"><span class="comment">// 6.500000</span></span><br></pre></td></tr></table></figure><h2 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h2><p>可以在使用KVC赋值前验证能否为这个key赋值指定value。</p><p><code>validateValue</code>方法的默认实现是查看消息接收者类中是否实现了遵循命名规则为<code>validate&lt;Key&gt;:error:</code>的方法，如果有的话就返回调用该方法的结果；如果没有的话，则默认验证成功并返回YES。我们可以在消息接收者类中实现<code>validate&lt;Key&gt;:error:</code>的方法来自定义逻辑返回YES或NO</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)validateValue:(<span class="type">id</span>  _Nullable *)value </span><br><span class="line">               forKey:(<span class="built_in">NSString</span> *)key </span><br><span class="line">                error:(<span class="built_in">NSError</span> * _Nullable *)error;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)validateValue:(<span class="keyword">inout</span> <span class="type">id</span>  _Nullable *)ioValue </span><br><span class="line">           forKeyPath:(<span class="built_in">NSString</span> *)inKeyPath </span><br><span class="line">                error:(<span class="keyword">out</span> <span class="built_in">NSError</span> * _Nullable *)outError;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，KVC是不会自动验证属性的。</p></blockquote><h2 id="搜索规则"><a href="#搜索规则" class="headerlink" title="搜索规则"></a>搜索规则</h2><p>除了了解KVC的使用，了解KVC取值和赋值过程的工作原理也是很有必要的。</p><h3 id="基本的-Getter-搜索模式"><a href="#基本的-Getter-搜索模式" class="headerlink" title="基本的 Getter 搜索模式"></a>基本的 Getter 搜索模式</h3><p>以下是valueForKey:方法的默认实现，给定一个key作为输入参数，在消息接收者类中操作，执行以下过程。</p><p>① 按照get<Key>、<key>、is<Key>、_<key>顺序查找方法。<br>如果找到就调用取值并执行⑤，否则执行②；<br>② 查找countOf<Key>、objectIn<Key>AtIndex:、<key>AtIndexes:命名的方法。<br>如果找到第一个和后面两个中的至少一个，则创建一个能够响应所有NSArray的方法的集合代理对象（类型为NSKeyValueArray，继承自NSArray），并返回该对象。否则执行③；</p><p>代理对象随后将其接收到的任何NSArray消息转换为countOf<Key>、objectIn<Key>AtIndex:、<Key>AtIndexes:消息的组合，并将其发送给KVC调用方。如果原始对象还实现了一个名为get<Key>:range:的可选方法，则代理对象也会在适当时使用该方法。<br>当KVC调用方与代理对象一起工作时，允许底层属性的行为如同NSArray一样，即使它不是NSArray。</p><p>③ 查找countOf<Key>、enumeratorOf<Key>、memberOf<Key>:命名的方法。<br>如果三个方法都找到，则创建一个能够响应所有NSSet的方法的集合代理对象（类型为NSKeyValueSet，继承自NSSet），并返回该对象。否则执行④；</p><p>代理对象随后将其接收到的任何NSSet消息转换为countOf<Key>、enumeratorOf<Key>、memberOf<Key>:消息的组合，并将其发送给KVC调用方。<br>当KVC调用方与代理对象一起工作时，允许底层属性的行为如同NSSet一样，即使它不是NSSet。</p><p>④ 查看消息接收者类的+accessInstanceVariablesDirectly方法的返回值（默认返回YES）。如果返回YES，就按照_<key>、_is<Key>、<key>、is<Key>顺序查找成员变量。如果找到就直接取值并执行⑤，否则执行⑥。如果+accessInstanceVariablesDirectly方法返回NO也执行⑥。<br>⑤ 如果取到的值是一个对象指针，即获取的是对象，则直接将对象返回。</p><p>如果取到的值是一个NSNumber支持的数据类型，则将其存储在NSNumber实例并返回。<br>如果取到的值不是一个NSNumber支持的数据类型，则转换为NSValue对象, 然后返回。</p><p>⑥ 调用valueForUndefinedKey:方法，该方法抛出异常NSUnknownKeyException，并导致程序Crash。这是默认实现，我们可以重写该方法根据特定key做一些特殊处理。</p><h3 id="基本的-Setter-搜索模式"><a href="#基本的-Setter-搜索模式" class="headerlink" title="基本的 Setter 搜索模式"></a>基本的 Setter 搜索模式</h3><p>以下是setValue:forKey:方法的默认实现，给定key和value作为输入参数，尝试将KVC调用方的属性名为key的值设置为value，执行以下过程。</p><p>① 按照set<Key>:、<em>set<Key>:顺序查找方法。<br>如果找到就调用并将value传进去（根据需要进行数据类型转换），否则执行②。<br>② 查看消息接收者类的+accessInstanceVariablesDirectly方法的返回值（默认返回YES）。如果返回YES，就按照</em><key>、_is<Key>、<key>、is<Key>顺序查找成员变量（同 基本的 Getter 搜索模式）。如果找到就将value赋值给它（根据需要进行数据类型转换），否则执行③。如果+accessInstanceVariablesDirectly方法返回NO也执行③。<br>③ 调用setValue:forUndefinedKey:方法，该方法抛出异常NSUnknownKeyException，并导致程序Crash。这是默认实现，我们可以重写该方法根据特定key做一些特殊处理。</p><h3 id="NSMutableArray-搜索模式"><a href="#NSMutableArray-搜索模式" class="headerlink" title="NSMutableArray 搜索模式"></a>NSMutableArray 搜索模式</h3><p>以下是mutableArrayValueForKey:方法的默认实现，给定一个key作为输入参数，返回属性名为key的集合的代理对象（这里指NSMutableArray对象），在消息接收者类中操作，执行以下过程。</p><p>① 查找一对方法insertObject:in<Key>AtIndex:和removeObjectFrom<Key>AtIndex:<br>（相当于NSMutableArray的原始方法insertObject:atIndex:和removeObjectAtIndex:），<br>或者insert<Key>:atIndexes:和remove<Key>AtIndexes:<br>（相当于NSMutableArray的原始方法insertObjects:atIndexes:和removeObjectsAtIndexes:）。</p><p>如果我们至少实现了一个insertion方法和一个removal方法，则返回一个代理对象，来响应发送给NSMutableArray的消息，通过发送insertObject:in<Key>AtIndex:、removeObjectFrom<Key>AtIndex:、insert<Key>:atIndexes:、remove<Key>AtIndexes:组合消息给KVC调用方。否则执行②。</p><blockquote><p>该代理对象类型为NSKeyValueFastMutableArray2，继承链为NSKeyValueFastMutableArray2-&gt;NSKeyValueFastMutableArray-&gt;NSKeyValueMutableArray-&gt;NSMutableArray。</p></blockquote><p>如果我们也实现了一个可选的replace object方法，如replaceObjectIn<Key>AtIndex:withObject:或replace<Key>AtIndexes:with<Key>:，代理对象在适当的情况下也会使用它们，以获得最佳性能。</p><p>② 查找set<Key>:方法。<br>如果找到，就会向KVC调用方发送一个set<Key>:消息，来返回一个响应NSMutableArray消息的代理对象。否则执行③。</p><p>该代理对象类型为NSKeyValueSlowMutableArray，继承链为NSKeyValueSlowMutableArray-&gt;NSKeyValueMutableArray-&gt;NSMutableArray。</p><p>注意：<br>此步骤中描述的机制比上一步的效率低得多，因为它可能重复创建新的集合对象，而不是修改现有的集合对象。因此，在设计自己的键值编码兼容对象时，通常应该避免使用它。<br>给代理对象发送NSMutableArray消息都会调用set<Key>:方法。即，对代理对象进行修改，都是调用set<Key>:来重新赋值，所以效率会低很多。</p><p>③ 查看消息接收者类的+accessInstanceVariablesDirectly方法的返回值（默认返回YES）。如果返回YES，就按照_<key>、<key>顺序查找成员变量。如果找到就返回一个代理对象，该代理对象将接收所有NSMutableArray消息，通常是NSMutableArray或其子类。否则执行④。如果+accessInstanceVariablesDirectly方法返回NO也执行④。</p><p>④ 返回一个可变的集合代理对象。当它接收到NSMutableArray消息时，发送一个valueForUndefinedKey:消息给KVC调用方，该方法抛出异常NSUnknownKeyException，并导致程序Crash。这是默认实现，我们可以重写该方法根据特定key做一些特殊处理。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>① 根据KVC搜索规则，当没有搜索到对应的key或者keyPath相关方法或者变量时，会调用对应的异常方法<code>valueForUndefinedKey</code>:或<code>setValue:forUndefinedKey:</code>，这两个方法的默认实现是抛出异常NSUnknownKeyException，并导致程序Crash。我们可以重写这两个方法来处理异常</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">void</span>)setValue:(<span class="keyword">nullable</span> <span class="type">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><p>② 当进行赋值如setValue:forKey:时，如果key的数据类型是非对象类型，则value就禁止传nil。否则会调用<code>setNilValueForKey:</code>方法，该方法的默认实现是抛出异常<code>NSInvalidArgumentException</code>，并导致程序Crash。我们可以重写这个方法来处理异常。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setNilValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@&quot;hidden&quot;</span>]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setValue:@(<span class="literal">NO</span>) forKey:@”hidden”];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="variable language_">super</span> setNilValueForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904082415550477">iOS - 关于 KVC 的一些总结</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Runtime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS组件化之Target-Action方案</title>
      <link href="/2022/03/05/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B9%8BTarget-Action%E6%96%B9%E6%A1%88/"/>
      <url>/2022/03/05/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B9%8BTarget-Action%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<img src="/2022/03/05/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B9%8BTarget-Action%E6%96%B9%E6%A1%88/moduleStart.png" class="&#x3D;"><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="蘑菇街组件化方案"><a href="#蘑菇街组件化方案" class="headerlink" title="蘑菇街组件化方案"></a>蘑菇街组件化方案</h3><ol><li>App启动时实例化各组件模块，然后这些组件向ModuleManager注册Url，有些时候不需要实例化，使用class注册。</li><li>当组件A需要调用组件B时，向ModuleManager传递URL，参数跟随URL以GET方式传递，类似openURL。然后由ModuleManager负责调度组件B，最后完成任务。</li></ol><p><strong>问题</strong></p><ol><li>第一步的问题在于，在组件化的过程中，注册URL并不是充分必要条件，组件是不需要向组件管理器注册Url的。而且注册了Url之后，会造成不必要的内存常驻，如果只是注册Class，内存常驻量就小一点，如果是注册实例，内存常驻量就大了。不过这还并不能算是致命错误，只能算是小缺陷。</li></ol><blockquote><p>注册URL的目的其实是一个服务发现的过程，在iOS领域中，服务发现的方式是不需要通过主动注册的，使用runtime就可以了。因为iOS会把所有的文件进行编译，不像静态语言，只编译链接需要的文件。</p></blockquote><ol start="2"><li>真正的致命错误在第二步。在iOS领域里，一定是组件化的中间件为openUrl提供服务，而不是openUrl方式为组件化提供服务。</li></ol><blockquote><p>一个App的组件化方案一定不是建立在URL上的，openURL的跨App调用是可以建立在组件化方案上的</p></blockquote><h2 id="casa-方案"><a href="#casa-方案" class="headerlink" title="casa 方案"></a>casa 方案</h2><img src="/2022/03/05/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B9%8BTarget-Action%E6%96%B9%E6%A1%88/targetAction.png" class="&#x3D;"><p>基于Mediator模式和Target-Action模式，中间采用了runtime来完成调用。这套组件化方案将远程应用调用和本地应用调用做了拆分，而且是由本地应用调用为远程应用调用提供服务</p><h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><h4 id="本地应用调用"><a href="#本地应用调用" class="headerlink" title="本地应用调用"></a>本地应用调用</h4><p>本地组件A在某处调用<code>[[CTMediator sharedInstance] performTarget:targetName action:actionName params:@&#123;...&#125;]</code>向CTMediator发起跨组件调用，CTMediator根据获得的target和action信息，通过objective-C的runtime转化生成target实例以及对应的action选择子，然后最终调用到目标业务提供的逻辑，完成需求。</p><h4 id="远程应用调用"><a href="#远程应用调用" class="headerlink" title="远程应用调用"></a>远程应用调用</h4><p>远程应用通过<code>openURL</code>的方式，由iOS系统根据<code>info.plist</code>里的<code>scheme</code>配置找到可以响应URL的应用（在当前我们讨论的上下文中，这就是你自己的应用），应用通过AppDelegate接收到URL之后，调用CTMediator的openUrl:方法将接收到的URL信息传入。当然，CTMediator也可以用openUrl:options:的方式顺便把随之而来的option也接收，这取决于你本地业务执行逻辑时的充要条件是否包含option数据。传入URL之后，CTMediator通过解析URL，将请求路由到对应的target和action，随后的过程就变成了上面说过的<code>本地应用</code>调用的过程了，最终完成响应。</p><blockquote><p>App中做路由解析可以做得简单点，制定URL规范就也能完成，最简单的方式就是scheme:&#x2F;&#x2F;target&#x2F;action这种，简单做个字符串处理就能把target和action信息从URL中提取出来了</p></blockquote><h3 id="组件仅通过Action暴露可调用接口"><a href="#组件仅通过Action暴露可调用接口" class="headerlink" title="组件仅通过Action暴露可调用接口"></a>组件仅通过Action暴露可调用接口</h3><p>模块与模块之间的接口被固化在了Target-Action这一层，避免了实施组件化的改造过程中，对Business的侵入，同时也提高了组件化接口的可维护性</p><img src="/2022/03/05/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B9%8BTarget-Action%E6%96%B9%E6%A1%88/actionInterface.png" class="&#x3D;"><blockquote><p>虚线圈起来的地方就是用于跨组件调用的target和action，这种方式避免了由BusinessA直接提供组件间调用会增加的复杂度，而且任何组件如果想要对外提供调用服务，直接挂上target和action就可以了，业务本身在大多数场景下去进行组件化改造时，是基本不用动的。</p></blockquote><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p><code>复杂参数</code>是指由普通类型的数据组成的多层级参数。在本文中，我们定义只要是能够被json解析的类型就都是普通类型</p><p><code>非常规参数</code>是指由普通类型以外的类型组成的参数，例如UIImage等这些不能够被json解析的类型。</p><h3 id="去model设计"><a href="#去model设计" class="headerlink" title="去model设计"></a>去model设计</h3><p>组件间调用时，是需要针对参数做去model化的。如果组件间调用不对参数做去model化的设计，就会导致业务形式上被组件化了，实质上依然没有被独立。</p><h4 id="为什么要去Model"><a href="#为什么要去Model" class="headerlink" title="为什么要去Model"></a>为什么要去Model</h4><p>假设模块A和模块B之间采用model化的方案去调用，那么调用方法时传递的参数就会是一个对象</p><p><strong>对象不是一个面向接口的通用对象</strong></p><p>mediator的参数处理就会非常复杂，因为要区分不同的对象类型。如果mediator不处理参数，直接将对象以范型的方式转交给模块B，那么模块B必然要包含对象类型的声明。假设对象声明放在模块A，那么B和A之间的组件化只是个形式主义。如果对象类型声明放在mediator，那么对于B而言，就不得不依赖mediator。但是，大家可以从上面的架构图中看到，对于响应请求的模块而言，依赖mediator并不是必要条件，因此这种依赖是完全不需要的，这种依赖的存在对于架构整体而言，是一种污染。</p><p><strong>参数是一个面向接口的对象</strong><br>mediator对于这种参数的处理其实就没必要了，更多的是直接转给响应方的模块。而且接口的定义就不可能放在发起方的模块中了，只能放在mediator中。响应方如果要完成响应，就也必须要依赖mediator，然而前面我已经说过，响应方对于mediator的依赖是不必要的，因此参数其实也并不适合以面向接口的对象的方式去传递。</p><h4 id="去Model化带来的问题"><a href="#去Model化带来的问题" class="headerlink" title="去Model化带来的问题"></a>去Model化带来的问题</h4><p>去model化的方式去传递，在iOS的开发中，就是以字典的方式去传递。这样就能够做到只有调用方依赖mediator，而响应方不需要依赖mediator。然而在去model化的实践中，由于这种方式自由度太大，我们至少需要保证调用方生成的参数能够被响应方理解，然而在组件化场景中，限制去model化方案的自由度的手段，相比于网络层和持久层更加容易得多。</p><p>因为组件化天然具备了限制手段：参数不对就无法调用！无法调用时直接debug就能很快找到原因。所以接下来要解决的去model化方案的另一个问题就是：如何提高开发效率。</p><p>在去model的组件化方案中，影响效率的点有两个：</p><ol><li>调用方如何知道接收方需要哪些key的参数？</li><li>调用方如何知道有哪些target可以被调用？</li></ol><h4 id="使用category解决"><a href="#使用category解决" class="headerlink" title="使用category解决"></a>使用category解决</h4><p>为什么是category而不是其他：</p><ol><li>category本身就是一种装饰模式，根据不同的分类提供不同的方法，此时每一个组件就是一个分类，因此把每个组件可以支持的调用用category封装是很合理的。</li><li>在category的方法中可以做到参数的验证，在架构中对于保证参数安全是很有必要的。当参数不对时，category就提供了补救的入口。</li><li>category可以很轻松地做请求转发，如果不采用category，请求转发逻辑就非常难做了。</li><li>category统一了所有的组件间调用入口，因此无论是在调试还是源码阅读上，都为工程师提供了极大的方便。</li><li>由于category统一了所有的调用入口，使得在跨模块调用时，对于param的hardcode在整个App中的作用域仅存在于category中，在这种场景下的hardcode就已经变成和调用宏或者调用声明没有任何区别了，因此是可以接受的。</li></ol><p><strong><a href="https://github.com/casatwy/CTMediator">demo</a></strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (indexPath.row == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">UIViewController</span> *viewController = [[<span class="built_in">CTMediator</span> sharedInstance] <span class="built_in">CTMediator_viewControllerForDetail</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得view controller之后，在这种场景下，到底push还是present，其实是要由使用者决定的，mediator只要给出view controller的实例就好了</span></span><br><span class="line">        [<span class="keyword">self</span> presentViewController:viewController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (indexPath.row == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">UIViewController</span> *viewController = [[<span class="built_in">CTMediator</span> sharedInstance] <span class="built_in">CTMediator_viewControllerForDetail</span>];</span><br><span class="line">        [<span class="keyword">self</span>.navigationController pushViewController:viewController animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (indexPath.row == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 这种场景下，很明显是需要被present的，所以不必返回实例，mediator直接present了</span></span><br><span class="line">        [[<span class="built_in">CTMediator</span> sharedInstance] <span class="built_in">CTMediator_presentImage</span>:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;image&quot;</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (indexPath.row == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 这种场景下，参数有问题，因此需要在流程中做好处理</span></span><br><span class="line">        [[<span class="built_in">CTMediator</span> sharedInstance] <span class="built_in">CTMediator_presentImage</span>:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (indexPath.row == <span class="number">4</span>) &#123;</span><br><span class="line">        [[<span class="built_in">CTMediator</span> sharedInstance] <span class="built_in">CTMediator_showAlertWithMessage</span>:<span class="string">@&quot;casa&quot;</span> cancelAction:<span class="literal">nil</span> confirmAction:^(<span class="built_in">NSDictionary</span> *info) &#123;</span><br><span class="line">            <span class="comment">// 做你想做的事</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, info);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://casatwy.com/iOS-Modulization.html">iOS应用架构谈 组件化方案</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Alamofire 5 使用</title>
      <link href="/2022/02/28/Alamofire%205%20%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/02/28/Alamofire%205%20%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>可链接的请求&#x2F;响应函数</li><li>URL &#x2F; JSON 参数编码</li><li>上传文件 &#x2F; Data &#x2F; 流 &#x2F; 多表单数据</li><li>使用请求或者恢复数据下载文件</li><li>使用 URLCredential 进行身份验证</li><li>HTTP 响应验证</li><li>带有进度的上传和下载闭包</li><li>cURL 命令的输出</li><li>动态调整和重试请求</li><li>TLS 证书和公钥固定</li><li>网络可达性</li><li>全面的单元和集成测试覆盖率</li></ul><blockquote><p>AF ，它是对 Session.default 的引用。</p></blockquote><span id="more"></span><h2 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AF</span>.request(<span class="string">&quot;https://httpbin.org/get&quot;</span>).response &#123; response <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">debugPrint</span>(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上是 Alamofire Session 类型上用于发出请求的两个顶层 APIs 的一种形式。它的完整定义如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">request</span>&lt;<span class="type">Parameters</span>: <span class="type">Encodable</span>&gt;(</span><br><span class="line">    <span class="keyword">_</span> <span class="params">convertible</span>: <span class="type">URLConvertible</span>,</span><br><span class="line">    <span class="params">method</span>: <span class="type">HTTPMethod</span> <span class="operator">=</span> .get,</span><br><span class="line">    <span class="params">parameters</span>: <span class="type">Parameters</span>? <span class="operator">=</span> <span class="literal">nil</span>,</span><br><span class="line">    <span class="params">encoder</span>: <span class="type">ParameterEncoder</span> <span class="operator">=</span> <span class="type">URLEncodedFormParameterEncoder</span>.default,</span><br><span class="line">    <span class="params">headers</span>: <span class="type">HTTPHeaders</span>? <span class="operator">=</span> <span class="literal">nil</span>,</span><br><span class="line">    <span class="params">interceptor</span>: <span class="type">RequestInterceptor</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">) -&gt; <span class="type">DataRequest</span></span><br></pre></td></tr></table></figure><p>此方法创建一个 DataRequest，同时允许组合来自各个组件（如 method 和 headers ）的请求，同时还允许每个传入 RequestInterceptors 和 Encodable 参数。</p><p>这个 API 的第二个版本要简单得多：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">request</span>(</span><br><span class="line">    <span class="keyword">_</span> <span class="params">urlRequest</span>: <span class="type">URLRequestConvertible</span>,</span><br><span class="line">    <span class="params">interceptor</span>: <span class="type">RequestInterceptor</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">) -&gt; <span class="type">DataRequest</span></span><br></pre></td></tr></table></figure><p>此方法为遵循 Alamofire 的 URLRequestConvertible 协议的任何类型创建 DataRequest 。所有不同于前一版本的参数都封装在该值中，这会产生非常强大的抽象。</p><h3 id="请求参数和参数编码器"><a href="#请求参数和参数编码器" class="headerlink" title="请求参数和参数编码器"></a>请求参数和参数编码器</h3><p>Alamofire 支持将任何 <code>Encodable</code> 类型作为请求的参数。然后，这些参数通过遵循 <code>ParameterEncoder</code> 协议的类型传递，并添加到 URLRequest 中，然后通过网络发送。Alamofire 包含两种遵循 ParameterEncoder 的类型：<code>JSONParameterEncoder</code> 和 <code>URLEncodedFormParameterEncoder</code> 。这些类型涵盖了现代服务使用的最常见的编码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Login</span>: <span class="title class_">Encodable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> email: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> password: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> login <span class="operator">=</span> <span class="type">Login</span>(email: <span class="string">&quot;test@test.test&quot;</span>, password: <span class="string">&quot;testPassword&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">AF</span>.request(<span class="string">&quot;https://httpbin.org/post&quot;</span>,</span><br><span class="line">           method: .post,</span><br><span class="line">           parameters: login,</span><br><span class="line">           encoder: <span class="type">JSONParameterEncoder</span>.default).response &#123; response <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">debugPrint</span>(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="URLEncodedFormParameterEncoder"><a href="#URLEncodedFormParameterEncoder" class="headerlink" title="URLEncodedFormParameterEncoder"></a>URLEncodedFormParameterEncoder</h4><p><code>URLEncodedFormParameterEncoder</code> 将值编码为 URL 编码字符串，以将其设置为或附加到任何现有 URL 查询字符串，或设置为请求的 HTTP body。通过设置编码的目的地，可以控制编码字符串的设置位置。<code>URLEncodedFormParameterEncoder.Destination</code> 枚举有三种情况：</p><ol><li><code>.methodDependent</code> - 对于 .<code>get</code>、.<code>head</code>、.<code>delete</code> 请求，它会将已编码查询字符串应用到现有的查询字符串中；对于其他类型的请求，会将其设置为 <code>HTTP body</code>。</li><li>.<code>queryString</code> - 将编码字符串设置或追加到请求的 URL 中。</li><li>.<code>httpBody</code> - 将编码字符串设置为 <code>URLRequest</code> 的 HTTP body。</li></ol><p>如果尚未设置 <code>Content-Type</code>，那么会把具有 HTTP body 的已编码请求的 HTTP header 设置为 <code>application/x-www-form-urlencoded; charset=utf-8</code></p><p>在内部，<code>URLEncodedFormParameterEncoder</code> 使用 <code>URLEncodedFormEncoder</code> 把 <code>Encodable</code> 类型编码为 URL 编码形式的 <code>String</code>。此编码器可用于自定义各种类型的编码，包括使用 <code>ArrayEncoding</code> 的 <code>Array</code>、使用 <code>BoolEncoding</code> 的<code>Bool</code>、使用 <code>DataEncoding</code> 的 <code>Data</code>、使用 <code>DateEncoding</code> 的 <code>Date</code>、使用 <code>KeyEncoding</code> 的 <code>keys</code> 以及使用 <code>SpaceEncoding</code> 的空格。</p><h4 id="使用-URL-编码参数的-GET-请求"><a href="#使用-URL-编码参数的-GET-请求" class="headerlink" title="使用 URL 编码参数的 GET 请求"></a>使用 URL 编码参数的 GET 请求</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parameters <span class="operator">=</span> [<span class="string">&quot;foo&quot;</span>: <span class="string">&quot;bar&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面三种方法都是等价的</span></span><br><span class="line"><span class="type">AF</span>.request(<span class="string">&quot;https://httpbin.org/get&quot;</span>, parameters: parameters) <span class="comment">// encoding defaults to `URLEncoding.default`</span></span><br><span class="line"><span class="type">AF</span>.request(<span class="string">&quot;https://httpbin.org/get&quot;</span>, parameters: parameters, encoder: <span class="type">URLEncodedFormParameterEncoder</span>.default)</span><br><span class="line"><span class="type">AF</span>.request(<span class="string">&quot;https://httpbin.org/get&quot;</span>, parameters: parameters, encoder: <span class="type">URLEncodedFormParameterEncoder</span>(destination: .methodDependent))</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://httpbin.org/get?foo=bar</span></span><br></pre></td></tr></table></figure><h4 id="使用-URL-编码参数的-POST-请求"><a href="#使用-URL-编码参数的-POST-请求" class="headerlink" title="使用 URL 编码参数的 POST 请求"></a>使用 URL 编码参数的 POST 请求</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parameters: [<span class="type">String</span>: [<span class="type">String</span>]] <span class="operator">=</span> [</span><br><span class="line">    <span class="string">&quot;foo&quot;</span>: [<span class="string">&quot;bar&quot;</span>],</span><br><span class="line">    <span class="string">&quot;baz&quot;</span>: [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>],</span><br><span class="line">    <span class="string">&quot;qux&quot;</span>: [<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面三种方法都是等价的</span></span><br><span class="line"><span class="type">AF</span>.request(<span class="string">&quot;https://httpbin.org/post&quot;</span>, method: .post, parameters: parameters)</span><br><span class="line"><span class="type">AF</span>.request(<span class="string">&quot;https://httpbin.org/post&quot;</span>, method: .post, parameters: parameters, encoder: <span class="type">URLEncodedFormParameterEncoder</span>.default)</span><br><span class="line"><span class="type">AF</span>.request(<span class="string">&quot;https://httpbin.org/post&quot;</span>, method: .post, parameters: parameters, encoder: <span class="type">URLEncodedFormParameterEncoder</span>(destination: .httpBody))</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP body: &quot;qux[]=x&amp;qux[]=y&amp;qux[]=z&amp;baz[]=a&amp;baz[]=b&amp;foo[]=bar&quot;</span></span><br></pre></td></tr></table></figure><h4 id="JSONParameterEncoder"><a href="#JSONParameterEncoder" class="headerlink" title="JSONParameterEncoder"></a>JSONParameterEncoder</h4><p><code>JSONParameterEncoder</code> 使用 Swift 的 <code>JSONEncoder</code> 对 <code>Encodable</code> 值进行编码，并将结果设置为 <code>URLRequest</code> 的 <code>httpBody</code>。如果 <code>Content-Type</code> 尚未设置，则将其设置为 <code>application/json</code></p><p><strong>JSON 编码参数的 POST 请求</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parameters: [<span class="type">String</span>: [<span class="type">String</span>]] <span class="operator">=</span> [</span><br><span class="line">    <span class="string">&quot;foo&quot;</span>: [<span class="string">&quot;bar&quot;</span>],</span><br><span class="line">    <span class="string">&quot;baz&quot;</span>: [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>],</span><br><span class="line">    <span class="string">&quot;qux&quot;</span>: [<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="type">AF</span>.request(<span class="string">&quot;https://httpbin.org/post&quot;</span>, method: .post, parameters: parameters, encoder: <span class="type">JSONParameterEncoder</span>.default)</span><br><span class="line"><span class="type">AF</span>.request(<span class="string">&quot;https://httpbin.org/post&quot;</span>, method: .post, parameters: parameters, encoder: <span class="type">JSONParameterEncoder</span>.prettyPrinted)</span><br><span class="line"><span class="type">AF</span>.request(<span class="string">&quot;https://httpbin.org/post&quot;</span>, method: .post, parameters: parameters, encoder: <span class="type">JSONParameterEncoder</span>.sortedKeys)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP body: &#123;&quot;baz&quot;:[&quot;a&quot;,&quot;b&quot;],&quot;foo&quot;:[&quot;bar&quot;],&quot;qux&quot;:[&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]&#125;</span></span><br></pre></td></tr></table></figure><h4 id="手动对URLRequest进行参数编码"><a href="#手动对URLRequest进行参数编码" class="headerlink" title="手动对URLRequest进行参数编码"></a>手动对URLRequest进行参数编码</h4><p><code>ParameterEncoder</code> APIs 也可以在 Alamofire 之外使用，方法是直接在URLRequest 中编码参数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://httpbin.org/get&quot;</span>)<span class="operator">!</span></span><br><span class="line"><span class="keyword">var</span> urlRequest <span class="operator">=</span> <span class="type">URLRequest</span>(url: url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> parameters <span class="operator">=</span> [<span class="string">&quot;foo&quot;</span>: <span class="string">&quot;bar&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> encodedURLRequest <span class="operator">=</span> <span class="keyword">try</span> <span class="type">URLEncodedFormParameterEncoder</span>.default.encode(parameters, into: urlRequest)</span><br></pre></td></tr></table></figure><h2 id="HTTP-Headers"><a href="#HTTP-Headers" class="headerlink" title="HTTP Headers"></a>HTTP Headers</h2><p>Alamofire 包含自己的 <code>HTTPHeaders</code> 类型，这是一种顺序保持且<code>不区分大小写</code>的 HTTP header name&#x2F;value 对的表示。HTTPHeader 类型封装单个 name&#x2F;value 对，并为常用的 headers 提供各种静态值。</p><p>向 Request 添加自定义 HTTPHeaders 就像向 request 方法传递值一样简单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> headers: <span class="type">HTTPHeaders</span> <span class="operator">=</span> [</span><br><span class="line">    <span class="string">&quot;Authorization&quot;</span>: <span class="string">&quot;Basic VXNlcm5hbWU6UGFzc3dvcmQ=&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="type">AF</span>.request(<span class="string">&quot;https://httpbin.org/headers&quot;</span>, headers: headers).responseJSON &#123; response <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">debugPrint</span>(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTTPHeaders 也可以由 HTTPHeader 数组构造：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> headers: <span class="type">HTTPHeaders</span> <span class="operator">=</span> [</span><br><span class="line">    .authorization(username: <span class="string">&quot;Username&quot;</span>, password: <span class="string">&quot;Password&quot;</span>),</span><br><span class="line">    .accept(<span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="type">AF</span>.request(<span class="string">&quot;https://httpbin.org/headers&quot;</span>, headers: headers).responseJSON &#123; response <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">debugPrint</span>(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于不会变的 HTTP headers，建议在 URLSessionConfiguration 上设置它们，以便让它们自动应用于底层 URLSession 创建的任何 URLSessionTask。</p></blockquote><p>默认的 Alamofire <code>Session</code> 为每个 Request 提供一组默认的 headers。其中包括：</p><ul><li>Accept-Encoding，默认为 br;q&#x3D;1.0, gzip;q&#x3D;0.8, deflate;q&#x3D;0.6，根据 RFC 7230 §4.2.3。</li><li>Accept-Language，默认为系统中最多 6 种首选语言，格式为 en;q&#x3D;1.0，根据 RFC 7231 §5.3.5。</li><li>User-Agent，其中包含有关当前应用程序的版本信息。例如：iOS Example&#x2F;1.0 (com.alamofire.iOS-Example; build:1; iOS 13.0.0) Alamofire&#x2F;5.0.0，根据 RFC 7231 §5.5.3。</li></ul><p>如果需要自定义这些 headers，则应创建自定义 <code>URLSessionConfiguration</code>，更新 <code>defaultHTTPHeaders</code> 属性，并将配置应用于新 Session 实例。使用<code>URLSessionConfiguration.af.default</code> 来自定义配置，会保留 Alamofire 的默认 headers。</p><h2 id="响应验证"><a href="#响应验证" class="headerlink" title="响应验证"></a>响应验证</h2><p>如果响应具有不可接受的状态代码或 MIME 类型，则在响应处理程序之前调用 <code>validate() </code>将导致生成错误</p><h3 id="自动验证"><a href="#自动验证" class="headerlink" title="自动验证"></a>自动验证</h3><p><code>validate() </code>API 自动验证状态代码是否在 <code>200..&lt;300</code> 范围内，以及响应的 <code>Content-Type</code> header 是否与请求的 <code>Accept</code> 匹配（如果有提供）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AF</span>.request(<span class="string">&quot;https://httpbin.org/get&quot;</span>).validate().responseJSON &#123; response <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">debugPrint</span>(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手动验证"><a href="#手动验证" class="headerlink" title="手动验证"></a>手动验证</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AF</span>.request(<span class="string">&quot;https://httpbin.org/get&quot;</span>)</span><br><span class="line">    .validate(statusCode: <span class="number">200</span><span class="operator">..&lt;</span><span class="number">300</span>)</span><br><span class="line">    .validate(contentType: [<span class="string">&quot;application/json&quot;</span>])</span><br><span class="line">    .responseData &#123; response <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">switch</span> response.result &#123;</span><br><span class="line">        <span class="keyword">case</span> .success:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Validation Successful&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .failure(error):</span><br><span class="line">            <span class="built_in">print</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h2><p>Alamofire 的 <code>DataRequest</code> 和 <code>DownloadRequest</code> 都有相应的响应类型：<code>DataResponse&lt;Success, Failure: Error&gt;</code> 和 <code>DownloadResponse&lt;Success, Failure: Error&gt;</code>。这两个类型都由两个泛型组成：序列化类型和错误类型。默认情况下，所有响应值都将生成 AFError 错误类型（<code>DataResponse&lt;Success, AFError&gt;</code>）。Alamofire 在其公共 API 中使用了更简单的 <code>AFDataResponse&lt;Success&gt;</code> 和 <code>AFDownloadResponse&lt;Success&gt;</code>，它们总是有 AFError 错误类型。UploadRequest 是 DataRequest 的一个子类，使用相同的 DataResponse 类型。</p><p>处理在 Alamofire 中发出的 DataRequest 或 UploadRequest 的 DataResponse 涉及到链接 response handler，例如 responseJSON 链接到 DataRequest:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AF</span>.request(<span class="string">&quot;https://httpbin.org/get&quot;</span>).responseJSON &#123; response <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">debugPrint</span>(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>responseJSON</code> handler 被添加到 <code>DataRequest</code> 中，以便在 <code>DataRequest</code> 完成后执行。传递给 handler 闭包的参数是从响应属性来的 <code>JSONResponseSerializer</code> 生成的 <code>AFDataResponse&lt;Any&gt;</code> 值。</p><p>此闭包并不阻塞执行以等待服务器的响应，而是作为回调添加，以便在收到响应后处理该响应。请求的结果仅在响应闭包的范围内可用。任何依赖于从服务器接收到的响应或数据的执行都必须在响应闭包中完成。</p><p>默认情况下，Alamofire 包含六个不同的数据响应 handlers，包括：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Response Handler - 未序列化的 Response</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">response</span>(</span><br><span class="line">    <span class="params">queue</span>: <span class="type">DispatchQueue</span> <span class="operator">=</span> .main,</span><br><span class="line">    <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">AFDataResponse</span>&lt;<span class="type">Data</span>?&gt;) -&gt; <span class="type">Void</span></span><br><span class="line">) -&gt; <span class="keyword">Self</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Response Serializer Handler - Serialize using the passed Serializer</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">response</span>&lt;<span class="type">Serializer</span>: <span class="type">DataResponseSerializerProtocol</span>&gt;(</span><br><span class="line">    <span class="params">queue</span>: <span class="type">DispatchQueue</span> <span class="operator">=</span> .main,</span><br><span class="line">    <span class="params">responseSerializer</span>: <span class="type">Serializer</span>,</span><br><span class="line">    <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">AFDataResponse</span>&lt;<span class="type">Serializer</span>.<span class="type">SerializedObject</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line">) -&gt; <span class="keyword">Self</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Response Data Handler - Serialized into Data</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">responseData</span>(</span><br><span class="line">    <span class="params">queue</span>: <span class="type">DispatchQueue</span> <span class="operator">=</span> .main,</span><br><span class="line">    <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">AFDataResponse</span>&lt;<span class="type">Data</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line">) -&gt; <span class="keyword">Self</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Response String Handler - Serialized into String</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">responseString</span>(</span><br><span class="line">    <span class="params">queue</span>: <span class="type">DispatchQueue</span> <span class="operator">=</span> .main,</span><br><span class="line">    <span class="params">encoding</span>: <span class="type">String</span>.<span class="type">Encoding</span>? <span class="operator">=</span> <span class="literal">nil</span>,</span><br><span class="line">    <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">AFDataResponse</span>&lt;<span class="type">String</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line">) -&gt; <span class="keyword">Self</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Response JSON Handler - Serialized into Any Using JSONSerialization</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">responseJSON</span>(</span><br><span class="line">    <span class="params">queue</span>: <span class="type">DispatchQueue</span> <span class="operator">=</span> .main,</span><br><span class="line">    <span class="params">options</span>: <span class="type">JSONSerialization</span>.<span class="type">ReadingOptions</span> <span class="operator">=</span> .allowFragments,</span><br><span class="line">    <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">AFDataResponse</span>&lt;<span class="keyword">Any</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line">) -&gt; <span class="keyword">Self</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Response Decodable Handler - Serialized into Decodable Type</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">responseDecodable</span>&lt;<span class="type">T</span>: <span class="type">Decodable</span>&gt;(</span><br><span class="line">    <span class="params">of</span> <span class="params">type</span>: <span class="type">T</span>.<span class="keyword">Type</span> <span class="operator">=</span> <span class="type">T</span>.<span class="keyword">self</span>,</span><br><span class="line">    <span class="params">queue</span>: <span class="type">DispatchQueue</span> <span class="operator">=</span> .main,</span><br><span class="line">    <span class="params">decoder</span>: <span class="type">DataDecoder</span> <span class="operator">=</span> <span class="type">JSONDecoder</span>(),</span><br><span class="line">    <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">AFDataResponse</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line">) -&gt; <span class="keyword">Self</span></span><br></pre></td></tr></table></figure><p>没有一个响应 handlers 对从服务器返回的 HTTPURLResponse 执行任何验证。</p><blockquote><p>例如，400..&lt;500 和 500..&lt;600 范围内的响应状态代码不会自动触发错误。Alamofire 使用响应验证链接来实现这一点。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6875140053635432462#heading-37">Alamofire 5 的使用 - 基本用法</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【读书笔记】《Effective Objective-C 2.0》</title>
      <link href="/2022/02/23/%E3%80%8AEffective%20Objective-C%202.0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/23/%E3%80%8AEffective%20Objective-C%202.0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<img src="/2022/02/23/%E3%80%8AEffective%20Objective-C%202.0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/start.png" class="&#x3D;"><img src="/2022/02/23/%E3%80%8AEffective%20Objective-C%202.0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.png" class="&#x3D;"><span id="more"></span><h2 id="第一章：熟悉-Objective-C"><a href="#第一章：熟悉-Objective-C" class="headerlink" title="第一章：熟悉 Objective-C"></a>第一章：熟悉 Objective-C</h2><h3 id="了解-Objective-C-语言的起源"><a href="#了解-Objective-C-语言的起源" class="headerlink" title="了解 Objective-C 语言的起源"></a>了解 Objective-C 语言的起源</h3><p>OC 的动态性都是由 “运行期组件” ，也就是 Runtime 库（<a href="https://opensource.apple.com/tarballs/objc4/">ObjC4</a>）来实现的，使用 OC 的面向对象特性所需的全部数据结构以及函数都在 ObjC4 里面。</p><p>运行期组件本质上是一种与开发者所编写的代码相链接的<code>动态库</code>（dynamic library），其代码能把开发者所编写的所有程序粘合起来，所以只要更新运行期组件，就可以提升应用程序性能。</p><h3 id="在类的头文件中尽量少引用其他头文件"><a href="#在类的头文件中尽量少引用其他头文件" class="headerlink" title="在类的头文件中尽量少引用其他头文件"></a>在类的头文件中尽量少引用其他头文件</h3><p>有时，类A需要将类B的实例变量作为它公共API的属性。这个时候，我们不应该引入类B的头文件，而应该使用向前声明（forward declaring）使用class关键字，并且在A的实现文件引用B的头文件。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EOCPerson.h</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">EOCEmployer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *firstName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *lastName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) EOCEmployer *employer;<span class="comment">//将EOCEmployer作为属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EOCPerson.m</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;EOCEmployer.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>优点:<br>不在A的头文件中引入B的头文件，就不会一并引入B的全部内容，这样就减少了编译时间。<br>可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。</p><p>个别的时候，必须在头文件中引入其他类的头文件:</p><ol><li>该类继承于某个类，则应该引入父类的头文件。</li><li>该类遵从某个协议，则应该引入该协议的头文件。而且最好将协议单独放在一个头文件中。</li></ol><h3 id="多用类型常量，少用-define-预处理指令"><a href="#多用类型常量，少用-define-预处理指令" class="headerlink" title="多用类型常量，少用 #define 预处理指令"></a>多用类型常量，少用 #define 预处理指令</h3><ul><li><p>不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。</p></li><li><p>在实现文件中使用 static const 来定义 “只在编译单元内可见的常量”（translation-unit-specific constant）。由于此类常量不在<code>全局符号表</code>中，所以无须为其名称加前缀。</p></li><li><p>在头文件中使用 <code>extern</code> 来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在<code>全局符号表</code>中，所以其名称应加以区隔，通常用与之相关的<code>类名做前缀</code>。</p></li></ul><h4 id="类型常量"><a href="#类型常量" class="headerlink" title="类型常量"></a>类型常量</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure><blockquote><p>static 修饰符意味着该常量只在定义它的 .m 中可见（设置了其使用范围）</p><p>const 修饰符意味着该常量不可修改（不可修改）</p></blockquote><p><strong>类型常量命名法</strong></p><ol><li>如果常量局限于某 “编译单元”（也就是 .m 中），则命名前面加字母 k，比如 <code>kAnimationDuration</code>。</li><li>如果常量在类之外可见，定义成了全局常量，则通常以 类名 作为前缀，比如 <code>EOCViewClassAnimationDuration</code>。</li></ol><p><strong>局部类型常量</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure><ol><li>一定要同时使用 static 和 const 来声明。这样编译器就不会创建符号，而是像预处理指令一样，进行值替换。</li><li>如果试图修改由 const 修饰的变量，编译器就会报错。</li><li>如果不加 static，则编译器就会它创建一个 “外部符号 symbol”。此时如果另一个编译单元中也声明了同名变量，那么编译器就会抛出 “重复定义符号” 的错误：</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">duplicate symbol _kAnimationDuration <span class="keyword">in</span>:</span><br><span class="line">    EOCAnimatedView.o</span><br><span class="line">    EOCOtherView.o</span><br></pre></td></tr></table></figure><ol><li>局部类型常量不放在 “全局符号表” 中，所以无须用类名作为前缀。</li></ol><p><strong>全局类型常量</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In the header file</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> EOCStringConstant;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In the implementation file</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> EOCStringConstant = <span class="string">@&quot;VALUE&quot;</span>;</span><br></pre></td></tr></table></figure><ol><li>此类常量会被放在 <code>“全局符号表”</code> 中，这样才可以在定义该常量的编译单元之外使用。</li><li>const 位置不同则常量类型不同，以上为，定义一个指针常量 <code>EOCStringConstant</code>，指向 NSString 对象。也就是说，<code>EOCStringConstant</code> 不会再指向另一个 NSString 对象。</li><li>extern 是告诉编译器，在 “全局符号表” 中将会有一个名叫 <code>EOCStringConstant</code> 的符号。这样编译器就允许代码使用该常量。因为它知道，当链接成二进制文件后，肯定能找到这个常量。</li><li>必须要定义，而且只能定义一次，通常定义在声明该常量的 .h 的对应的 .m 中。</li><li>在实现文件生成目标文件时（编译器每收到一个 “编译单元” .m，就会输出一份 “目标文件” ），编译器会在 “数据段” 为字符串分配存储空间。链接器会把此目标文件与其他目标文件相链接，以生成最终的二进制文件。凡是用到 <code>EOCStringConstant</code> 这个全局符号的地方，链接器都能将其解析。</li><li>因为符号要放在全局符号表里，所以常量命名需谨慎，为避免名称冲突，一般以类名作为前缀。</li></ol><h2 id="第二章：对象、消息、运行期"><a href="#第二章：对象、消息、运行期" class="headerlink" title="第二章：对象、消息、运行期"></a>第二章：对象、消息、运行期</h2><h3 id="理解-“属性”-这一概念"><a href="#理解-“属性”-这一概念" class="headerlink" title="理解 “属性” 这一概念"></a>理解 “属性” 这一概念</h3><p><code>@synthesize</code> 和 <code>@dynamic</code> </p><ol><li>可以通过<code>@synthesize</code>来指定实例变量名字，如果你不喜欢默认的以下划线开头来命名实例变量的话。但最好还是用默认的，否则别人可能看不懂。</li></ol><p> 如果不想令编译器合成存取方法，则可以自己实现。如果你只实现了其中一个存取方法 <code>setter</code> or <code>getter</code>，那么另一个还是会由编译器来合成。但是需要注意的是，如果你实现了属性所需的全部方法（如果属性是 <code>readwrite</code> 则需实现 <code>setter</code> and <code>getter</code>，如果是 <code>readonly</code> 则只需实现 <code>getter</code> 方法），那么编译器就不会自动进行 <code>@synthesize</code>，这时候就不会生成该属性的实例变量，需要根据实际情况自己手动 <code>@synthesize</code> 一下。</p><p><code>@synthesize name = _myName;</code></p><ol><li><code>@dynamic</code> 会告诉编译器：不要自动创建实现属性所用的实例变量，也不要为其创建存取方法，即告诉编译器你要自己做这些事。当使用了 <code>@dynamic</code>，即使你没有为其实现存取方法，编译器也不会报错，因为你已经告诉它你要自己来做。</li></ol><ul><li>注意：遵循属性定义<br>如果属性定义为<code>copy</code>，那么在非设置方法里设定属性的时候，也要遵循<code>copy</code>的语义</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)initWithFirstName:(<span class="built_in">NSString</span>*)firstName lastName:(<span class="built_in">NSString</span>*)lastName</span><br><span class="line">&#123;</span><br><span class="line">         <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">            _firstName = [firstName <span class="keyword">copy</span>];</span><br><span class="line">            _lastName = [lastName <span class="keyword">copy</span>];</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="理解-“对象等同性”-这一概念"><a href="#理解-“对象等同性”-这一概念" class="headerlink" title="理解 “对象等同性” 这一概念"></a>理解 “对象等同性” 这一概念</h3><p><code>==</code> 操作符比较的是两个指针本身，而不是其所指的对象,应该使用 <code>NSObject</code> 协议中声明的 <code>isEqual</code>: 方法来判断两个对象的等同性。某些对象提供了特殊的“等同性判定方法”，比如 <code>NSString</code> 的 <code>isEqualToString</code>:、<code>NSArray</code> 的 <code>isEqualToArray</code>:、<code>NSDictionary</code> 的 <code>isEqualToDictionary</code>:。</p><h3 id="理解Objective-C错误类型"><a href="#理解Objective-C错误类型" class="headerlink" title="理解Objective-C错误类型"></a>理解Objective-C错误类型</h3><p>用NSError描述错误。 使用NSError可以封装三种信息：</p><ol><li><code>Error domain</code>:错误范围，类型是字符串</li><li><code>Error code</code> :错误码，类型是整数</li><li><code>User info</code>：用户信息，类型是字典</li></ol><h2 id="接口与API设计"><a href="#接口与API设计" class="headerlink" title="接口与API设计"></a>接口与API设计</h2><h3 id="理解-NSCopying-协议"><a href="#理解-NSCopying-协议" class="headerlink" title="理解 NSCopying 协议"></a>理解 NSCopying 协议</h3><ul><li>对 mutable 对象与 immutable 对象 进行 copy 与 mutableCopy 的结果：<img src="/2022/02/23/%E3%80%8AEffective%20Objective-C%202.0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/copy.png" class="&#x3D;"></li></ul><blockquote><p>注：这里的 mutable 对象与 immutable 对象指的是系统类 NSArray、NSDictionary、NSSet、NSString、NSData 与它们的可变版本如 NSMutableArray 等。</p></blockquote><ul><li>以上对 collection 容器对象进行的深浅拷贝是指对容器对象本身的，对 collection 中的对象执行的<code>默认都是浅拷贝</code>。也就是说只拷贝容器对象本身，而不复制其中的数据。主要原因是，容器内的对象未必都能拷贝，而且调用者也未必想在拷贝容器时一并拷贝其中的每个对象。</li></ul><img src="/2022/02/23/%E3%80%8AEffective%20Objective-C%202.0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/collectionCopy.png" class="&#x3D;"><ul><li>如果想要实现对自定义对象的拷贝，需要遵守 NSCopying 协议，并实现 <code>copyWithZone</code>: 方法</li></ul><p>如果要浅拷贝，copyWithZone: 方法就返回同一个对象：return self；<br>如果要深拷贝，copyWithZone: 方法中就创建新对象，并给希望拷贝的属性赋值。</p><ul><li>如果自定义对象支持可变拷贝和不可变拷贝，那么还需要遵守 <code>NSMutableCopying</code> 协议，并实现 <code>mutableCopyWithZone</code>: 方法，返回可变副本。而 <code>copyWithZone</code>: 方法返回不可变副本。使用方可根据需要调用该对象的 <code>copy</code> 或 <code>mutableCopy</code> 方法来进行不可变拷贝或可变拷贝。</li></ul><h3 id="尽量使用不可变对象"><a href="#尽量使用不可变对象" class="headerlink" title="尽量使用不可变对象"></a>尽量使用不可变对象</h3><p>把对外公布出来的属性设置为只读，在实现文件内部设为读写。具体做法是：</p><p>在头文件中，设置对象属性为<code>readonly</code>，在实现文件中设置为<code>readwrite</code>。这样一来，在外部就只能读取该数据，而不能修改它，使得这个类的实例所持有的数据更加安全。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *firstName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *lastName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSSet</span> *friends <span class="comment">//向外公开的不可变集合</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)initWithFirstName:(<span class="built_in">NSString</span>*)firstName lastName:(<span class="built_in">NSString</span>*)lastName;</span><br><span class="line">- (<span class="type">void</span>)addFriend:(EOCPerson*)person;</span><br><span class="line">- (<span class="type">void</span>)removeFriend:(EOCPerson*)person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>在这里，我们将friends属性设置为不可变的set。然后，提供了来增加和删除这个set里的元素的公共接口。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSString</span> *firstName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSString</span> *lastName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCPerson</span> </span>&#123;</span><br><span class="line">     <span class="built_in">NSMutableSet</span> *_internalFriends;  <span class="comment">//实现文件里的可变集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSSet</span>*)friends &#123;</span><br><span class="line">     <span class="keyword">return</span> [_internalFriends <span class="keyword">copy</span>]; <span class="comment">//get方法返回的永远是可变set的不可变型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)addFriend:(EOCPerson*)person &#123;</span><br><span class="line">    [_internalFriends addObject:person]; <span class="comment">//在外部增加集合元素的操作</span></span><br><span class="line">    <span class="comment">//do something when add element</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)removeFriend:(EOCPerson*)person &#123;</span><br><span class="line">    [_internalFriends removeObject:person]; <span class="comment">//在外部移除元素的操作</span></span><br><span class="line">    <span class="comment">//do something when remove element</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)initWithFirstName:(<span class="built_in">NSString</span>*)firstName lastName:(<span class="built_in">NSString</span>*)lastName &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">        _firstName = firstName;</span><br><span class="line">        _lastName = lastName;</span><br><span class="line">        _internalFriends = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在公共接口设置不可变<code>set</code> 和 将增删的代码放在公共接口中是否矛盾的？</li></ul><p>因为如果将<code>friends</code>属性设置为可变的，那么外部就可以随便更改<code>set</code>集合里的数据，这里的更改，仅仅是底层数据的更改，并不伴随其他任何操作。<br>然而有时，我们需要在更改set数据的同时要执行隐秘在实现文件里的其他工作，那么如果在外部随意更改这个属性的话，显然是达不到这种需求的。<br>因此，我们需要提供给外界我们定制的增删的方法，并不让外部”自行“增删。</p><h2 id="协议与分类"><a href="#协议与分类" class="headerlink" title="协议与分类"></a>协议与分类</h2><h3 id="通过委托与数据源协议进行对象间通信"><a href="#通过委托与数据源协议进行对象间通信" class="headerlink" title="通过委托与数据源协议进行对象间通信"></a>通过委托与数据源协议进行对象间通信</h3><p>可以通过委托 （也就是我们平常所说的 “代理 delegate” ）与数据源（data source）协议进行对象间通信。<br>协议中可以定义什么？方法和属性。</p><h4 id="委托模式（代理模式）"><a href="#委托模式（代理模式）" class="headerlink" title="委托模式（代理模式）"></a>委托模式（代理模式）</h4><ul><li><p>代理模式的主旨：<br>定义一个委托协议，若对象想接受另一个对象（委托方）的委托，则需遵守该协议，以成为 “<code>代理方</code>”。而委托方则可以通过协议方法给代理方回传一些信息，也可以在发生相关事件时通知代理方。这样委托方就可以把应对某个行为的责任委托给代理方去处理了。</p></li><li><p>代理的工作流程：</p></li></ul><p>“委托方” 要求 “代理方” 需要实现的接口，全都定义在 “委托协议” 当中；<br>“代理方” 遵守 “协议” 并实现 “协议” 方法；<br>“代理方” 所实现的 “协议” 方法可能会有返回值，将返回值返回给 “委托方” ；<br>“委托方” 调用 “代理方” 遵从的 “协议” 方法。</p><img src="/2022/02/23/%E3%80%8AEffective%20Objective-C%202.0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/delegate.png" class="&#x3D;"><ul><li><p>数据源模式<br>旨在向类提供数据，所以也称 “数据源模式”。<br>数据源模式是用协议定义一套接口，令某类经由该接口获取其所需的数据。</p></li><li><p>数据源模式与常规委托模式的区别在于：<br>数据源模式中，信息从数据源（Data Source）流向类（委托方）；<br>常规委托模式中，信息从类（委托方）流向受委托者（代理方）。</p></li><li><p>通过 UITableView 就可以很好的理解 Data Source 和 Delegate 这两种模式：<br>通过 UITableViewDataSource 协议获取要在列表中显示的数据；<br>通过 UITableViewDelegate 协议来处理用户与列表的交互操作。</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UITableViewDataSource</span>&lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section;</span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView; </span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UITableViewDelegate</span>&lt;<span class="title">NSObject</span>, <span class="title">UIScrollViewDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">-(<span class="type">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>在实现委托模式和数据源模式时，如果协议方法时可选的，那么在调用协议方法时就需要判断其是否能响应。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_delegate &amp;&amp; [_delegate respondsToSelector:<span class="keyword">@selector</span>(networkFetcher:didReceiveData)]) &#123;</span><br><span class="line">    [_delegate networkFetcher:<span class="keyword">self</span> didReceiveData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们需要频繁调用该协议方法，那么仅需要第一次判断是否能响应即可。以上代码可做性能优化，将代理方是否能响应某个协议方法这一信息缓存起来：</p><ol><li>在委托方中嵌入一个含有位域（bitfield，又称 “位段”、“位字段”）的结构体作为其实例变量，而结构体中的每个位域则表示 delegate 对象是否实现了协议中的相关方法。该结构体就是用来缓存代理方是否能响应特定的协议方法的。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCNetworkFetcher</span> () </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> didReceiveData      : <span class="number">1</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> didFailWithError    : <span class="number">1</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> didUpdateProgressTo : <span class="number">1</span>;</span><br><span class="line">    &#125; _delegateFlags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>重写 delegate 属性的 setter 方法，对 _delegateFlags 结构体里的标志进行赋值，实现缓存功能。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setDelegate:(<span class="type">id</span>&lt;EOCNetworkFetcher&gt;)delegate &#123;</span><br><span class="line">    _delegate = delegate;</span><br><span class="line">    _delegateFlags.didReceiveData = [delegate respondsToSelector:<span class="keyword">@selector</span>(networkFetcher:didReceiveData:)];</span><br><span class="line">    _delegateFlags.didFailWithError = [delegate respondsToSelector:<span class="keyword">@selector</span>(networkFetcher:didFailWithError:)];</span><br><span class="line">    _delegateFlags.didUpdateProgressTo = [delegate respondsToSelector:<span class="keyword">@selector</span>(networkFetcher:didUpdateProgressTo:)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>这样每次调用 delegate 的相关方法之前，就不用通过 respondsToSelector: 方法来检测代理方是否能响应特定协议方法了，而是直接查询结构体中的标志，提升了执行速度。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_delegate &amp;&amp; _delegateFlags.didReceiveData) &#123;</span><br><span class="line">    [_delegate networkFetcher:<span class="keyword">self</span> didReceiveData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="用-“僵尸对象”-调试内存管理问题"><a href="#用-“僵尸对象”-调试内存管理问题" class="headerlink" title="用 “僵尸对象” 调试内存管理问题"></a>用 “僵尸对象” 调试内存管理问题</h3><ul><li>向已回收的对象发送消息是不安全的，对象所占内存在 “解除分配(deallocated)” 之后，只是放回可用内存池。如果对象所占内存还没有分配给别人，这时候访问没有问题，如果已经分配给了别人，再次访问就会崩溃。</li></ul><p>这在调试的时候可能不太方便，我们可以通过 “<code>僵尸对象(Zombie Object)</code>” 来更好地调试内存管理问题。</p><ul><li><p>僵尸对象的启用：<br>通过环境变量 <code>NSZombieEnabled</code> 启用 “僵尸对象” 功能。</p></li><li><p>僵尸对象的工作原理：<br>它的实现代码深植与 Objective-C 的运行期库、Foundation 框架及 CoreFoundation 框架中。系统在即将回收对象时，如果发现 <code>NSZombieEnabled == YES</code>，那么就把对象转化为僵尸对象，而不是将其真的回收。接下来给该对象（此时已是僵尸对象）发送消息，就会在控制台打印一条包含消息内容及其接收者的信息（如下），然后终止应用程序。这样我们就能知道在何时何处向业已回收的对象发送消息了。</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[EOCClass message] : message sent to deallocated instance <span class="number">0x7fc821c02a00</span></span><br></pre></td></tr></table></figure><ul><li>僵尸对象的实现原理：</li></ul><ol><li>在启用僵尸对象后，运行期系统就会 swizzle 交换 dealloc 方法实现，当每个对象即将被系统回收时，系统都会为其创建一个 <code>_NSZombie_OriginalClass</code> 类。（<code>OriginalClass</code> 为对象所属类类名，这些类直接由 <code>_NSZombie_</code> 类拷贝而来而不是使用效率更低的继承，然后赋予类新的名字 <code>_NSZombie_OriginalClass</code> 来记住旧类名。记住旧类名是为了在给僵尸对象发送消息时，系统可由此知道该对象原来所属的类。）。<br>然后将对象的 isa 指针指向僵尸类，从而待回收的对象变为僵尸对象。（由于是交换了 dealloc 方法，所有 free() 函数就不会执行，对象所占内存也就不会释放。虽然这样内存泄漏了，但也只是调试手段而已，所以泄漏问题无关紧要）。</li><li>由于 <code>_NSZombie_</code> 类（以及所有从该类拷贝出来的类 <code>_NSZombie_OriginalClass</code>）没有实现任何方法，所以给僵尸对象发送任何消息，都会进入 “完整的消息转发阶段”。而在 “完整的消息转发阶段” 中，<code>__forwarding__</code> 函数是核心。它首先要做的事情包括检查接收消息的对象所属的类名。若前缀为 <code>_NSZombie_</code> 则表明消息接收者是僵尸对象，需要特殊处理：在控制台打印一条信息（信息中指明僵尸对象所接收到的消息、原来所属的类、内存地址等，<code>[OriginalClass message] : message sent to deallocated instance 0x7fc821c02a00</code>），然后终止应用程序。</li></ol><h2 id="块与大中枢派发"><a href="#块与大中枢派发" class="headerlink" title="块与大中枢派发"></a>块与大中枢派发</h2><h3 id="理解-“块”-这一概念"><a href="#理解-“块”-这一概念" class="headerlink" title="理解 “块” 这一概念"></a>理解 “块” 这一概念</h3><p>如果块中没有显式地使用 self 来访问实例变量，那么块就会隐式捕获 self，这很容易在我们不经意间造成循环引用。如下代码，编译器会给出警告，建议用 <code>self-&gt;_anInstanceVariable </code>或 <code>self.anInstanceVariable</code> 来访问。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">    _anInstanceVariable = <span class="string">@&quot;Something&quot;</span>；<span class="comment">// ⚠️ Block implicitly retains ‘self’; explicitly mention ‘self’ to indicate this is intended behavior</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>块的内存布局</strong></p><ul><li>isa 指针指向 Class 对象</li><li>invoke 变量是个函数指针，指向块的实现代码</li><li>descriptor 变量是指向结构体的指针，其中声明了块对象的总体大小，还声明了保留和释放捕获的对象的 copy 和 dispose 这两个函数所对应的函数指针</li><li>块还会把它所捕获的所有变量都拷贝一份，放在 descriptor 变量的后面</li></ul><img src="/2022/02/23/%E3%80%8AEffective%20Objective-C%202.0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/blockMem.png" class="&#x3D;"><h3 id="多用派发队列，少用同步锁"><a href="#多用派发队列，少用同步锁" class="headerlink" title="多用派发队列，少用同步锁"></a>多用派发队列，少用同步锁</h3><ul><li>用锁来实现同步，会有死锁的风险，而且效率也不是很高。而用 GCD 能以更简单、更高效的形式为代码加锁。</li></ul><h4 id="用锁实现同步"><a href="#用锁实现同步" class="headerlink" title="用锁实现同步"></a>用锁实现同步</h4><p><strong>@synchronized</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)synchronizedMethod &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// Safe</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：@synchronized 会根据给定的对象，自动创建一个锁，并等待块中的代码执行完毕，然后释放锁。<br>缺点：滥用 @synchronized(self) 会降低代码效率，因为共用同一个锁的那些同步块，都必须按顺序执行，也就是说所有的 @synchronized(self) 块中的代码之间都同步了。若是在 self 对象上频繁加锁，那么程序可能要等另一段与此无关的代码执行完毕，才能继续执行当前代码，这样做其实并没有必要。</p><p><strong>NSLock等</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)synchronizedMethod &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    <span class="comment">// Safe</span></span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用GCD实现同步"><a href="#用GCD实现同步" class="headerlink" title="用GCD实现同步"></a>用GCD实现同步</h4><p><strong>GCD 串行同步队列</strong><br>将读取操作和写入操作都安排在同一个队列里，即可保证数据同步。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue = dispatch_queue_create(<span class="string">&quot;com.effectiveobjectivec.syncQueue&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">- (<span class="built_in">NSString</span> *)someString &#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *localSomeString;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</span><br><span class="line">        localSomeString = _someString;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> localSomeString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</span><br><span class="line">        _someString = _someString;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以将 setter 方法的代码异步执行。由于 getter 方法需要返回值，所以需要同步执行以阻塞线程来防止提前 return，而 setter 方法不需要返回值所以可以异步执行。<br><code>异步执行时需要拷贝 block</code>，所以这里异步执行是否能提高执行速度取决于 block 任务的繁重程度。如果拷贝 block 的时间超过执行 block 的时间，那么异步执行反而降低效率，而如果 block 任务繁重，那么是可以提高执行速度的。</p><p><strong>GCD 栅栏函数</strong><br>以上虽保证了读写安全，但并不是最优方案，因为读取方法之间同步执行了。<br>保证读写安全，只需满足三个条件即可：</p><ol><li>同一时间，只能有一个线程进行写操作；</li><li>同一时间，允许有多个线程进行读操作；</li><li>同一时间，不允许既有读操作，又有写操作。</li></ol><p>我们可以针对第二点进行优化，让读取方法可以并发执行。使用 GCD 栅栏函数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)someString &#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *localSomeString;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</span><br><span class="line">        localSomeString = _someString;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> localSomeString;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)setSomeString:(<span class="built_in">NSString</span> *)someString &#123;</span><br><span class="line">    <span class="comment">// 这里也可以根据 block 任务繁重程度选择 dispatch_barrier_async</span></span><br><span class="line">    dispatch_barrier_sync(_syncQueue, ^&#123; </span><br><span class="line">        _someString = _someString;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/02/23/%E3%80%8AEffective%20Objective-C%202.0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/GCD.png" class="&#x3D;"><h3 id="多用GCD，少用performSelector系列方法"><a href="#多用GCD，少用performSelector系列方法" class="headerlink" title="多用GCD，少用performSelector系列方法"></a>多用GCD，少用performSelector系列方法</h3><p>NSObject 定义了几个 <code>performSelector</code> 系列方法，可以让开发者随意调用任何方法，可以推迟执行方法调用，也可以指定执行方法的线程等等。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)performSelector:(SEL)aSelector;</span><br><span class="line">- (<span class="type">id</span>)performSelector:(SEL)aSelector withObject:(<span class="type">id</span>)object;</span><br><span class="line">- (<span class="type">id</span>)performSelector:(SEL)aSelector withObject:(<span class="type">id</span>)object1 withObject:(<span class="type">id</span>)object2;</span><br><span class="line">- (<span class="type">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="type">id</span>)arg waitUntilDone:(<span class="type">BOOL</span>)wait;</span><br><span class="line">- (<span class="type">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="type">id</span>)arg waitUntilDone:(<span class="type">BOOL</span>)wait;</span><br><span class="line">- (<span class="type">void</span>)performSelectorInBackground:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="type">id</span>)arg;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><strong>performSelector:方法有什么用处？</strong></p><ol><li>如果你只是用来调用一个方法的话，那么它确实有点多余</li><li>用法一：selector 是在运行期决定的</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SEL selector;</span><br><span class="line"><span class="keyword">if</span> ( <span class="comment">/* some condition */</span> ) &#123;</span><br><span class="line">    selector = <span class="keyword">@selector</span>(foo);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="comment">/* some other condition */</span> ) &#123;</span><br><span class="line">    selector = <span class="keyword">@selector</span>(bar);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    selector = <span class="keyword">@selector</span>(baz);</span><br><span class="line">&#125;</span><br><span class="line">[object performSelector:selector];</span><br></pre></td></tr></table></figure><ol><li>用法二：把 selector 保存起来等某个事件发生后再调用</li></ol><p><strong>performSelector:方法的缺点：</strong></p><ol><li>存在内存泄漏的隐患：<br>由于 selector 在运行期才确定，所以编译器不知道所要执行的 selector 是什么。如果在 ARC 下，编译器会给出警告，提示可能会导致内存泄漏。</li></ol><p>由于编译器不知道所要执行的 selector 是什么，也就不知道其方法名、方法签名及返回值等，所以就没办法运用 ARC 的内存管理规则来判定返回值是不是应该释放。鉴于此，ARC 采用了比较谨慎的做法，就是不添加释放操作，然而这样可能会导致内存泄漏，因为方法在返回对象时可能已经将其保留了。</p><blockquote><p>如果是调用以<code> alloc/new/copy/mutableCopy</code> 开头的方法，创建时就会持有对象，ARC 环境下编译器就会插入 release 方法来释放对象，而使用 performSelector 的话编译器就不添加释放操作，这就导致了内存泄漏。而其他名称开头的方法，返回的对象会被添加到自动释放池中，所以无须插入 release 方法，使用 performSelector 也就不会有问题。</p></blockquote><ol start="2"><li><p>返回值只能是 void 或对象类型<br>如果想返回基本数据类型，就需要执行一些复杂的转换操作，且容易出错；如果返回值类型是 C struct，则不可使用 performSelector 方法。</p></li><li><p>参数类型和个数也有局限性<br>类型：参数类型必须是 id 类型，不能是基本数据类型；<br>个数：所执行的 selector 的参数最多只能有两个。而如果使用 performSelector 延后执行或是指定线程执行的方法，那么 selector 的参数最多只能有一个。</p></li></ol><p><strong>使用 GCD 替代 performSelector</strong></p><ol><li>如果要延后执行，可以使用 dispatch_after</li><li>如果要指定线程执行，那么 GCD 也完全可以做到</li></ol><h3 id="掌握-GCD-及操作队列的使用时机"><a href="#掌握-GCD-及操作队列的使用时机" class="headerlink" title="掌握 GCD 及操作队列的使用时机"></a>掌握 GCD 及操作队列的使用时机</h3><p>根据实际情况使用GCD 或者 NSOperation,以下是它们的区别：</p><img src="/2022/02/23/%E3%80%8AEffective%20Objective-C%202.0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/gcdOperation.png" class="&#x3D;"><p><strong>使用 NSOperation 和 NSOperationQueue 的优势：</strong></p><ul><li>取消某个操作<br>可以在执行操作之前调用 <code>NSOperation</code> 的 <code>cancel</code> 方法来取消，不过正在执行的操作无法取消。iOS8 以后 GCD 可以用 <code>dispatch_block_cancel</code> 函数取消尚未执行的任务，正在执行的任务同样无法取消。</li><li>指定操作间的依赖关系<br> 使特定的操作必须在另外一个操作顺利执行完以后才能执行。</li><li>通过 KVO 监控 NSOperation 对象的属性<br> 在某个操作任务变更其状态时得到通知，比如 isCancelled、isFinished。而 GCD 不行。</li><li>指定操作的优先级<br>指定一个操作与队列中其他操作之间的优先级关系，优先级高的操作先执行，优先级低的则后执行。GCD 没有直接实现此功能的办法。</li><li>重用 NSOperation 对象<br>可以使用系统提供的 <code>NSOperation</code> 子类（比如 <code>NSBlockOperation</code>），也可以自定义子类。</li></ul><p>GCD 任务用块来表示，块是轻量级数据结构，而 NSOperation 则是更为重量级的 Objective-C 对象。虽说如此，但 GCD 并不是最佳方案。有时候采用对象所带来的开销微乎其微，反而它所到来的好处大大反超其缺点。另外，“应该尽可能选用高层 API，只在确有必要时才求助于底层” 这个说法并不绝对。某些功能确实可以用高层的 API 来做，但这并不等于说它就一定比底层实现方案好。要想确定哪种方案更佳，最好还是测试一下性能。</p><h2 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h2><h3 id="对自定义其内存管理语义的-collection-使用无缝桥接"><a href="#对自定义其内存管理语义的-collection-使用无缝桥接" class="headerlink" title="对自定义其内存管理语义的 collection 使用无缝桥接"></a>对自定义其内存管理语义的 collection 使用无缝桥接</h3><p>有 <code>__bridge</code> 、 <code>__bridge_retained</code> 、 <code>__bridge_transfer</code> 三种桥接方案，它们的区别为：</p><ol><li><code>__bridge</code>：不改变对象的内存管理权所有者。</li><li><code>__bridge_retained</code>：用在 Foundation 对象转换成 Core Foundation 对象时，进行 ARC 内存管理权的剥夺。</li><li><code>__bridge_transfer</code>：用在 Core Foundation 对象转换成 Foundation 对象时，进行内存管理权的移交。</li></ol><p>在使用 Foundation 框架中的字典对象时会遇到一个大问题，其键的内存管理语义为 “<code>拷贝</code>”，而值的语义是 “<code>保留</code>”。也就是说，在向 NSMutableDictionary 中加入键和值时，字典会自动 “拷贝” 键并 “保留” 值。如果用做键的对象不支持拷贝操作（如果要支持，就必须遵守 <code>NSCopying</code> 协议，并实现 copyWithZone: 方法），那么编译器会给出警告并在运行期 Crash：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *mDict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">[mDict setObject:<span class="string">@&quot;&quot;</span> forKey:[Person new]]; <span class="comment">// ⚠️ warning : Sending &#x27;Person *&#x27; to parameter of incompatible type &#x27;id&lt;NSCopying&gt; _Nonnull&#x27;</span></span><br><span class="line"></span><br><span class="line">Runtime:</span><br><span class="line">*** Terminating app due to uncaught exception <span class="string">&#x27;NSInvalidArgumentException&#x27;</span>, </span><br><span class="line">reason: <span class="string">&#x27;-[Person copyWithZone:]: unrecognized selector sent to instance 0x60000230c210&#x27;</span></span><br></pre></td></tr></table></figure><p>我们是无法直接修改 <code>NSMutableDictionary</code> 的键和值的内存管理语义的。这时候我们可以通过创建 CoreFoundation 框架的 <code>CFMutableDictionary</code> C 数据结构，修改内存管理语义，对键执行 “保留” 而非 “拷贝” 操作，然后再通过无缝桥接技术，将其转换 NSMutableDictionary 对象</p><blockquote><p>也可以使用 NSMapTable，指定 key 和 value 的内存管理语义。</p></blockquote><h3 id="构建缓存时选用NSCache而非NSDictionary"><a href="#构建缓存时选用NSCache而非NSDictionary" class="headerlink" title="构建缓存时选用NSCache而非NSDictionary"></a>构建缓存时选用NSCache而非NSDictionary</h3><p><strong>NSCache 的优势在于：</strong></p><ol><li>当系统资源将要耗尽时，它可以优雅的自动删减缓存，且会先行删减最久未使用的缓存。使用 NSDictionary 虽也可以自己实现但很复杂。</li><li>NSCache 不会拷贝键，而是保留它。使用 NSDictionary 虽也可以实现但比较复杂</li><li>NSCache 是线程安全的。不编写加锁代码的前提下，多个线程可以同时访问 NSCache。而 NSDictionary 不是线程安全的。</li></ol><p><strong>可以操控 NSCache 删减缓存的时机</strong></p><ol><li><code>totalCostLimit</code> 限制缓存中所有对象的总开销</li><li><code>countLimit</code> 限制缓存中对象的总个数</li><li><code>- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g; </code>将对象添加进缓存时，可指定其开销值</li></ol><p><strong>可能会删减缓存对象的时机：</strong></p><ol><li>当对象总数或者总开销超过上限时</li><li>在可用的系统资源趋于紧张时</li></ol><p>需要注意的是：</p><ol><li>可能会删减某个对象，并不意味着一定会删减</li><li>删减对象的顺序，由具体实现决定的</li><li>想通过调整开销值来迫使缓存优先删减某对象是不建议的，绝对不要把这些尺度当成可靠的 “硬限制”，它们仅对 NSCache 起指导作用。</li></ol><p>使用 <code>- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g; </code>可以在将对象添加进缓存时指定其开销值。但这种情况只适用于开销值能很快计算出来的情况，因为缓存的本意就是为了增加应用程序响应用户操作的速度。</p><p>比方说，计算开销值时必须访问磁盘或者数据库才能确定文件大小，那么就不适用这种方法。<br>如果要加入缓存的是 <code>NSData</code> 对象，其数据大小已知，直接访问属性即可 <code>data.length</code>。</p><p><strong>NSPurgeableData</strong></p><ol><li>NSPurgeableData 继承自 NSMutableData，它与 NSCache 搭配使用，可实现自动清除数据的功能。它实现了 NSDiscardableContent 协议（如果某个对象所占内存能够根据数据需要随时丢弃，就可以实现该协议定义的接口），将其加入 NSCache 后当该对象被系统所丢弃时，也会自动从缓存中清除。可以通过 NSCache 的 evictsObjectWithDiscardedContent 属性来开启或关闭此功能。</li><li>使用 NSPurgeableData 的方式和 “引用计数” 很像，当需要访问某个 NSPurgeableData 对象时，可以调用 <code>beginContentAccess</code> 进行 “持有”，并在用完时调用 <code>endContentAccess</code> 进行 “释放”。NSPurgeableData 在创建的时候其 “引用计数” 就为 1，所以无须调用 beginContentAccess，只需要在使用完毕后调用 endContentAccess 就行。</li></ol><blockquote><p>beginContentAccess：告诉它现在还不应该丢弃自己所占据的内存<br>endContentAccess：告诉它必要时可以丢弃自己所占据的内存</p></blockquote><p><strong>NSPurgeableData 与 NSCache 一起实现缓存的代码示例：</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network fetcher class</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>(^EOCNetworkFetcherCompletionHandler)(<span class="built_in">NSData</span> *data);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCNetworkFetcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)initWithURL:(<span class="built_in">NSURL</span>*)url;</span><br><span class="line">- (<span class="type">void</span>)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Class that uses the network fetcher and caches results</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCClass</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSCache</span> *_cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)init &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">        _cache = [<span class="built_in">NSCache</span> new];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cache a maximum of 100 URLs</span></span><br><span class="line">        _cache.countLimit = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The size in bytes of data is used as the cost,</span></span><br><span class="line"><span class="comment">         * so this sets a cost limit of 5MB.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        _cache.totalCostLimit = <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)downloadDataForURL:(<span class="built_in">NSURL</span>*)url &#123; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSPurgeableData</span> *cachedData = [_cache objectForKey:url];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cachedData) &#123;</span><br><span class="line">        [cachedData beginContentAccess];</span><br><span class="line">        <span class="comment">// Cache hit：存在缓存，读取</span></span><br><span class="line">        [<span class="keyword">self</span> useData:cachedData];</span><br><span class="line">        [cachedData endContentAccess];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Cache miss：没有缓存，下载</span></span><br><span class="line">        EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];      </span><br><span class="line"></span><br><span class="line">        [fetcher startWithCompletionHandler:^(<span class="built_in">NSData</span> *data)&#123;</span><br><span class="line">            <span class="built_in">NSPurgeableData</span> *purgeableData = [<span class="built_in">NSPurgeableData</span> dataWithData:data];</span><br><span class="line">            [_cache setObject:purgeableData forKey:url cost:purgeableData.length];    </span><br><span class="line">            [<span class="keyword">self</span> useData:data];</span><br><span class="line">            [purgeableData endContentAccess];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="精简-initialize-与-load-的实现代码"><a href="#精简-initialize-与-load-的实现代码" class="headerlink" title="精简 initialize 与 load 的实现代码"></a>精简 initialize 与 load 的实现代码</h3><h4 id="使用-load-方法的问题和注意事项："><a href="#使用-load-方法的问题和注意事项：" class="headerlink" title="使用 load 方法的问题和注意事项："></a>使用 load 方法的问题和注意事项：</h4><ol><li>在 <code>load</code> 方法中使用其他类是不安全的。比方说，类 A 和 B 没有继承关系，它们之间 <code>load</code> 方法的执行顺序是不确定的，而你在类 A 的 load 方法中去实例化 B，而类 B 可能会在其 load 方法中去完成实例化 B 前的一些重要操作，此时类 B 的 load 方法可能还未执行，所以不安全。</li><li><code>load</code> 方法务必实现得精简一些，尽量减少其所执行的操作，不要执行耗时太久或需要加锁的任务，因为整个应用程序在执行 <code>load</code> 方法时都会阻塞。</li><li>如果任务没必要在类加载进内存时就执行，而是可以在类初始化时执行，那么改用 <code>initialize</code> 替代 <code>load</code> 方法。</li></ol><h4 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h4><ul><li><code>initialize</code> 除了在调用时刻、调用方式、调用顺序方面与 <code>load</code> 有区别以外。<code>initialize</code> 方法还是安全的。<br>运行期系统在执行 <code>initialize</code> 时，是处于正常状态的，因为这时候可以安全使用并调用任意类中的任意方法了。而且运行期系统也能确保 <code>initialize</code> 方法一定会在 “线程安全的环境” 中执行，只有执行 initialize 的那个线程可以操作类或类实例，其他线程都要先阻塞等着 <code>initialize</code> 执行完。</li><li>如果子类没有实现 <code>initialize</code> 方法，那么就会调用父类的，所以通常会在 <code>initialize</code> 实现中对消息接收者做一下判断：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == [EOCBaseClass <span class="keyword">class</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ initialized&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initialize</code> 的实现也要保持精简，其原因在于：</p><ol><li>如果在主线程初始化一个类，那么初始化期间就会一直阻塞。</li><li>无法控制类的初始化时机。编写代码时不能令代码依赖特定的时间点执行，否则如果以后运行期系统更新改变了类的初始化方式，那么就会很危险。</li><li>如果在 <code>initialize</code> 中给其他类发送消息，那么会迫使这些类都进行初始化。如果其他类在执行 <code>initialize</code> 时又依赖该类的某些数据，而该类的这些数据又在 <code>initialize</code> 中完成，就会发生问题，产生 “环状依赖”。<br>所以，<code>initialize</code> 方法只应该用来设置内部数据，例如无法在编译期设定的全局常量，可以放在 <code>initialize</code> 方法里初始化。不应该调用其他方法，即便是本类自己的方法，也最好别调用。</li></ol><p>实现 <code>load</code> 和 <code>initialize</code> 方法时，一定要注意以上问题，精简代码。除了初始化全局状态之外，如果还有其他事情要做，那么可以专门创建一个方法来执行这些操作，并要求该类的使用者必须在使用本类之前调用此方法。比如说，如果 “单例类” 在首次使用之前必须执行一些操作，那就可以采用这个办法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6904440732287762439/">《Effective Objective-C 2.0》52 个知识点总结</a><br><a href="https://juejin.cn/post/6844903549780885511">《Effective Objective-C》干货三部曲</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift语法基础</title>
      <link href="/2022/02/16/Swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/16/Swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<img src="/2022/02/16/Swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/start.png" class="&#x3D;"><span id="more"></span><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>let定义常量   不可修改</p><p>let代表不可变对象，即对象首地址不能发生变更，也就是说内存地址不能改变，但也可以修饰可变对象</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;sb&quot;</span></span><br><span class="line">a <span class="operator">=</span> <span class="string">&quot;sbc&quot;</span>    <span class="comment">// 会报错误 ，因为let修饰的变量不能改变指针指向</span></span><br><span class="line"><span class="keyword">let</span> array: <span class="type">NSMutableArray</span> <span class="operator">=</span> <span class="type">NSMutableArray</span>()</span><br><span class="line">array.add(<span class="string">&quot;123&quot;</span>)  <span class="comment">//不会报错，因为数组a 的指针没有重新指向</span></span><br></pre></td></tr></table></figure><p>var 定义变量</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;sb&quot;</span></span><br><span class="line">b <span class="operator">=</span> <span class="string">&quot;sbc&quot;</span> <span class="comment">// 不会报错，因为var修饰的变量指针可以重新指向</span></span><br></pre></td></tr></table></figure><p> let 和 var 的区别就是在于对象内存地址可不可以改变</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">funcname</span>(形参) -&gt; returntype</span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">Statement1</span></span><br><span class="line">   <span class="type">Statement2</span></span><br><span class="line">   <span class="operator">……</span></span><br><span class="line">   <span class="type">Statement</span> <span class="type">N</span></span><br><span class="line">   <span class="keyword">return</span> parameters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">runoob</span>(<span class="params">site</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (site)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(runoob(site: <span class="string">&quot;www.runoob.com&quot;</span>))</span><br></pre></td></tr></table></figure><p>打印常量和变量<br><code>print(_:separator:terminator:) </code></p><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if</span></span><br><span class="line"><span class="keyword">let</span> s <span class="operator">=</span> <span class="string">&quot;hi&quot;</span></span><br><span class="line"><span class="keyword">if</span> s.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;String is Empty&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;String is <span class="subst">\(s)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if let-else</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">f</span>(<span class="params">s</span>: <span class="type">String</span>?) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> s1 <span class="operator">=</span> s &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;s1 is <span class="subst">\(s1)</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;s1 is nothing&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nil-coalescing</span></span><br><span class="line">    <span class="keyword">let</span> s2 <span class="operator">=</span> s <span class="operator">??</span> <span class="string">&quot;nothing&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;s2 is <span class="subst">\(s2)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">f(s: <span class="string">&quot;something&quot;</span>)</span><br><span class="line">f(s: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h3 id="if-guard-guard-let"><a href="#if-guard-guard-let" class="headerlink" title="if guard, guard let"></a>if guard, guard let</h3><blockquote><p>guard let is designed to exit the current function, loop, or condition if the check fails, so any values you unwrap using it will stay around after the check</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getMeaningOfLife</span>() -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">printMeaningOfLife</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> name <span class="operator">=</span> getMeaningOfLife() &#123;</span><br><span class="line">        <span class="built_in">print</span>(name)<span class="comment">//返回为int时才会执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//That uses if let, so that the result of getMeaningOfLife() will only be printed if it returned an integer rather than nil.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//guard let </span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">printMeaningOfLife</span>() &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name <span class="operator">=</span> getMeaningOfLife() <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>use <code>if let</code> if you just want to unwrap some optionals, but prefer <code>guard let</code> if you’re specifically checking that conditions are correct before continuing</p><p>更好地处理异常情况</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// guard</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">f1</span>(<span class="params">p</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> p.isEmpty <span class="operator">!=</span> <span class="literal">true</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Empty string.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;String <span class="subst">\(p)</span> is not empty.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(f1(p: <span class="string">&quot;&quot;</span>)) <span class="comment">// Empty string.</span></span><br><span class="line"><span class="built_in">print</span>(f1(p: <span class="string">&quot;lemon&quot;</span>)) <span class="comment">// String lemon is not empty.</span></span><br><span class="line"><span class="comment">// guard let</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">f2</span>(<span class="params">p1</span>: <span class="type">String</span>?) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> p2 <span class="operator">=</span> p1 <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Nil.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;String <span class="subst">\(p2)</span> is not nil.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(f2(p1: <span class="literal">nil</span>)) <span class="comment">// Nil.</span></span><br><span class="line"><span class="built_in">print</span>(f2(p1: <span class="string">&quot;lemon&quot;</span>)) <span class="comment">// String lemon is not nil.</span></span><br></pre></td></tr></table></figure><h3 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h3><p>可能会是 <code>nil </code>的变量就是可选变量。当变量为 <code>nil </code>通过<code>??</code>操作符可以提供一个默认值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o: <span class="type">Int</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> i <span class="operator">=</span> o <span class="operator">??</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>Optional</code>类型的本质实际上就是一个<code>带有泛型参数的enum类型</code>，这个类型和<code>Swift</code>中的<code>Result</code>类有异曲同工之妙</p><p>eg:</p><p><code>var num: Int?</code></p><p>声明了一个Optional类型，它可能包含一个Int值，也可能什么都不包含</p><p>Int!或者Int?这种写法，只是一种Optional类型的糖语法写法</p><p>在OC中我们的对象都可以赋值为nil，而在Swift中，能赋值为nil只有Optional类型！</p><ul><li>解包</li></ul><p>解包的基本思路，使用if let或者guard let，而非强制解包</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///强制解包</span></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">getHeight</span>(<span class="keyword">_</span> <span class="params">height</span>: <span class="type">Float</span>?) -&gt; <span class="type">Float</span>? &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> height <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> height<span class="operator">!</span> <span class="operator">/</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///安全解包 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">getHeight</span>(<span class="keyword">_</span> <span class="params">height</span>: <span class="type">Float</span>?) -&gt; <span class="type">Float</span>? &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">let</span> unwrapedHeight <span class="operator">=</span> height &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> unwrapedHeight <span class="operator">/</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///安全解包 2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">getHeight</span>(<span class="keyword">_</span> <span class="params">height</span>: <span class="type">Float</span>?) -&gt; <span class="type">Float</span>? &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">guard</span> <span class="keyword">let</span> unwrapedHeight <span class="operator">=</span> height <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> unwrapedHeight <span class="operator">/</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>更倾向于使用guard let</p><p>对于一个以返回结果为目的的函数，函数主体展示正常返回值，而将异常抛出在判断中，这样不仅逻辑更清晰，而且更加易于代码阅读。</p><p>guard let与if let不仅可以判断一个值的解包,而且可以进行连续操作</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>语法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;(parameters) -&gt; (<span class="keyword">return</span> type)   <span class="keyword">in</span></span><br><span class="line">statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h4><p>如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，将这个闭包替换成为尾随闭包的形式很有用。尾随闭包是一个书写在函数圆括号之后的闭包表达式，函数支持将其作为最后一个参数调用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 就是一个尾随闭包参数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">exec</span>(<span class="params">v1</span>: <span class="type">Int</span>, <span class="params">v2</span>: <span class="type">Int</span>, <span class="params">fn</span>: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(fn(v1, v2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">exec(v1: <span class="number">10</span>, v2: <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="variable">$0</span> <span class="operator">+</span> <span class="variable">$1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展Extension"><a href="#扩展Extension" class="headerlink" title="扩展Extension"></a>扩展Extension</h3><p>ObjC中有分类和扩展<br>Swift中只有扩展（更类似ObjC中的分类）<br>与ObjC不同的是，在Swift 的 extension 中 不可以直接添加属性。编译会报错。<br>和ObjC一样，我们可以用关联方法来添加属性。</p><p><strong>swift中扩展(Extensions)</strong></p><blockquote><p>扩展就是向一个已有的类、结构体、枚举类型或者协议类型添加新功能（functionality）。<br>这包括在没有权限获取原始源代码的情况下扩展类型的能力（即逆向建模）。<br>扩展和 Objective-C 中的分类（categories）类似。（不过更加强大，而且与Objective-C 不同的是，<code>Swift 的扩展没有名字</code>。）</p></blockquote><h4 id="遵守代理或者数据源的时候使用Extension"><a href="#遵守代理或者数据源的时候使用Extension" class="headerlink" title="遵守代理或者数据源的时候使用Extension"></a>遵守代理或者数据源的时候使用<code>Extension</code></h4><p>Extension可以用于遵守代理与数据源使用，同时建议每遵守一个协议就另起一个分类，因为Extension的用途之一就是用来分隔不同的业务。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - 网络请求处理模块</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">ViewController</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - 按钮点击事件的处理模块</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">ViewController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="私有API与对外API使用Extension"><a href="#私有API与对外API使用Extension" class="headerlink" title="私有API与对外API使用Extension"></a>私有API与对外API使用<code>Extension</code></h4><p>Swift中只有一个.swift文件，不能一眼看出那些是私有API那些是对外API。需要看private 和 fileprivate关键字才行</p><p>通过Extension进行私有API与对外API的分离</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - 私有API</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">extension</span> <span class="title class_">ViewController</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">extension</span> <span class="title class_">ViewController</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - 对外API</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">ViewController</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者在声明类class的大括号中全部写对外API函数，在Extension中写私有API函数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - 对外API</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ViewController</span>: <span class="title class_">UIViewController</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - 私有API</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">ViewController</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Protocol与Extension配合使用，变相实现多继承</p><h3 id="关键词-Open-Public-Internal-File-private-Private"><a href="#关键词-Open-Public-Internal-File-private-Private" class="headerlink" title="关键词:Open, Public, Internal, File-private, Private"></a>关键词:Open, Public, Internal, File-private, Private</h3><p>Swift 有五个级别的访问控制权限，从高到底依次为比如 Open, Public, Internal, File-private, Private<br>遵循的基本原则是：高级别的变量不允许被定义为低级别变量的成员变量。比如一个 private 的 class 中不能含有 public 的 String。反之，低级别的变量却可以定义在高级别的变量中。比如 public 的 class 中可以含有 private 的 Int。</p><p>1.Open 具备最高的访问权限。其修饰的类和方法可以在任意 Module 中被访问和重写；它是 Swift 3 中新添加的访问权限。</p><p>2.Public 的权限仅次于 Open。与 Open 唯一的区别在于它修饰的对象可以在任意 Module 中被访问，但不能重写。</p><p>3.Internal 是默认的权限。它表示只能在当前定义的 Module 中访问和重写，它可以被一个 Module 中的多个文件访问，但不可以被其他的 Module 中被访问。</p><p>4.File-private 也是 Swift 3 新添加的权限。其被修饰的对象只能在当前文件中被使用。例如它可以被一个文件中的 class，extension，struct 共同使用。</p><p>5.Private 是最低的访问权限。它的对象只能在定义的作用域内使用。离开了这个作用域，即使是同一个文件中的其他作用域，也无法访问。</p><h3 id="copy-on-write"><a href="#copy-on-write" class="headerlink" title="copy-on-write"></a>copy-on-write</h3><p>值类型(比如:struct),在复制时,复制对象与原对象实际上在内存中指向同一个对象,当且仅当修改复制的对象时,才会在内存中创建一个新的对象,</p><p>为了提升性能，Struct, String、Array、Dictionary、Set采取了Copy On Write的技术<br>比如仅当有“写”操作时，才会真正执行拷贝操作<br>对于标准库值类型的赋值操作，Swift 能确保最佳性能，所有没必要为了保证最佳性能来避免赋值</p><ul><li>举例</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 <span class="operator">=</span> <span class="string">&quot;hi&quot;</span></span><br><span class="line"><span class="keyword">var</span> str2 <span class="operator">=</span> str1</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"><span class="built_in">print</span>(str2)</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">str1和str2指针地址相同</span></span><br><span class="line"><span class="comment">打印结果：</span></span><br><span class="line"><span class="comment">hi</span></span><br><span class="line"><span class="comment">hi</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">str1.appendContentsOf(<span class="string">&quot;xixi&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"><span class="built_in">print</span>(str2)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">str1和str2指针地址不相同</span></span><br><span class="line"><span class="comment">打印结果：</span></span><br><span class="line"><span class="comment">hixixi</span></span><br><span class="line"><span class="comment">hi</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="swift为什么将String，Array，Dictionary设计为值类型"><a href="#swift为什么将String，Array，Dictionary设计为值类型" class="headerlink" title="swift为什么将String，Array，Dictionary设计为值类型"></a>swift为什么将String，Array，Dictionary设计为值类型</h3><ul><li>值类型和引用类型相比,最大优势可以<code>高效的使用内存</code>。</li><li>值类型在栈上操作,引用类型在堆上操作。</li><li>栈上操作仅仅是单个指针的移动,而堆上操作牵涉到<code>合并,位移,重链接</code>。</li><li>Swift 这样设计减少了堆上内存分配和回收次数,使用 <code>copy-on-write将值传递与复制开销降到最低</code>。</li></ul><h3 id="属性观察"><a href="#属性观察" class="headerlink" title="属性观察"></a>属性观察</h3><p>属性观察是指在当前类型内对特性属性进行监测,并作出响应,属性观察是 swift 中的特性,具有2种, <code>willset</code> 和 <code>didset</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> title: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">willSet</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;willSet&quot;</span>, newValue)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;didSet&quot;</span>, oldValue, title)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>willSet会传递新值，默认叫newValue</li><li>didSet会传递旧值，默认叫oldValue</li><li>在初始化器中设置属性值不会触发willSet和didSet</li></ul><h3 id="将Swift协议-protocol-中的部分方法设计为可选-optional"><a href="#将Swift协议-protocol-中的部分方法设计为可选-optional" class="headerlink" title="将Swift协议(protocol)中的部分方法设计为可选(optional)"></a>将Swift协议(protocol)中的部分方法设计为可选(optional)</h3><p>1.在协议和方法前面添加 @objc,然后在方法前面添加 optional关键字,改方式实际上是将协议转为了OC的方式</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">protocol</span> <span class="title class_">someProtocol</span> &#123;</span><br><span class="line">  <span class="keyword">@objc</span>  <span class="keyword">optional</span> <span class="keyword">func</span> <span class="title function_">test</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用扩展(extension),来规定可选方法,在 swift 中,协议扩展可以定义部分方法的默认实现</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">someProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">test</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">someProtocol</span>&#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Swift和ObjC中的protocol有什么不同"><a href="#Swift和ObjC中的protocol有什么不同" class="headerlink" title="Swift和ObjC中的protocol有什么不同"></a>Swift和ObjC中的protocol有什么不同</h3><p>相同点: 两者都可以被用作代理;<br>不同点: Swift中的 protocol还可以对接口进行抽象,可以实现面向协议,从而大大提高编程效率,Swift中的protocol可以用于值类型,结构体,枚举;</p><h3 id="Swift和ObjC中的自省"><a href="#Swift和ObjC中的自省" class="headerlink" title="Swift和ObjC中的自省"></a>Swift和ObjC中的自省</h3><p>自省在OC中就是判断某一对象是否属于某一个类的操作,有以下2中方式</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[obj iskinOfClass:[SomeClass <span class="keyword">class</span>]]</span><br><span class="line">[obj isMemberOfClass:[SomeClass <span class="keyword">class</span>]]</span><br></pre></td></tr></table></figure><p>在 Swift 中由于很多 class 并非继承自 NSObject, 故而 Swift 使用<code>is</code>来判断是否属于某一类型, is 不仅可以作用于class, 还是作用于enum和struct</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span>: <span class="title class_">ClassA</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj: <span class="type">AnyObject</span> <span class="operator">=</span> <span class="type">ClassB</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="type">ClassA</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;obj 属于 ClassA&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="type">ClassB</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;obj 属于 ClassB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string <span class="operator">=</span> <span class="string">&quot;String&quot;</span></span><br><span class="line"><span class="keyword">if</span> string <span class="keyword">is</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="swift-支持函数重载"><a href="#swift-支持函数重载" class="headerlink" title="swift 支持函数重载"></a>swift 支持函数重载</h3><p>函数重载是指: 函数名称相同,函数的参数个数不同, 或者参数类型不同,或参数标签不同, 返回值类型与函数重载无关</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.cn/post/6861804041085648910">Swift系列面试题总结</a><br><a href="https://www.jianshu.com/p/e1fe08c5db1a">“if let”和”guard let”</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSSet、NSDictionary底层实现</title>
      <link href="/2022/02/15/NSSet%E3%80%81NSDictionary%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/02/15/NSSet%E3%80%81NSDictionary%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>Foundation框架很多都是和Core Foundation对应，例如NSSet和_CFSet相对应，NSDictionary和_CFDictionary相对应。</p><span id="more"></span><h2 id="NSSet"><a href="#NSSet" class="headerlink" title="NSSet"></a>NSSet</h2><p>数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFSet</span> &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    CFIndex _count;<span class="comment">/* number of values */</span></span><br><span class="line">    CFIndex _capacity;<span class="comment">/* maximum number of values */</span></span><br><span class="line">    CFIndex _bucketsNum;<span class="comment">/* number of slots */</span></span><br><span class="line">    <span class="type">uintptr_t</span> _marker;</span><br><span class="line">    <span class="type">void</span> *_context;<span class="comment">/* private */</span></span><br><span class="line">    CFIndex _deletes;</span><br><span class="line">    CFOptionFlags _xflags;      <span class="comment">/* bits for GC */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> **_keys;<span class="comment">/* can be NULL if not allocated yet */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现set内部使用了指针数组来保存keys，可以从源码中了解到采用的是连续存储的方式存储</p><p>在数组长度不大的情况下，链表法衍生出来的链表会非常庞大，而且需要二次遍历，匹配损耗一样很大，这样等于没有优化。官方说查找算法接近O(1)，所以肯定不是链表法，那就是开放定址法。</p><p>开放定址法可以通过动态扩容数组长度解决表存储满无法插入的问题，也符合O(1)的查询速度。在CFSet内部结构里还有个<code>_capacity</code>表示当前数组的扩容阈值，当count达到这个值就扩容</p><blockquote><p>NSSet添加key，key值会根据特定的hash函数算出hash值，然后存储数据的时候，会根据hash函数算出来的值，找到对应的下标，如果该下标下已有数据，开放定址法后移动插入，如果数组到达阈值，这个时候就会进行扩容，然后重新hash插入。查询速度就可以和连续性存储的数据一样接近O(1)了</p></blockquote><h2 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h2><p>数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFDictionary</span> &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    CFIndex _count;<span class="comment">/* number of values */</span></span><br><span class="line">    CFIndex _capacity;<span class="comment">/* maximum number of values */</span></span><br><span class="line">    CFIndex _bucketsNum;<span class="comment">/* number of slots */</span></span><br><span class="line">    <span class="type">uintptr_t</span> _marker;</span><br><span class="line">    <span class="type">void</span> *_context;<span class="comment">/* private */</span></span><br><span class="line">    CFIndex _deletes;</span><br><span class="line">    CFOptionFlags _xflags;      <span class="comment">/* bits for GC */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> **_keys;<span class="comment">/* can be NULL if not allocated yet */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> **_values;<span class="comment">/* can be NULL if not allocated yet */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>字典则用了两个数组keys和values，说明这两个数据是被分开存储的。</p><p>同样的也是利用开放定址法来动态扩容数组来解决数组满了无法插入的问题，也可以通过setValue的实现证实这一点，下面代码已除去无关逻辑：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">CFDictionarySetValue</span>(<span class="built_in">CFMutableDictionaryRef</span> dict, <span class="keyword">const</span> <span class="type">void</span> *key, <span class="keyword">const</span> <span class="type">void</span> *value) &#123;</span><br><span class="line">    <span class="comment">// 通过match，nomatch来判断是否存在key</span></span><br><span class="line">    <span class="built_in">CFIndex</span> match, nomatch;</span><br><span class="line">    __CFDictionaryFindBuckets2(dict, key, &amp;match, &amp;nomatch);</span><br><span class="line">    。。。</span><br><span class="line">    <span class="keyword">if</span> (kCFNotFound != match) &#123;</span><br><span class="line">        <span class="comment">// key已存在，覆盖newValue</span></span><br><span class="line"><span class="built_in">CF_OBJC_KVO_WILLCHANGE</span>(dict, key);</span><br><span class="line"><span class="built_in">CF_WRITE_BARRIER_ASSIGN</span>(valuesAllocator, dict-&gt;_values[match], newValue);</span><br><span class="line"><span class="built_in">CF_OBJC_KVO_DIDCHANGE</span>(dict, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// key不存在，新增value</span></span><br><span class="line"><span class="built_in">CF_OBJC_KVO_WILLCHANGE</span>(dict, key);</span><br><span class="line"><span class="built_in">CF_WRITE_BARRIER_ASSIGN</span>(keysAllocator, dict-&gt;_keys[nomatch], newKey);</span><br><span class="line"><span class="built_in">CF_WRITE_BARRIER_ASSIGN</span>(valuesAllocator, dict-&gt;_values[nomatch], newValue);</span><br><span class="line">dict-&gt;_count++;</span><br><span class="line"><span class="built_in">CF_OBJC_KVO_DIDCHANGE</span>(dict, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找key存储的位置</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> __CFDictionaryFindBuckets2(<span class="built_in">CFDictionaryRef</span> dict, <span class="keyword">const</span> <span class="type">void</span> *key, <span class="built_in">CFIndex</span> *match, <span class="built_in">CFIndex</span> *nomatch) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">CFDictionaryKeyCallBacks</span> *cb = __CFDictionaryGetKeyCallBacks(dict);</span><br><span class="line">    <span class="comment">// 获取hash值</span></span><br><span class="line">    <span class="built_in">CFHashCode</span> keyHash = cb-&gt;hash ? (<span class="built_in">CFHashCode</span>)INVOKE_CALLBACK2(((<span class="built_in">CFHashCode</span> (*)(<span class="keyword">const</span> <span class="type">void</span> *, <span class="type">void</span> *))cb-&gt;hash), key, dict-&gt;_context) : (<span class="built_in">CFHashCode</span>)key;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">void</span> **keys = dict-&gt;_keys;</span><br><span class="line">    uintptr_t marker = dict-&gt;_marker;</span><br><span class="line">    <span class="built_in">CFIndex</span> probe = keyHash % dict-&gt;_bucketsNum;</span><br><span class="line">    <span class="built_in">CFIndex</span> probeskip = <span class="number">1</span>;<span class="comment">// See RemoveValue() for notes before changing this value</span></span><br><span class="line">    <span class="built_in">CFIndex</span> start = probe;</span><br><span class="line">    *match = kCFNotFound;</span><br><span class="line">    *nomatch = kCFNotFound;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">uintptr_t currKey = (uintptr_t)keys[probe];</span><br><span class="line"><span class="comment">// 空桶，返回nomatch，未匹配</span></span><br><span class="line"><span class="keyword">if</span> (marker == currKey) &#123;<span class="comment">/* empty */</span></span><br><span class="line">    <span class="keyword">if</span> (nomatch) *nomatch = probe;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (~marker == currKey) &#123;<span class="comment">/* deleted */</span></span><br><span class="line">    <span class="keyword">if</span> (nomatch) &#123;</span><br><span class="line">*nomatch = probe;</span><br><span class="line">nomatch = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (currKey == (uintptr_t)key || (cb-&gt;equal &amp;&amp; INVOKE_CALLBACK3((Boolean (*)(<span class="keyword">const</span> <span class="type">void</span> *, <span class="keyword">const</span> <span class="type">void</span> *, <span class="type">void</span>*))cb-&gt;equal, (<span class="type">void</span> *)currKey, key, dict-&gt;_context))) &#123;</span><br><span class="line">    <span class="comment">// 匹配成功，返回match</span></span><br><span class="line">    *match = probe;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未匹配，发生碰撞，将数组下标后移，直到找到空闲区域位置</span></span><br><span class="line">probe = probe + probeskip;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dict-&gt;_bucketsNum &lt;= probe) &#123;</span><br><span class="line">    probe -= dict-&gt;_bucketsNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (start == probe) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有重复的key插入到字典NSDictionary时，会覆盖旧值，而集合NSSet则什么都不做，保证了里面的元素不会重复。</p><p>key和value是分别存储在两个不同的数组里，这里面是如何对key、value进行绑定的呢？</p><blockquote><p>首先key利用hash函数算出hash值，然后对数组的长度取模，得到数组下标的位置，同样将这个地址对应到values数组的下标，就匹配到相应的value</p></blockquote><p>要保证一点，就是keys和values这两个数组的长度要一致。所以扩容的时候，需要对keys和values两个数组一起扩容</p><p><strong>开放地址法最好存储的是临时需要，尽快的释放资源</strong></p><p>对于字典NSDictionary设置的key和value，key值会根据特定的hash函数算出hash值，keys和values同样多，利用hash值对数组长度取模，得到其对应的下标index，如果下标已有数据，开放定址法后移插入，如果数组达到阈值，就扩容，然后重新hash插入。这样的机制就把一些不连续的key-value值插入到能建立起关系的hash表中。<br>查找的时候，key根据hash函数以及数组长度，得到下标，然后根据下标直接访问hash表的keys和values，这样查询速度就可以和连续线性存储的数据一样接近O(1)了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903769801490445">集合NSSet、字典NSDictionary的底层实现原理</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GCD</title>
      <link href="/2022/02/08/GCD/"/>
      <url>/2022/02/08/GCD/</url>
      
        <content type="html"><![CDATA[<img src="/2022/02/08/GCD/GCDstart.png" class="&#x3D;"><span id="more"></span><h2 id="GCD概述"><a href="#GCD概述" class="headerlink" title="GCD概述"></a>GCD概述</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>纯C语言实现</li><li>苹果公司为了多核并行运算提出的解决方案，会自动充分利用设备的多核</li><li>会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li></ul><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="两个核心"><a href="#两个核心" class="headerlink" title="两个核心"></a>两个核心</h4><ul><li>任务： 执行什么操作</li><li>队列： 用来存放任务</li></ul><h3 id="GCD的任务"><a href="#GCD的任务" class="headerlink" title="GCD的任务"></a>GCD的任务</h3><p>GCD中的任务有两种封装： <code>dispatch_block_t</code> 和 <code>dispatch_function_t</code></p><blockquote><p><code>dispatch_block_t</code> 提交给指定队列的block，无参无返回值 <code>typedef void (^dispatch_block_t)(void);</code><br><code>dispatch_function_t</code> 提交给指定队列的function，void(*)()类型的函数指针<code> typedef void (*dispatch_function_t)(void *);</code></p></blockquote><h3 id="GCD的队列"><a href="#GCD的队列" class="headerlink" title="GCD的队列"></a>GCD的队列</h3><p>全局并发队列：一种特殊的并发队列，可以指定服务质量（服务质量有助于确定队列执行的任务的优先级）</p><h3 id="全局队列和手动创建的并发队列区别"><a href="#全局队列和手动创建的并发队列区别" class="headerlink" title="全局队列和手动创建的并发队列区别:"></a>全局队列和手动创建的并发队列区别:</h3><ol><li>手动创建的并发队列可以设置唯一标识，可以跟踪错误，而全局并发队列没有；</li><li>在 ARC 中不需要考虑释放内存，dispatch_release(q);不需要也不允许调用。而在 MRC 中由于手动创建的并发队列是 create 出来的，所以需要调用dispatch_release(q);来释放内存，而全局并发队列不需要;</li><li>全局并发队列可以指定服务质量（服务质量有助于确定队列执行的任务的优先级）;</li><li>一般我们使用全局并发队列。</li></ol><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="死锁的四大条件"><a href="#死锁的四大条件" class="headerlink" title="死锁的四大条件"></a>死锁的四大条件</h3><ol><li>互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。</li><li>占有且等待：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。</li><li>不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。</li><li>循环等待：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。</li></ol><h3 id="GCD-中的死锁"><a href="#GCD-中的死锁" class="headerlink" title="GCD 中的死锁"></a>GCD 中的死锁</h3><p>使用<code>dispatch_sync</code>函数往当前<code>串行队列中添加任务</code>，会卡住当前的串行队列（产生死锁）</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="GCD队列的服务质量与优先级"><a href="#GCD队列的服务质量与优先级" class="headerlink" title="GCD队列的服务质量与优先级"></a>GCD队列的服务质量与优先级</h3><ul><li><p>NSQualityOfServiceUserInteractive<br>与用户交互的任务，这些任务通常跟 UI 级别的刷新相关，比如动画，这些任务需要在一瞬间完成；</p></li><li><p>NSQualityOfServiceUserInitiated<br>由用户发起的并且需要立即得到结果的任务，比如滑动 scroll view 时去加载数据用于后续 cell 的显示，这些任务通常跟后续的用户交互相关，在几秒或者更短的时间内完成；</p></li><li><p>NSQualityOfServiceUtility<br>一些可能需要花点时间的任务，这些任务不需要马上返回结果，比如下载的任务，这些任务可能花费几秒或者几分钟的时间；</p></li><li><p>NSQualityOfServiceBackground<br>这些任务对用户不可见，比如后台进行备份的操作，这些任务可能需要较长的时间，几分钟甚至几个小时；</p></li><li><p>NSQualityOfServiceDefault<br>优先级介于 user-initiated 和 utility，当没有 QoS 信息时默认使用，开发者不应该使用这个值来设置自己的任务。</p></li></ul><h3 id="服务质量枚举类型"><a href="#服务质量枚举类型" class="headerlink" title="服务质量枚举类型"></a>服务质量枚举类型</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QOS_CLASS_USER_INTERACTIVE</span><br><span class="line">QOS_CLASS_USER_INITIATED</span><br><span class="line">QOS_CLASS_DEFAULT</span><br><span class="line">QOS_CLASS_UTILITY</span><br><span class="line">QOS_CLASS_BACKGROUND</span><br></pre></td></tr></table></figure><p>队列的优先级与服务质量的对应关系：</p><img src="/2022/02/08/GCD/Qos.png" class="&#x3D;"><h3 id="给队列设置QoS"><a href="#给队列设置QoS" class="headerlink" title="给队列设置QoS"></a>给队列设置QoS</h3><p>dispatch_queue_attr_make_with_qos_class<br>dispatch_set_target_queue</p><h3 id="GCD队列任务间依赖关系"><a href="#GCD队列任务间依赖关系" class="headerlink" title="GCD队列任务间依赖关系"></a>GCD队列任务间依赖关系</h3><h4 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h4><p>除了能用来设置队列的 QoS 之外，还能够创建队列的层次体系。当我们想让不同队列中的任务同步的执行时，我们可以创建一个串行队列，然后将这些队列的 target 指向新创建的队列即可，比如： </p><img src="/2022/02/08/GCD/targetQueue.png" class="&#x3D;"><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> targetQueue = dispatch_queue_create(<span class="string">&quot;target_queue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">&quot;queue1&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">&quot;queue2&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_set_target_queue(queue1, targetQueue);</span><br><span class="line">    dispatch_set_target_queue(queue2, targetQueue);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务1,%s&quot;</span>,dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务2,%s&quot;</span>,dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务3,%s&quot;</span>,dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2020-02-01 19:05:18.142729+0800 多线程[6669:1213619] 执行任务1,queue1</span></span><br><span class="line"><span class="comment">2020-02-01 19:05:19.143926+0800 多线程[6669:1213619] 执行任务2,queue2</span></span><br><span class="line"><span class="comment">2020-02-01 19:05:20.147740+0800 多线程[6669:1213619] 执行任务3,queue2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>注意点： 避免相互依赖，如将队列 A 的目标队列设置为队列 B，并将队列 B 的目标队列设置为队列 A。</p><h3 id="Dispatch-Group队列组"><a href="#Dispatch-Group队列组" class="headerlink" title="Dispatch Group队列组"></a>Dispatch Group队列组</h3><p>GCD 队列组，又称“调度组”，实现所有任务执行完成后有一个统一的回调。</p><p>例如：异步下载歌曲，等所有歌曲都下载完毕以后，转到主线程提示用户</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@,下载歌曲1&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@,下载歌曲2&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@,下载歌曲3&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@,下载完毕&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;NSThread: 0x6000028c8c00&gt;&#123;number = 6, name = (null)&#125;,下载歌曲2</span></span><br><span class="line"><span class="comment">&lt;NSThread: 0x60000283f400&gt;&#123;number = 5, name = (null)&#125;,下载歌曲1</span></span><br><span class="line"><span class="comment">&lt;NSThread: 0x600002803440&gt;&#123;number = 4, name = (null)&#125;,下载歌曲3</span></span><br><span class="line"><span class="comment">&lt;NSThread: 0x60000285c5c0&gt;&#123;number = 1, name = main&#125;,下载完毕</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="队列组的原理"><a href="#队列组的原理" class="headerlink" title="队列组的原理"></a>队列组的原理</h4><p>真正实现统一回调的操作：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> dispatch_group_enter(dispatch_group_t group);</span><br><span class="line"><span class="type">void</span> dispatch_group_leave(dispatch_group_t group);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_async(group, queue, ^&#123; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 1.创建队列组</span></span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    <span class="comment">// 2.获取全局并发队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//ARC中不用写也不能写</span></span><br><span class="line"><span class="comment">//    dispatch_retain(group);</span></span><br><span class="line">    <span class="comment">// 3.进入队列组，执行此函数后，再添加的异步执行的block任务都会被group监听</span></span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    <span class="comment">// 4.添加任务</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@,执行任务1&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="comment">// 5.离开队列组</span></span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">        <span class="comment">//ARC中不用写也不能写</span></span><br><span class="line"><span class="comment">//        dispatch_release(group);</span></span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@,执行任务2&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 6.获得队列组的通知</span></span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@,执行任务3&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 7.等待队列组，监听的队列中的所有任务都执行完毕，才会执行后续代码，会阻塞线程（很少使用）</span></span><br><span class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@,执行任务4&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;NSThread: 0x600003d98d00&gt;&#123;number = 3, name = (null)&#125;,执行任务1</span></span><br><span class="line"><span class="comment">&lt;NSThread: 0x600003d4de80&gt;&#123;number = 9, name = (null)&#125;,执行任务2</span></span><br><span class="line"><span class="comment">&lt;NSThread: 0x600003dcd2c0&gt;&#123;number = 1, name = main&#125;,执行任务4</span></span><br><span class="line"><span class="comment">&lt;NSThread: 0x600003dcd2c0&gt;&#123;number = 1, name = main&#125;,执行任务3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="Dispatch-Barrier栅栏函数"><a href="#Dispatch-Barrier栅栏函数" class="headerlink" title="Dispatch Barrier栅栏函数"></a>Dispatch Barrier栅栏函数</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在并发调度队列中执行的任务的同步点</p><p>使用栅栏函数来同步调度队列中一个或多个任务的执行。在向并发调度队列添加栅栏时，该队列会延迟栅栏任务（以及栅栏之后提交的所有任务）的执行，直到所有先前提交的任务都执行完成为止。在完成先前的任务后，队列将自己执行栅栏任务。栅栏任务执行完毕之后，队列将恢复其正常执行行为。</p><h4 id="栅栏函数"><a href="#栅栏函数" class="headerlink" title="栅栏函数"></a>栅栏函数</h4><ul><li><p>同步栅栏函数<br><code>dispatch_barrier_sync</code>：提交一个栅栏 block 以同步执行，并等待该 block 执行完；<br><code>dispatch_barrier_sync_f</code>：提交一个栅栏 function 以同步执行，并等待该 function 执行完。</p></li><li><p>异步栅栏函数<br><code>dispatch_barrier_async</code>：提交一个栅栏 block 以异步执行，并直接返回；<br><code>dispatch_barrier_async_f</code>：提交一个栅栏 function 以异步执行，并直接返回。</p></li></ul><h4 id="同步栅栏函数-dispatch-barrier-sync"><a href="#同步栅栏函数-dispatch-barrier-sync" class="headerlink" title="同步栅栏函数 dispatch_barrier_sync"></a>同步栅栏函数 dispatch_barrier_sync</h4><p><code>void dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block);</code><br><code>dispatch_barrier_sync</code>同步栅栏函数会等待该函数传入的队列中的任务都执行完毕，再执行<code>dispatch_barrier_sync</code>函数中的任务以及后面的任务，会阻塞当前线程。</p><ul><li>使用场景：保证顺序执行，会阻塞当前线程</li></ul><p>需求： 现有任务1、2、3、4，前两个任务执行完毕，再执行后两个任务以及主线程的代码。</p><p>解决方法：</p><p>1.使用 GCD 队列组；<br>2.使用dispatch_barrier_sync函数。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;myqueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="comment">/* 1.异步函数 */</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务1-%zd-%@&quot;</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务2-%zd-%@&quot;</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/* 2. 同步栅栏函数 */</span></span><br><span class="line">    dispatch_barrier_sync(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;------------------dispatch_barrier_sync-%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;任务1、2执行完毕&quot;</span>);</span><br><span class="line">    <span class="comment">/* 3. 异步函数 */</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务3-%zd-%@&quot;</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;正在执行任务3、4&quot;</span>);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务4-%zd-%@&quot;</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行任务1-0-&lt;NSThread: 0x600003ffa780&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务2-0-&lt;NSThread: 0x600003fefa00&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务2-1-&lt;NSThread: 0x600003fefa00&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务1-1-&lt;NSThread: 0x600003ffa780&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务2-2-&lt;NSThread: 0x600003fefa00&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务1-2-&lt;NSThread: 0x600003ffa780&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">------------------dispatch_barrier_sync-&lt;NSThread: 0x600003fa5b80&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">任务1、2执行完毕</span></span><br><span class="line"><span class="comment">正在执行任务3、4</span></span><br><span class="line"><span class="comment">执行任务3-0-&lt;NSThread: 0x600003ffa780&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务4-0-&lt;NSThread: 0x600003fefa00&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务3-1-&lt;NSThread: 0x600003ffa780&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务4-1-&lt;NSThread: 0x600003fefa00&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务3-2-&lt;NSThread: 0x600003ffa780&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务4-2-&lt;NSThread: 0x600003fefa00&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="异步栅栏函数-dispatch-barrier-async"><a href="#异步栅栏函数-dispatch-barrier-async" class="headerlink" title="异步栅栏函数 dispatch_barrier_async"></a>异步栅栏函数 dispatch_barrier_async</h4><p><code>void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</code><br>先来看一下上面的代码改为异步栅栏函数的执行效果：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;myqueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="comment">/* 1.异步函数 */</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务1-%zd-%@&quot;</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务2-%zd-%@&quot;</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/* 2. 异步栅栏函数 */</span></span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;------------------dispatch_barrier_async-%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;任务1、2执行完毕&quot;</span>);</span><br><span class="line">    <span class="comment">/* 3. 异步函数 */</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务3-%zd-%@&quot;</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;正在执行任务3、4&quot;</span>);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;执行任务4-%zd-%@&quot;</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">任务1、2执行完毕</span></span><br><span class="line"><span class="comment">执行任务2-0-&lt;NSThread: 0x6000020f3100&gt;&#123;number = 4, name = (null)&#125;</span></span><br><span class="line"><span class="comment">正在执行任务3、4</span></span><br><span class="line"><span class="comment">执行任务1-0-&lt;NSThread: 0x6000020c6a00&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务2-1-&lt;NSThread: 0x6000020f3100&gt;&#123;number = 4, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务1-1-&lt;NSThread: 0x6000020c6a00&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务2-2-&lt;NSThread: 0x6000020f3100&gt;&#123;number = 4, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务1-2-&lt;NSThread: 0x6000020c6a00&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment">------------------dispatch_barrier_async-&lt;NSThread: 0x6000020c6a00&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务4-0-&lt;NSThread: 0x6000020d2e00&gt;&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务3-0-&lt;NSThread: 0x6000020c6a00&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务4-1-&lt;NSThread: 0x6000020d2e00&gt;&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务3-1-&lt;NSThread: 0x6000020c6a00&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务4-2-&lt;NSThread: 0x6000020d2e00&gt;&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment">执行任务3-2-&lt;NSThread: 0x6000020c6a00&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>从打印日志可以看到，改为异步栅栏函数，任务3、4仍然可以等到任务1、2以及栅栏任务都执行完毕再执行，但不会阻塞主线程，并且栅栏任务是在子线程执行。</p><p><code>dispatch_barrier_async</code>异步栅栏函数会等待该函数传入的队列中的任务都执行完毕，再执行<code>dispatch_barrier_async</code>函数中的任务以及后面的任务，执行该函数会直接返回，继续往下执行代码，不会阻塞当前线程。</p><ul><li>主要用于在多个异步操作完成之后，统一对非线程安全的对象进行更新；</li><li>适合于大规模的 I&#x2F;O 操作；</li><li>当访问数据库或者文件的时候，更新数据的时候不能和其他更新或者读取的操作在同一时间执行，可以使用队列组不过有点复杂，可以使用dispatch_barrier_async解决；</li><li>保证线程安全、读写安全。</li></ul><h5 id="使用场景1：保证线程安全"><a href="#使用场景1：保证线程安全" class="headerlink" title="使用场景1：保证线程安全"></a>使用场景1：保证线程安全</h5><p>例如： 我们要从网络上异步获取很多图片，然后将它们添加到非线程安全的对象——数组中去：异步并发。<br>  同一时间点，可能有多个线程执行给数组添加对象的方法，所以可能会丢掉 1 到多次，我们执行 1000 次，可能数组就保存了 990 多个，还有程序出现奔溃的可能。</p><p>解决办法：<br>① 加锁：比较耗时，而且下载完什么时候添加进数组也不一定。我们希望所有图片都下载完，再往数组里面添加；<br>② 使用 GCD 队列组；<br>③ 使用dispatch_barrier_async函数，栅栏中的任务会等待队列中的所有任务执行完成，才会执行栅栏中的任务，保证了线程安全。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;myqueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="comment">//下载图片</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;图片下载完成%d,%@&quot;</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">                <span class="comment">//将图片添加进数组</span></span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;添加图片%d,%@&quot;</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">图片下载完成2,&lt;NSThread: 0x600000348d80&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">图片下载完成0,&lt;NSThread: 0x600000341f40&gt;&#123;number = 4, name = (null)&#125;</span></span><br><span class="line"><span class="comment">图片下载完成1,&lt;NSThread: 0x60000036f480&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment">图片下载完成3,&lt;NSThread: 0x60000039ce80&gt;&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment">图片下载完成4,&lt;NSThread: 0x600000348d80&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">添加图片2,&lt;NSThread: 0x600000348d80&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">添加图片0,&lt;NSThread: 0x600000348d80&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">添加图片1,&lt;NSThread: 0x600000348d80&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">添加图片3,&lt;NSThread: 0x600000348d80&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">添加图片4,&lt;NSThread: 0x600000348d80&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="使用场景2：实现读写安全"><a href="#使用场景2：实现读写安全" class="headerlink" title="使用场景2：实现读写安全"></a>使用场景2：实现读写安全</h5><p>dispatch_barrier_async可以用来实现“读写安全”。我们将“写”操作放在dispatch_barrier_async中，这样能确保在“写”操作的时候会等待前面的“读”操作完成，而后续的“读”操作也会等到“写”操作完成后才能继续执行，提高文件读写的执行效率。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;myqueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="comment">// 读：执行“读”操作</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 写：执行“写”操作</span></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.queue = dispatch_queue_create(<span class="string">&quot;myqueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        [test read];</span><br><span class="line">        [test read];</span><br><span class="line">        [test write];</span><br><span class="line">        [test read];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)read &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;read,%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)write &#123;</span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;write,%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2020-01-20 01:45:09.847878+0800 多线程[27767:6103230] read,&lt;NSThread: 0x600002d42ac0&gt;&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 01:45:09.847849+0800 多线程[27767:6096149] read,&lt;NSThread: 0x600002d8ed80&gt;&#123;number = 4, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 01:45:10.849965+0800 多线程[27767:6096149] write,&lt;NSThread: 0x600002d8ed80&gt;&#123;number = 4, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 01:45:11.851259+0800 多线程[27767:6103230] read,&lt;NSThread: 0x600002d42ac0&gt;&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 01:45:11.851265+0800 多线程[27767:6103231] read,&lt;NSThread: 0x600002d42640&gt;&#123;number = 8, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 01:45:11.851277+0800 多线程[27767:6096149] read,&lt;NSThread: 0x600002d8ed80&gt;&#123;number = 4, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 01:45:12.854305+0800 多线程[27767:6103231] write,&lt;NSThread: 0x600002d42640&gt;&#123;number = 8, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 01:45:13.859167+0800 多线程[27767:6103231] read,&lt;NSThread: 0x600002d42640&gt;&#123;number = 8, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 01:45:13.859167+0800 多线程[27767:6103230] read,&lt;NSThread: 0x600002d42ac0&gt;&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 01:45:13.859167+0800 多线程[27767:6096149] read,&lt;NSThread: 0x600002d8ed80&gt;&#123;number = 4, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 01:45:14.864153+0800 多线程[27767:6103231] write,&lt;NSThread: 0x600002d42640&gt;&#123;number = 8, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 01:45:15.869272+0800 多线程[27767:6096149] read,&lt;NSThread: 0x600002d8ed80&gt;&#123;number = 4, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="dispatch-barrier-sync-与-dispatch-barrier-async-的区别及注意点"><a href="#dispatch-barrier-sync-与-dispatch-barrier-async-的区别及注意点" class="headerlink" title="dispatch_barrier_sync 与 dispatch_barrier_async 的区别及注意点"></a>dispatch_barrier_sync 与 dispatch_barrier_async 的区别及注意点</h5><p> 相同点： 都会等待队列中在它们（栅栏）之前提交的任务都执行完毕，再执行它们的任务，接着执行它们后面的任务。</p><p>不同点：</p><ul><li><code>dispatch_barrier_sync</code>：提交一个栅栏 block 以同步执行，并等待该 block 执行完；由于是同步，不会开启新的子线程，会阻塞当前线程。</li><li><code>dispatch_barrier_async</code>：提交一个栅栏 block 以异步执行，并直接返回，会继续往下执行代码，不会阻塞当前线程。</li></ul><p>注意点：</p><ul><li><code>dispatch_barrier_(a)sync</code>函数传入的的队列必须是自己手动创建的并发队列，如果传入的是全局并发队列或者串行队列，那么这个函数是没有栅栏的效果的，效果等同于dispatch_(a)sync函数。</li><li>只能栅栏<code>dispatch_barrier_(a)sync</code>函数中传入的queue。</li></ul><h3 id="Dispatch-Apply多次执行"><a href="#Dispatch-Apply多次执行" class="headerlink" title="Dispatch Apply多次执行"></a>Dispatch Apply多次执行</h3><h4 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h4><p>类似一个 for 循环。提交一个 block 到指定队列，并使该 block 执行指定的次数 n，等待 block 执行完 n 次才会返回。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @param iterations</span></span><br><span class="line"><span class="comment"> * 执行 block 的次数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param queue</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param block</span></span><br><span class="line"><span class="comment"> * 要提交的 block，此参数不能为空（NULL）</span></span><br><span class="line"><span class="comment"> * 该 block 没有返回值，并带有一个 size_t 类型的参数（iteration：当前迭代索引，即当前是第几次调用）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> dispatch_apply(size_t iterations, <span class="built_in">dispatch_queue_t</span> queue, <span class="type">void</span> (^block)(size_t));</span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>该函数会等待 block 都执行完毕才会返回，所以是同步的，会阻塞；</li><li>如果指定的队列是全局并发队列<code>dispatch_get_global_queue</code>，则这些 block 可以并发执行，这里需要注意可重入性；</li><li>如果指定的队列是手动创建的并发队列，在有些情况下不会并发执行，所以建议使用全局并发队列<code>dispatch_get_global_queue</code>；</li><li>当使用串行队列时，不会开启子线程，block 在主线程按串行执行；</li><li>当使用并发队列时，不一定会开启子线程，block 不一定都在子线程执行，也可能都在主线程执行，取决于任务的耗时程度。</li></ul><p>串行队列</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;myqueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;开始执行&quot;</span>);</span><br><span class="line">    dispatch_apply(<span class="number">5</span>, queue, ^(size_t i) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%zu,%@&quot;</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;执行完毕&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2020-02-01 00:20:00.828203+0800 多线程[5402:867594] 开始执行</span></span><br><span class="line"><span class="comment">2020-02-01 00:20:01.829521+0800 多线程[5402:867594] 0,&lt;NSThread: 0x600002182200&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:20:02.830285+0800 多线程[5402:867594] 1,&lt;NSThread: 0x600002182200&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:20:03.831774+0800 多线程[5402:867594] 2,&lt;NSThread: 0x600002182200&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:20:04.833280+0800 多线程[5402:867594] 3,&lt;NSThread: 0x600002182200&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:20:05.834919+0800 多线程[5402:867594] 4,&lt;NSThread: 0x600002182200&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:20:05.835200+0800 多线程[5402:867594] 执行完毕</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>并发队列</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;开始执行&quot;</span>);</span><br><span class="line">    dispatch_apply(<span class="number">5</span>, queue, ^(size_t i) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%zu,%@&quot;</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;执行完毕&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2020-02-01 00:20:21.107718+0800 多线程[5402:867594] 开始执行</span></span><br><span class="line"><span class="comment">2020-02-01 00:20:22.109137+0800 多线程[5402:867736] 1,&lt;NSThread: 0x6000021b0d80&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:20:22.109137+0800 多线程[5402:867594] 0,&lt;NSThread: 0x600002182200&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:20:22.109186+0800 多线程[5402:868618] 2,&lt;NSThread: 0x600002111400&gt;&#123;number = 8, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:20:22.109190+0800 多线程[5402:868619] 3,&lt;NSThread: 0x600002108ec0&gt;&#123;number = 9, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:20:23.109931+0800 多线程[5402:867736] 4,&lt;NSThread: 0x6000021b0d80&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:20:23.110251+0800 多线程[5402:867594] 执行完毕</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>使用场景<br>在某些场景下使用dispatch_apply会对性能有很大的提升，比如你的代码需要以每个像素为基准来处理计算 image 图片。同时dispatch_apply能够避免一些线程爆炸的情况发生（创建很多线程）</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//危险，可能导致线程爆炸以及死锁</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(q, ^&#123;...&#125;);</span><br><span class="line">&#125;</span><br><span class="line">dispatch_barrier_sync(q, ^&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//较优选择， GCD 会管理并发</span></span><br><span class="line">dispatch_apply(<span class="number">999</span>, q, ^(size_t i)&#123;...&#125;);</span><br></pre></td></tr></table></figure><p>在异步中实现同步，并将任务并发执行</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;开始执行&quot;</span>);</span><br><span class="line">        dispatch_apply(<span class="number">5</span>, queue, ^(size_t i) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%zu,%@&quot;</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;执行完毕&quot;</span>);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;回到主线程&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2020-02-01 00:12:00.243244+0800 多线程[5320:860216] 开始执行</span></span><br><span class="line"><span class="comment">2020-02-01 00:12:01.246097+0800 多线程[5320:860216] 0,&lt;NSThread: 0x600000d769c0&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:12:01.249172+0800 多线程[5320:860352] 3,&lt;NSThread: 0x600000dec600&gt;&#123;number = 8, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:12:01.249177+0800 多线程[5320:860351] 2,&lt;NSThread: 0x600000dc2dc0&gt;&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:12:01.249172+0800 多线程[5320:860353] 1,&lt;NSThread: 0x600000dc2ac0&gt;&#123;number = 9, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:12:02.246783+0800 多线程[5320:860216] 4,&lt;NSThread: 0x600000d769c0&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:12:02.247289+0800 多线程[5320:860216] 执行完毕</span></span><br><span class="line"><span class="comment">2020-02-01 00:12:02.247622+0800 多线程[5320:860146] 回到主线程</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>将上面代码的队列改为手动创建的并发队列，任务就不会并发执行：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;myqueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;开始执行&quot;</span>);</span><br><span class="line">        dispatch_apply(<span class="number">5</span>, queue, ^(size_t i) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%zu,%@&quot;</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;执行完毕&quot;</span>);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;回到主线程&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2020-02-01 00:15:40.050698+0800 多线程[5364:863969] 开始执行</span></span><br><span class="line"><span class="comment">2020-02-01 00:15:41.056250+0800 多线程[5364:863969] 0,&lt;NSThread: 0x600000824880&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:15:42.061385+0800 多线程[5364:863969] 1,&lt;NSThread: 0x600000824880&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:15:43.066950+0800 多线程[5364:863969] 2,&lt;NSThread: 0x600000824880&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:15:44.069207+0800 多线程[5364:863969] 3,&lt;NSThread: 0x600000824880&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:15:45.071144+0800 多线程[5364:863969] 4,&lt;NSThread: 0x600000824880&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 00:15:45.071491+0800 多线程[5364:863969] 执行完毕</span></span><br><span class="line"><span class="comment">2020-02-01 00:15:45.071912+0800 多线程[5364:863900] 回到主线程</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="Dispatch-Source"><a href="#Dispatch-Source" class="headerlink" title="Dispatch Source"></a>Dispatch Source</h3><p>dispatch 框架提供一套接口用于监听系统底层对象(如文件描述符、Mach 端口、信号量等)，当这些对象有事件产生时会自动把事件的处理 block 函数提交到 dispatch 队列中执行，这套接口就是 Dispatch Source API，Dispatch Source 其实就是对 kqueue 功能的封装，可以去查看 dispatch_source 的 c 源码实现(什么是 kqueue？Google，什么是 Mach 端口? Google Again)，Dispatch Source 主要处理以下几种事件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_SOURCE_TYPE_DATA_ADD        变量增加</span><br><span class="line">DISPATCH_SOURCE_TYPE_DATA_OR         变量OR</span><br><span class="line">DISPATCH_SOURCE_TYPE_MACH_SEND       Mach端口发送</span><br><span class="line">DISPATCH_SOURCE_TYPE_MACH_RECV       Mach端口接收</span><br><span class="line">DISPATCH_SOURCE_TYPE_MEMORYPRESSURE  内存压力情况变化</span><br><span class="line">DISPATCH_SOURCE_TYPE_PROC            与进程相关的事件</span><br><span class="line">DISPATCH_SOURCE_TYPE_READ            可读取文件映像</span><br><span class="line">DISPATCH_SOURCE_TYPE_SIGNAL          接收信号</span><br><span class="line">DISPATCH_SOURCE_TYPE_TIMER           定时器事件</span><br><span class="line">DISPATCH_SOURCE_TYPE_VNODE           文件系统变更</span><br><span class="line">DISPATCH_SOURCE_TYPE_WRITE           可写入文件映像</span><br></pre></td></tr></table></figure><p>当有事件发生时，dispatch source 自动将一个 block 放入一个 dispatch queue 执行。</p><h4 id="GCD定时器"><a href="#GCD定时器" class="headerlink" title="GCD定时器"></a>GCD定时器</h4><p> NSTimer 和 CADisplayLink 定时器不准时的问题，解决办法就是使用 GCD 定时器。GCD 的定时器是直接跟系统内核挂钩的，而且它不依赖于RunLoop，所以它非常的准时。</p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">     <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;myqueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建定时器</span></span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    <span class="comment">//设置时间（start:几s后开始执行； interval:时间间隔）</span></span><br><span class="line">    uint64_t start = <span class="number">2.0</span>; <span class="comment">//2s后开始执行</span></span><br><span class="line">    uint64_t interval = <span class="number">1.0</span>; <span class="comment">//每隔1s执行</span></span><br><span class="line">    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * <span class="built_in">NSEC_PER_SEC</span>), interval * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//设置回调</span></span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//启动定时器</span></span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.timer = timer;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2020-02-01 21:34:23.036474+0800 多线程[7309:1327653] &lt;NSThread: 0x600001a5cfc0&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 21:34:25.036832+0800 多线程[7309:1327705] &lt;NSThread: 0x600001acb600&gt;&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 21:34:26.036977+0800 多线程[7309:1327705] &lt;NSThread: 0x600001acb600&gt;&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 21:34:27.036609+0800 多线程[7309:1327707] &lt;NSThread: 0x600001a1e5c0&gt;&#123;number = 4, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="dispatch-queue-set-specific-amp-dispatch-get-specific"><a href="#dispatch-queue-set-specific-amp-dispatch-get-specific" class="headerlink" title="dispatch_queue_set_specific &amp; dispatch_get_specific"></a>dispatch_queue_set_specific &amp; dispatch_get_specific</h3><p>这两个 API 类似于objc_setAssociatedObject跟objc_getAssociatedObject，FMDB 里就用到这个来防止死锁，来看看 FMDB 的部分源码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="type">void</span> * <span class="keyword">const</span> kDispatchQueueSpecificKey = &amp;kDispatchQueueSpecificKey;</span><br><span class="line"><span class="comment">//创建一个串行队列来执行数据库的所有操作</span></span><br><span class="line">_queue = dispatch_queue_create([[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;fmdb.%@&quot;</span>, <span class="keyword">self</span>] UTF8String], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过key标示队列，设置context为self</span></span><br><span class="line">dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge <span class="type">void</span> *)<span class="keyword">self</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>当要执行数据库操作时，如果在 queue 里面的 block 执行过程中，又调用了 indatabase 方法，需要检查是不是同一个 queue，因为同一个 queue 的话会产生死锁情况</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)inDatabase:(<span class="type">void</span> (^)(FMDatabase *db))block &#123;</span><br><span class="line">    FMDatabaseQueue *currentSyncQueue = (__bridge <span class="type">id</span>)dispatch_get_specific(kDispatchQueueSpecificKey);</span><br><span class="line">    assert(currentSyncQueue != <span class="keyword">self</span> &amp;&amp; <span class="string">&quot;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904077642432526">关于 GCD 的一些总结</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RunLoop之NSTimer</title>
      <link href="/2022/01/31/RunLoop%E4%B9%8BNSTimer/"/>
      <url>/2022/01/31/RunLoop%E4%B9%8BNSTimer/</url>
      
        <content type="html"><![CDATA[<h2 id="NSTimer-的创建"><a href="#NSTimer-的创建" class="headerlink" title="NSTimer 的创建"></a>NSTimer 的创建</h2><p><code>NSTimer</code>的创建通常有两种方式，一种是以 <code>scheduledTimerWithTimeInterval</code> 为开头的类方法 。这些方法在创建了 <code>NSTimer</code> 之后会将这个 <code>NSTimer</code> 以 <code>NSDefaultRunLoopMode</code> 模式放入当前线程的 <code>RunLoop</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ ( <span class="built_in">NSTimer</span> *) scheduledTimerWithTimeInterval:invocation:repeats: </span><br><span class="line">+ ( <span class="built_in">NSTimer</span> *) scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</span><br></pre></td></tr></table></figure><p>另一种是以 timerWithTimeInterval 为开头的类方法。这些方法创建的 NSTimer 并不能马上使用，还需要调用 RunLoop 的 addTimer:forMode: 方法将 NSTimer 放入 RunLoop，这样 NSTimer 才能正常工作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ ( <span class="built_in">NSTimer</span> *) timerWithTimeInterval:invocation:repeats:</span><br><span class="line">+ ( <span class="built_in">NSTimer</span> *) timerWithTimeInterval:target:selector:userInfo:repeats:</span><br></pre></td></tr></table></figure><blockquote><p>Timers work in conjunction with run loops. Run loops maintain strong references to their timers, so you don’t have to maintain your own strong reference to a timer after you have added it to a run loop.</p></blockquote><p>从 <code>NSTimer</code> 的官方文档可以得知，<code>RunLoop</code> 对加入其中的 <code>NSTimer</code> 会添加一个强引用。</p><span id="more"></span><p>以 <code>timerWithTimeInterval</code> 为开头的类方法创建出来的 <code>NSTimer</code> 需要手动加入 <code>RunLoop</code>, 这样 <code>RunLoop</code> 才会对这个 <code>NSTimer</code> 有强引用。若是我们使用 <code>weak</code> 修饰 <code>NSTimer</code> 变量，在 <code>NSTimer</code> 创建之后加入 <code>RunLoop</code> 之前，将 <code>NSTimer</code> 对象赋值给 <code>weak</code> 修饰的变量，那么对导致 <code>NSTimer</code> 对象被释放。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;TimerViewController.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerViewController</span> ()</span></span><br><span class="line"><span class="comment">// 使用 weak</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// NSTimer 创建之后没有被自动加入 RunLoop</span></span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(outputLog:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.timer == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;timer 被释放了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)outputLog:(<span class="built_in">NSTimer</span> *)timer&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;it is log!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决这个问题的方法也很简单， NSTimer 对象创建之后先加入 RunLoop 再赋值给变量。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...... 省略代码</span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 创建 NSTimer</span></span><br><span class="line">    <span class="built_in">NSTimer</span> *doNotWorkTimer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(outputLog:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    <span class="comment">// NSTimer 加入 NSRunLoop</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:doNotWorkTimer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    <span class="comment">// 赋值给 weak 变量</span></span><br><span class="line">    <span class="keyword">self</span>.timer = doNotWorkTimer;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...... 省略代码</span></span><br></pre></td></tr></table></figure><h2 id="NSTimer保留环"><a href="#NSTimer保留环" class="headerlink" title="NSTimer保留环"></a>NSTimer保留环</h2><p>在使用NSTimer的时候，NSTimer会生成指向其使用者的引用，而其使用者如果也引用了NSTimer，那么就会生成保留环。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="type">void</span>)startPolling;</span><br><span class="line">- (<span class="type">void</span>)stopPolling;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCClass</span> </span>&#123;</span><br><span class="line">     <span class="built_in">NSTimer</span> *_pollTimer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)init &#123;</span><br><span class="line">     <span class="keyword">return</span> [<span class="variable language_">super</span> init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    [_pollTimer invalidate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)stopPolling &#123;</span><br><span class="line"></span><br><span class="line">    [_pollTimer invalidate];</span><br><span class="line">    _pollTimer = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)startPolling &#123;</span><br><span class="line">   _pollTimer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">5.0</span></span><br><span class="line">                                                 target:<span class="keyword">self</span></span><br><span class="line">                                               selector:<span class="keyword">@selector</span>(p_doPoll)</span><br><span class="line">                                               userInfo:<span class="literal">nil</span></span><br><span class="line">                                                repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)p_doPoll &#123;</span><br><span class="line">    <span class="comment">// Poll the resource</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>在EOCClass和_pollTimer之间形成了保留环，如果不主动调用stopPolling方法就无法打破这个保留环。通过回收该类的方法来打破此保留环也是行不通的，因为会将该类和NSTimer孤立出来，形成“孤岛”</p></blockquote><img src="/2022/01/31/RunLoop%E4%B9%8BNSTimer/NSTimerCycle.png" class="&#x3D;"><h3 id="通过“块”来解决"><a href="#通过“块”来解决" class="headerlink" title="通过“块”来解决"></a>通过“块”来解决</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSTimer</span> (<span class="title">EOCBlocksSupport</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span>*)eoc_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval</span><br><span class="line">                                         block:(<span class="type">void</span>(^)())block</span><br><span class="line">                                         repeats:(<span class="type">BOOL</span>)repeats;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSTimer</span> (<span class="title">EOCBlocksSupport</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span>*)eoc_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval</span><br><span class="line">                                         block:(<span class="type">void</span>(^)())block</span><br><span class="line">                                        repeats:(<span class="type">BOOL</span>)repeats</span><br><span class="line">&#123;</span><br><span class="line">             <span class="keyword">return</span> [<span class="keyword">self</span> scheduledTimerWithTimeInterval:interval</span><br><span class="line">                                                  target:<span class="keyword">self</span></span><br><span class="line">                                                selector:<span class="keyword">@selector</span>(eoc_blockInvoke:)</span><br><span class="line">                                                userInfo:[block <span class="keyword">copy</span>]</span><br><span class="line">                                                 repeats:repeats];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">void</span>)eoc_blockInvoke:(<span class="built_in">NSTimer</span>*)timer &#123;</span><br><span class="line">     <span class="type">void</span> (^block)() = timer.userInfo;</span><br><span class="line">         <span class="keyword">if</span> (block) &#123;</span><br><span class="line">             block();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在NSTimer类里添加了方法，我们来看一下如何使用它：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)startPolling &#123;</span><br><span class="line">         __<span class="keyword">weak</span> EOCClass *weakSelf = <span class="keyword">self</span>;    </span><br><span class="line">         _pollTimer = [<span class="built_in">NSTimer</span> eoc_scheduledTimerWithTimeInterval:<span class="number">5.0</span> block:^&#123;</span><br><span class="line"></span><br><span class="line">               EOCClass *strongSelf = weakSelf;</span><br><span class="line">               [strongSelf p_doPoll];</span><br><span class="line">          &#125;</span><br><span class="line">         repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，创建了一个<code>self</code>的弱引用，然后让块捕获了这个<code>self</code>变量，让其在执行期间存活。<br>一旦外界指向EOC类的最后一个引用消失，该类就会被释放，被释放的同时，也会向<code>NSTimer</code>发送<code>invalidate</code>消息（因为在该类的<code>dealloc</code>方法中向<code>NSTimer</code>发送了<code>invalidate</code>消息）。<br>而且，即使在<code>dealloc</code>方法里没有发送<code>invalidate</code>消息，因为块里的<code>weakSelf</code>会变成<code>nil</code>，所以<code>NSTimer</code>同样会失效。</p><h2 id="RunLoop与NSTimer"><a href="#RunLoop与NSTimer" class="headerlink" title="RunLoop与NSTimer"></a>RunLoop与NSTimer</h2><p>NSTimer是由RunLoop来管理的，NSTImer其实就是CFRunLoopTimerRef，他们之间是toll-free bridged的，可以相互转换；</p><p>如果我们在子线程上使用NSTimer，就必须开启子线程的RunLoop，否则定时器无法生效</p><h3 id="tableview滑动时NSTimer失效的问题"><a href="#tableview滑动时NSTimer失效的问题" class="headerlink" title="tableview滑动时NSTimer失效的问题"></a>tableview滑动时NSTimer失效的问题</h3><p>RunLoop同一时间只能运行在一种模式下，当我们滑动tableView&#x2F;scrollview的时候，Runloop会切换到UITrackingRunLoopMode界面追踪模式下，如果我们的NSTimer是添加到RunLoop的defauleMode默认模式下的话，此时是会失效的。</p><p>解决：可以将NSTimer添加到RunLoop的ComonModes通用模式下，来保证无论在默认模式还是界面追踪模式下NSTimer都可以执行。</p><h3 id="NSTimer的创建方式"><a href="#NSTimer的创建方式" class="headerlink" title="NSTimer的创建方式"></a>NSTimer的创建方式</h3><p>自动添加到RunLoop的默认模式下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;123&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>自定义添加到RunLoop的某种模式下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;123&quot;</span>);</span><br><span class="line">&#125;];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure><blockquote><p>注意： 如果是通过timerxxx开头方法创建的NSTimer是不会自动添加到RunLoop中的，所以一定要记得手动添加，否则NSTimer不生效</p></blockquote><h3 id="CFRunLoopAddTimer函数实现"><a href="#CFRunLoopAddTimer函数实现" class="headerlink" title="CFRunLoopAddTimer函数实现"></a>CFRunLoopAddTimer函数实现</h3><p><code>CFRunLoopAddTimer()</code>函数中会判断传入的<code>modeName</code>模式名称是不是<br><code>kCFRunLoopCommonModes</code>通用模式，是的话就会将timer添加到<code>RunLoop</code>的 <code>_commonModeItems</code> 集合中，并同步该<code>timer</code>到 <code>_commonModes</code> 里的所有模式中，这样无论在默认模式还是界面追踪模式下<code>NSTimer</code>都可以执行。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">CFRunLoopAddTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> rlt, <span class="built_in">CFStringRef</span> modeName) &#123;    </span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!__CFIsValid(rlt) || (<span class="literal">NULL</span> != rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop != rl)) <span class="keyword">return</span>;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="keyword">if</span> (modeName == kCFRunLoopCommonModes) &#123;       <span class="comment">// 判断 modeName 是不是 kCFRunLoopCommonModes</span></span><br><span class="line">    <span class="built_in">CFSetRef</span> set = rl-&gt;_commonModes ? <span class="built_in">CFSetCreateCopy</span>(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == rl-&gt;_commonModeItems) &#123;    <span class="comment">// 懒加载，判断 _commonModeItems 是否为空，是的话创建</span></span><br><span class="line">        rl-&gt;_commonModeItems = <span class="built_in">CFSetCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFSetAddValue</span>(rl-&gt;_commonModeItems, rlt);  <span class="comment">// 将 timer 添加到 _commonModeItems 中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != set) &#123;</span><br><span class="line">        <span class="built_in">CFTypeRef</span> context[<span class="number">2</span>] = &#123;rl, rlt&#125;;  <span class="comment">// 将 timer 和 RunLoop 封装到 context 中</span></span><br><span class="line">        <span class="comment">/* add new item to all common-modes */</span></span><br><span class="line">            <span class="comment">// 遍历 commonModes，将 timer 添加到 commonModes 的所有模式下</span></span><br><span class="line">        <span class="built_in">CFSetApplyFunction</span>(set, (__CFRunLoopAddItemToCommonModes), (<span class="type">void</span> *)context);</span><br><span class="line">        <span class="built_in">CFRelease</span>(set);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> __CFRunLoopAddItemToCommonModes(<span class="keyword">const</span> <span class="type">void</span> *value, <span class="type">void</span> *ctx) &#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> modeName = (<span class="built_in">CFStringRef</span>)value;</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> rl = (<span class="built_in">CFRunLoopRef</span>)(((<span class="built_in">CFTypeRef</span> *)ctx)[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">CFTypeRef</span> item = (<span class="built_in">CFTypeRef</span>)(((<span class="built_in">CFTypeRef</span> *)ctx)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CFGetTypeID</span>(item) == <span class="built_in">CFRunLoopSourceGetTypeID</span>()) &#123;</span><br><span class="line"><span class="built_in">CFRunLoopAddSource</span>(rl, (<span class="built_in">CFRunLoopSourceRef</span>)item, modeName);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">CFGetTypeID</span>(item) == <span class="built_in">CFRunLoopObserverGetTypeID</span>()) &#123;</span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(rl, (<span class="built_in">CFRunLoopObserverRef</span>)item, modeName);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">CFGetTypeID</span>(item) == <span class="built_in">CFRunLoopTimerGetTypeID</span>()) &#123;</span><br><span class="line"><span class="built_in">CFRunLoopAddTimer</span>(rl, (<span class="built_in">CFRunLoopTimerRef</span>)item, modeName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NSTImer和CADisplayLink存在的问题"><a href="#NSTImer和CADisplayLink存在的问题" class="headerlink" title="NSTImer和CADisplayLink存在的问题"></a>NSTImer和CADisplayLink存在的问题</h3><p>不准时：NSTime和CADisplayLink底层都是基于RunLoop的<code>CFRunLoopTimerRef</code>的实现的，也就是说它们都依赖于RunLoop。如果RunLoop的任务过于繁重，会导致它们不准时</p><p>比如NSTimer每1.0秒就会执行一次任务，Runloop每进行一次循环，就会看一下NSTimer的时间是否达到1.0秒，是的话就执行任务。但是由于Runloop每一次循环的任务不一样，所花费的时间就不固定。假设第一次循环所花时间为 0.2s，第二次 0.3s，第三次 0.3s，则再过 0.2s 就会执行NSTimer的任务，这时候可能Runloop的任务过于繁重，第四次花了0.5s，那加起来时间就是 1.3s，导致NSTimer不准时。</p><blockquote><p>CADisplayLink 是用于同步屏幕刷新的定时器，如果任务繁重的话，会出现丢帧现象的</p></blockquote><p>解决方法：使用GCD的定时器，GCD 的定时器是直接跟系统内核挂钩的，而且它不依赖于RunLoop，所以它非常的准时。示例如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;myqueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建定时器</span></span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    <span class="comment">//设置时间（start:几s后开始执行； interval:时间间隔）</span></span><br><span class="line">    uint64_t start = <span class="number">2.0</span>;    <span class="comment">//2s后开始执行</span></span><br><span class="line">    uint64_t interval = <span class="number">1.0</span>; <span class="comment">//每隔1s执行</span></span><br><span class="line">    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * <span class="built_in">NSEC_PER_SEC</span>), interval * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//设置回调</span></span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//启动定时器</span></span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.timer = timer;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2020-02-01 21:34:23.036474+0800 多线程[7309:1327653] &lt;NSThread: 0x600001a5cfc0&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 21:34:25.036832+0800 多线程[7309:1327705] &lt;NSThread: 0x600001acb600&gt;&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 21:34:26.036977+0800 多线程[7309:1327705] &lt;NSThread: 0x600001acb600&gt;&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-01 21:34:27.036609+0800 多线程[7309:1327707] &lt;NSThread: 0x600001a1e5c0&gt;&#123;number = 4, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/11fae16ab622">NSTimer 避坑指南</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> RunLoop </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RunLoop之事件循环机制、线程</title>
      <link href="/2022/01/31/RunLoop%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E3%80%81%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/01/31/RunLoop%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E3%80%81%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h2><h3 id="分析UIApplicationMain如何启动主线程的RunLoop"><a href="#分析UIApplicationMain如何启动主线程的RunLoop" class="headerlink" title="分析UIApplicationMain如何启动主线程的RunLoop"></a>分析UIApplicationMain如何启动主线程的RunLoop</h3><p>打断点，通过lldb指令bt查看函数调用栈如下：</p><img src="/2022/01/31/RunLoop%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E3%80%81%E7%BA%BF%E7%A8%8B/runLoopStart.png" class="&#x3D;"><p>在UIApplicationMain函数中调用了Core Foundation框架下的<code>CFRunLoopRunSpecific</code>函数</p><span id="more"></span><h3 id="CFRunLoopRunSpecific函数实现：RunLoop的入口"><a href="#CFRunLoopRunSpecific函数实现：RunLoop的入口" class="headerlink" title="CFRunLoopRunSpecific函数实现：RunLoop的入口"></a>CFRunLoopRunSpecific函数实现：RunLoop的入口</h3><p>源码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    <span class="built_in">CHECK_FOR_FORK</span>();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span> kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="comment">// 根据 modeName 找到本次运行的 mode</span></span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 如果没找到 || mode 中没有注册任何事件，则就此停止，不进入循环</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line">Boolean did = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (currentMode) __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">__CFRunLoopUnlock(rl);</span><br><span class="line"><span class="keyword">return</span> did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</span><br><span class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    <span class="type">int32_t</span> result = kCFRunLoopRunFinished;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知 Observers：即将进入 RunLoop</span></span><br><span class="line"><span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    <span class="comment">// RunLoop 具体要做的事情</span></span><br><span class="line">result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    <span class="comment">// 通知 Observers：即将退出 RunLoop</span></span><br><span class="line"><span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line"></span><br><span class="line">        __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">        __CFRunLoopPopPerRunData(rl, previousPerRun);</span><br><span class="line">rl-&gt;_currentMode = previousMode;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删掉不重要的细节：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知 Observers：即将进入 RunLoop</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    <span class="comment">// RunLoop 具体要做的事情</span></span><br><span class="line">result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    <span class="comment">// 通知 Observers：即将退出 RunLoop</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可知，RunLoop事件循环的实现机制体现在__CFRunLoopRun函数中。</p><img src="/2022/01/31/RunLoop%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E3%80%81%E7%BA%BF%E7%A8%8B/runloopRun.png" class="&#x3D;"><h3 id="CFRunLoopRun函数实现：事件循环的实现机制"><a href="#CFRunLoopRun函数实现：事件循环的实现机制" class="headerlink" title="__CFRunLoopRun函数实现：事件循环的实现机制"></a>__CFRunLoopRun函数实现：事件循环的实现机制</h3><p>精简后的代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  __CFRunLoopRun</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param rl              运行的 RunLoop 对象</span></span><br><span class="line"><span class="comment"> *  @param rlm             运行的 mode</span></span><br><span class="line"><span class="comment"> *  @param seconds         loop 超时时间</span></span><br><span class="line"><span class="comment"> *  @param stopAfterHandle true: RunLoop 处理完事件就退出  false:一直运行直到超时或者被手动终止</span></span><br><span class="line"><span class="comment"> *  @param previousMode    上一次运行的 mode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 返回 4 种状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 通知 Observers：即将处理 Timers</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        <span class="comment">// 通知 Observers：即将处理 Sources</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        <span class="comment">// 处理 Blocks</span></span><br><span class="line">    __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        <span class="comment">// 处理 Sources0</span></span><br><span class="line">        <span class="keyword">if</span> (__CFRunLoopDoSources0(rl, rlm, stopAfterHandle)) &#123;</span><br><span class="line">            <span class="comment">// 处理 Blocks</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 判断有无 Source1</span></span><br><span class="line">        <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="built_in">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果有 Source1，就跳转到 handle_msg</span></span><br><span class="line">            <span class="keyword">goto</span> handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通知 Observers：即将进入休眠</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">    __CFRunLoopSetSleeping(rl);</span><br><span class="line">        <span class="comment">// ⚠️休眠，等待消息来唤醒线程</span></span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="built_in">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">    __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        <span class="comment">// 通知 Observers：刚从休眠中唤醒</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">handle_msg:</span><br><span class="line">        <span class="keyword">if</span> (被 Timer 唤醒) &#123;</span><br><span class="line">            <span class="comment">// 处理 Timer</span></span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, <span class="built_in">mach_absolute_time</span>())</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (被 GCD 唤醒) &#123;</span><br><span class="line">            <span class="comment">// 处理 GCD </span></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 被 Source1 唤醒   </span></span><br><span class="line">            <span class="comment">// 处理 Source1</span></span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 Blocks</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 设置返回值 */</span></span><br><span class="line">        <span class="comment">// 进入 loop 时参数为处理完事件就返回</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;  </span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        <span class="comment">// 超出传入参数标记的超时时间</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; <span class="built_in">mach_absolute_time</span>()) &#123;  </span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        <span class="comment">// 被外部调用者强制停止</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;  </span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        <span class="comment">// 自动停止</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;  </span><br><span class="line">            rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        <span class="comment">// mode 中没有任何的 Source0/Source1/Timer/Observer</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;  </span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从该函数实现中可以得知RunLoop主要就做以下几件事情：</p><ul><li>__CFRunLoopDoObservers：通知<code>Observers</code>接下来要做什么</li><li>__CFRunLoopDoBlocks：处理<code>Blocks</code></li><li>__CFRunLoopDoSources0：处理<code>Sources0</code></li><li>__CFRunLoopDoSources1：处理<code>Sources1</code></li><li>__CFRunLoopDoTimers：处理<code>Timers</code></li><li>处理 GCD 相关：<code>dispatch_async(dispatch_get_main_queue(), ^&#123; &#125;);</code></li><li>__CFRunLoopSetSleeping&#x2F;__CFRunLoopUnsetSleeping：休眠等待&#x2F;结束休眠</li><li>__CFRunLoopServiceMachPort -&gt; mach-msg()：转移当前线程的控制权</li></ul><img src="/2022/01/31/RunLoop%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E3%80%81%E7%BA%BF%E7%A8%8B/runLoopWhile.png" class="&#x3D;"><h3 id="CFRunLoopServiceMachPort函数实现：RunLoop休眠的实现原理"><a href="#CFRunLoopServiceMachPort函数实现：RunLoop休眠的实现原理" class="headerlink" title="__CFRunLoopServiceMachPort函数实现：RunLoop休眠的实现原理"></a>__CFRunLoopServiceMachPort函数实现：RunLoop休眠的实现原理</h3><p>在<code>__CFRunLoopRun</code>函数中，会调用<code>__CFRunLoopServiceMachPort</code>函数，该函数中调用了<code>mach_msg()</code>函数来转移当前线程的控制权给内核态&#x2F;用户态。</p><ul><li>没有消息需要处理时，休眠线程以避免资源占用。调用mach_msg()从用户态切换到内核态，等待消息；</li><li>有消息需要处理时，立刻唤醒线程，调用mach_msg()回到用户态处理消息。</li></ul><p>这就是RunLoop休眠的实现原理，也是<code>RunLoop</code>与简单的<code>do...while</code>循环区别：</p><ul><li>RunLoop：休眠的时候，当前线程不会做任何事，CPU 不会再分配资源；</li><li>简单的do…while循环：当前线程并没有休息，一直占用 CPU 资源。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Boolean __CFRunLoopServiceMachPort(<span class="type">mach_port_name_t</span> port, <span class="type">mach_msg_header_t</span> **buffer, <span class="type">size_t</span> buffer_size, <span class="type">mach_port_t</span> *livePort, <span class="type">mach_msg_timeout_t</span> timeout, <span class="type">voucher_mach_msg_state_t</span> *voucherState, <span class="type">voucher_t</span> *voucherCopy) &#123;</span><br><span class="line">    Boolean originalBuffer = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">kern_return_t</span> ret = KERN_SUCCESS;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">/* In that sleep of death what nightmares may come ... */</span></span><br><span class="line">        <span class="type">mach_msg_header_t</span> *msg = (<span class="type">mach_msg_header_t</span> *)*buffer;</span><br><span class="line">        msg-&gt;msgh_bits = <span class="number">0</span>;</span><br><span class="line">        msg-&gt;msgh_local_port = port;</span><br><span class="line">        msg-&gt;msgh_remote_port = MACH_PORT_NULL;</span><br><span class="line">        msg-&gt;msgh_size = buffer_size;</span><br><span class="line">        msg-&gt;msgh_id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (TIMEOUT_INFINITY == timeout) &#123; <span class="built_in">CFRUNLOOP_SLEEP</span>(); &#125; <span class="keyword">else</span> &#123; <span class="built_in">CFRUNLOOP_POLL</span>(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⚠️⚠️⚠️</span></span><br><span class="line">        ret = <span class="built_in">mach_msg</span>(msg, MACH_RCV_MSG|(voucherState ? MACH_RCV_VOUCHER : <span class="number">0</span>)|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : <span class="number">0</span>)|<span class="built_in">MACH_RCV_TRAILER_TYPE</span>(MACH_MSG_TRAILER_FORMAT_0)|<span class="built_in">MACH_RCV_TRAILER_ELEMENTS</span>(MACH_RCV_TRAILER_AV), <span class="number">0</span>, msg-&gt;msgh_size, port, timeout, MACH_PORT_NULL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Take care of all voucher-related work right after mach_msg.</span></span><br><span class="line">        <span class="comment">// If we don&#x27;t release the previous voucher we&#x27;re going to leak it.</span></span><br><span class="line">        <span class="built_in">voucher_mach_msg_revert</span>(*voucherState);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Someone will be responsible for calling voucher_mach_msg_revert. This call makes the received voucher the current one.</span></span><br><span class="line">        *voucherState = <span class="built_in">voucher_mach_msg_adopt</span>(msg);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (voucherCopy) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*voucherState != VOUCHER_MACH_MSG_STATE_UNCHANGED) &#123;</span><br><span class="line">                <span class="comment">// Caller requested a copy of the voucher at this point. By doing this right next to mach_msg we make sure that no voucher has been set in between the return of mach_msg and the use of the voucher copy.</span></span><br><span class="line">                <span class="comment">// CFMachPortBoost uses the voucher to drop importance explicitly. However, we want to make sure we only drop importance for a new voucher (not unchanged), so we only set the TSD when the voucher is not state_unchanged.</span></span><br><span class="line">                *voucherCopy = <span class="built_in">voucher_copy</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *voucherCopy = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CFRUNLOOP_WAKEUP</span>(ret);</span><br><span class="line">        <span class="keyword">if</span> (MACH_MSG_SUCCESS == ret) &#123;</span><br><span class="line">            *livePort = msg ? msg-&gt;msgh_local_port : MACH_PORT_NULL;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (MACH_RCV_TIMED_OUT == ret) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!originalBuffer) <span class="built_in">free</span>(msg);</span><br><span class="line">            *buffer = <span class="literal">NULL</span>;</span><br><span class="line">            *livePort = MACH_PORT_NULL;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (MACH_RCV_TOO_LARGE != ret) <span class="keyword">break</span>;</span><br><span class="line">        buffer_size = <span class="built_in">round_msg</span>(msg-&gt;msgh_size + MAX_TRAILER_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (originalBuffer) *buffer = <span class="literal">NULL</span>;</span><br><span class="line">        originalBuffer = <span class="literal">false</span>;</span><br><span class="line">        *buffer = <span class="built_in">realloc</span>(*buffer, buffer_size);</span><br><span class="line">    &#125;</span><br><span class="line">    HALT;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RunLoop与线程"><a href="#RunLoop与线程" class="headerlink" title="RunLoop与线程"></a>RunLoop与线程</h2><ul><li>RunLoop对象和线程是一一对应关系；</li><li>RunLoop保存在一个全局的Dictionary里，线程作为key，RunLoop作为value</li><li>如果没有RunLoop，线程执行完任务就会退出；如果没有RunLoop，主线程执行完main()函数就会退出，程序就不能处于运行状态；</li><li>RunLoop创建时机：线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建</li><li>RunLoop销毁时机：RunLoop会在线程结束时销毁；</li><li>主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop</li><li>主线程的RunLoop对象是在UIApplicationMain中通过<code>[NSRunLoop currentRunLoop]</code>获取，一旦发现它不存在，就会创建RunLoop对象。</li></ul><h3 id="未启动RunLoop的子线程"><a href="#未启动RunLoop的子线程" class="headerlink" title="未启动RunLoop的子线程"></a>未启动RunLoop的子线程</h3><p>创建一个NSThread的子类HTThread并重写了dealloc方法来观察线程的状态。执行以下代码，发现线程执行完一次test任务就退出销毁了，没有再执行test任务，原因就是没有启动该线程的RunLoop</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    HTThread *thread = [[HTThread alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test) object:<span class="literal">nil</span>];</span><br><span class="line">    [thread start];</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;test on %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test on &lt;HTThread: 0x600003cb52c0&gt;&#123;number = 7, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// HTThread dealloc</span></span><br></pre></td></tr></table></figure><h3 id="开启子线程的RunLoop的过程"><a href="#开启子线程的RunLoop的过程" class="headerlink" title="开启子线程的RunLoop的过程"></a>开启子线程的RunLoop的过程</h3><p>获取RunLoop对象</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Foundation</span></span><br><span class="line">[<span class="built_in">NSRunLoop</span> mainRunLoop];     <span class="comment">// 获取主线程的 RunLoop 对象</span></span><br><span class="line">[<span class="built_in">NSRunLoop</span> currentRunLoop];  <span class="comment">// 获取当前线程的 RunLoop 对象</span></span><br><span class="line"><span class="comment">// Core Foundation</span></span><br><span class="line"><span class="built_in">CFRunLoopGetMain</span>();     <span class="comment">// 获取主线程的 RunLoop 对象</span></span><br><span class="line"><span class="built_in">CFRunLoopGetCurrent</span>();  <span class="comment">// 获取当前线程的 RunLoop 对象</span></span><br></pre></td></tr></table></figure><p>来看一下CFRunLoopGetCurrent()函数是怎么获取RunLoop对象的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>(<span class="type">void</span>) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> rl = (<span class="built_in">CFRunLoopRef</span>)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet0(pthread_self());  <span class="comment">// 调用 _CFRunLoopGet0 函数并传入当前线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// should only be called by Foundation</span></span><br><span class="line"><span class="comment">// t==0 is a synonym for &quot;main thread&quot; that always works</span></span><br><span class="line"><span class="built_in">CF_EXPORT</span> <span class="built_in">CFRunLoopRef</span> _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line"><span class="built_in">CFMutableDictionaryRef</span> dict = <span class="built_in">CFDictionaryCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line"><span class="built_in">CFRunLoopRef</span> mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line"><span class="built_in">CFDictionarySetValue</span>(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line"><span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, dict, (<span class="type">void</span> * <span class="keyword">volatile</span> *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">    <span class="built_in">CFRelease</span>(dict);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CFRelease</span>(mainLoop);</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ️当前线程作为 Key，从 __CFRunLoops 字典中获取 RunLoop </span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    __CFUnlock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;  <span class="comment">// ️如果字典中不存在</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> newLoop = __CFRunLoopCreate(t);  <span class="comment">// 创建当前线程的 RunLoop</span></span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">    loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(__CFRunLoops, pthreadPointer(t), newLoop);  <span class="comment">// 保存到字典中</span></span><br><span class="line">        loop = newLoop;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// don&#x27;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span></span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">    <span class="built_in">CFRelease</span>(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="type">void</span> *)loop, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="type">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), (<span class="type">void</span> (*)(<span class="type">void</span> *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动子线程的RunLoop"><a href="#启动子线程的RunLoop" class="headerlink" title="启动子线程的RunLoop"></a>启动子线程的RunLoop</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Foundation</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line"><span class="comment">// Core Foundation</span></span><br><span class="line"><span class="built_in">CFRunLoopRun</span>();</span><br><span class="line"><span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);  <span class="comment">// 第3个参数：设置为 true，代表执行完 Source/Port 后就会退出当前 loop</span></span><br></pre></td></tr></table></figure><p>来看一下CFRunLoopRun()&#x2F;CFRunLoopRunInMode()函数是怎么启动RunLoop的:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="type">void</span>) &#123;</span><br><span class="line">    int32_t result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SInt32 <span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;   </span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它通过调用CFRunLoopRunSpecific()函数来启动Runloop</p><h3 id="实现一个常驻线程"><a href="#实现一个常驻线程" class="headerlink" title="实现一个常驻线程"></a>实现一个常驻线程</h3><ul><li>好处：经常用到子线程的时候，不用一直创建销毁，提高性能；</li><li>条件：该任务需是串行的，而非并发；</li><li>步骤：<br>① 获取&#x2F;创建当前线程的RunLoop；<br>② 向该RunLoop中添加一个Source&#x2F;Port等来维持RunLoop的事件循环（如果 Mode 里没有任何Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer，RunLoop会立马退出）；<br>③ 启动该RunLoop。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewController.m</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;HTThread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) HTThread *thread;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span>=isStoped) <span class="type">BOOL</span> stopped;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.stopped = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">self</span>.thread = [[HTThread alloc] initWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;begin-----%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ① 获取/创建当前线程的 RunLoop </span></span><br><span class="line">        <span class="comment">// ② 向该 RunLoop 中添加一个 Source/Port 等来维持 RunLoop 的事件循环</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (weakSelf &amp;&amp; !weakSelf.isStoped) &#123;</span><br><span class="line">            <span class="comment">// ③ 启动该 RunLoop</span></span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">              [[NSRunLoop currentRunLoop] run]</span></span><br><span class="line"><span class="comment">              如果调用 RunLoop 的 run 方法，则会开启一个永不销毁的线程</span></span><br><span class="line"><span class="comment">              因为 run 方法会通过反复调用 runMode:beforeDate: 方法，以运行在 NSDefaultRunLoopMode 模式下</span></span><br><span class="line"><span class="comment">              换句话说，该方法有效地开启了一个无限的循环，处理来自 RunLoop 的输入源 Sources 和 Timers 的数据</span></span><br><span class="line"><span class="comment">            */</span> </span><br><span class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;end-----%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);    </span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.thread) <span class="keyword">return</span>;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程需要执行的任务</span></span><br><span class="line">- (<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s-----%@&quot;</span>, __func__, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止子线程的 RunLoop</span></span><br><span class="line">- (<span class="type">void</span>)stopThread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置标记为 YES</span></span><br><span class="line">    <span class="keyword">self</span>.stopped = <span class="literal">YES</span>;   </span><br><span class="line">    <span class="comment">// 停止 RunLoop</span></span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s-----%@&quot;</span>, __func__, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="comment">// 清空线程</span></span><br><span class="line">    <span class="keyword">self</span>.thread = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.thread) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 在子线程调用（waitUntilDone设置为YES，代表子线程的代码执行完毕后，当前方法才会继续往下执行）</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(stopThread) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTThread.h</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HTThread</span> : <span class="title">NSThread</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTThread.m</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;HTThread.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HTThread</span></span></span><br><span class="line">- (<span class="type">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>点击view，接着退出当前ViewController。输出如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin-----&lt;HTThread: 0x600002b71240&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">-[ViewController test]-----&lt;HTThread: 0x600002b71240&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">-[ViewController dealloc]</span><br><span class="line">-[ViewController stopThread]-----&lt;HTThread: 0x600002b71240&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">end-----&lt;HTThread: 0x600002b71240&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">-[HTThread dealloc]</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904073959833613">深入浅出 RunLoop</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> RunLoop </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RunLoop之简介、数据结构</title>
      <link href="/2022/01/30/RunLoop%E4%B9%8B%E7%AE%80%E4%BB%8B%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/01/30/RunLoop%E4%B9%8B%E7%AE%80%E4%BB%8B%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<img src="/2022/01/30/RunLoop%E4%B9%8B%E7%AE%80%E4%BB%8B%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/runloopStart.png" class="&#x3D;"><span id="more"></span><h2 id="RunLoop简介"><a href="#RunLoop简介" class="headerlink" title="RunLoop简介"></a>RunLoop简介</h2><blockquote><p>运行循环，在程序运行过程中循环做一些事情（如接收消息、处理消息、休眠等待等）；<br><code>RunLoop</code>是通过内部维护的事件循环来对<code>事件/消息</code>进行管理的一个对象；<br><code>RunLoop</code>不是一个简单的<code>do...while</code>循环，它涉及到<code>用户态</code>和<code>内核态</code>之间的切换。</p></blockquote><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>事件循环就是对事件&#x2F;消息进行管理，事件循环可以达到：</p><ul><li>没有消息需要处理时，休眠线程以避免资源占用。从用户态切换到内核态，等待消息；</li><li>有消息需要处理时，立刻唤醒线程，回到用户态处理消息；</li><li>通过调用<code>mach_msg()</code>函数来转移当前线程的控制权给内核态&#x2F;用户态</li></ul><h3 id="RunLoop的基本作用"><a href="#RunLoop的基本作用" class="headerlink" title="RunLoop的基本作用"></a>RunLoop的基本作用</h3><p>保持程序的持续运行：如果没有Runloop，main()函数一执行完，程序就会立刻退出（main()函数中调用了UIApplicationMain函数，它的内部会启动主线程的Runloop）</p><p>处理App中的各种事件（比如触摸事件、定时器事件等）</p><p>节省CPU资源，提高程序性能；该做事时做事，该休息时休息</p><h3 id="应用范畴"><a href="#应用范畴" class="headerlink" title="应用范畴"></a>应用范畴</h3><p>定时器、PerformSelector<br>GCD：dispatch_async(dispatch_get_main_queue(), ^{ });<br>事件响应、手势识别、界面刷新<br>网络请求<br>AutoreleasePool</p><h3 id="实际开发中的应用"><a href="#实际开发中的应用" class="headerlink" title="实际开发中的应用"></a>实际开发中的应用</h3><p>使用端口或自定义输入源与其他线程进行通信<br>在子线程上使用定时器<br>解决NSTimer在滑动时停止工作的问题<br>控制线程的生命周期，实现一个常驻线程<br>在Cocoa应用程序中使用任何performSelector…方法<br>监控应用卡顿<br>性能优化</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="CFRunLoopRef"><a href="#CFRunLoopRef" class="headerlink" title="CFRunLoopRef"></a>CFRunLoopRef</h3><p><code>RunLoop</code>对象的底层就是一个<code>CFRunLoopRef</code>结构体，它里面存储者：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CFRunLoop.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__CFRunLoop</span> * CFRunLoopRef;</span><br><span class="line"><span class="comment">// CFRunLoop.c</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoop</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> _pthread;  <span class="comment">// 与线程一一对应</span></span><br><span class="line">    CFMutableSetRef _commonModes;<span class="comment">//存储着 NSString 对象的集合（Mode 的名称）</span></span><br><span class="line">    CFMutableSetRef _commonModeItems;<span class="comment">//存储着被标记为通用模式的Source0/Source1/Timer/Observer</span></span><br><span class="line">    CFRunLoopModeRef _currentMode;<span class="comment">//RunLoop当前的运行模式</span></span><br><span class="line">    CFMutableSetRef _modes;<span class="comment">//存储着RunLoop所有的 Mode（CFRunLoopModeRef）模式</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CFRunLoop.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__CFRunLoopMode</span> *CFRunLoopModeRef;</span><br><span class="line"><span class="comment">// CFRunLoop.c</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoopMode</span> &#123;</span><br><span class="line">    CFStringRef _name;             <span class="comment">// mode 类型，如：NSDefaultRunLoopMode</span></span><br><span class="line">    CFMutableSetRef _sources0;     <span class="comment">// CFRunLoopSourceRef</span></span><br><span class="line">    CFMutableSetRef _sources1;     <span class="comment">// CFRunLoopSourceRef</span></span><br><span class="line">    CFMutableArrayRef _observers;  <span class="comment">// CFRunLoopObserverRef</span></span><br><span class="line">    CFMutableArrayRef _timers;     <span class="comment">// CFRunLoopTimerRef</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>CFRunLoopModeRef代表RunLoop的运行模式<br>一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0&#x2F;Souce1&#x2F;Timer&#x2F;Obsesrver；<br>RunLoop启动时只能选择其中一个Mode，作为currentMode；<br>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入，切换模式不会导致程序退出<br>不同Mode中的Source0&#x2F;Souce1&#x2F;Timer&#x2F;Observer能分隔开来，互不影响<br>如果Mode里没有任何Source0&#x2F;Souce1&#x2F;Timer&#x2F;Observer，RunLoop会立马退出</p><h4 id="常见模式"><a href="#常见模式" class="headerlink" title="常见模式"></a>常见模式</h4><p>NSDefaultRunLoopMode、UITrackingRunLoopMode、UIRunLoopCommonModes（通用模式，默认包含defaultMode和TrackingMode，该模式不是实际存在的一种模式，它只是一个特殊的标记，是同步Source0&#x2F;Souce1&#x2F;Timer&#x2F;Observer到多个Mode中的技术方案。被标记为通用模式的Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer都会存放到多个Mode中的技术方案。被标记为通用模式Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer都会存放到_commonModeItems集合中，会同步这些Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer到多个Mode中）</p><h3 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h3><p>在RunLoop中有两个很重要的概念，一个是上面提到的模式，还有一个就是事件源。事件源分为输入源和定时器源两种：</p><p>输入源又分为Source0和Source1两种，以下__CFRunLoopSource中的共用体uinon中的version0和version1就分别对应Source0和Source1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CFRunLoop.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__CFRunLoopSource</span> * CFRunLoopSourceRef;</span><br><span class="line"><span class="comment">// CFRunLoop.m</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoopSource</span> &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="type">uint32_t</span> _bits;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> _lock;</span><br><span class="line">    CFIndex _order;                       <span class="comment">/* immutable */</span></span><br><span class="line">    CFMutableBagRef _runLoops;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        CFRunLoopSourceContext version0;  <span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">        CFRunLoopSourceContext1 version1; <span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">    &#125; _context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Source0和Source1的区别"><a href="#Source0和Source1的区别" class="headerlink" title="Source0和Source1的区别"></a>Source0和Source1的区别</h3><img src="/2022/01/30/RunLoop%E4%B9%8B%E7%AE%80%E4%BB%8B%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/source.png" class="&#x3D;"><h3 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h3><p><code>CFRunloopTImer</code>和<code>NSTimer</code>是toll-free bridged的，可以相互转换；<br><code>performSelector:withObject:afterDelay:</code>方法会创建timer并添加到RunLoop中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CFRunLoop.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CF_BRIDGED_MUTABLE_TYPE</span>(NSTimer) __CFRunLoopTimer * CFRunLoopTimerRef;</span><br><span class="line"><span class="comment">// CFRunLoop.c</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoopTimer</span> &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="type">uint16_t</span> _bits;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;           <span class="comment">// 添加该 timer 的 RunLoop</span></span><br><span class="line">    CFMutableSetRef _rlModes;        <span class="comment">// 所有包含该 timer 的 modeName</span></span><br><span class="line">    CFAbsoluteTime _nextFireDate;</span><br><span class="line">    CFTimeInterval _interval;        <span class="comment">/* immutable 理想时间间隔 */</span>    </span><br><span class="line">    CFTimeInterval _tolerance;       <span class="comment">/* mutable 时间偏差 */</span>  </span><br><span class="line">    <span class="type">uint64_t</span> _fireTSR;             <span class="comment">/* TSR units */</span></span><br><span class="line">    CFIndex _order;                  <span class="comment">/* immutable */</span></span><br><span class="line">    CFRunLoopTimerCallBack _callout; <span class="comment">/* immutable 回调入口 */</span></span><br><span class="line">    CFRunLoopTimerContext _context;  <span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p><code>CFRunLoopObserverRef</code>用来监听<code>RunLoop</code>的6种活动状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>),          <span class="comment">// 即将进入 RunLoop</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>),   <span class="comment">// 即将处理 Timers</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>),  <span class="comment">// 即将处理 Sources</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>),  <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>),   <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>),           <span class="comment">// 即将退出 RunLoop</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U  <span class="comment">// 表示以上所有状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>UI刷新（BeforeWaiting）</li><li>Autorelease Pool（BeforeWaiting）</li></ul><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CFRunLoop.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__CFRunLoopObserver</span> * CFRunLoopObserverRef;</span><br><span class="line"><span class="comment">// CFRunLoop.c</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoopObserver</span> &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;              <span class="comment">// 添加该 observer 的 RunLoop</span></span><br><span class="line">    CFIndex _rlCount;</span><br><span class="line">    CFOptionFlags _activities;        <span class="comment">/* immutable 监听的活动状态 */</span></span><br><span class="line">    CFIndex _order;                     <span class="comment">/* immutable */</span></span><br><span class="line">    CFRunLoopObserverCallBack _callout;<span class="comment">/* immutable 回调入口 */</span></span><br><span class="line">    CFRunLoopObserverContext _context;<span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>CFRunLoopObserverRef中的<code>_activities</code>用来保存<code>RunLoop</code>的活动状态。当<code>RunLoop</code>的状态发生改变时，通过回调<code>_callout</code>通知所有监听这个状态的<code>Observer</code></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> RunLoop </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>super的本质</title>
      <link href="/2022/01/27/super%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
      <url>/2022/01/27/super%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="objc-supre与objc-msgSendSuper"><a href="#objc-supre与objc-msgSendSuper" class="headerlink" title="objc_supre与objc_msgSendSuper"></a>objc_supre与objc_msgSendSuper</h2><h3 id="objc-super-和-objc-super2"><a href="#objc-super-和-objc-super2" class="headerlink" title="objc_super 和 objc_super2"></a>objc_super 和 objc_super2</h3><p>它们的区别在于第二个成员：</p><p><code>objc_super</code>：super_class &#x2F;&#x2F;receiverClass的父类<br><code>objc_super2</code>: current_class&#x2F;&#x2F;receiverClass（消息接收者的class对象）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// message.h（objc4）</span></span><br><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull <span class="type">id</span> receiver;  <span class="comment">// 消息接收者</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span><br><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull Class <span class="keyword">class</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull Class super_class;  <span class="comment">// receiverClass 的父类</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc_runtime_new.h（objc4）</span></span><br><span class="line"><span class="keyword">struct</span> objc_super2 &#123;</span><br><span class="line">    <span class="type">id</span> receiver;  <span class="comment">// 消息接收者</span></span><br><span class="line">    Class current_class;  <span class="comment">// receiverClass（消息接收者的class对象）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="objc-msgSendSuper-和objc-msgSendSuper2"><a href="#objc-msgSendSuper-和objc-msgSendSuper2" class="headerlink" title="objc_msgSendSuper()和objc_msgSendSuper2()"></a>objc_msgSendSuper()和objc_msgSendSuper2()</h3><p><code>objc_msgSendSuper2() </code>函数所接收的第一个参数应该为<code>objc_super2</code>而非<code>objc_super</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// message.h（objc4）</span></span><br><span class="line"><span class="type">void</span> objc_msgSendSuper(<span class="type">void</span> <span class="comment">/* struct objc_super *super, SEL op, ... */</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-abi.h（objc4）</span></span><br><span class="line"><span class="comment">// objc_msgSendSuper2() takes the current search class, not its superclass.</span></span><br><span class="line"><span class="type">id</span> _Nullable objc_msgSendSuper2(<span class="keyword">struct</span> objc_super * _Nonnull <span class="variable language_">super</span>, SEL _Nonnull op, ...)</span><br></pre></td></tr></table></figure><h2 id="self和super"><a href="#self和super" class="headerlink" title="self和super"></a>self和super</h2><h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><ul><li><p>OC方法都带有两个隐式参数:(id)self和(SEL)_cmd</p></li><li><p>self是一个对象指针，指向当前方法的调用者&#x2F;消息接收者<br>如果是实例方法，它就是指向当前类的实例对象；<br>如果是类方法，它就指向当前类的类对象</p></li><li><p>当使用self调用方法的时候，底层会转换为objc_msgSend()函数的调用，该函数会从<code>当前消息接收类</code>中开始查找方法的实现。</p></li></ul><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul><li>super是一个编译器指令</li><li>当使用super调用方法的时候，底层会转换为<code>objc_msgSendSuper2()</code>函数的调用，该函数会从当前消息接收者类的父类中开始查找方法的实现。</li></ul><h2 id="super本质"><a href="#super本质" class="headerlink" title="super本质"></a>super本质</h2><p>使用clang将以下OC代码转换为C++代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="variable language_">super</span> viewDidLoad]</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换为 C++</span></span><br><span class="line">((<span class="type">void</span> (*)(__rw_objc_super *, SEL))(<span class="type">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(<span class="type">id</span>)<span class="keyword">self</span>, (<span class="type">id</span>)class_getSuperclass(objc_getClass(<span class="string">&quot;ViewController&quot;</span>))&#125;, sel_registerName(<span class="string">&quot;viewDidLoad&quot;</span>));</span><br><span class="line"><span class="comment">// 简化</span></span><br><span class="line"><span class="keyword">struct</span> objc_super arg = &#123;</span><br><span class="line">    <span class="keyword">self</span>,</span><br><span class="line">    class_getSuperclass(objc_getClass(<span class="string">&quot;ViewController&quot;</span>))</span><br><span class="line">&#125;;</span><br><span class="line">objc_msgSendSuper(arg, sel_registerName(<span class="string">&quot;viewDidLoad&quot;</span>));</span><br></pre></td></tr></table></figure><p>可以看到，Runtime 将<code>super</code>转换为<code>objc_msgSendSuper()</code>函数的调用，参数为<code>objc_super</code>和<code>SEL</code></p><h3 id="LLVM-amp-中间代码"><a href="#LLVM-amp-中间代码" class="headerlink" title="LLVM &amp; 中间代码"></a>LLVM &amp; 中间代码</h3><p>为什么前面说super会转换为objc_msgSendSuper2()函数的调用呢？<br>因为转成的C++的实现和真正的底层实现是有差异的，LLVM编译器会将“OC代码”先转成“中间代码(.ll)”再转成“汇编、机器代码”，该中间代码非C&#x2F;C++</p><p>可以使用以下命令行指令生成中间代码:<code>clang -emit-llvm -S main.m</code></p><h3 id="通过汇编验证"><a href="#通过汇编验证" class="headerlink" title="通过汇编验证"></a>通过汇编验证</h3><p>将ViewController.m文件转换成汇编代码进行验证</p><img src="/2022/01/27/super%E7%9A%84%E6%9C%AC%E8%B4%A8/superAssemble.png" class="&#x3D;"><p>查看第 18 行代码即[super viewDidLoad]转换成的汇编代码</p><p>以上可以看到，<code>[super viewDidLoad]</code>底层实际上是转换成了<code>objc_msgSendSuper2()</code>函数的调用而非<code>objc_msgSendSuper()</code>。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>当使用super调用方法的时候，底层会转换为<code>objc_msgSendSuper2()</code>函数的调用，该函数接收两个参数<code>struct objc_super2</code> 和 <code>SEL</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super2 &#123;</span><br><span class="line">    <span class="type">id</span> receiver;  <span class="comment">// 消息接收者</span></span><br><span class="line">    Class current_class;  <span class="comment">// receiverClass</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">id</span> _Nullable objc_msgSendSuper2(<span class="keyword">struct</span> objc_super * _Nonnull <span class="variable language_">super</span>, SEL _Nonnull op, ...)</span><br></pre></td></tr></table></figure><p>objc_msgSendSuper2()函数内部会通过current_class的superclass指针拿到它的父类，从父类开始查找方法的实现。忽略“从 receiverClass 中查找方法的过程”，对应下图就是直接从第 5 步开始</p><p>要注意<code>receiver消息接收者还是子类对象</code>，而不是父类对象，只是查找方法实现的范围变了。</p><h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><p>Q：调用以下 init 方法的打印结果是什么？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HTPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HTStudent</span> : <span class="title">HTPerson</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HTStudent</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[self class] = %@&quot;</span>,[<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[super class] = %@&quot;</span>,[<span class="variable language_">super</span> <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[self superclass] = %@&quot;</span>,[<span class="keyword">self</span> superclass]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[super superclass] = %@&quot;</span>,[<span class="variable language_">super</span> superclass]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> <span class="keyword">class</span>] = HTStudent </span><br><span class="line">[<span class="variable language_">super</span> <span class="keyword">class</span>] = HTStudent </span><br><span class="line">[<span class="keyword">self</span> superclass] = HTPerson</span><br><span class="line">[<span class="variable language_">super</span> superclass] = HTPerson</span><br></pre></td></tr></table></figure><p>class和superclass方法的实现在 NSObject 类中，可以看到它们的返回值取决于receiver</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line">+ (Class)superclass &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>-&gt;superclass;</span><br><span class="line">&#125;</span><br><span class="line">- (Class)superclass &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>]-&gt;superclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>[self class]</code>是从<code>receiverClass</code>开始查找方法的实现，如果没有重写的情况，则会一直找到基类 NSObject，然后调用。<br><code>[super class]</code>是从<code>receiverClass-&gt;superclass</code>开始查找方法的实现，如果没有重写的情况，则会一直找到基类 NSObject，然后调用。<br>由于receiver相同，所以它们的返回值是一样的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904072252751880">深入浅出 Runtime（四）：super 的本质</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Runtime </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Runtime数据结构</title>
      <link href="/2022/01/25/Runtime%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/01/25/Runtime%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<img src="/2022/01/25/Runtime%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/runtime.png" class="&#x3D;"><span id="more"></span><h2 id="objc-object"><a href="#objc-object" class="headerlink" title="objc_object"></a>objc_object</h2><p><code>Objective-C </code>的面相对象都是基于C&#x2F;C++的数据结构—<code>结构体</code>实现的。所有对象都是id类型，对应到runtime中，就是<code>objc_object</code>结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A pointer to an instance of a class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_object</span> *id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">isa_t</span> isa;</span><br><span class="line">    <span class="comment">/*...</span></span><br><span class="line"><span class="comment">      isa操作相关</span></span><br><span class="line"><span class="comment">      弱引用相关</span></span><br><span class="line"><span class="comment">      关联对象相关</span></span><br><span class="line"><span class="comment">      内存管理相关</span></span><br><span class="line"><span class="comment">      ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="objc-class"><a href="#objc-class" class="headerlink" title="objc_class"></a>objc_class</h2><p><code>Class</code>指针用来指向一个Objective-C的类，它是<code>objc_class</code>结构体类型，所以<code>class</code>、<code>meta-class</code>底层结构都是<code>objc_class</code>结构体，<code>objc_class</code>继承自<code>objc_object</code>,所以它也有<code>isa</code>指针，它也是对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An opaque type that represents an Objective-C class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_class</span> *Class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;          <span class="comment">// 指向父类</span></span><br><span class="line">    <span class="type">cache_t</span> cache;             <span class="comment">// 方法缓存 formerly cache pointer and vtable</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;    <span class="comment">// 用于获取具体的类信息 class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="class-data-bits-t"><a href="#class-data-bits-t" class="headerlink" title="class_data_bits_t"></a>class_data_bits_t</h3><p><code>class_data_bits_t</code>主要是对<code>class_rw_t</code>的封装，可以通过<code>bits &amp; FAST_DATA_MASK</code>获得<code>class_rw_t</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">class_data_bits_t</span> &#123;</span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>class_rw_t</code>代表了类相关的读写信息，它是对<code>class_ro_t</code>的封装；</li><li><code>class_rw_t</code>中主要存储着类的方法列表、属性列表、协议列表等；</li><li><code>class_rw_t</code>里面的<code>methods</code>、<code>properties</code>、<code>protocols</code>都继承于list_array_tt二维数组，是可读可写的，包含了类的初始内容、分类的内容。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">class_rw_t</span> &#123;</span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">class_ro_t</span> *ro;</span><br><span class="line"></span><br><span class="line">    <span class="type">method_array_t</span> methods;       <span class="comment">// 方法列表</span></span><br><span class="line">    <span class="type">property_array_t</span> properties;  <span class="comment">// 属性列表</span></span><br><span class="line">    <span class="type">protocol_array_t</span> protocols;   <span class="comment">// 协议列表</span></span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *demangledName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>class_ro_t</code>代表了类相关的只读信息；</li><li><code>class_ro_t</code>中主要存储着类的成员变量列表、类名等；</li><li><code>class_ro_t</code>里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容；</li><li>一开始类的信息都存放在<code>class_ro_t</code>里，当程序运行时，经过一系列的函数调用栈，在realizeClass()函数中，将class_ro_t里的东西和分类的东西合并起来放到class_rw_t里，并让bits指向class_rw_t。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">class_ro_t</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="type">uint32_t</span> instanceSize;  <span class="comment">// instance对象占用的内存空间</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="type">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * ivarLayout;    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * name;  <span class="comment">// 类名</span></span><br><span class="line">    <span class="type">method_list_t</span> * baseMethodList;  </span><br><span class="line">    <span class="type">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="type">const</span> <span class="type">ivar_list_t</span> * ivars;  <span class="comment">// 成员变量列表</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="type">property_list_t</span> *baseProperties;</span><br><span class="line">    <span class="function"><span class="type">method_list_t</span> *<span class="title">baseMethods</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>method_array_t</code>与<code>method_list_t</code></p><img src="/2022/01/25/Runtime%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/methodStruct.png" class="&#x3D;"><h3 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h3><p>用于快速查找方法执行函数；<br>是可增量扩展的哈希表结构，用哈希表来缓存曾经使用过的方法，可以提高方法的查找速度（空间换时间：牺牲内存空间来换取执行效率）；<br>是<code>局部性原理</code>的最佳应用（比如一些方法调用的频率高，存放到cache中，下一次调用这些方法的命中率就会更高些）；<br>hash 函数式为 <code>f(@selector()) = index, @selector() &amp; _mask</code>；<br>当我们调用过一个方法后，runtime会将这个方法缓存到cache中，下次再调用此方法的时候，runtime会优先去cache中查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cache_t</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bucket_t</span> *_buckets;  <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="type">mask_t</span> _mask;               <span class="comment">// 哈希表的长度 - 1</span></span><br><span class="line">    <span class="type">mask_t</span> _occupied;           <span class="comment">// 已经缓存的方法数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bucket_t</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">cache_key_t</span> _key;  <span class="comment">// SEL</span></span><br><span class="line">    IMP _imp;          <span class="comment">// IMP 函数的内存地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="缓存查找流程"><a href="#缓存查找流程" class="headerlink" title="缓存查找流程"></a>缓存查找流程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//objc-cache.mm（objc4）</span></span><br><span class="line"><span class="function"><span class="type">bucket_t</span> * <span class="title">cache_t::find</span><span class="params">(<span class="type">cache_key_t</span> k, id receiver)</span>  <span class="comment">// 根据 k 即 @selector 进行查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(k != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">bucket_t</span> *b = <span class="built_in">buckets</span>();          <span class="comment">// 获取_buckets</span></span><br><span class="line">    <span class="type">mask_t</span> m = <span class="built_in">mask</span>();                <span class="comment">// 获取_mask</span></span><br><span class="line">    <span class="type">mask_t</span> begin = <span class="built_in">cache_hash</span>(k, m);  <span class="comment">// 计算起始索引</span></span><br><span class="line">    <span class="type">mask_t</span> i = begin;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 根据索引 i 从 _buckets 哈希表中取值</span></span><br><span class="line">        <span class="comment">// 如果取出来的 bucket_t 的 _key = 0，说明在索引的位置上还没有缓存过方法，返回该 bucket_t，中止缓存查询，用于 cache_fill_nolock() 函数</span></span><br><span class="line">        <span class="comment">// 如果取出来的 bucket_t 的 _key = k，说明查询成功，返回该 bucket_t</span></span><br><span class="line">        <span class="keyword">if</span> (b[i].<span class="built_in">key</span>() == <span class="number">0</span>  ||  b[i].<span class="built_in">key</span>() == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 在 __arm64__ 下将索引 i -1，继续查找，反向遍历 _buckets 哈希表</span></span><br><span class="line">      <span class="comment">// 直到 i 指向首个元素即索引 = 0 时，将 mask 赋值给 i，使其指向哈希表最后一个元素，继续反向遍历</span></span><br><span class="line">      <span class="comment">// 如果此时还没有找到 k 对应的 bucket_t ，或者是空的 bucket_t ，则循环结束，查找失败，调用 bad_cache() 函数</span></span><br><span class="line">      <span class="comment">// 接下来去类对象中 class_rw_t 中的 methods 查找</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((i = <span class="built_in">cache_next</span>(i, m)) != begin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hack</span></span><br><span class="line">    Class cls = (Class)((<span class="type">uintptr_t</span>)<span class="keyword">this</span> - <span class="built_in">offsetof</span>(objc_class, cache));</span><br><span class="line">    <span class="type">cache_t</span>::<span class="built_in">bad_cache</span>(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">mask_t</span> <span class="title">cache_hash</span><span class="params">(<span class="type">cache_key_t</span> key, <span class="type">mask_t</span> mask)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">mask_t</span>)(key &amp; mask);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">mask_t</span> <span class="title">cache_next</span><span class="params">(<span class="type">mask_t</span> i, <span class="type">mask_t</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return (i+1) &amp; mask;  // __arm__  ||  __x86_64__  ||  __i386__</span></span><br><span class="line">    <span class="keyword">return</span> i ? i<span class="number">-1</span> : mask;   <span class="comment">// __arm64__</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存添加流程"><a href="#缓存添加流程" class="headerlink" title="缓存添加流程"></a>缓存添加流程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//objc-cache.mm（objc4）</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">cache_fill_nolock</span><span class="params">(Class cls, SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cacheUpdateLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Never cache before +initialize is done</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;<span class="built_in">isInitialized</span>()) <span class="keyword">return</span>;   <span class="comment">// 如果类还未初始化，直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the entry wasn&#x27;t added to the cache by some other thread </span></span><br><span class="line">    <span class="comment">// before we grabbed the cacheUpdateLock.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cache_getImp</span>(cls, sel)) <span class="keyword">return</span>;  <span class="comment">// 可能有其它线程抢先将该方法缓存了，所以要检查一次缓存，如果存在，直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="type">cache_t</span> *cache = <span class="built_in">getCache</span>(cls);  <span class="comment">// ️取出该 class 的 cache_t</span></span><br><span class="line">    <span class="type">cache_key_t</span> key = <span class="built_in">getKey</span>(sel);   <span class="comment">// ️根据 sel 获得 _key</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the cache as-is if it is less than 3/4 full</span></span><br><span class="line">    <span class="type">mask_t</span> newOccupied = cache-&gt;<span class="built_in">occupied</span>() + <span class="number">1</span>;  <span class="comment">// 将 cache_t 的 _occupied 即已经缓存的方法数量 + 1，这里只是为了判断 +1 后缓存容量是否满</span></span><br><span class="line">    <span class="type">mask_t</span> capacity = cache-&gt;<span class="built_in">capacity</span>();  <span class="comment">// 获得缓存容量 = _mask + 1</span></span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;<span class="built_in">isConstantEmptyCache</span>()) &#123;  <span class="comment">// 如果缓存是只读的，重新申请缓存空间</span></span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">        cache-&gt;<span class="built_in">reallocate</span>(capacity, capacity ?: INIT_CACHE_SIZE);  <span class="comment">// 申请新的缓存空间，并释放旧的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newOccupied &lt;= capacity / <span class="number">4</span> * <span class="number">3</span>) &#123;  <span class="comment">// ️如果当前已经缓存的方法数量 +1 &lt;= 缓存容量的 3/4，就继续往下操作</span></span><br><span class="line">        <span class="comment">// Cache is less than 3/4 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// ️如果以上条件不满足，说明缓存已满，进行缓存扩容</span></span><br><span class="line">        <span class="comment">// Cache is too full. Expand it.</span></span><br><span class="line">        cache-&gt;<span class="built_in">expand</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for the first unused slot and insert there.     // 扫描第一个未使用的插槽（bucket_t）并将其插入</span></span><br><span class="line">    <span class="comment">// There is guaranteed to be an empty slot because the  // 必然会有一个空的插槽（bucket_t）</span></span><br><span class="line">    <span class="comment">// minimum size is 4 and we resized at 3/4 full.        // 因为最小大小是4，我们调整为3/4满</span></span><br><span class="line">    <span class="type">bucket_t</span> *bucket = cache-&gt;<span class="built_in">find</span>(key, receiver);       <span class="comment">// ️调用 find() 函数进行一次缓存查找，必然会得到一个空的 bucket_t</span></span><br><span class="line">    <span class="keyword">if</span> (bucket-&gt;<span class="built_in">key</span>() == <span class="number">0</span>) cache-&gt;<span class="built_in">incrementOccupied</span>();  <span class="comment">// ️如果该 bucket_t 为空，将 _occupied 即已经缓存的方法数量 + 1</span></span><br><span class="line">    bucket-&gt;<span class="built_in">set</span>(key, imp);  <span class="comment">// ️添加缓存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cache_fill</span><span class="params">(Class cls, SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !DEBUG_TASK_THREADS</span></span><br><span class="line">    <span class="function"><span class="type">mutex_locker_t</span> <span class="title">lock</span><span class="params">(cacheUpdateLock)</span></span>;</span><br><span class="line">    <span class="built_in">cache_fill_nolock</span>(cls, sel, imp, receiver);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    _collecting_in_critical();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存扩容流程"><a href="#缓存扩容流程" class="headerlink" title="缓存扩容流程"></a>缓存扩容流程</h4><p>① 设置新的缓存bucket_t，容量 &#x3D; 旧的两倍；<br>② 设置新的_mask&#x3D;bucket_t长度 - 1；<br>③ 释放旧的缓存（在runtime动态交换方法实现时也会释放缓存）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//objc-cache.mm（objc4）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cache_t::expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cacheUpdateLock.<span class="built_in">assertLocked</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> oldCapacity = <span class="built_in">capacity</span>();</span><br><span class="line">    <span class="comment">// ️将缓存扩容为原来的两倍，如果是首次调用，设置缓存容量的初始值为 4</span></span><br><span class="line">    <span class="type">uint32_t</span> newCapacity = oldCapacity ? oldCapacity*<span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uint32_t</span>)(<span class="type">mask_t</span>)newCapacity != newCapacity) &#123;</span><br><span class="line">        <span class="comment">// mask overflow - can&#x27;t grow further</span></span><br><span class="line">        <span class="comment">// fixme this wastes one bit of mask</span></span><br><span class="line">        newCapacity = oldCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reallocate</span>(oldCapacity, newCapacity);  <span class="comment">// ️申请新的缓存空间，并释放旧的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">2</span>,</span><br><span class="line">    INIT_CACHE_SIZE      = (<span class="number">1</span> &lt;&lt; INIT_CACHE_SIZE_LOG2)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cache_t::reallocate</span><span class="params">(<span class="type">mask_t</span> oldCapacity, <span class="type">mask_t</span> newCapacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> freeOld = <span class="built_in">canBeFreed</span>();  <span class="comment">// ️判断一下缓存是不是空的，如果为空，就没必要释放空间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bucket_t</span> *oldBuckets = <span class="built_in">buckets</span>();</span><br><span class="line">    <span class="type">bucket_t</span> *newBuckets = <span class="built_in">allocateBuckets</span>(newCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache&#x27;s old contents are not propagated. </span></span><br><span class="line">    <span class="comment">// This is thought to save cache memory at the cost of extra cache fills.</span></span><br><span class="line">    <span class="comment">// fixme re-measure this</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(newCapacity &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>((<span class="type">uintptr_t</span>)(<span class="type">mask_t</span>)(newCapacity<span class="number">-1</span>) == newCapacity<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setBucketsAndMask</span>(newBuckets, newCapacity - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (freeOld) &#123;</span><br><span class="line">        <span class="built_in">cache_collect_free</span>(oldBuckets, oldCapacity);</span><br><span class="line">        <span class="built_in">cache_collect</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cache_t::canBeFreed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isConstantEmptyCache</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cache_t::isConstantEmptyCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">        <span class="built_in">occupied</span>() == <span class="number">0</span>  &amp;&amp;  </span><br><span class="line">        <span class="built_in">buckets</span>() == <span class="built_in">emptyBucketsForCapacity</span>(<span class="built_in">capacity</span>(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h2><ol><li><code>isa</code>指针用来维护对象和类之间的关系，并确保对象和类能够通过isa指针找到对应的方法、实例变量、属性、协议等；</li><li>在 arm64 架构之前，isa就是一个普通的指针，直接指向<code>objc_class</code>，存储着<code>Class</code>、<code>Meta-Class</code>对象的内存地址。instance对象的isa指向class对象，class对象的isa指向meta-class对象；</li><li>从 arm64 架构开始，对isa进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息。将 64 位的内存数据分开来存储着很多的东西，其中的 33 位才是拿来存储<code>class</code>、<code>meta-class</code>对象的内存地址信息。要通过位运算将<code>isa</code>的值<code>&amp; ISA_MASK</code>掩码，才能得到<code>class</code>、<code>meta-class</code>对象的内存地址。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line">    Class isa;  <span class="comment">// 在 arm64 架构之前</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">isa_t</span> isa;  <span class="comment">// 在 arm64 架构开始</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">isa_t</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">isa_t</span>(<span class="type">uintptr_t</span> value) : <span class="built_in">bits</span>(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_PACKED_ISA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// extra_rc must be the MSB-most field (so it matches carry/overflow flags)</span></span><br><span class="line">    <span class="comment">// nonpointer must be the LSB (fixme or get rid of it)</span></span><br><span class="line">    <span class="comment">// shiftcls must occupy the same bits that a real class pointer would</span></span><br><span class="line">    <span class="comment">// bits + RC_ONE is equivalent to extra_rc + 1</span></span><br><span class="line">    <span class="comment">// RC_HALF is the high bit of extra_rc (i.e. half of its range)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// future expansion:</span></span><br><span class="line">    <span class="comment">// uintptr_t fast_rr : 1;     // no r/r overrides</span></span><br><span class="line">    <span class="comment">// uintptr_t lock : 2;        // lock for atomic property, @synch</span></span><br><span class="line">    <span class="comment">// uintptr_t extraBytes : 1;  // allocated with extra bytes</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL  <span class="comment">// 用来取出 Class、Meta-Class 对象的内存地址</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> nonpointer        : <span class="number">1</span>;  <span class="comment">// 0：代表普通的指针，存储着 Class、Meta-Class 对象的内存地址</span></span><br><span class="line">                                          <span class="comment">// 1：代表优化过，使用位域存储更多的信息</span></span><br><span class="line">        <span class="type">uintptr_t</span> has_assoc         : <span class="number">1</span>;  <span class="comment">// 是否有设置过关联对象，如果没有，释放时会更快</span></span><br><span class="line">        <span class="type">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;  <span class="comment">// 是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</span></span><br><span class="line">        <span class="type">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// 存储着 Class、Meta-Class 对象的内存地址信息</span></span><br><span class="line">        <span class="type">uintptr_t</span> magic             : <span class="number">6</span>;  <span class="comment">// 用于在调试时分辨对象是否未完成初始化</span></span><br><span class="line">        <span class="type">uintptr_t</span> weakly_referenced : <span class="number">1</span>;  <span class="comment">// 是否有被弱引用指向过，如果没有，释放时会更快</span></span><br><span class="line">        <span class="type">uintptr_t</span> deallocating      : <span class="number">1</span>;  <span class="comment">// 对象是否正在释放</span></span><br><span class="line">        <span class="type">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">// 如果为1，代表引用计数过大无法存储在 isa 中，那么超出的引用计数会存储在一个叫 SideTable 结构体的 RefCountMap（引用计数表）哈希表中</span></span><br><span class="line">        <span class="type">uintptr_t</span> extra_rc          : <span class="number">19</span>; <span class="comment">// 里面存储的值是引用计数 retainCount - 1</span></span><br><span class="line"><span class="meta">#       <span class="keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#       <span class="keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="isa-与-superclass-指针指向"><a href="#isa-与-superclass-指针指向" class="headerlink" title="isa 与 superclass 指针指向"></a>isa 与 superclass 指针指向</h3><img src="/2022/01/25/Runtime%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/isaSuperclass.png" class="&#x3D;"><h2 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h2><ol><li>Method就是method_t类型的指针；</li><li>method_t是对方法&#x2F;函数的封装（函数四要素：函数名、返回值、参数、函数体）。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> method_t *Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> method_t &#123;</span><br><span class="line">    SEL name;  <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *types;  <span class="comment">// 编码（返回值类型、参数类型）</span></span><br><span class="line">    IMP imp;   <span class="comment">// 方法的地址/实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><ul><li>SEL 又称“选择器”，它是一个指向方法的selector的指针，代表方法&#x2F;函数名；</li><li>SEL 维护在一个全局的 Map 中，所以它是全局唯一的，不同类中相同名字的方法的 SEL 是相同的。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure><p>SEL 可以通过以下方式获得</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SEL sel1 = <span class="keyword">@selector</span>(selector);</span><br><span class="line">SEL sel2 = sel_registerName(<span class="string">&quot;selector&quot;</span>);</span><br><span class="line">SEL sel3 = <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;selector&quot;</span>);</span><br></pre></td></tr></table></figure><p>SEL 可以通过以下方式转换成字符串</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *string1 = sel_getName(sel1);</span><br><span class="line"><span class="built_in">NSString</span> *string2 = <span class="built_in">NSStringFromSelector</span>(sel1);</span><br></pre></td></tr></table></figure><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><ul><li>IMP 是指向方法实现的函数指针；</li><li>我们调用方法，实际上就是根据方法 SEL 查找 IMP；</li><li><code>method_t</code>实际上相当于在 SEL 和 IMP 之间做了一个映射。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (*IMP)(<span class="type">void</span> <span class="comment">/* id, SEL, ... */</span> ); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">id</span> _Nullable (*IMP)(<span class="type">id</span> _Nonnull, SEL _Nonnull, ...); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="Type-Encodings"><a href="#Type-Encodings" class="headerlink" title="Type Encodings"></a>Type Encodings</h3><ul><li>Type Encodings 编码技术就是配合runtime的技术，把一个方法的返回值类型、参数类型通过字符串的形式描述；</li><li><code>@encode()</code>指令可以将类型转换为 Type Encodings 字符串编码， 如<code>@encode(int)=i</code>；</li><li>OC方法都有两个隐式参数，方法调用者(id)self和方法名(SEL) _cmd，所以我们才能在方法中使用self和_cmd；</li><li>如 -(void)test，它的编码为“v16@0:8”，可以简写为“v@:”<br>v：代表返回值类型为 void<br>@：代表参数 1 类型为 id<br>:：代表参数 2 类型为 SEL<br>16：代表所有参数所占的总字节数<br>0：代表参数 1 从第几个字节开始存储<br>8：代表参数 2 从第几个字节开始存储</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904072215003143">深入浅出 Runtime（二）：数据结构</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Runtime </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息机制</title>
      <link href="/2022/01/25/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/01/25/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<img src="/2022/01/25/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/start.png" class="&#x3D;"><span id="more"></span><h2 id="objc-msgSend方法调用流程"><a href="#objc-msgSend方法调用流程" class="headerlink" title="objc_msgSend方法调用流程"></a>objc_msgSend方法调用流程</h2><p>在<code>OC</code>中调用一个方法时，编译器会根据情况调用以下函数中的一个进行消息传递：<code>objc_msgSend</code>、<code>objc_msgSend_stret</code>、<code>objc_msgSendSuper</code>、<code>objc_msgSendSuper_stret</code>，当方法调用者为super时会调用objc_msgSendSuper，当数据结构作为返回值时会调用<code>objc_msgSend_stret</code>或<code>objc_msgSendSuper_stret</code>，其他方法调用的情况都是转换为<code>objc_msgSend()</code>函数的调用。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> objc_msgSend(<span class="type">id</span> _Nullable <span class="keyword">self</span>, SEL _Nonnull op, ...)</span><br></pre></td></tr></table></figure><p>给receiver（方法调用者&#x2F;消息接收者）发送一条消息（SEL方法名）<br>参数1： receiver<br>参数2: SEL<br>参数3、4、5….: SEL方法的参数</p><p>objc_msgSend()的执行流程可以分为3大阶段:</p><ol><li>消息发送</li><li>动态方法解析</li><li>消息转发</li></ol><h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><h3 id="消息发送流程"><a href="#消息发送流程" class="headerlink" title="消息发送流程"></a>消息发送流程</h3><img src="/2022/01/25/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/msgSend.png" class="&#x3D;"><img src="/2022/01/25/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/msgSend2.png" class="&#x3D;"><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在底层汇编里面如果需要调用C函数的话，苹果会为其加一个下划线_，所以查看objc_msgSend函数的实现，需要搜索<code>_objc_msgSend</code></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-msg-arm64.s（objc4）</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       _objc_msgSend 函数实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// ⚠️汇编程序入口格式为：ENTRY + 函数名</span></span><br><span class="line"><span class="meta">ENTRY</span> _objc_msgSend</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️如果 receiver 为 nil 或者 tagged pointer，执行 LNilOrTagged，否则继续往下执行</span></span><br><span class="line"><span class="keyword">cmp</span>x0, <span class="number">#0</span><span class="comment">// nil check and tagged pointer check</span></span><br><span class="line">b.leLNilOrTagged   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️通过 isa 找到 class/meta-class</span></span><br><span class="line"><span class="keyword">ldr</span>x13, [x0]<span class="comment">// x13 = isa</span></span><br><span class="line"><span class="keyword">and</span>x16, x13, <span class="symbol">#ISA_MASK</span><span class="comment">// x16 = class</span></span><br><span class="line"><span class="symbol">LGetIsaDone:</span></span><br><span class="line">    <span class="comment">// ⚠️进入 cache 缓存查找，传的参数为 NORMAL</span></span><br><span class="line">    <span class="comment">// CacheLookup 宏，用于在缓存中查找 SEL 对应方法实现</span></span><br><span class="line">CacheLookup NORMAL<span class="comment">// calls imp or objc_msgSend_uncached </span></span><br><span class="line"></span><br><span class="line"><span class="symbol">LNilOrTagged:</span></span><br><span class="line">    <span class="comment">// ⚠️如果 receiver 为 nil，执行 LReturnZero，结束 objc_msgSend</span></span><br><span class="line">b.eqLReturnZero<span class="comment">// nil check </span></span><br><span class="line">    <span class="comment">// ⚠️如果 receiver 为 tagged pointer，则执行其它</span></span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">b</span>LGetIsaDone</span><br><span class="line"></span><br><span class="line"><span class="symbol">LReturnZero:</span></span><br><span class="line">    ret  <span class="comment">// 返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️汇编中，函数的结束格式为：ENTRY + 函数名</span></span><br><span class="line">END_ENTRY _objc_msgSend</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">.macro</span> CacheLookup</span><br><span class="line">    <span class="comment">// ⚠️根据 SEL 去哈希表 buckets 中查找方法</span></span><br><span class="line"><span class="comment">// x1 = SEL, x16 = isa</span></span><br><span class="line">ldpx10, x11, [x16, <span class="symbol">#CACHE</span>]<span class="comment">// x10 = buckets, x11 = occupied|mask</span></span><br><span class="line"><span class="keyword">and</span>w12, w1, w11<span class="comment">// x12 = _cmd &amp; mask</span></span><br><span class="line"><span class="keyword">add</span>x12, x10, x12, <span class="keyword">LSL</span> <span class="number">#4</span><span class="comment">// x12 = buckets + ((_cmd &amp; mask)&lt;&lt;4)</span></span><br><span class="line"></span><br><span class="line">ldpx9, x17, [x12]<span class="comment">// &#123;x9, x17&#125; = *bucket</span></span><br><span class="line">    <span class="comment">// ⚠️缓存命中，进行 CacheHit 操作</span></span><br><span class="line"><span class="number">1</span>:<span class="keyword">cmp</span>x9, x1<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">b.ne<span class="number">2</span>f<span class="comment">//     scan more</span></span><br><span class="line">CacheHit <span class="number">$0</span><span class="comment">// call or return imp</span></span><br><span class="line">    <span class="comment">// ⚠️缓存中没有找到，进行 CheckMiss 操作</span></span><br><span class="line"><span class="number">2</span>:<span class="comment">// not hit: x12 = not-hit bucket</span></span><br><span class="line">CheckMiss <span class="number">$0</span><span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line"><span class="keyword">cmp</span>x12, x10<span class="comment">// wrap if bucket == buckets</span></span><br><span class="line">b.eq<span class="number">3</span>f</span><br><span class="line">ldpx9, x17, [x12, #-<span class="number">16</span>]!<span class="comment">// &#123;x9, x17&#125; = *--bucket</span></span><br><span class="line"><span class="keyword">b</span><span class="number">1</span>b<span class="comment">// loop</span></span><br><span class="line"><span class="number">3</span>:<span class="comment">// wrap: x12 = first bucket, w11 = mask</span></span><br><span class="line"><span class="keyword">add</span>x12, x12, w11, UXTW <span class="number">#4</span><span class="comment">// x12 = buckets+(mask&lt;&lt;4)</span></span><br><span class="line"><span class="comment">// Clone scanning loop to miss instead of hang when cache is corrupt.</span></span><br><span class="line"><span class="comment">// The slow path may detect any corruption and halt later.</span></span><br><span class="line">ldpx9, x17, [x12]<span class="comment">// &#123;x9, x17&#125; = *bucket</span></span><br><span class="line"><span class="number">1</span>:<span class="keyword">cmp</span>x9, x1<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">b.ne<span class="number">2</span>f<span class="comment">//     scan more</span></span><br><span class="line">CacheHit <span class="number">$0</span><span class="comment">// call or return imp</span></span><br><span class="line"><span class="number">2</span>:<span class="comment">// not hit: x12 = not-hit bucket</span></span><br><span class="line">CheckMiss <span class="number">$0</span><span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line"><span class="keyword">cmp</span>x12, x10<span class="comment">// wrap if bucket == buckets</span></span><br><span class="line">b.eq<span class="number">3</span>f</span><br><span class="line">ldpx9, x17, [x12, #-<span class="number">16</span>]!<span class="comment">// &#123;x9, x17&#125; = *--bucket</span></span><br><span class="line"><span class="keyword">b</span><span class="number">1</span>b<span class="comment">// loop</span></span><br><span class="line"><span class="number">3</span>:<span class="comment">// double wrap</span></span><br><span class="line">JumpMiss <span class="number">$0</span></span><br><span class="line"><span class="symbol">.endmacro</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CacheLookup NORMAL|GETIMP|LOOKUP</span></span><br><span class="line"><span class="comment">#define NORMAL 0</span></span><br><span class="line"><span class="comment">#define GETIMP 1</span></span><br><span class="line"><span class="comment">#define LOOKUP 2</span></span><br><span class="line"><span class="symbol">.macro</span> CacheHit</span><br><span class="line"><span class="symbol">.if</span> <span class="number">$0</span> == NORMAL  <span class="comment">// ⚠️CacheLookup 传的参数是 NORMAL</span></span><br><span class="line">MESSENGER_END_FAST</span><br><span class="line"><span class="keyword">br</span>x17<span class="comment">// call imp  // ⚠️执行函数</span></span><br><span class="line"><span class="symbol">.elseif</span> <span class="number">$0</span> == GETIMP</span><br><span class="line"><span class="keyword">mov</span>x0, x17<span class="comment">// return imp</span></span><br><span class="line">ret</span><br><span class="line"><span class="symbol">.elseif</span> <span class="number">$0</span> == LOOKUP</span><br><span class="line">ret<span class="comment">// return imp via x17</span></span><br><span class="line"><span class="symbol">.else</span></span><br><span class="line"><span class="symbol">.abort</span> oops</span><br><span class="line"><span class="symbol">.endif</span></span><br><span class="line"><span class="symbol">.endmacro</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">.macro</span> CheckMiss</span><br><span class="line"><span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line"><span class="symbol">.if</span> <span class="number">$0</span> == GETIMP</span><br><span class="line"><span class="keyword">cbz</span>x9, LGetImpMiss</span><br><span class="line"><span class="symbol">.elseif</span> <span class="number">$0</span> == NORMAL  <span class="comment">// ⚠️CacheLookup 传的参数是 NORMAL</span></span><br><span class="line"><span class="keyword">cbz</span>x9, __objc_msgSend_uncached  <span class="comment">// ⚠️执行 __objc_msgSend_uncached</span></span><br><span class="line"><span class="symbol">.elseif</span> <span class="number">$0</span> == LOOKUP</span><br><span class="line"><span class="keyword">cbz</span>x9, __objc_msgLookup_uncached</span><br><span class="line"><span class="symbol">.else</span></span><br><span class="line"><span class="symbol">.abort</span> oops</span><br><span class="line"><span class="symbol">.endif</span></span><br><span class="line"><span class="symbol">.endmacro</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">.macro</span> JumpMiss</span><br><span class="line"><span class="symbol">.if</span> <span class="number">$0</span> == GETIMP</span><br><span class="line"><span class="keyword">b</span>LGetImpMiss</span><br><span class="line"><span class="symbol">.elseif</span> <span class="number">$0</span> == NORMAL</span><br><span class="line"><span class="keyword">b</span>__objc_msgSend_uncached</span><br><span class="line"><span class="symbol">.elseif</span> <span class="number">$0</span> == LOOKUP</span><br><span class="line"><span class="keyword">b</span>__objc_msgLookup_uncached</span><br><span class="line"><span class="symbol">.else</span></span><br><span class="line"><span class="symbol">.abort</span> oops</span><br><span class="line"><span class="symbol">.endif</span></span><br><span class="line"><span class="symbol">.endmacro</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️__objc_msgSend_uncached</span></span><br><span class="line">    <span class="comment">// ⚠️缓存中没有找到方法的实现，接下来去 MethodTableLookup 类的方法列表中查找</span></span><br><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">MethodTableLookup NORMAL</span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line"><span class="symbol">.macro</span> MethodTableLookup</span><br><span class="line"><span class="keyword">blx</span>__class_lookupMethodAndLoadCache3  <span class="comment">// ⚠️执行C函数 _class_lookupMethodAndLoadCache3</span></span><br><span class="line"><span class="symbol">.endmacro</span></span><br></pre></td></tr></table></figure><p>相反，通过汇编中函数名找对应 C 函数实现时，需要去掉一个下划线_。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm（objc4）</span></span><br><span class="line"><span class="symbol">IMP</span> _class_lookupMethodAndLoadCache3(id obj, <span class="keyword">SEL</span> sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ⚠️注意传参，由于之前已经通过汇编去缓存中查找方法，所以这里不会再次到缓存中查找</span></span><br><span class="line">    return lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              YES<span class="comment">/*initialize*/</span>, NO<span class="comment">/*cache*/</span>, YES<span class="comment">/*resolver*/</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">IMP</span> lookUpImpOrForward(Class cls, <span class="keyword">SEL</span> sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = nil<span class="comment">;</span></span><br><span class="line">    bool triedResolver = NO<span class="comment">;  // triedResolver 标记用于 动态方法解析</span></span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="meta">if</span> (cache) &#123;  <span class="comment">// cache = NO，跳过 </span></span><br><span class="line">        imp = cache_getImp(cls, sel)<span class="comment">;</span></span><br><span class="line">        <span class="meta">if</span> (imp) return imp<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during isRealized and isInitialized checking</span></span><br><span class="line">    <span class="comment">// to prevent races against concurrent realization.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during method search to make</span></span><br><span class="line">    <span class="comment">// method-lookup + cache-fill atomic with respect to method addition.</span></span><br><span class="line">    <span class="comment">// Otherwise, a category could be added but ignored indefinitely because</span></span><br><span class="line">    <span class="comment">// the cache was re-filled with the old value after the cache flush on</span></span><br><span class="line">    <span class="comment">// behalf of the category.</span></span><br><span class="line"></span><br><span class="line">    runtimeLock.read()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">if</span> (!cls-&gt;isRealized()) &#123;  <span class="comment">// ⚠️如果 receiverClass(消息接受者类)  还未实现，就进行 realize 操作</span></span><br><span class="line">        <span class="comment">// Drop the read-lock and acquire the write-lock.</span></span><br><span class="line">        <span class="comment">// realizeClass() checks isRealized() again to prevent</span></span><br><span class="line">        <span class="comment">// a race while the lock is down.</span></span><br><span class="line">        runtimeLock.unlockRead()<span class="comment">;</span></span><br><span class="line">        runtimeLock.write()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        realizeClass(cls)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        runtimeLock.unlockWrite()<span class="comment">;</span></span><br><span class="line">        runtimeLock.read()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️如果 receiverClass 需要初始化且还未初始化，就进行初始化操作</span></span><br><span class="line">    <span class="comment">// 这里插入一个 +initialize 方法的知识点</span></span><br><span class="line">    <span class="comment">// 调用 _class_initialize(cls)，该函数中会递归遍历父类，判断父类是否存在且还未初始化 _class_initialize(cls-&gt;superclass)</span></span><br><span class="line">    <span class="comment">// 调用 callInitialize(cls) ，给 cls 发送一条 initialize 消息((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize)</span></span><br><span class="line">    <span class="comment">// 所以 +initialize 方法会在类第一次接收到消息时调用</span></span><br><span class="line">    <span class="comment">// 调用方式：objc_msgSend()</span></span><br><span class="line">    <span class="comment">// 调用顺序：先调用父类的 +initialize，再调用子类的 +initialize (先初始化父类，再初始化子类，每个类只会初始化1次）</span></span><br><span class="line">    <span class="meta">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead()<span class="comment">;</span></span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst))<span class="comment">;</span></span><br><span class="line">        runtimeLock.read()<span class="comment">;</span></span><br><span class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won&#x27;t happen. 2778172</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⚠️⚠️⚠️核心 </span></span><br><span class="line"><span class="symbol"> retry:</span>    </span><br><span class="line">    runtimeLock.assertReading()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️去 receiverClass 的 cache 中查找方法，如果找到 imp 就直接调用</span></span><br><span class="line">    imp = cache_getImp(cls, sel)<span class="comment">;</span></span><br><span class="line">    <span class="meta">if</span> (imp) goto done<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️去 receiverClass 的 class_rw_t 中的方法列表查找方法，如果找到 imp 就调用并将该方法缓存到 receiverClass 的 cache 中</span></span><br><span class="line">    &#123;</span><br><span class="line">        Method meth = getMethodNoSuper_nolock(cls, sel)<span class="comment">;  // ⚠️去目标类的方法列表中查找方法实现</span></span><br><span class="line">        <span class="meta">if</span> (meth) &#123;</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls)<span class="comment">;  // ⚠️缓存方法</span></span><br><span class="line">            imp = meth-&gt;imp<span class="comment">;</span></span><br><span class="line">            goto done<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️逐级查找父类的缓存和方法列表，如果找到 imp 就调用并将该方法缓存到 receiverClass 的 cache 中</span></span><br><span class="line">    &#123;</span><br><span class="line">        unsigned attempts = unreasonableClassCount()<span class="comment">;</span></span><br><span class="line">        for (Class curClass = cls-&gt;superclass<span class="comment">;</span></span><br><span class="line">             curClass != nil<span class="comment">;</span></span><br><span class="line">             curClass = curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">            <span class="meta">if</span> (--attempts == <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;Memory corruption in class list.&quot;</span>)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Superclass cache.</span></span><br><span class="line">            imp = cache_getImp(curClass, sel)<span class="comment">;</span></span><br><span class="line">            <span class="meta">if</span> (imp) &#123;</span><br><span class="line">                <span class="meta">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass)<span class="comment">;</span></span><br><span class="line">                    goto done<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">                    <span class="comment">// Stop searching, but don&#x27;t cache yet; call method </span></span><br><span class="line">                    <span class="comment">// resolver for this class first.</span></span><br><span class="line">                    break<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// Superclass method list.</span></span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel)<span class="comment">;</span></span><br><span class="line">            <span class="meta">if</span> (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass)<span class="comment">;</span></span><br><span class="line">                imp = meth-&gt;imp<span class="comment">;</span></span><br><span class="line">                goto done<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️进入“动态方法解析”阶段</span></span><br><span class="line">    <span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line">    <span class="meta">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlockRead()<span class="comment">;</span></span><br><span class="line">        _class_resolveMethod(cls, sel, inst)<span class="comment">;</span></span><br><span class="line">        runtimeLock.read()<span class="comment">;</span></span><br><span class="line">        <span class="comment">// Don&#x27;t cache the result; we don&#x27;t hold the lock so it may have </span></span><br><span class="line">        <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">        triedResolver = YES<span class="comment">;</span></span><br><span class="line">        goto retry<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️进入“消息转发”阶段</span></span><br><span class="line">    <span class="comment">// No implementation found, and method resolver didn&#x27;t help. </span></span><br><span class="line">    <span class="comment">// Use forwarding.</span></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache<span class="comment">;</span></span><br><span class="line">    cache_fill(cls, sel, imp, inst)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol"> done:</span></span><br><span class="line">    runtimeLock.unlockRead()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    return imp<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getMethodNoSuper_nolock(cls,sel)是怎么从类中查找方法实现的</p><ul><li>如果方法是经过排序的，则进行二分查找</li><li>如果方法列表没有进行排序，则进行线性遍历查找。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">method_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">getMethodNoSuper_nolock</span><span class="params">(Class cls, SEL sel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line">    <span class="built_in">assert</span>(cls-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="comment">// fixme nil cls? </span></span><br><span class="line">    <span class="comment">// fixme nil sel?</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> mlists = cls-&gt;<span class="built_in">data</span>()-&gt;methods.<span class="built_in">beginLists</span>(), </span><br><span class="line">              end = cls-&gt;<span class="built_in">data</span>()-&gt;methods.<span class="built_in">endLists</span>(); </span><br><span class="line">         mlists != end;</span><br><span class="line">         ++mlists)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// ⚠️核心函数 search_method_list()</span></span><br><span class="line">        <span class="type">method_t</span> *m = <span class="built_in">search_method_list</span>(*mlists, sel);</span><br><span class="line">        <span class="keyword">if</span> (m) <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">method_t</span> *<span class="title">search_method_list</span><span class="params">(<span class="type">const</span> <span class="type">method_list_t</span> *mlist, SEL sel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> methodListIsFixedUp = mlist-&gt;<span class="built_in">isFixedUp</span>();</span><br><span class="line">    <span class="type">int</span> methodListHasExpectedSize = mlist-&gt;<span class="built_in">entsize</span>() == <span class="built_in">sizeof</span>(<span class="type">method_t</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// ⚠️如果方法列表是经过排序的，则进行二分查找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findMethodInSortedMethodList</span>(sel, mlist);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ⚠️如果方法列表没有进行排序，则进行线性遍历查找</span></span><br><span class="line">        <span class="comment">// Linear search of unsorted method list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meth.name == sel) <span class="keyword">return</span> &amp;meth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">method_t</span> *<span class="title">findMethodInSortedMethodList</span><span class="params">(SEL key, <span class="type">const</span> <span class="type">method_list_t</span> *list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(list);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">method_t</span> * <span class="type">const</span> first = &amp;list-&gt;first;</span><br><span class="line">    <span class="type">const</span> <span class="type">method_t</span> *base = first;</span><br><span class="line">    <span class="type">const</span> <span class="type">method_t</span> *probe;</span><br><span class="line">    <span class="type">uintptr_t</span> keyValue = (<span class="type">uintptr_t</span>)key;</span><br><span class="line">    <span class="type">uint32_t</span> count;</span><br><span class="line">    <span class="comment">// ⚠️count &gt;&gt;= 1 二分查找</span></span><br><span class="line">    <span class="keyword">for</span> (count = list-&gt;count; count != <span class="number">0</span>; count &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        probe = base + (count &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">uintptr_t</span> probeValue = (<span class="type">uintptr_t</span>)probe-&gt;name;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (keyValue == probeValue) &#123;</span><br><span class="line">            <span class="comment">// `probe` is a match.</span></span><br><span class="line">            <span class="comment">// Rewind looking for the *first* occurrence of this value.</span></span><br><span class="line">            <span class="comment">// This is required for correct category overrides.</span></span><br><span class="line">            <span class="keyword">while</span> (probe &gt; first &amp;&amp; keyValue == (<span class="type">uintptr_t</span>)probe[<span class="number">-1</span>].name) &#123;</span><br><span class="line">                probe--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">method_t</span> *)probe;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (keyValue &gt; probeValue) &#123;</span><br><span class="line">            base = probe + <span class="number">1</span>;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>log_and_fill_cache(cls,meth-&gt;img,sel,inst,cls)</code>是怎么缓存方法的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* log_and_fill_cache</span></span><br><span class="line"><span class="comment">* Log this method call. If the logger permits it, fill the method cache.</span></span><br><span class="line"><span class="comment">* cls is the method whose cache should be filled. </span></span><br><span class="line"><span class="comment">* implementer is the class that owns the implementation in question.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">log_and_fill_cache</span><span class="params">(Class cls, IMP imp, SEL sel, id receiver, Class implementer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_MESSAGE_LOGGING</span></span><br><span class="line">    <span class="keyword">if</span> (objcMsgLogEnabled) &#123;</span><br><span class="line">        <span class="type">bool</span> cacheIt = <span class="built_in">logMessageSend</span>(implementer-&gt;<span class="built_in">isMetaClass</span>(), </span><br><span class="line">                                      cls-&gt;<span class="built_in">nameForLogging</span>(),</span><br><span class="line">                                      implementer-&gt;<span class="built_in">nameForLogging</span>(), </span><br><span class="line">                                      sel);</span><br><span class="line">        <span class="keyword">if</span> (!cacheIt) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">cache_fill</span> (cls, sel, imp, receiver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_WIN32  ||  TARGET_OS_EMBEDDED</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> SUPPORT_MESSAGE_LOGGING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> SUPPORT_MESSAGE_LOGGING 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><img src="/2022/01/25/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/dynamicMethod.png" class="&#x3D;"><p>如果“消息发送”阶段未找到方法的实现，进行一次“动态方法解析”；</p><p>“动态方法解析”后，会再次进入“消息发送”流程，从“去receiverClass的cache中查找方法”这一步开始执行。</p><p>可以根据方法类型（实例or类方法）重写以下方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel;</span><br><span class="line">+(<span class="type">BOOL</span>)resolveClassMethod:(SEL)sel;</span><br></pre></td></tr></table></figure><p>在方法中调用以下函数来动态添加方法的实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BOOL</span> class_addMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="type">char</span> *types)</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>分别调用了 HTPerson 的eat实例方法和类方法，而 HTPerson.m 文件中并没有这两个方法的对应实现，我们为这两个方法动态添加了实现，输出结果如下。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;HTPerson.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[HTPerson new] eat];</span><br><span class="line">        [HTPerson eat];   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTPerson.h</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HTPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="type">void</span>)eat;  <span class="comment">// 没有对应实现</span></span><br><span class="line">- (<span class="type">void</span>)sleep;</span><br><span class="line">+ (<span class="type">void</span>)eat;  <span class="comment">// 没有对应实现</span></span><br><span class="line">+ (<span class="type">void</span>)sleep;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTPerson.m</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;HTPerson.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HTPerson</span></span></span><br><span class="line">- (<span class="type">void</span>)sleep</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">void</span>)sleep</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(eat)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取其它方法， Method 就是指向 method_t 结构体的指针</span></span><br><span class="line">        Method method = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(sleep));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ** 参数1:给哪个类添加</span></span><br><span class="line"><span class="comment">         ** 参数2:给哪个方法添加</span></span><br><span class="line"><span class="comment">         ** 参数3:方法的实现地址</span></span><br><span class="line"><span class="comment">         ** 参数4:方法的编码类型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>,  <span class="comment">// 实例方法存放在类对象中，所以这里要传入类对象</span></span><br><span class="line">                        sel,</span><br><span class="line">                        method_getImplementation(method),</span><br><span class="line">                        method_getTypeEncoding(method)</span><br><span class="line">                        );</span><br><span class="line">        <span class="comment">// 返回 YES 代表有动态添加方法实现</span></span><br><span class="line">        <span class="comment">// 从源码来看，该返回值只是用来打印解析结果相关信息，并不影响动态方法解析的结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveClassMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(eat)) &#123;</span><br><span class="line">        </span><br><span class="line">        Method method = class_getClassMethod(object_getClass(<span class="keyword">self</span>), <span class="keyword">@selector</span>(sleep));</span><br><span class="line"></span><br><span class="line">        class_addMethod(object_getClass(<span class="keyword">self</span>),  <span class="comment">// 类方法存放在元类对象中，所以这里要传入元类对象</span></span><br><span class="line">                        sel,</span><br><span class="line">                        method_getImplementation(method),</span><br><span class="line">                        method_getTypeEncoding(method)</span><br><span class="line">                        );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[HTPerson sleep]</span><br><span class="line">+[HTPerson sleep]</span><br></pre></td></tr></table></figure><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, <span class="type">id</span> inst, </span><br><span class="line">                       <span class="type">bool</span> initialize, <span class="type">bool</span> cache, <span class="type">bool</span> resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = <span class="literal">nil</span>;</span><br><span class="line">    <span class="type">bool</span> triedResolver = <span class="literal">NO</span>;</span><br><span class="line">    ......   </span><br><span class="line"></span><br><span class="line"> retry:    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️如果“消息发送”阶段未找到方法的实现，进行一次“动态方法解析”</span></span><br><span class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);  <span class="comment">// ⚠️核心函数</span></span><br><span class="line">        runtimeLock.read();</span><br><span class="line">        <span class="comment">// Don&#x27;t cache the result; we don&#x27;t hold the lock so it may have </span></span><br><span class="line">        <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">        triedResolver = <span class="literal">YES</span>;  <span class="comment">// ⚠️标记triedResolver为YES</span></span><br><span class="line">        <span class="keyword">goto</span> retry;  <span class="comment">// ⚠️再次进入消息发送，从“去 receiverClass 的 cache 中查找方法”这一步开始</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️进入“消息转发”阶段</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-class.mm（objc4）</span></span><br><span class="line"><span class="type">void</span> _class_resolveMethod(Class cls, SEL sel, <span class="type">id</span> inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ⚠️判断是 class 对象还是 meta-class 对象</span></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        <span class="comment">// ⚠️核心函数</span></span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        <span class="comment">// ⚠️核心函数</span></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _class_resolveInstanceMethod</span></span><br><span class="line"><span class="comment">* Call +resolveInstanceMethod, looking for a method to be added to class cls.</span></span><br><span class="line"><span class="comment">* cls may be a metaclass or a non-meta class.</span></span><br><span class="line"><span class="comment">* Does not check if the method already exists.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> _class_resolveInstanceMethod(Class cls, SEL sel, <span class="type">id</span> inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ⚠️查看 receiverClass 的 meta-class 对象的方法列表里面是否有 SEL_resolveInstanceMethod 函数 imp</span></span><br><span class="line">    <span class="comment">// ⚠️也就是看我们是否实现了 +(BOOL)resolveInstanceMethod:(SEL)sel 方法</span></span><br><span class="line">    <span class="comment">// ⚠️这里一定会找到该方法实现，因为 NSObject 中有实现</span></span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </span><br><span class="line">                         <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ⚠️如果没找到，说明程序异常，直接返回</span></span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️如果找到了，通过 objc_msgSend 给对象发送一条 SEL_resolveInstanceMethod 消息</span></span><br><span class="line">    <span class="comment">// ⚠️即调用一下 +(BOOL)resolveInstanceMethod:(SEL)sel 方法</span></span><br><span class="line">    <span class="type">BOOL</span> (*msg)(Class, SEL, SEL) = (<span class="keyword">typeof</span>(msg))objc_msgSend;</span><br><span class="line">    <span class="type">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️下面是解析结果的一些打印信息</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _class_resolveClassMethod</span></span><br><span class="line"><span class="comment">* Call +resolveClassMethod, looking for a method to be added to class cls.</span></span><br><span class="line"><span class="comment">* cls should be a metaclass.</span></span><br><span class="line"><span class="comment">* Does not check if the method already exists.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> _class_resolveClassMethod(Class cls, SEL sel, <span class="type">id</span> inst)</span><br><span class="line">&#123;</span><br><span class="line">    assert(cls-&gt;isMetaClass());</span><br><span class="line">    <span class="comment">// ⚠️查看 receiverClass 的 meta-class 对象的方法列表里面是否有 SEL_resolveClassMethod 函数 imp</span></span><br><span class="line">    <span class="comment">// ⚠️也就是看我们是否实现了 +(BOOL)resolveClassMethod:(SEL)sel 方法</span></span><br><span class="line">    <span class="comment">// ⚠️这里一定会找到该方法实现，因为 NSObject 中有实现</span></span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </span><br><span class="line">                         <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ⚠️如果没找到，说明程序异常，直接返回</span></span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⚠️如果找到了，通过 objc_msgSend 给对象发送一条 SEL_resolveClassMethod 消息</span></span><br><span class="line">    <span class="comment">// ⚠️即调用一下 +(BOOL)resolveClassMethod:(SEL)sel 方法</span></span><br><span class="line">    <span class="type">BOOL</span> (*msg)(Class, SEL, SEL) = (<span class="keyword">typeof</span>(msg))objc_msgSend;</span><br><span class="line">    <span class="type">bool</span> resolved = msg(_class_getNonMetaClass(cls, inst),   <span class="comment">// 该函数返回值是类对象，而非元类对象</span></span><br><span class="line">                        SEL_resolveClassMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️下面是解析结果的一些打印信息</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><img src="/2022/01/25/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/msgTransfer.png" class="&#x3D;"><p>如果<code>消息发送</code>阶段未找到方法的实现，且通过<code>动态方法解析</code>没有解决，就进入<code>消息转发</code>阶段；</p><p>消息转发阶段分两步进行：Fast forwarding 和 Normal forwarding，第一步速度要比第二步快；</p><p>Fast forwarding：将消息转发给一个其它OC对象（找一个备用接收者），我们可以重写以下方法，返回一个<code>！=receiver</code>的对象，来完成这一步骤；<code>+/- (id)forwardingTargetForSelector:(SEL)sel</code></p><p>Normal forwarding：实现一个完整的消息转发过程</p><p>如果上一步没能解决未知消息，可以重写以下两个方法启动完整的消息转发。</p><ul><li>第一个方法<br>我们需要在该方法中返回一个适合该未知消息的方法签名（方法签名就是对返回值类型、参数类型的描述，可以使用 Type Encodings 编码</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+/- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure><p>Runtime 会根据这个方法签名，创建一个NSInvocation对象（NSInvocation封装了未知消息的全部内容，包括：方法调用者 target、方法名 selector、方法参数 argument 等），然后调用第二个方法并将该NSInvocation对象作为参数传入。</p><ul><li>第二个方法<br>可以在该方法中：将未知消息转发给其它对象；改变未知消息的内容(如方法名、方法参数)再转发给其它对象；甚至可以定义任何逻辑。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+/- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation</span><br></pre></td></tr></table></figure><p>如果第一个方法中没有返回方法签名，或者我们没有重写第二个方法，系统就会认为我们彻底不想处理这个消息了，这时候就会调用<code>+/- (void)doesNotRecognizeSelector:(SEL)sel</code>方法并抛出经典的 <code>crash:unrecognized selector sent to instance/class</code>，结束 <code>objc_msgSend</code> 的全部流程。</p><p>这几个方法的默认实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSObject.mm</span></span><br><span class="line">+ (<span class="type">id</span>)forwardingTargetForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;+[NSObject methodSignatureForSelector:] &quot;</span></span><br><span class="line">                <span class="string">&quot;not available without CoreFoundation&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    [<span class="keyword">self</span> doesNotRecognizeSelector:(invocation ? [invocation selector] : <span class="number">0</span>)];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">void</span>)doesNotRecognizeSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;+[%s %s]: unrecognized selector sent to instance %p&quot;</span>, </span><br><span class="line">                class_getName(<span class="keyword">self</span>), sel_getName(sel), <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fast-forwarding示例"><a href="#Fast-forwarding示例" class="headerlink" title="Fast forwarding示例"></a>Fast forwarding示例</h3><p>调用了 HTPerson 的eat实例方法，而 HTPerson.m 文件中并没有该方法的对应实现，HTDog.m 中有同名方法的实现，我们将消息转发给 HTDog 的实例对象</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;HTPerson.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[HTPerson new] eat];        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTPerson.h</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HTPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="type">void</span>)eat;  <span class="comment">// 没有对应实现</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTPerson.m</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;HTPerson.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;HTDog.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HTPerson</span></span></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(eat)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [HTDog new];  <span class="comment">// 将 eat 消息转发给 HTDog 的实例对象</span></span><br><span class="line"><span class="comment">//        return [HTDog class];  // 还可以将 eat 消息转发给 HTDog 的类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTDog.m</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;HTDog.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HTDog</span></span></span><br><span class="line">- (<span class="type">void</span>)eat</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">void</span>)eat</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>-[HTDog eat]</p></blockquote><h3 id="Normal-forwarding示例"><a href="#Normal-forwarding示例" class="headerlink" title="Normal forwarding示例"></a>Normal forwarding示例</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTPerson.m</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;HTPerson.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;HTDog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HTPerson</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(eat)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [[HTDog new] methodSignatureForSelector:aSelector];</span><br><span class="line">        <span class="comment">//return [NSMethodSignature signatureWithObjCTypes:&quot;v@:i&quot;];</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将未知消息转发给其它对象</span></span><br><span class="line">    [anInvocation invokeWithTarget:[HTDog new]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 改变未知消息的内容(如方法名、方法参数)再转发给其它对象</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    anInvocation.selector = @selector(sleep);</span></span><br><span class="line"><span class="comment">    anInvocation.target = [HTDog new];</span></span><br><span class="line"><span class="comment">    int age;</span></span><br><span class="line"><span class="comment">    [anInvocation getArgument:&amp;age atIndex:2];  // 参数顺序：target、selector、other arguments</span></span><br><span class="line"><span class="comment">    [anInvocation setArgument:&amp;age atIndex:2];  // 参数的个数由上个方法返回的方法签名决定，要注意数组越界问题</span></span><br><span class="line"><span class="comment">    [anInvocation invoke];</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    int ret;</span></span><br><span class="line"><span class="comment">    [anInvocation getReturnValue:&amp;age];  // 获取返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义任何逻辑，如：只打印一句话</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     NSLog(@&quot;好好学习&quot;);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>-[HTDog eat]</p></blockquote><h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm（objc4）</span></span><br><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, <span class="type">id</span> inst, </span><br><span class="line">                       <span class="type">bool</span> initialize, <span class="type">bool</span> cache, <span class="type">bool</span> resolver)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️如果“消息发送”阶段未找到方法的实现，且通过“动态方法解析”没有解决</span></span><br><span class="line">    <span class="comment">// ⚠️进入“消息转发”阶段</span></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;  <span class="comment">// 进入汇编</span></span><br><span class="line">    cache_fill(cls, sel, imp, inst);       <span class="comment">// 缓存方法</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-msg-arm64.s（objc4）</span></span><br><span class="line">STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line"><span class="keyword">b</span>__objc_msgForward</span><br><span class="line">END_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line"><span class="meta">ENTRY</span> __objc_msgForward</span><br><span class="line"><span class="keyword">adrp</span>x17, __objc_forward_handler<span class="comment">@PAGE   // ⚠️执行C函数 _objc_forward_handler</span></span><br><span class="line"><span class="keyword">ldr</span>x17, [x17, __objc_forward_handler<span class="comment">@PAGEOFF]</span></span><br><span class="line"><span class="keyword">br</span>x17</span><br><span class="line">END_ENTRY __objc_msgForward</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-runtime.mm（objc4）</span></span><br><span class="line"><span class="comment">// Default forward handler halts the process.</span></span><br><span class="line">__attribute__((noreturn)) <span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">objc_defaultForwardHandler</span><span class="params">(id self, SEL sel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</span></span><br><span class="line">                <span class="string">&quot;(no message forward handler is installed)&quot;</span>, </span><br><span class="line">                <span class="built_in">class_isMetaClass</span>(<span class="built_in">object_getClass</span>(self)) ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                <span class="built_in">object_getClassName</span>(self), <span class="built_in">sel_getName</span>(sel), self);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *_objc_forward_handler = (<span class="type">void</span>*)objc_defaultForwardHandler;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>_objc_forward_handler</code>是一个函数指针，指向<code>objc_defaultForwardHandler()</code>，该函数只是打印信息，苹果没有对此开源。</p><p>我们知道，如果调用一个没有实现的方法，并且没有进行动态方法解析和消息转发处理，会报经单的crash：<code>unrecognized selector sent to instance/class</code>。我们查看crash打印信息的函数调用栈，可以看到系统调用了一个<code>__forwarding__</code>的函数。</p><img src="/2022/01/25/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/crash.png" class="&#x3D;"><p>该函数是 <code>CoreFoundation</code> 框架中的，苹果对此函数尚未开源，我们可以打断点进入该函数的汇编实现。</p><img src="/2022/01/25/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/CoreFundationForewarding.png" class="&#x3D;"><p>以下是网上找到的__forewarding__的C语言伪代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="type">int</span> __forwarding__(<span class="type">void</span> *frameStackPointer, <span class="type">int</span> isStret) &#123;</span><br><span class="line">    id receiver = *(id *)frameStackPointer;</span><br><span class="line">    SEL sel = *(SEL *)(frameStackPointer + <span class="number">8</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *selName = sel_getName(sel);</span><br><span class="line">    Class receiverClass = object_getClass(receiver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️⚠️⚠️调用 forwardingTargetForSelector:</span></span><br><span class="line">    <span class="keyword">if</span> (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123;</span><br><span class="line">        id forwardingTarget = [receiver forwardingTargetForSelector:sel];</span><br><span class="line">        <span class="comment">// ⚠️判断该方法是否返回了一个对象且该对象 != receiver</span></span><br><span class="line">        <span class="keyword">if</span> (forwardingTarget &amp;&amp; forwardingTarget != receiver) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isStret == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> ret;</span><br><span class="line">                objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//⚠️objc_msgSend(返回值, sel, ...);</span></span><br><span class="line">            <span class="keyword">return</span> objc_msgSend(forwardingTarget, sel, ...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 僵尸对象</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *className = class_getName(receiverClass);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *zombiePrefix = <span class="string">&quot;_NSZombie_&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> prefixLen = <span class="built_in">strlen</span>(zombiePrefix); <span class="comment">// 0xa</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(className, zombiePrefix, prefixLen) == <span class="number">0</span>) &#123;</span><br><span class="line">        CFLog(kCFLogLevelError,</span><br><span class="line">              @<span class="string">&quot;*** -[%s %s]: message sent to deallocated instance %p&quot;</span>,</span><br><span class="line">              className + prefixLen,</span><br><span class="line">              selName,</span><br><span class="line">              receiver);</span><br><span class="line">        &lt;breakpoint-interrupt&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⚠️⚠️⚠️调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</span></span><br><span class="line">    <span class="keyword">if</span> (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123;</span><br><span class="line">        <span class="comment">// ⚠️调用 methodSignatureForSelector 获取方法签名</span></span><br><span class="line">        NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel];</span><br><span class="line">        <span class="comment">// ⚠️判断返回值是否为 nil</span></span><br><span class="line">        <span class="keyword">if</span> (methodSignature) &#123;</span><br><span class="line">            BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</span><br><span class="line">            <span class="keyword">if</span> (signatureIsStret != isStret) &#123;</span><br><span class="line">                CFLog(kCFLogLevelWarning ,</span><br><span class="line">                      @<span class="string">&quot;*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of &#x27;%s&#x27;.  Signature thinks it does%s return a struct, and compiler thinks it does%s.&quot;</span>,</span><br><span class="line">                      selName,</span><br><span class="line">                      signatureIsStret ? <span class="string">&quot;&quot;</span> : not,</span><br><span class="line">                      isStret ? <span class="string">&quot;&quot;</span> : not);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ⚠️根据方法签名创建一个 NSInvocation 对象</span></span><br><span class="line">                NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ⚠️调用 forwardInvocation</span></span><br><span class="line">                [receiver forwardInvocation:invocation];</span><br><span class="line"></span><br><span class="line">                <span class="type">void</span> *returnValue = <span class="literal">NULL</span>;</span><br><span class="line">                [invocation getReturnValue:&amp;value];</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                CFLog(kCFLogLevelWarning ,</span><br><span class="line">                      @<span class="string">&quot;*** NSForwarding: warning: object %p of class &#x27;%s&#x27; does not implement forwardInvocation: -- dropping message&quot;</span>,</span><br><span class="line">                      receiver,</span><br><span class="line">                      className);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SEL *registeredSel = sel_getUid(selName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// selector 是否已经在 Runtime 注册过</span></span><br><span class="line">    <span class="keyword">if</span> (sel != registeredSel) &#123;</span><br><span class="line">        CFLog(kCFLogLevelWarning ,</span><br><span class="line">              @<span class="string">&quot;*** NSForwarding: warning: selector (%p) for message &#x27;%s&#x27; does not match selector known to Objective C runtime (%p)-- abort&quot;</span>,</span><br><span class="line">              sel,</span><br><span class="line">              selName,</span><br><span class="line">              registeredSel);</span><br><span class="line">    &#125; <span class="comment">// ⚠️⚠️⚠️调用 doesNotRecognizeSelector </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123;</span><br><span class="line"></span><br><span class="line">        [receiver doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        CFLog(kCFLogLevelWarning ,</span><br><span class="line">              @<span class="string">&quot;*** NSForwarding: warning: object %p of class &#x27;%s&#x27; does not implement doesNotRecognizeSelector: -- abort&quot;</span>,</span><br><span class="line">              receiver,</span><br><span class="line">              className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The point of no return.</span></span><br><span class="line">    kill(getpid(), <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904072235974663">深入浅出 Runtime（三）：消息机制</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Runtime </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Block详解</title>
      <link href="/2022/01/24/Block%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/01/24/Block%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<img src="/2022/01/24/Block%E8%AF%A6%E8%A7%A3/Block.png" class="&#x3D;"><span id="more"></span><h2 id="Block的使用"><a href="#Block的使用" class="headerlink" title="Block的使用"></a>Block的使用</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>块，封装了函数调用以及调用环境的OC对象</p><h2 id="Block底层数据结构"><a href="#Block底层数据结构" class="headerlink" title="Block底层数据结构"></a>Block底层数据结构</h2><p>Block本质上也是一个OC对象，它内部也有个<code>isa</code>指针<br>Block是封装了函数调用以及调用环境的OC对象<br>Block底层数据结构如下图所示：</p><img src="/2022/01/24/Block%E8%AF%A6%E8%A7%A3/BlockStruct.png" class="&#x3D;"><h2 id="Block变量捕获机制"><a href="#Block变量捕获机制" class="headerlink" title="Block变量捕获机制"></a>Block变量捕获机制</h2><p>为了保证block内部能够正常访问外部变量，block有个变量捕获机制。</p><ol><li>对于全局变量，不会捕获到block内部，访问方式为直接访问</li><li>对于auto类型的局部变量，会捕获到block内部，block内部会自动生成一个成员变量，用来存储这个变量的值，访问方式为值传递。</li><li>对于static类型的局部变量，会捕获到block内部，block内部会自动生成一个成员变量，用来存储这个变量的地址，访问方式为指针传递</li><li>对于对象类型的局部变量，block会连同它的所有权修饰符一起捕获</li></ol><img src="/2022/01/24/Block%E8%AF%A6%E8%A7%A3/valueCapture.png" class="&#x3D;"><h3 id="为什么局部变量需要捕获，全局变量不用捕获呢？"><a href="#为什么局部变量需要捕获，全局变量不用捕获呢？" class="headerlink" title="为什么局部变量需要捕获，全局变量不用捕获呢？"></a>为什么局部变量需要捕获，全局变量不用捕获呢？</h3><ol><li>作用域的原因，全局变量哪里都可以直接访问，所有不用捕获</li><li>局部变量，外部不能直接访问，所以需要捕获</li><li>auto类型的局部变量可能会被销毁，其内存会消失，block将来执行代码的时候不可能再去访问那块内存，所以捕获其值</li><li>static变量会一直保存在内存中，所以捕获其地址即可</li></ol><h3 id="对象类型的auto变量"><a href="#对象类型的auto变量" class="headerlink" title="对象类型的auto变量"></a>对象类型的auto变量</h3><p>当block内部访问了对象类型的auto变量时</p><p>如果block是在堆上，将不会对auto变量产生强引用</p><p>如果block被拷贝到堆上<br>① block 内部的 desc 结构体会新增两个函数：<br> <code>copy</code>（__main_block_copy_0，函数名命名规范同__main_block_impl_0）<br> <code>dispose</code>（__main_block_dispose_0）<br>② 会调用 block 内部的 copy 函数<br>③ copy 函数内部会调用<code>_Block_object_assign</code>函数<br>④ _Block_object_assign函数会根据 auto 变量的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用</p><p>如果block从堆上移除<br>① 会调用 block 内部的 <code>dispose</code> 函数<br>② dispose 函数内部会调用<code>_Block_object_dispose</code>函数<br>③ _Block_object_dispose函数会自动释放引用的 auto 变量（release）</p><img src="/2022/01/24/Block%E8%AF%A6%E8%A7%A3/objectCopy.png" class="&#x3D;"><h3 id="block"><a href="#block" class="headerlink" title="__block"></a>__block</h3><h4 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h4><ol><li><code>__block </code>可以用于解决 block 内部无法修改 auto 变量值的问题；</li><li><code>__block </code>不能修饰全局变量、静态变量；</li><li>编译器会将 <code>__block</code> 变量包装成一个对象（<code>struct __Block_byref_age_0</code>（byref：按地址传递））；</li><li>加 <code>__block</code> 修饰不会修改变量的性质，它还是 auto 变量；</li><li>一般情况下，对被捕获变量进行赋值(赋值!&#x3D;使用)操作需要添加 <code>__block</code> 修饰符。比如给数组添加或者删除对象，就不用加 <code>__block</code> 修饰；</li><li>在 MRC 下使用 <code>__block</code> 修饰对象类型，在 block 内部不会对该对象进行 retain 操作，所以在 MRC 环境下可以通过 <code>__block</code> 解决循环引用的问题。</li></ol><h4 id="block的-forwarding指针"><a href="#block的-forwarding指针" class="headerlink" title="__block的__forwarding指针"></a>__block的__forwarding指针</h4><p><code>__block</code> 的<code>__forwarding</code>指针存在的意义？</p><p>为什么要通过 age 结构体里的<code>__forwarding</code>指针拿到 age 变量的值，而不直接 age 结构体拿到 age 变量的值呢？</p><p><code>__block</code> 的<code>__forwarding</code>是指向自己本身的指针， 为了不论在任何内存位置，都可以顺利的访问同一个 <code>__block</code> 变量。</p><ol><li>block 对象 copy 到堆上时，内部的<code> __block</code> 变量也会 copy 到堆上去。为了防止 age 的值赋值给栈上的 <code>__block</code> 变量，就使用了<code>__forwarding</code>；</li><li>当 <code>__block</code> 变量在栈上的时候，<code>__block</code> 变量的结构体中的<code>__forwarding</code>指针指向自己，这样通过<code>__forwarding</code>取到结构体中的 age 给它赋值没有问题；</li><li>当 <code>__block</code> 变量 copy 到堆上后，栈上的<code>__forwarding</code>指针会指向 copy 到堆上的 _block 变量结构体，而堆上的<code>__forwarding</code>指向自己；</li></ol><p>这样不管我们访问的是栈上还是堆上的 __block 变量结构体，只要是通过__forwarding指针访问，都是访问到堆上的 <code>__block</code> 变量结构体；给 age 赋值，就肯定会赋值给堆上的那个 <code>__block</code> 变量中的 age</p><img src="/2022/01/24/Block%E8%AF%A6%E8%A7%A3/forwarding.png" class="&#x3D;"><h4 id="对象类型的auto变量、-block变量内存管理区别"><a href="#对象类型的auto变量、-block变量内存管理区别" class="headerlink" title="对象类型的auto变量、__block变量内存管理区别"></a>对象类型的auto变量、__block变量内存管理区别</h4><p>当 block 在栈上时，对它们都不会产生强引用<br>当 block 拷贝到堆上时，都会通过 copy 函数来处理它们</p><img src="/2022/01/24/Block%E8%AF%A6%E8%A7%A3/objectblock.png" class="&#x3D;"><p>当 block 从堆上移除时，都会通过 dispose 函数来释放它们</p><img src="/2022/01/24/Block%E8%AF%A6%E8%A7%A3/objectDispose.png" class="&#x3D;"><h4 id="被-block修饰的对象类型"><a href="#被-block修饰的对象类型" class="headerlink" title="被__block修饰的对象类型"></a>被__block修饰的对象类型</h4><ul><li>当 <code>__block</code> 变量在栈上时，不会对指向的对象产生强引用</li><li>当 <code>__block</code> 变量被 copy 到堆时<br>①<code>__Block_byref_object_0</code>即 <code>__block</code> 变量内部会新增两个函数：<br> <code>copy</code>（__Block_byref_id_object_copy）<br> <code>dispose</code>（__Block_byref_id_object_dispose）<br>② 会调用 <code>__block</code> 变量内部的 <code>copy</code> 函数<br>③ <code>copy</code> 函数内部会调用_Block_object_assign函数<br>④ <code>_Block_object_assign</code>函数会根据所指向对象的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用（注意：这里仅限于 ARC 时会 retain，MRC 时不会 retain）</li><li>如果 <code>__block</code> 变量从堆上移除<br>① 会调用 <code>__block</code> 变量内部的 dispose 函数<br>② dispose 函数内部会调用_Block_object_dispose函数<br>③ <code>_Block_object_dispose</code>函数会自动释放指向的对象（release）</li></ul><h2 id="Block类型"><a href="#Block类型" class="headerlink" title="Block类型"></a>Block类型</h2><p>block 有 3 种类型，可以通过调用 class 方法或者 isa 指针 查看具体类型，最终都是继承自 NSBlock 类型。</p><img src="/2022/01/24/Block%E8%AF%A6%E8%A7%A3/blockType.png" class="&#x3D;"><p>每一种类型的 block 调用 copy 后的结果如下所示：</p><img src="/2022/01/24/Block%E8%AF%A6%E8%A7%A3/blockcopy.png" class="&#x3D;"><h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><p>Q：block在给 NSMutableArray 添加或移除对象，需不需要添加 __block？</p><p>不需要。</p><p>Q：self 会不会捕获到 block 内部？</p><p>会捕获。 OC 方法都有两个隐式参数，方法调用者self和方法名_cmd。 参数也是一种局部变量。</p><p>Q：_name 会不会捕获到 block 内部？</p><p>会捕获。不是将_name变量进行捕获，而是直接将self捕获到 block 内部，因为_name是 Person 类的成员变量，_name来自当前的对象&#x2F;方法调用者self（self-&gt;_name）。</p><p>如果使用self.name即调用self的getter方法，即给self对象发送一条消息，那还是要访问到self。self是局部变量，不是全局变量，所以self会捕获到 block 内部。</p><p>Q：__block 修饰符使用注意点：</p><p>在 MRC 下使用 <code>__block</code> 修饰对象类型，在 block 内部不会对该对象进行 retain 操作，所以在 MRC 环境下可以通过 <code>__block</code> 解决循环引用的问题。</p><p>Q：解决在 block 内部通过弱指针访问对象成员时编译器报错的问题：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf; <span class="comment">//避免执行过程中提前释放</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,strongSelf-&gt;age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Q：以下代码有问题吗？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="type">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%p&quot;</span>,weakSelf);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 MRC 下，不会产生循环引用；<br>在 ARC 下，会产生循环引用，导致内存泄漏，解决方案如下。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="type">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%p&quot;</span>,weakSelf);</span><br><span class="line">    weakSelf = <span class="literal">nil</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">self</span>.block();</span><br></pre></td></tr></table></figure><p>缺点：必须要调用 block，而且 block 里要将指针置为 nil。如果一直不调用 block，对象就会一直保存在内存中，造成内存泄漏。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904070746996750">OC 底层探索 - Block 详解</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Association关联对象</title>
      <link href="/2022/01/21/Association%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/01/21/Association%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Association-关联对象"><a href="#Association-关联对象" class="headerlink" title="Association 关联对象"></a>Association 关联对象</h2><p>默认情况下，由于分类底层结构的限制，不能直接给 Category 添加成员变量，但是可以通过关联对象间接实现 Category 有成员变量的效果。 </p><span id="more"></span><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Test</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> height;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Person+Test.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test</span>)</span></span><br><span class="line">- (<span class="type">void</span>)setHeight:(<span class="type">int</span>)height</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(height), [<span class="built_in">NSNumber</span> numberWithInt:height], OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">int</span>)height</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(height)) intValue];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="objc-AssociationPolicy-关联策略"><a href="#objc-AssociationPolicy-关联策略" class="headerlink" title="objc_AssociationPolicy 关联策略"></a>objc_AssociationPolicy 关联策略</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="key的常见用法"><a href="#key的常见用法" class="headerlink" title="key的常见用法"></a>key的常见用法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  使用 getter 方法的 SEL 作为 key（可读性高，有智能提示）</span></span><br><span class="line">objc_setAssociatedObject(object, <span class="keyword">@selector</span>(<span class="keyword">getter</span>), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">objc_getAssociatedObject(object, <span class="keyword">@selector</span>(<span class="keyword">getter</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或使用隐式参数 _cmd</span></span><br><span class="line">objc_getAssociatedObject(object, _cmd];</span><br></pre></td></tr></table></figure><h3 id="关联对象的原理"><a href="#关联对象的原理" class="headerlink" title="关联对象的原理"></a>关联对象的原理</h3><p>实现关联对象技术的核心对象</p><p><code>AssociationsManager</code><br><code>AssociationsHashMap</code><br><code>ObjectAssociationMap</code><br><code>ObjcAssociation</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AssociationsManager &#123;</span><br><span class="line">    <span class="keyword">static</span> AssociationsHashMap *_map;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap&gt;</span><br><span class="line"><span class="keyword">class</span> ObjectAssociationMap : public std::map&lt;<span class="type">void</span> *, ObjcAssociation&gt;</span><br><span class="line"><span class="keyword">class</span> ObjcAssociation &#123;</span><br><span class="line">    uintptr_t _policy;</span><br><span class="line">    <span class="type">id</span> _value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/01/21/Association%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/AssociationsManager.png" class="&#x3D;"><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>AssociationsManager</li></ul><p>关联对象并不是存储在关联对象本身内存中，而是存储在全局统一的一个容器中；<br>由 AssociationsManager 管理并在它维护的一个单例 Hash 表 AssociationsHashMap 中存储；<br>使用 AssociationsManagerLock 自旋锁保证了线程安全。</p><img src="/2022/01/21/Association%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/AssociationsManager_class.png" class="&#x3D;"><ul><li><p>AssociationsHashMap</p></li><li><p>一个单例的 Hash 表，存储 disguised_ptr_t 和 ObjectAssociationMap 之间的映射。</p></li><li><p>disguised_ptr_t 是根据 object 生成，但不存在引用关系。</p></li></ul><p><code>disguised_ptr_t disguised_object = DISGUISE(object);</code></p><ul><li>ObjectAssociationMap<br>存储 key 和 ObjcAssociation 之间的映射</li></ul><img src="/2022/01/21/Association%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/ObjectAssociationMap.png" class="&#x3D;"><ul><li><p>ObjcAssociation<br>存储着关联策略 policy 和关联对象的值 value</p><img src="/2022/01/21/Association%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/ObjcAssociation.png" class="&#x3D;"></li><li><p>objc_setAssociatedObject</p></li></ul><p>① 实例化一个 AssociationsManager 对象，它维护了一个单例 Hash 表 AssociationsHashMap 对象；<br>② 实例化一个 AssociationsHashMap 对象，它维护 disguised_ptr_t 和 ObjectAssociationMap 对象之间的关系；<br>③ 根据object生成一个 disguised_ptr_t 对象；<br>④ 根据 disguised_ptr_t 获取对应的 ObjectAssociationMap 对象，它存储key和 ObjcAssociation 之间的映射；<br>⑤ 根据policy和value创建一个 ObjcAssociation 对象，并存储在 ObjectAssociationMap 中；<br>⑥ 如果传进来的value为 nil，则在 ObjectAssociationMap 中删除该 ObjcAssociation 对象。</p><img src="/2022/01/21/Association%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/objc_setAssociatedObject.png" class="&#x3D;"><ul><li>objc_getAssociatedObject<br>① 实例化一个 AssociationsManager 对象；<br>② 实例化一个 AssociationsHashMap 对象；<br>③ 根据object生成一个 disguised_ptr_t 对象；<br>④ 根据 disguised_ptr_t 获取对应的 ObjectAssociationMap 对象；<br>⑤ 根据 key 获取到它所对应的 ObjcAssociation 对象；<br>⑥ 返回 ObjcAssociation 中的 value。</li></ul><ul><li>objc_removeAssociatedObjects<br>① 实例化一个 AssociationsManager 对象；<br>② 实例化一个 AssociationsHashMap 对象；<br>③ 根据object生成一个 disguised_ptr_t 对象；<br>④ 根据 disguised_ptr_t 获取对应的 ObjectAssociationMap 对象；<br>⑤ 删除该 ObjectAssociationMap 对象。</li></ul><ul><li>acquireValue<br>根据policy来对value进行retain或者copy操作。</li></ul><img src="/2022/01/21/Association%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/acquireValue.png" class="&#x3D;"><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="Q：如何移除关联对象？"><a href="#Q：如何移除关联对象？" class="headerlink" title="Q：如何移除关联对象？"></a>Q：如何移除关联对象？</h4><ul><li><p>移除一个object的某个key的关联对象：调用<code>objc_setAssociatedObject</code>设置关联对象value为nil。<br>objc_setAssociatedObject函数会调用_object_set_associative_reference函数，并在该函数中判断传进来的value是否为nil，是的话会调用erase(j)擦除函数，将j变量擦除。j即为ObjectAssociationMap对象里的一对【key: key value: ObjcAssociation（_policy、_value）】。</p></li><li><p>移除一个object的所有关联对象：调用函数<code>objc_removeAssociatedObjects</code>。<br>objc_removeAssociatedObjects函数会调用<code>_object_remove_assocations</code>函数，并在该函数中调用对象的erase(i)擦除函数，将i变量擦除。i即为AssociationsHashMap对象中的一对【key: object value: ObjectAssociationMap】。</p></li></ul><h4 id="Q：如果-object-被销毁，那它所对应的-ObjectAssociationMap-是否也会自动销毁？"><a href="#Q：如果-object-被销毁，那它所对应的-ObjectAssociationMap-是否也会自动销毁？" class="headerlink" title="Q：如果 object 被销毁，那它所对应的 ObjectAssociationMap 是否也会自动销毁？"></a>Q：如果 object 被销毁，那它所对应的 ObjectAssociationMap 是否也会自动销毁？</h4><p>会。</p><h4 id="如果没有关联对象，怎么实现-Category-有成员变量的效果？"><a href="#如果没有关联对象，怎么实现-Category-有成员变量的效果？" class="headerlink" title="如果没有关联对象，怎么实现 Category 有成员变量的效果？"></a>如果没有关联对象，怎么实现 Category 有成员变量的效果？</h4><p>使用字典。创建一个全局的字典，将self对象在内存中的地址作为key。<br>缺点：<br>① 内存泄漏问题：全局变量会一直存储在内存中；<br>② 线程安全问题：可能会有多个对象同时访问字典，加锁可以解决；<br>③ 每添加一个成员变量就要创建一个字典，很麻烦。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Test</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">int</span> height;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Person+Test.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test</span>)</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *heights_;</span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    heights_ = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)setHeight:(<span class="type">int</span>)height &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>,<span class="keyword">self</span>];</span><br><span class="line">    heights_[key] = @(height);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">int</span>)height &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>,<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">return</span> [heights_[key] intValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903972315070471">OC 底层探索 - Association 关联对象</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Runtime </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【读书笔记】iOS之师大小海腾博客</title>
      <link href="/2022/01/21/iOS%E4%B9%8B%E5%B8%88%E5%A4%A7%E5%B0%8F%E6%B5%B7%E8%85%BE%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/21/iOS%E4%B9%8B%E5%B8%88%E5%A4%A7%E5%B0%8F%E6%B5%B7%E8%85%BE%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="属性关键字和所有权修饰符"><a href="#属性关键字和所有权修饰符" class="headerlink" title="属性关键字和所有权修饰符"></a>属性关键字和所有权修饰符</h2><h3 id="atomic-修饰的属性是怎么样保存线程安全的？"><a href="#atomic-修饰的属性是怎么样保存线程安全的？" class="headerlink" title="atomic 修饰的属性是怎么样保存线程安全的？"></a>atomic 修饰的属性是怎么样保存线程安全的？</h3><p><code>atomic</code> 原子性（默认），编译器会自动生成互斥锁，对setter和getter方法进行加锁，可以保证<code>属性的赋值和取值</code>的原子性是线程安全的，但<code>不包括操作和访问</code></p><p>比如说atomic修饰的是一个数组的话，那么我们对数组进行赋值和取值是可以保证线程安全的，但是如果我们对数组进行操作，比如说给数组添加对象或者移除对象，是不在atomic的负责范围之内的，所以给被atomic修饰的数组添加对象或者移除对象是没办法保证线程安全的。</p><span id="more"></span><h3 id="assign修饰对象类型"><a href="#assign修饰对象类型" class="headerlink" title="assign修饰对象类型"></a>assign修饰对象类型</h3><p>修饰对象类型时，不增加其引用计数，会产生<code>悬垂指针</code>（assign修饰的对象在被释放之后，指针仍然指向原对象地址，该指针变为悬垂指针，这时候如果继续通过该指针访问原对象的话，就可能导致程序崩溃）</p><h2 id="Category和Extension"><a href="#Category和Extension" class="headerlink" title="Category和Extension"></a>Category和Extension</h2><img src="/2022/01/21/iOS%E4%B9%8B%E5%B8%88%E5%A4%A7%E5%B0%8F%E6%B5%B7%E8%85%BE%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0/category.png" class="&#x3D;"><img src="/2022/01/21/iOS%E4%B9%8B%E5%B8%88%E5%A4%A7%E5%B0%8F%E6%B5%B7%E8%85%BE%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0/extension.png" class="&#x3D;"><h3 id="Category-的使用场合"><a href="#Category-的使用场合" class="headerlink" title="Category 的使用场合"></a>Category 的使用场合</h3><p>① 给一个类添加新的方法，可以<code>为系统的类扩展功能</code>。<br>② <code>分解体积庞大的类文件</code>，可以将一个类按功能拆解成多个模块，方便代码管理。<br>③ <code>创建对私有方法的前向引用</code>：声明私有方法，把 Framework 的私有方法公开等。直接调用其他类的私有方法时编译器会报错的，这时候可以创建一个该类的分类，在分类中声明这些私有方法（不必提供方法实现），接着导入这个分类的头文件就可以正常调用这些私有方法。<br>④ <code>向对象添加非正式协议</code>：创建一个 NSObject 或其子类的分类称为 “创建一个非正式协议”。</p><p>（<code>正式协议</code>是通过 protocol 指定的一系列方法的声明，然后由遵守该协议的类自己去实现这些方法。而<code>非正式协议是通过给 NSObject 或其子类添加一个分类来实现</code>。非正式协议已经渐渐被正式协议取代，正式协议最大的优点就是可以使用泛型约束，而非正式协议不可以。）</p><h3 id="Category-中都可以添加哪些内容？"><a href="#Category-中都可以添加哪些内容？" class="headerlink" title="Category 中都可以添加哪些内容？"></a>Category 中都可以添加哪些内容？</h3><p>实例方法、类方法、协议、属性（<code>只生成 setter 和 getter 方法的声明，不会生成 setter 和 getter 方法的实现以及下划线成员变量</code>）；<br>默认情况下，因为分类底层结构的限制，不能添加成员变量到分类中，但可以通过关联对象来间接实现这种效果。</p><h3 id="Category-的实现原理"><a href="#Category-的实现原理" class="headerlink" title="Category 的实现原理"></a>Category 的实现原理</h3><p>① 分类的实现原理取决于运行时决议；<br>② 同名分类方法谁能生效取决于编译顺序，最后参与编译的分类中的同名方法会最终生效；<br>③ 分类方法会“覆盖”同名的宿主类（原类）方法，这里说的“覆盖”并不是指原来的方法没了。消息传递过程中优先查找宿主类中靠前的元素，找到同名方法就进行调用，但实际上宿主类中原有同名方法的实现仍然是存在的。我们可以通过一些手段来调用到宿主类原有同名方法的实现，如可以<code>通过Runtime</code>的<code>class_copyMethodList</code>方法打印类的方法列表，<code>找到宿主类方法的imp</code>，进行调用（可以交换方法实现）。</p><h3 id="加载处理过程"><a href="#加载处理过程" class="headerlink" title="加载处理过程"></a>加载处理过程</h3><p>在编译时，<code>Category</code> 中的数据还没有合并到类中，而是在程序运行的时候通过<code>Runtime</code>机制将所有分类数据合并到类（类对象、元类对象）中去。下面我们来看一下 Category 的加载处理过程。</p><p>① 通过Runtime加载某个类的所有 Category 数据；<br>② 把所有的分类数据（方法、属性、协议），合并到一个<code>大数组</code>中；（后面参与编译的 Category 数据，会在数组的前面）<br>③ 将合并后的分类数据（方法、属性、协议），<code>插入到宿主类原来数据的前面</code>。（所以会优先调用最后参与编译的分类中的同名方法）</p><h2 id="load和-initialize"><a href="#load和-initialize" class="headerlink" title="load和 initialize"></a>load和 initialize</h2><h3 id="load方法的调用"><a href="#load方法的调用" class="headerlink" title="load方法的调用"></a>load方法的调用</h3><p>① 调用时刻：<br>+load方法会在Runtime加载类、分类时调用（不管有没有用到这些类，在程序运行起来的时候都会加载进内存，并调用+load方法）；<br>每个类、分类的+load ，在程序运行过程中只调用一次（除非开发者手动调用）。<br>② 调用方式： 系统自动调用+load 方式为直接<code>通过函数地址</code>调用，开发者手动调用+load 方式为消息机制objc_msgSend函数调用。<br>③ 调用顺序：<br><code>先调用类的+load </code>，按照编译先后顺序调用（先编译，先调用），<code>调用子类的+load 之前会先调用父类的+load </code>；<br><code>再调用分类的+load</code> ，按照编译先后顺序调用（先编译，先调用）（注意：分类的其它方法是：后编译，优先调用）。</p><h3 id="initialize-方法的调用"><a href="#initialize-方法的调用" class="headerlink" title="initialize 方法的调用"></a>initialize 方法的调用</h3><p>① 调用时刻：<br><code>+initialize</code>方法会在类第一次接收到消息时调用。<br><code>如果子类没有实现+initialize方法，会调用父类的+initialize</code>，所以父类的+initialize方法可能会被调用多次，但不代表父类初始化多次，每个类只会初始化一次。<br>② 调用方式： 消息机制objc_msgSend函数调用。<br>③ 调用顺序： <code>先调用父类的+initialize，再调用子类的+initialize</code>（先初识化父类，再初始化子类）</p><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="Category-中有-load-方法吗？-load-方法是什么时候调用的？-load-方法能继承吗？"><a href="#Category-中有-load-方法吗？-load-方法是什么时候调用的？-load-方法能继承吗？" class="headerlink" title="Category 中有 +load 方法吗？+load 方法是什么时候调用的？+load 方法能继承吗？"></a>Category 中有 +load 方法吗？+load 方法是什么时候调用的？+load 方法能继承吗？</h4><p>分类中有+load方法；<br>+load方法在Runtime加载类、分类的时候调用；<br>+load方法可以继承，但是一般情况下不会手动去调用+load方法，都是让系统自动调用。</p><h4 id="手动调用-Student-类的-load-方法，但是-Student-类没有实现该方法，为什么会去调用父类的-load-方法，且是调用父类的分类的-load-方法呢？"><a href="#手动调用-Student-类的-load-方法，但是-Student-类没有实现该方法，为什么会去调用父类的-load-方法，且是调用父类的分类的-load-方法呢？" class="headerlink" title="手动调用 Student 类的 +load 方法，但是 Student 类没有实现该方法，为什么会去调用父类的 +load 方法，且是调用父类的分类的 +load 方法呢？"></a>手动调用 Student 类的 +load 方法，但是 Student 类没有实现该方法，为什么会去调用父类的 +load 方法，且是调用父类的分类的 +load 方法呢？</h4><p>因为+load方法可以继承，[Student load]手动调用方式为是消息机制objc_msgSend函数的调用，会去类方法列表里找对应的方法，由于 Student 类没有实现，就会去父类的方法列表中查找，且优先调用分类的+load方法。而系统自动调用的+load方法是直接通过函数地址调用的。</p><h2 id="Swift-Objc-混编"><a href="#Swift-Objc-混编" class="headerlink" title="Swift Objc 混编"></a>Swift Objc 混编</h2><h3 id="Objc-override-alloc兼容问题"><a href="#Objc-override-alloc兼容问题" class="headerlink" title="Objc override alloc兼容问题"></a>Objc override alloc兼容问题</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)alloc OBJC_SWIFT_UNAVAILABLE(<span class="string">&quot;use object initializers instead&quot;</span>);</span><br></pre></td></tr></table></figure><p>在 Swift 中 alloc 方法被禁用，alloc 和 init 自动合并了，内部会处理内存分配。而且在 Swift 中实例化 Objective-C，也不会调用 alloc 方法，也是直接调用构造器方法。</p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>在基础库中定义了一个 <code>DefaultLoadingView</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DefaultLoadingView</span> : <span class="title">UIView</span> &lt;<span class="title">LoadingViewProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DefaultLoadingView</span> (<span class="title">sub</span>)</span></span><br><span class="line">+ (Class)defaultLoadingViewClass4Sub;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DefaultLoadingView</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)alloc &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(defaultLoadingViewClass4Sub)]) &#123;</span><br><span class="line">        Class tempClass = [<span class="keyword">self</span> defaultLoadingViewClass4Sub];</span><br><span class="line">        <span class="keyword">if</span> (tempClass) &#123;</span><br><span class="line">            <span class="keyword">return</span> [tempClass alloc];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> alloc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>业务方可以通过实现<code>DefaultLoadingView+sub</code> 分类来自定义 <code>loadingView</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DefaultLoadingView</span> (<span class="title">sub</span>)</span></span><br><span class="line">+ (Class)defaultLoadingViewClass4Sub &#123;</span><br><span class="line">    <span class="keyword">return</span> CustomLoadingView.class;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在 Objective-C 中我们可以直接通过 <code>[[DefaultLoadingView alloc] init] </code>来创建 loadingView 实例，如果业务方有自定义的那创建的就是 <code>CustomLoadingView</code> 类型，否则就是<code> DefaultLoadingView</code> 类型。<br>但在 Swift 中通过 DefaultLoadingView() 创建实例的话，都将是 DefaultLoadingView 类型，因为它<code>不会调用 alloc 方法</code>。</p><h4 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h4><p>如果要继续保留采用alloc方案的话，就在Objective-C中包个中间层。这里可以新增一个工厂方法来调用alloc和构造器方法，然后使用 <code>NS_SWIFT_NAME</code> 重命名该工厂方法使其作为构造器导入到Swift中以方便使用，同时使用 <code>NS_SWIFT_UNAVAILABLE </code>将原先的构造器方法标记为在Swift中不可用且指示调用者使用新的构造器方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DefaultLoadingView</span> : <span class="title">UIView</span> &lt;<span class="title">LoadingViewProtocol</span>&gt;</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)loadingViewWithFrame:(<span class="built_in">CGRect</span>)frame <span class="built_in">NS_SWIFT_NAME</span>(init(swift_frame:));</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame <span class="built_in">NS_SWIFT_UNAVAILABLE</span>(<span class="string">&quot;Use init(swift_frame:) instead&quot;</span>);</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DefaultLoadingView</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)loadingViewWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithFrame:frame];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用新的构造器方法</span></span><br><span class="line">let loadingView = DefaultLoadingView.init(swift_frame: frame)</span><br></pre></td></tr></table></figure><p>这个方案的缺点是：如果原先构造器方法有多个，那么就要新增多个对应的工厂方法，并添加 <code>NS_SWIFT_NAME</code> 和 <code>NS_SWIFT_UNAVAILABLE</code>。</p><h4 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h4><p>在 Swift 中直接取出想要的那个类，摒弃 alloc 方案，当然你也可以为了向后兼容对其进行保留。通过<code>协议工厂</code>（维护 <code>protocol</code> 和 <code>implClass</code> 的映射关系），在基础库中对协议 <code>LoadingViewProtocol</code> 注册 defaultImplClass DefaultLoadingView，业务方可以对协议注册 implClass CustomLoadingView。使用的时候通过协议去工厂中取出 implClass 或 implInstance，内部实现是如果未注册 implClass 则取默认的 defaultImplClass 或 defaultImplInstance。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DefaultLoadingView</span></span></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    [ServiceFactory registerService:<span class="class"><span class="keyword">@protocol</span>(<span class="title">LoadingViewProtocol</span>) <span class="title">defaultImplClass</span>:<span class="title">self</span>.<span class="title">class</span>];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CustomLoadingView</span></span></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    [ServiceFactory registerService:<span class="class"><span class="keyword">@protocol</span>(<span class="title">LoadingViewProtocol</span>) <span class="title">implClass</span>:<span class="title">CustomLoadingView</span>.<span class="title">class</span>];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 通过协议工厂创建</span></span><br><span class="line">let loadingView = ServiceFactory.createService(LoadingViewProtocol.self, initBlock: <span class="literal">nil</span>) as! <span class="built_in">UIView</span> &amp; LoadingViewProtocol</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS内存管理之AutoreleasePool</title>
      <link href="/2022/01/21/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8BAutoreleasePool/"/>
      <url>/2022/01/21/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8BAutoreleasePool/</url>
      
        <content type="html"><![CDATA[<img src="/2022/01/21/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8BAutoreleasePool/catalog.png" class="&#x3D;"><span id="more"></span><h2 id="autoreleasePool-示例"><a href="#autoreleasePool-示例" class="headerlink" title="autoreleasePool 示例"></a>autoreleasePool 示例</h2><h3 id="mac-OS-工程示例分析"><a href="#mac-OS-工程示例分析" class="headerlink" title="mac OS 工程示例分析"></a>mac OS 工程示例分析</h3><p>iOS工程中，系统在自动释放池中注册了一些对象。为了排除这些干扰，接下来我们通过macOS工程代码示例，结合AutoreleasePoolPage的内存分布图以及_objc_autoreleasePoolPrint()私有函数，来帮助我们更好地理解@autoreleasepool的原理</p><blockquote><p>注意：</p></blockquote><p>由于ARC环境下不能调用autorelease等方法，所以需要将工程切换为MRC环境。<br>如果使用ARC，则可以使用__autoreleasing所有权修饰符替代autorelease方法。</p><h4 id="单个-autoreleasepool"><a href="#单个-autoreleasepool" class="headerlink" title="单个 @autoreleasepool"></a>单个 @autoreleasepool</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    _objc_autoreleasePoolPrint();     <span class="comment">// print1</span></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        _objc_autoreleasePoolPrint(); <span class="comment">// print2</span></span><br><span class="line">        HTPerson *p1 = [[[HTPerson alloc] init] autorelease];</span><br><span class="line">        HTPerson *p2 = [[[HTPerson alloc] init] autorelease];</span><br><span class="line">        _objc_autoreleasePoolPrint(); <span class="comment">// print3</span></span><br><span class="line">    &#125;</span><br><span class="line">    _objc_autoreleasePoolPrint();     <span class="comment">// print4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/01/21/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8BAutoreleasePool/single%20autorelasepool.png" class="&#x3D;"><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动释放池的情况</span></span><br><span class="line">objc[<span class="number">68122</span>]: ############## (print1)</span><br><span class="line">objc[<span class="number">68122</span>]: AUTORELEASE POOLS <span class="keyword">for</span> thread <span class="number">0x1000aa5c0</span></span><br><span class="line">objc[<span class="number">68122</span>]: <span class="number">0</span> releases pending. <span class="comment">//当前自动释放池中没有任何对象</span></span><br><span class="line">objc[<span class="number">68122</span>]: [<span class="number">0x102802000</span>]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[<span class="number">68122</span>]: #############<span class="meta">#</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">objc[68122]: ############## (print2)</span></span><br><span class="line">objc[<span class="number">68122</span>]: AUTORELEASE POOLS <span class="keyword">for</span> thread <span class="number">0x1000aa5c0</span></span><br><span class="line">objc[<span class="number">68122</span>]: <span class="number">1</span> releases pending. <span class="comment">//当前自动释放池中有1个对象，这个对象为POOL_BOUNDARY</span></span><br><span class="line">objc[<span class="number">68122</span>]: [<span class="number">0x102802000</span>]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[<span class="number">68122</span>]: [<span class="number">0x102802038</span>]  ################  POOL <span class="number">0x102802038</span>  <span class="comment">//POOL_BOUNDARY</span></span><br><span class="line">objc[<span class="number">68122</span>]: #############<span class="meta">#</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">objc[68122]: ############## (print3)</span></span><br><span class="line">objc[<span class="number">68122</span>]: AUTORELEASE POOLS <span class="keyword">for</span> thread <span class="number">0x1000aa5c0</span></span><br><span class="line">objc[<span class="number">68122</span>]: <span class="number">3</span> releases pending. <span class="comment">//当前自动释放池中有3个对象</span></span><br><span class="line">objc[<span class="number">68122</span>]: [<span class="number">0x102802000</span>]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[<span class="number">68122</span>]: [<span class="number">0x102802038</span>]  ################  POOL <span class="number">0x102802038</span>  <span class="comment">//POOL_BOUNDARY</span></span><br><span class="line">objc[<span class="number">68122</span>]: [<span class="number">0x102802040</span>]       <span class="number">0x100704a10</span>  HTPerson          <span class="comment">//p1</span></span><br><span class="line">objc[<span class="number">68122</span>]: [<span class="number">0x102802048</span>]       <span class="number">0x10075cc30</span>  HTPerson          <span class="comment">//p2</span></span><br><span class="line">objc[<span class="number">68122</span>]: #############<span class="meta">#</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">objc[68156]: ############## (print4)</span></span><br><span class="line">objc[<span class="number">68156</span>]: AUTORELEASE POOLS <span class="keyword">for</span> thread <span class="number">0x1000aa5c0</span></span><br><span class="line">objc[<span class="number">68156</span>]: <span class="number">0</span> releases pending. <span class="comment">//当前自动释放池中没有任何对象，因为@autoreleasepool作用域结束，调用pop方法释放了对象</span></span><br><span class="line">objc[<span class="number">68156</span>]: [<span class="number">0x100810000</span>]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[<span class="number">68156</span>]: ##############</span><br></pre></td></tr></table></figure><h4 id="嵌套-autoreleasepool"><a href="#嵌套-autoreleasepool" class="headerlink" title="嵌套 @autoreleasepool"></a>嵌套 @autoreleasepool</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    _objc_autoreleasePoolPrint();             <span class="comment">// print1</span></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123; <span class="comment">//r1 = push()</span></span><br><span class="line">        _objc_autoreleasePoolPrint();         <span class="comment">// print2</span></span><br><span class="line">        HTPerson *p1 = [[[HTPerson alloc] init] autorelease];</span><br><span class="line">        HTPerson *p2 = [[[HTPerson alloc] init] autorelease];</span><br><span class="line">        _objc_autoreleasePoolPrint();         <span class="comment">// print3</span></span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123; <span class="comment">//r2 = push()</span></span><br><span class="line">            HTPerson *p3 = [[[HTPerson alloc] init] autorelease];</span><br><span class="line">            _objc_autoreleasePoolPrint();     <span class="comment">// print4</span></span><br><span class="line">            <span class="keyword">@autoreleasepool</span> &#123; <span class="comment">//r3 = push()</span></span><br><span class="line">                HTPerson *p4 = [[[HTPerson alloc] init] autorelease];</span><br><span class="line">                _objc_autoreleasePoolPrint(); <span class="comment">// print5</span></span><br><span class="line">            &#125; <span class="comment">//pop(r3)</span></span><br><span class="line">            _objc_autoreleasePoolPrint();     <span class="comment">// print6</span></span><br><span class="line">        &#125; <span class="comment">//pop(r2)</span></span><br><span class="line">        _objc_autoreleasePoolPrint();         <span class="comment">// print7</span></span><br><span class="line">    &#125; <span class="comment">//pop(r1)</span></span><br><span class="line">    _objc_autoreleasePoolPrint();             <span class="comment">// print8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/01/21/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8BAutoreleasePool/poolinpool.png" class="&#x3D;"><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动释放池的情况</span></span><br><span class="line">objc[<span class="number">68285</span>]: ############## (print1)</span><br><span class="line">objc[<span class="number">68285</span>]: AUTORELEASE POOLS <span class="keyword">for</span> thread <span class="number">0x1000aa5c0</span></span><br><span class="line">objc[<span class="number">68285</span>]: <span class="number">0</span> releases pending. <span class="comment">//当前自动释放池中没有任何对象</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802000</span>]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[<span class="number">68285</span>]: #############<span class="meta">#</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">objc[68285]: ############## (print2)</span></span><br><span class="line">objc[<span class="number">68285</span>]: AUTORELEASE POOLS <span class="keyword">for</span> thread <span class="number">0x1000aa5c0</span></span><br><span class="line">objc[<span class="number">68285</span>]: <span class="number">1</span> releases pending. <span class="comment">//当前自动释放池中有1个对象</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802000</span>]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802038</span>]  ################  POOL <span class="number">0x102802038</span>  <span class="comment">//POOL_BOUNDARY</span></span><br><span class="line">objc[<span class="number">68285</span>]: #############<span class="meta">#</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">objc[68285]: ############## (print3)</span></span><br><span class="line">objc[<span class="number">68285</span>]: AUTORELEASE POOLS <span class="keyword">for</span> thread <span class="number">0x1000aa5c0</span></span><br><span class="line">objc[<span class="number">68285</span>]: <span class="number">3</span> releases pending. <span class="comment">//当前自动释放池中有3个对象（1个@autoreleasepool）</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802000</span>]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802038</span>]  ################  POOL <span class="number">0x102802038</span>  <span class="comment">//POOL_BOUNDARY</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802040</span>]       <span class="number">0x100707d80</span>  HTPerson          <span class="comment">//p1</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802048</span>]       <span class="number">0x100707de0</span>  HTPerson          <span class="comment">//p2</span></span><br><span class="line">objc[<span class="number">68285</span>]: #############<span class="meta">#</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">objc[68285]: ############## (print4)</span></span><br><span class="line">objc[<span class="number">68285</span>]: AUTORELEASE POOLS <span class="keyword">for</span> thread <span class="number">0x1000aa5c0</span></span><br><span class="line">objc[<span class="number">68285</span>]: <span class="number">5</span> releases pending. <span class="comment">//当前自动释放池中有5个对象（2个@autoreleasepool）</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802000</span>]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802038</span>]  ################  POOL <span class="number">0x102802038</span>  <span class="comment">//POOL_BOUNDARY</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802040</span>]       <span class="number">0x100707d80</span>  HTPerson          <span class="comment">//p1</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802048</span>]       <span class="number">0x100707de0</span>  HTPerson          <span class="comment">//p2</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802050</span>]  ################  POOL <span class="number">0x102802050</span>  <span class="comment">//POOL_BOUNDARY</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802058</span>]       <span class="number">0x1005065b0</span>  HTPerson          <span class="comment">//p3</span></span><br><span class="line">objc[<span class="number">68285</span>]: #############<span class="meta">#</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">objc[68285]: ############## (print5)</span></span><br><span class="line">objc[<span class="number">68285</span>]: AUTORELEASE POOLS <span class="keyword">for</span> thread <span class="number">0x1000aa5c0</span></span><br><span class="line">objc[<span class="number">68285</span>]: <span class="number">7</span> releases pending. <span class="comment">//当前自动释放池中有7个对象（3个@autoreleasepool）</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802000</span>]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802038</span>]  ################  POOL <span class="number">0x102802038</span>  <span class="comment">//POOL_BOUNDARY</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802040</span>]       <span class="number">0x100707d80</span>  HTPerson          <span class="comment">//p1</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802048</span>]       <span class="number">0x100707de0</span>  HTPerson          <span class="comment">//p2</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802050</span>]  ################  POOL <span class="number">0x102802050</span>  <span class="comment">//POOL_BOUNDARY</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802058</span>]       <span class="number">0x1005065b0</span>  HTPerson          <span class="comment">//p3</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802060</span>]  ################  POOL <span class="number">0x102802060</span>  <span class="comment">//POOL_BOUNDARY</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802068</span>]       <span class="number">0x100551880</span>  HTPerson          <span class="comment">//p4</span></span><br><span class="line">objc[<span class="number">68285</span>]: #############<span class="meta">#</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">objc[68285]: ############## (print6)</span></span><br><span class="line">objc[<span class="number">68285</span>]: AUTORELEASE POOLS <span class="keyword">for</span> thread <span class="number">0x1000aa5c0</span></span><br><span class="line">objc[<span class="number">68285</span>]: <span class="number">5</span> releases pending. <span class="comment">//当前自动释放池中有5个对象（第3个@autoreleasepool已释放）</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802000</span>]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802038</span>]  ################  POOL <span class="number">0x102802038</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802040</span>]       <span class="number">0x100707d80</span>  HTPerson</span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802048</span>]       <span class="number">0x100707de0</span>  HTPerson</span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802050</span>]  ################  POOL <span class="number">0x102802050</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802058</span>]       <span class="number">0x1005065b0</span>  HTPerson</span><br><span class="line">objc[<span class="number">68285</span>]: #############<span class="meta">#</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">objc[68285]: ############## (print7)</span></span><br><span class="line">objc[<span class="number">68285</span>]: AUTORELEASE POOLS <span class="keyword">for</span> thread <span class="number">0x1000aa5c0</span></span><br><span class="line">objc[<span class="number">68285</span>]: <span class="number">3</span> releases pending. <span class="comment">//当前自动释放池中有3个对象（第2、3个@autoreleasepool已释放）</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802000</span>]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802038</span>]  ################  POOL <span class="number">0x102802038</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802040</span>]       <span class="number">0x100707d80</span>  HTPerson</span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802048</span>]       <span class="number">0x100707de0</span>  HTPerson</span><br><span class="line">objc[<span class="number">68285</span>]: #############<span class="meta">#</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">objc[68285]: ############## (print8)</span></span><br><span class="line">objc[<span class="number">68285</span>]: AUTORELEASE POOLS <span class="keyword">for</span> thread <span class="number">0x1000aa5c0</span></span><br><span class="line">objc[<span class="number">68285</span>]: <span class="number">0</span> releases pending. <span class="comment">//当前自动释放池没有任何对象（3个@autoreleasepool都已释放）</span></span><br><span class="line">objc[<span class="number">68285</span>]: [<span class="number">0x102802000</span>]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[<span class="number">68285</span>]: ##############</span><br></pre></td></tr></table></figure><h4 id="复杂情况-autoreleasepool"><a href="#复杂情况-autoreleasepool" class="headerlink" title="复杂情况 @autoreleasepool"></a>复杂情况 @autoreleasepool</h4><p>自动释放池（即所有的AutoreleasePoolPage对象）是以栈为结点通过双向链表的形式组合而成。每当Page满了的时候，就会创建一个新的Page，并设置它为hotPage，而首个Page为coldPage。接下来我们来看一下多个Page和多个@autoreleasepool嵌套的情况。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123; <span class="comment">//r1 = push()</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">600</span>; i++) &#123;</span><br><span class="line">            HTPerson *p = [[[HTPerson alloc] init] autorelease];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123; <span class="comment">//r2 = push()</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">                HTPerson *p = [[[HTPerson alloc] init] autorelease];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">@autoreleasepool</span> &#123; <span class="comment">//r3 = push()</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">                    HTPerson *p = [[[HTPerson alloc] init] autorelease];</span><br><span class="line">                &#125;</span><br><span class="line">                _objc_autoreleasePoolPrint();</span><br><span class="line">            &#125; <span class="comment">//pop(r3)</span></span><br><span class="line">        &#125; <span class="comment">//pop(r2)</span></span><br><span class="line">    &#125; <span class="comment">//pop(r1)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个<code>AutoreleasePoolPage</code>对象的内存大小为<code>4096</code>个字节，它自身成员变量占用内存<code>56</code>个字节，所以剩下的<code>4040</code>个字节用来存储<code>autorelease</code>对象的内存地址。又因为<code>64bit</code>下一个OC对象的指针所占内存为<code>8</code>个字节，所以<code>一个Page可以存放505</code>个对象的地址。<code>POOL_BOUNDARY</code>也是一个对象，因为它的值为<code>nil</code>。所以以上代码的自动释放池内存分布图如下所示。</p><img src="/2022/01/21/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8BAutoreleasePool/poolcompose.png" class="&#x3D;"><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">objc[<span class="number">69731</span>]: #############<span class="meta">#</span></span><br><span class="line"><span class="meta">objc[69731]: AUTORELEASE POOLS for thread 0x1000aa5c0</span></span><br><span class="line">objc[<span class="number">69731</span>]: <span class="number">1303</span> releases pending. <span class="comment">//当前自动释放池中有1303个对象（3个POOL_BOUNDARY和1300个HTPerson实例）</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x100806000</span>]  ................  PAGE (full)  (cold) <span class="comment">/* 第一个PAGE，full代表已满，cold代表coldPage */</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x100806038</span>]  ################  POOL <span class="number">0x100806038</span>    <span class="comment">//POOL_BOUNDARY</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x100806040</span>]       <span class="number">0x10182a040</span>  HTPerson            <span class="comment">//p1</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x100806048</span>]       .....................            <span class="comment">//...</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x100806ff8</span>]       <span class="number">0x101824e40</span>  HTPerson            <span class="comment">//p504</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x102806000</span>]  ................  PAGE (full)         <span class="comment">/* 第二个PAGE */</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x102806038</span>]       <span class="number">0x101824e50</span>  HTPerson            <span class="comment">//p505</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x102806040</span>]       .....................            <span class="comment">//...</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x102806330</span>]       <span class="number">0x101825440</span>  HTPerson            <span class="comment">//p600</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x102806338</span>]  ################  POOL <span class="number">0x102806338</span>    <span class="comment">//POOL_BOUNDARY</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x102806340</span>]       <span class="number">0x101825450</span>  HTPerson            <span class="comment">//p601</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x102806348</span>]       .....................            <span class="comment">//...</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x1028067e0</span>]       <span class="number">0x101825d90</span>  HTPerson            <span class="comment">//p1008</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x102804000</span>]  ................  PAGE  (hot)         <span class="comment">/* 第三个PAGE，hot代表hotPage */</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x102804038</span>]       <span class="number">0x101826dd0</span>  HTPerson            <span class="comment">//p1009</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x102804040</span>]       .....................            <span class="comment">//...</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x102804310</span>]       <span class="number">0x101827380</span>  HTPerson            <span class="comment">//p1100</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x102804318</span>]  ################  POOL <span class="number">0x102804318</span>    <span class="comment">//POOL_BOUNDARY</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x102804320</span>]       <span class="number">0x101827390</span>  HTPerson            <span class="comment">//p1101</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x102804328</span>]       .....................            <span class="comment">//...</span></span><br><span class="line">objc[<span class="number">69731</span>]: [<span class="number">0x102804958</span>]       <span class="number">0x10182b160</span>  HTPerson            <span class="comment">//p1300</span></span><br><span class="line">objc[<span class="number">69731</span>]: ##############</span><br></pre></td></tr></table></figure><h3 id="iOS-工程示例分析"><a href="#iOS-工程示例分析" class="headerlink" title="iOS 工程示例分析"></a>iOS 工程示例分析</h3><p>从以上<code>macOS</code>工程示例可以得知，在<code>@autoreleasepool</code>大括号结束的时候，就会调用<code>Page</code>的<code>pop()</code>方法，给<code>@autoreleasepool</code>中的<code>autorelease</code>对象发送<code>release</code>消息, 在<code>iOS</code>工程中，方法里的<code>autorelease</code>对象是什么时候释放的呢？有<code>系统干预释放</code>和<code>手动干预释放</code>两种情况。</p><p><code>系统干预释放</code>是不指定<code>@autoreleasepool</code>，所有<code>autorelease</code>对象都<code>由主线程的RunLoop</code>创建的<code>@autoreleasepool</code>来管理。<br><code>手动干预释放</code>就是将<code>autorelease</code>对象添加进我们手动创建的<code>@autoreleasepool</code>中。</p><h4 id="系统干预释放"><a href="#系统干预释放" class="headerlink" title="系统干预释放"></a>系统干预释放</h4><ul><li>Xcode 11 版本的iOS程序中的main()函数，和旧版本的差异</li></ul> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Xcode 11</span></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// Setup code that might create autoreleased objects goes here.</span></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, appDelegateClassName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Xcode 旧版本</span></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 如果你的程序使用了<code>AppKit</code>或<code>UIKit</code>框架，那么主线程的<code>RunLoop</code>就会在每次事件循环迭代中创建并处理<code>@autoreleasepool</code>。也就是说，应用程序所有<code>autorelease</code>对象的都是由<code>RunLoop</code>创建的<code>@autoreleasepool</code>来管理。而<code>main()</code>函数中的<code>@autoreleasepool</code>只是负责管理它的作用域中的<code>autorelease</code>对象。</p><p> 在以上《使用 MacOS 工程示例分析》章节中提到了嵌套<code>@autoreleasepool</code>的情况。<code>Xcode旧版本</code>的<code>main</code>函数中是将整个应用程序运行（<code>UIApplicationMain</code>）放在<code>@autoreleasepool</code>内，而<code>主线程</code>的<code>RunLoop</code>就是在<code>UIApplicationMain</code>中创建，所以<code>RunLoop</code>创建的<code>@autoreleasepool</code>是嵌套在<code>main</code>函数的<code>@autoreleasepool</code>内的。<code>RunLoop</code>会在每次事件循环中对自动释放池进行<code>pop</code>和<code>push</code>（以下会详细讲解），但是它的<code>pop</code>只会释放掉它的<code>POOL_BOUNDARY</code>之后的对象，它并不会影响到外层即<code>main</code>函数中<code>@autoreleasepool</code>。</p><ul><li>新版本 Xcode 11 中的 main 函数发生了哪些变化？</li></ul><p><code>旧版本</code>是将整个应用程序运行放在<code>@autoreleasepool</code>内，由于<code>RunLoop</code>的存在，要<code>return</code>即程序结束后<code>@autoreleasepool</code>作用域才会结束，这意味着程序结束后<code>main</code>函数中的<code>@autoreleasepool</code>中的<code>autorelease</code>对象才会释放。</p><p>而在 <code>Xcode 11</code>中，触发主线程<code>RunLoop</code>的<code>UIApplicationMain</code>函数放在了<code>@autoreleasepool</code>外面，这可以保证<code>@autoreleasepool</code>中的a<code>utorelease</code>对象在程序启动后立即释放。正如新版本的<code>@autoreleasepool</code>中的注释所写 “<code>Setup code that might create autoreleased objects goes here.</code>”（如上代码），可以将<code>autorelease</code>对象放在此处。</p><ul><li>系统干预释放</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];    </span><br><span class="line">    HTPerson *person = [[[HTPerson alloc] init] autorelease];    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewWillAppear:(<span class="type">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewWillAppear:animated];    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidAppear:(<span class="type">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidAppear:animated];    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -[ViewController viewDidLoad]</span></span><br><span class="line"><span class="comment">// -[ViewController viewWillAppear:]</span></span><br><span class="line"><span class="comment">// -[HTPerson dealloc]</span></span><br><span class="line"><span class="comment">// -[ViewController viewDidAppear:]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，调用了autorelease方法的person对象不是在viewDidLoad方法结束后释放，而是在viewWillAppear方法结束后释放，说明在viewWillAppear方法结束的时候，调用了pop()方法释放了person对象。其实这是由RunLoop控制的，下面来讲解一下RunLoop和@autoreleasepool的关系。</p><ul><li>RunLoop 与 @autoreleasepool</li></ul><p>iOS在主线程的<code>RunLoop</code>中注册了两个<code>Observer</code>。</p><p>第1个Observer监听了<code>kCFRunLoopEntry</code>事件，会调用<code>objc_autoreleasePoolPush()</code>；<br>第2个Observer</p><p>① 监听了<code>kCFRunLoopBeforeWaiting</code>事件，会调用<code>objc_autoreleasePoolPop()</code>、<code>objc_autoreleasePoolPush()</code>；<br>② 监听了<code>kCFRunLoopBeforeExit</code>事件，会调用<code>objc_autoreleasePoolPop()</code></p><img src="/2022/01/21/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8BAutoreleasePool/runloopautoreleasepool.png" class="&#x3D;"><p>在iOS工程中系统干预释放的autorelease对象的释放时机是由RunLoop控制的，会<code>在当前RunLoop每次循环结束时释放</code>。<br>以上person对象在viewWillAppear方法结束后释放，说明viewDidLoad和viewWillAppear方法在同一次循环里。</p><p><code>kCFRunLoopEntry</code>：在即将进入RunLoop时，会自动创建一个<code>__AtAutoreleasePool</code>结构体对象，并调用<code>objc_autoreleasePoolPush()</code>函数。</p><p><code>kCFRunLoopBeforeWaiting</code>：在RunLoop即将休眠时，会自动销毁一个<code>__AtAutoreleasePool</code>对象，调用<code>objc_autoreleasePoolPop()</code>。然后创建一个新的<code>__AtAutoreleasePool</code>对象，并调用<code>objc_autoreleasePoolPush()</code>。</p><p><code>kCFRunLoopBeforeExit</code>，在即将退出<code>RunLoop</code>时，会自动销毁最后一个创建的<code>__AtAutoreleasePool</code>对象，并调用<code>objc_autoreleasePoolPop()</code>。</p><h4 id="手动干预释放"><a href="#手动干预释放" class="headerlink" title="手动干预释放"></a>手动干预释放</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];    </span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        HTPerson *person = [[[HTPerson alloc] init] autorelease];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewWillAppear:(<span class="type">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewWillAppear:animated];    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidAppear:(<span class="type">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidAppear:animated];    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -[HTPerson dealloc]</span></span><br><span class="line"><span class="comment">// -[ViewController viewDidLoad]</span></span><br><span class="line"><span class="comment">// -[ViewController viewWillAppear:]</span></span><br><span class="line"><span class="comment">// -[ViewController viewDidAppear:]</span></span><br></pre></td></tr></table></figure><p>添加进手动指定的@autoreleasepool中的autorelease对象，在@autoreleasepool大括号结束时就会释放，不受RunLoop控制</p><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><h5 id="ARC-环境下，autorelease-对象在什么时候释放？"><a href="#ARC-环境下，autorelease-对象在什么时候释放？" class="headerlink" title="ARC 环境下，autorelease 对象在什么时候释放？"></a>ARC 环境下，autorelease 对象在什么时候释放？</h5><p>分系统干预释放和手动干预释放两种情况回答。</p><h5 id="ARC-环境下，需不需要手动添加-autoreleasepool？"><a href="#ARC-环境下，需不需要手动添加-autoreleasepool？" class="headerlink" title="ARC 环境下，需不需要手动添加 @autoreleasepool？"></a>ARC 环境下，需不需要手动添加 @autoreleasepool？</h5><p>AppKit 和 UIKit 框架会在RunLoop每次事件循环迭代中创建并处理@autoreleasepool，因此，你通常不必自己创建@autoreleasepool</p><p>苹果给出了三种需要手动添加@autoreleasepool的情况：<br>① 如果你编写的程序不是基于 UI 框架的，比如说命令行工具；<br> ②如果你编写的循环中创建了大量的临时对象；<br>你可以在循环内使用@autoreleasepool在下一次迭代之前处理这些对象。在循环中使用@autoreleasepool有助于减少应用程序的最大内存占用。<br>③ 如果你创建了辅助线程。<br>一旦线程开始执行，就必须创建自己的@autoreleasepool；否则，你的应用程序将存在内存泄漏。</p><h5 id="如果对-NSAutoreleasePool-对象调用-autorelease-方法会发生什么情况？"><a href="#如果对-NSAutoreleasePool-对象调用-autorelease-方法会发生什么情况？" class="headerlink" title="如果对 NSAutoreleasePool 对象调用 autorelease 方法会发生什么情况？"></a>如果对 NSAutoreleasePool 对象调用 autorelease 方法会发生什么情况？</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">   [pool autorelease];</span><br></pre></td></tr></table></figure><p>抛出异常NSInvalidArgumentException并导致程序Crash，异常原因：不能对NSAutoreleasePool对象调用autorelease。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception &#x27;NSInvalidArgumentException&#x27;, </span><br><span class="line">reason: &#x27;*** -[NSAutoreleasePool autorelease]: Cannot autorelease an autorelease pool&#x27; </span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://juejin.cn/post/6844904094503567368">iOS - 聊聊 autorelease 和 @autoreleasepool</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> AutoreleasePool </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ReactiveObjC的高级用法</title>
      <link href="/2021/11/23/ReactiveObjC%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
      <url>/2021/11/23/ReactiveObjC%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Hook是一种用于改变API执行结果的技术，而RAC运用的是Hook思想</p></blockquote><span id="more"></span><h2 id="RAC常见操作介绍"><a href="#RAC常见操作介绍" class="headerlink" title="RAC常见操作介绍"></a>RAC常见操作介绍</h2><h3 id="RAC操作需知"><a href="#RAC操作需知" class="headerlink" title="RAC操作需知"></a>RAC操作需知</h3><p>所有的信号<code>RACSignal</code>都可以进行操作处理，因为所有操作方法都定义在<code>RACStream.h</code>中，因此只要继承<code>RACStream</code>就有了操作处理方法。</p><h3 id="RAC操作思想"><a href="#RAC操作思想" class="headerlink" title="RAC操作思想"></a>RAC操作思想</h3><p>运用的是Hook（钩子）思想，Hook是一种用于改变API执行结果的技术<br>Hook用处：截获API调用的技术<br>Hook原理：在每次调用一个API返回结果之前，先执行你自己的方法，改变结果的输出</p><h2 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h2><h3 id="核心方法bind"><a href="#核心方法bind" class="headerlink" title="核心方法bind"></a>核心方法bind</h3><p>RAC中核心开发方式是<code>绑定</code>，之前的开发方式是<code>赋值</code>，用RAC开发，应该把重心放在绑定，也就是可以创建一个对象的时候，就绑定好以后想要做的事情，而不是赋值之后再去做事情</p><p>开发中很少用到bind方法，bind属于RAC中的底层方法，RAC已经封装了很多好用的其它方法，底层都是调用bind，用法比bind简单。</p><p>bind方法简单介绍和使用</p><p>需求：监听文本框的内容，每次输出的时候，在内容后面拼上字符串“jun”,并显示在label上</p><p>方式一: 在返回结果后, 拼接字符串</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>)</span><br><span class="line">[_textField.rac_textSignal subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.showLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@+%@&quot;</span>, x, <span class="string">@&quot;jun&quot;</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>方式二: 在返回结果前, 拼接字符串, 用bind方法操作</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[_textField.rac_textSignal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line">    <span class="keyword">return</span> ^RACSignal *(<span class="type">id</span> value, <span class="type">BOOL</span> *stop)&#123;</span><br><span class="line">        <span class="keyword">return</span> [RACReturnSignal <span class="keyword">return</span>:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;输出: %@&quot;</span>, value]];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>bind 底层实现<br>源信号调用bind，会重新创建一个绑定信号<br>当绑定信号被订阅，就会调用绑定信号中的didSubscribe，生成一个bindingBlock<br>当源信号有内容发出，就会把内容传递到bindingBlock处理，调用bindingBlock（value，stop）<br>调用bindingBlock（value，stop）会返回一个内容处理完成的信号RACReturnSignal<br>订阅RACReturnSignal，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。</li></ul><h3 id="映射（flattenMap，Map）"><a href="#映射（flattenMap，Map）" class="headerlink" title="映射（flattenMap，Map）"></a>映射（flattenMap，Map）</h3><h4 id="flattenMap"><a href="#flattenMap" class="headerlink" title="flattenMap"></a>flattenMap</h4><p><code>flattenMap把源信号的内容映射成一个新的信号，信号可以是任意类型</code></p><p>eg:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>)</span><br><span class="line">[[_textField.rac_textSignal flattenMap:^__kindof RACSignal * _Nullable(<span class="built_in">NSString</span> * _Nullable value) &#123;</span><br><span class="line">    <span class="comment">//源信号发出的时候，就会调用这个block。</span></span><br><span class="line">    <span class="comment">// 返回值：绑定信号的内容.</span></span><br><span class="line">    <span class="keyword">return</span> [RACReturnSignal <span class="keyword">return</span>:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;flat输出: %@&quot;</span>, value]];</span><br><span class="line">&#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>)</span><br><span class="line">    <span class="comment">//订阅绑定信号, 每当原信号发送内容, 处理后, 就会调用这个black</span></span><br><span class="line">    <span class="keyword">self</span>.showLabel.text = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>Map作用:把源信号的值映射成一个新的值</code><br>eg:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map</span></span><br><span class="line">   [[_textField.rac_textSignal map:^<span class="type">id</span> _Nullable(<span class="built_in">NSString</span> * _Nullable value) &#123;</span><br><span class="line">       <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;map输出: %@&quot;</span>, value];</span><br><span class="line">   &#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">       @strongify(<span class="keyword">self</span>)</span><br><span class="line">       <span class="keyword">self</span>.showLabel.text = x;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//对数组的处理</span></span><br><span class="line">   <span class="built_in">NSArray</span> *arr = @[<span class="string">@&quot;2&quot;</span>, <span class="string">@&quot;3&quot;</span>, <span class="string">@&quot;a&quot;</span>, <span class="string">@&quot;g&quot;</span>];</span><br><span class="line">   RACSequence *sequence = [arr.rac_sequence map:^<span class="type">id</span> _Nullable(<span class="type">id</span>  _Nullable value) &#123;</span><br><span class="line">       <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;-%@-&quot;</span>, value];</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [sequence array]);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*输出: </span></span><br><span class="line"><span class="comment">   2018-03-24 14:13:32.421337+0800 ReactiveObjc[9043:492929] (</span></span><br><span class="line"><span class="comment">       &quot;-2-&quot;,</span></span><br><span class="line"><span class="comment">       &quot;-3-&quot;,</span></span><br><span class="line"><span class="comment">       &quot;-a-&quot;,</span></span><br><span class="line"><span class="comment">       &quot;-g-&quot;</span></span><br><span class="line"><span class="comment">   )</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p><code>按照某一固定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号</code><br>eg</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setConcatAction &#123;</span><br><span class="line">    <span class="comment">//当需要按顺序执行的时候: 先执行A, 在执行B</span></span><br><span class="line">    RACSubject *subC = [RACSubject subject];</span><br><span class="line">    RACSubject *subD = [RACReplaySubject subject];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array2 = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订阅信号</span></span><br><span class="line">    [[subC concat:subD] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        [array2 addObject:x];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送信号</span></span><br><span class="line">    [subD sendNext:<span class="string">@&quot;D&quot;</span>];</span><br><span class="line">    [subC sendNext:<span class="string">@&quot;C&quot;</span>];</span><br><span class="line">    [subC sendCompleted];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出: [C, D]</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, array2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p><code>用于连接两个信号，当第一个信号完成，才会连接then返回的信号</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setThenAction &#123;</span><br><span class="line">    RACSubject *subjectA = [RACReplaySubject subject];</span><br><span class="line">    RACSubject *subjectB = [RACReplaySubject subject];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送信号</span></span><br><span class="line">    [subjectA sendNext:<span class="string">@&quot;A&quot;</span>];</span><br><span class="line">    [subjectA sendCompleted];</span><br><span class="line">    [subjectB sendNext:<span class="string">@&quot;B&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订阅信号</span></span><br><span class="line">    [[subjectA then:^RACSignal * _Nonnull&#123;</span><br><span class="line">        <span class="keyword">return</span> subjectB;</span><br><span class="line">    &#125;] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里只会输出: B</span></span><br><span class="line">    <span class="comment">//不会输出: A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p><code>把多个信号合并为一个信号，任何一个信号有新值的时候就会调用</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setMergeAction &#123;</span><br><span class="line">    <span class="comment">// 只要想无序的整合信号数据</span></span><br><span class="line">    RACSubject *subjectA = [RACSubject subject];</span><br><span class="line">    RACSubject *subjectB = [RACSubject subject];</span><br><span class="line">    RACSubject *subjectC = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并信号</span></span><br><span class="line">    RACSignal *single = [[subjectA merge:subjectB] merge:subjectC];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订阅信号</span></span><br><span class="line">    [single subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发出消息</span></span><br><span class="line">    [subjectA sendNext:<span class="string">@&quot;A&quot;</span>];</span><br><span class="line">    [subjectC sendNext:<span class="string">@&quot;C&quot;</span>];</span><br><span class="line">    [subjectB sendNext:<span class="string">@&quot;B&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果(分别输出): A, C, B</span></span><br></pre></td></tr></table></figure><h4 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h4><p><code>把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setZipwithAction &#123;</span><br><span class="line">    <span class="comment">// 只要想无序的整合信号数据</span></span><br><span class="line">    RACSubject *subjectA = [RACSubject subject];</span><br><span class="line">    RACSubject *subjectB = [RACSubject subject];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//合并信号</span></span><br><span class="line">    RACSignal *single = [subjectA zipWith:subjectB];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订阅信号</span></span><br><span class="line">    [single subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发出消息</span></span><br><span class="line">    [subjectA sendNext:<span class="string">@&quot;A&quot;</span>];</span><br><span class="line">    [subjectB sendNext:<span class="string">@&quot;B&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 输出:</span></span><br><span class="line"><span class="comment">     (A, B)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h4><p><code>将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的信号至少都有过一次sendNext，才会触发合并的信号</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setCombineLatest &#123;</span><br><span class="line">    <span class="comment">//把两个信号组合成一个信号,跟zip一样，没什么区别</span></span><br><span class="line">    RACSignal *single = [_accountText.rac_textSignal combineLatestWith:_passwordText.rac_textSignal];</span><br><span class="line">    </span><br><span class="line">    [single subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        RACTupleUnpack(<span class="built_in">NSString</span> *account, <span class="built_in">NSString</span> *password) = x;</span><br><span class="line">        </span><br><span class="line">        _loginButton.enabled = account.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>聚合:<code>用于信号发出是元组的内容，把信号发出元组的值聚合成一个值</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setReduceAction &#123;</span><br><span class="line">    <span class="comment">// reduce:把多个信号的值,聚合为一个值</span></span><br><span class="line">    RACSignal *single = [RACSignal combineLatest:@[_accountText.rac_textSignal, _passwordText.rac_textSignal] reduce:^<span class="type">id</span> (<span class="built_in">NSString</span> *account, <span class="built_in">NSString</span> *password)&#123;</span><br><span class="line">        <span class="keyword">return</span> @(account.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [single subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        _loginButton.enabled = [x boolValue];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用一个宏, 急需将上面的代码简化一下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setReduceAction &#123;</span><br><span class="line">    RAC(_loginButton, enabled) = [RACSignal combineLatest:@[_accountText.rac_textSignal, _passwordText.rac_textSignal] reduce:^<span class="type">id</span> (<span class="built_in">NSString</span> *account, <span class="built_in">NSString</span> *password)&#123;</span><br><span class="line">        <span class="keyword">return</span> @(account.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p><code>过滤信号, 过滤掉不符合条件的信号</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>) filterAction&#123;</span><br><span class="line">    <span class="comment">//filter</span></span><br><span class="line">    <span class="comment">//截取等于11位的字符</span></span><br><span class="line">    [[_accountText.rac_textSignal filter:^<span class="type">BOOL</span>(<span class="built_in">NSString</span> * _Nullable value) &#123;</span><br><span class="line">        <span class="comment">//类似手机号的输入, 只有等于11位的时候才返回true</span></span><br><span class="line">        <span class="keyword">return</span> value.length == <span class="number">11</span>;</span><br><span class="line">    &#125;]subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">        <span class="comment">//这里只会返回等于11位的字符</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;filter = %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ignore"><a href="#ignore" class="headerlink" title="ignore"></a>ignore</h4><p><code>忽略掉某些特定值的信号</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setIgnoreAction &#123;</span><br><span class="line">    <span class="comment">///ignore</span></span><br><span class="line">    <span class="comment">//这里的测试只有第一个字符位: m的时候能看到效果</span></span><br><span class="line">    [[_accountText.rac_textSignal ignore:<span class="string">@&quot;m&quot;</span>] subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;ignore = %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ignoreValues: 忽略所有信号</span></span><br><span class="line">    [[_passwordText.rac_textSignal ignoreValues] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;allIgnore = %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged"></a>distinctUntilChanged</h4><p><code>当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。在开发中，刷新UI经常使用，只有两次数据不一样才需要刷新</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//distinctUntilChanged</span></span><br><span class="line">- (<span class="type">void</span>)setdistinctUntilChanged &#123;</span><br><span class="line">    <span class="comment">//创建信号</span></span><br><span class="line">    RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订阅</span></span><br><span class="line">    [[subject distinctUntilChanged] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;distinctUntilChanged = %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [subject sendNext:@<span class="number">12</span>];</span><br><span class="line">    [subject sendNext:@<span class="number">12</span>];</span><br><span class="line">    [subject sendNext:@<span class="number">23</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*输出结果:只会输出两次</span></span><br><span class="line"><span class="comment">     distinctUntilChanged = 12</span></span><br><span class="line"><span class="comment">     distinctUntilChanged = 23</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="take"><a href="#take" class="headerlink" title="take"></a>take</h4><p><code>从开始一共取N次的信号, 当遇到sendCompleted语句执行时, 会提前停止发送信号</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setTakeAndTakeLast &#123;</span><br><span class="line">    <span class="comment">//take</span></span><br><span class="line">    RACSubject *subject1 = [RACSubject subject];</span><br><span class="line">    [[subject1 take:<span class="number">2</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [subject1 sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subject1 sendNext:@<span class="number">2</span>];</span><br><span class="line">    [subject1 sendCompleted];</span><br><span class="line">    [subject1 sendNext:@<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分别输出: 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果上面发送信号的代码调整为</span></span><br><span class="line">    [subject1 sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subject1 sendCompleted];</span><br><span class="line">    [subject1 sendNext:@<span class="number">2</span>];</span><br><span class="line">    [subject1 sendNext:@<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//那么输出结果将会,只输出: 1</span></span><br></pre></td></tr></table></figure><h4 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h4><p><code>取调用sendCompleted之前的N次信号,前提条件，订阅者必须调用sendCompleted，否则不会执行任何操作</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setTakeAndTakeLast &#123;</span><br><span class="line">    <span class="comment">//takeLast</span></span><br><span class="line">    RACSubject *subject1 = [RACSubject subject];</span><br><span class="line">    [[subject1 takeLast:<span class="number">2</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [subject1 sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subject1 sendNext:@<span class="number">2</span>];</span><br><span class="line">    [subject1 sendNext:@<span class="number">3</span>];</span><br><span class="line">    [subject1 sendCompleted];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="takeUntil"><a href="#takeUntil" class="headerlink" title="takeUntil"></a>takeUntil</h4><p>只要传入的信号发送完成或者subject2开始发送信号的时候,就不会再接收信号的内容</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setTakeAndTakeLast &#123;</span><br><span class="line">    <span class="comment">//takeUntil</span></span><br><span class="line">    RACSubject *subject1 = [RACSubject subject];</span><br><span class="line">    RACSubject *subject2 = [RACSubject subject];</span><br><span class="line">    </span><br><span class="line">    [[subject1 takeUntil:subject2] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [subject1 sendNext:@<span class="number">11</span>];</span><br><span class="line">    [subject1 sendNext:@<span class="number">12</span>];</span><br><span class="line"><span class="comment">//    [subject1 sendCompleted];</span></span><br><span class="line">    [subject1 sendNext:@<span class="number">13</span>];</span><br><span class="line">    [subject2 sendNext:<span class="string">@&quot;21&quot;</span>];</span><br><span class="line">    [subject2 sendNext:<span class="string">@&quot;22&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这样会输出: 11, 12, 13</span></span><br><span class="line">    <span class="comment">//当sendCompleted取消注释的时候, 只会输出: 11, 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switchToLatest"><a href="#switchToLatest" class="headerlink" title="switchToLatest"></a>switchToLatest</h4><p><code>主要用于信号的信号, 有时候也会发出信号, 会在信号的信号中获取其发送的最新的信号</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setswitchToLatest &#123;</span><br><span class="line">    <span class="comment">//信号的信号</span></span><br><span class="line">    RACSubject *subject1 = [RACSubject subject];</span><br><span class="line">    RACSubject *subject2 = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取信号中信号最近发出信号，订阅最近发出的信号</span></span><br><span class="line">    [[subject1 switchToLatest] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送信号</span></span><br><span class="line">    [subject1 sendNext:subject2];</span><br><span class="line">    [subject2 sendNext:<span class="string">@&quot;信号中信号&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最终结果输出: &quot;信号中信号&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>跳过N个信号后, 再开始订阅信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setSkipAction &#123;</span><br><span class="line">    <span class="comment">//创建信号</span></span><br><span class="line">    RACSubject *subject = [RACSubject subject];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订阅信号</span></span><br><span class="line">    <span class="comment">//要求跳过2个信号</span></span><br><span class="line">    [[subject skip:<span class="number">2</span>] subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送信号</span></span><br><span class="line">    [subject sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subject sendNext:@<span class="number">2</span>];</span><br><span class="line">    [subject sendNext:@<span class="number">3</span>];</span><br><span class="line">    [subject sendNext:@<span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为上面跳过了两个信号, 所以这里只会输出: 3, 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="https://juejin.cn/post/6844903585679949831">ReactiveCocoa 的一些高级用法</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> RAC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS Memory 内存详解</title>
      <link href="/2021/11/22/iOS%20Memory%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/11/22/iOS%20Memory%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>iOS是基于BSD发展而来，本文将涉及一般桌面系统的内存机制，然后着重讲解iOS系统层面，单个App的内存管理策略</p><span id="more"></span><h1 id="操作系统的内存机制"><a href="#操作系统的内存机制" class="headerlink" title="操作系统的内存机制"></a>操作系统的内存机制</h1><h2 id="冯诺伊曼结构问题"><a href="#冯诺伊曼结构问题" class="headerlink" title="冯诺伊曼结构问题"></a>冯诺伊曼结构问题</h2><p>冯诺伊曼瓶颈-在目前的科技水平之下，CPU与存储器之间的读写速度远远小于CPU的工作效率。现行的解决方式就是采用多级存储，来平衡存储器的读写速率、容量、价格。</p><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p>存储器主要分为两类：易失性存储器速度更快，断电之后数据会丢失；<br>非易失性存储器容量更大，价格更低，断电不会丢失数据</p><img src="/2021/11/22/iOS%20Memory%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/01.jpeg" class=""><p>平时常说的内存，实际上就是指的L4主存。而L1-L3高速缓存都已经集成在CPU芯片内部。其中L0寄存器本身就是CPU的组成部分之一，读写速度最快，操作耗费0个时钟周期。</p><p>为什么采用缓存就能够提高效率呢？<br>因为存在局部性原理，被使用过的存储器内容在未来可能会被多次使用，以及它附近的内容大概率被使用</p><h2 id="CPU寻址方式"><a href="#CPU寻址方式" class="headerlink" title="CPU寻址方式"></a>CPU寻址方式</h2><h3 id="物理寻址"><a href="#物理寻址" class="headerlink" title="物理寻址"></a>物理寻址</h3><p>内存可以被看作一个数组，数组元素是一个字节大小的空间，而数组索引则是所谓的物理地址。最简单最直接的方式，就是CPU直接通过物理地址去访问对应的内存，这样也被叫做物理寻址。</p><p>物理寻址后来也扩展支持了分段机制，通过在CPU中增加段寄存器，将物理地址变成“段地址”：“段内偏移量”的形式，增加了物理寻址的寻址范围。</p><p>地址空间缺乏保护？<br>因为直接暴露物理地址，进程可以访问到任何物理地址，用户进程想干嘛就干嘛，这是非常危险的。</p><h3 id="虚拟寻址"><a href="#虚拟寻址" class="headerlink" title="虚拟寻址"></a>虚拟寻址</h3><p>现代处理器使用的是虚拟寻址的方式，CPU通过访问虚拟地址，经过翻译获取物理地址，才能访问内存，这个翻译过程由CPU中的内存管理单元MMU完成。</p><p>具体流程如下图：</p><img src="/2021/11/22/iOS%20Memory%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/02.png" class=""><p>首先会在 TLB（Translation Lookaside Buffer）中进行查询，它表位于 CPU 内部，查询速度最快；如果没有命中，那么接下来会在页表（Page Table）中进行查询，页表位于物理内存中，所以查询速度较慢；最后如果发现目标页并不在物理内存中，称为缺页，此时会去磁盘中找。当然，如果页表中还找不到，那就是出错了。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>如何解决直接使用物理地址，会有地址空间缺乏保护的问题？</p><p>在使用虚拟寻址之后，由于每次都会进行一个翻译过程，所以可以在翻译中增加一些额外的权限判定，对地址空间进行保护。所以，对每个进程来说，操作系统可以为其提供一个独立的、私有的、连续的地址空间，这就是所谓的虚拟内存。</p><blockquote><p>虚拟内存最大的意义就是保护了进程的地址空间，使得进程之间不能够越权进行互相地干扰。</p></blockquote><img src="/2021/11/22/iOS%20Memory%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/03.png" class=""><p>对于进程来说，它的可见部分只有分配给它的虚拟内存，而<code>虚拟内存实际上可能映射到物理内存以及磁盘的任何区域</code>。由于硬盘读写速度并不如内存快，所以操作系统会优先使用物理内存空间，但是<code>当物理内存空间不够时，就会将部分内存数据交换到硬盘上去存储，这就是所谓的 Swap 内存交换机制</code>。有了内存交换机制以后，相比起物理寻址，虚拟内存实际上利用硬盘空间拓展了内存空间。</p><p>虚拟内存有下面几个意义：保护了每个进程的地址空间、简化了内存管理、利用硬盘空间拓展了内存空间。</p><h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>虚拟内存和物理内存建立了映射的关系。为了方便映射和管理，虚拟内存和物理内存都被分割成相同大小的单位，<code>物理内存的最小单位被称为帧</code>（Frame），而<code>虚拟内存的最小单位被称为页</code>（Page）。</p><p>页和帧大小相同，有着类似函数的映射关系，前文提到的借助 TLB、页表进行的翻译过程，实际上和函数的映射非常类似。</p><p><code>内存分页最大的意义在于，支持了物理内存的离散使用</code>。由于存在映射过程，所以虚拟内存对应的物理内存可以任意存放，这样就方便了操作系统对物理内存的管理，也能够可以最大化利用物理内存。同时，也可以<code>采用一些页面调度（Paging）算法，利用翻译过程中也存在的局部性原理，将大概率被使用的帧地址加入到 TLB 或者页表之中，提高翻译的效率</code>。</p><h1 id="iOS的内存机制"><a href="#iOS的内存机制" class="headerlink" title="iOS的内存机制"></a>iOS的内存机制</h1><h2 id="iOS使用了虚拟内存机制"><a href="#iOS使用了虚拟内存机制" class="headerlink" title="iOS使用了虚拟内存机制"></a>iOS使用了虚拟内存机制</h2><h2 id="内存有限，但单应用可用内存大"><a href="#内存有限，但单应用可用内存大" class="headerlink" title="内存有限，但单应用可用内存大"></a>内存有限，但单应用可用内存大</h2><blockquote><p>iOS系统给每个进程分配的虚拟内存空间非常大，据官方文档的说法，iOS为每个32位的进程都会提供高达4G的可寻址空间。</p></blockquote><h2 id="没有内存交换机制"><a href="#没有内存交换机制" class="headerlink" title="没有内存交换机制"></a>没有内存交换机制</h2><blockquote><p>iOS不支持内存交换机制，大多数移动设备都不支持内存交换机制。移动设备上的大容量存储器通常都是闪存（flash），它的读写速度远远小于电脑所使用的硬盘，这就导致了在移动设备就算使用内存交换机制，也并不能提升性能。其次，移动设备的容量本身就经常短缺、闪存的读写寿命也是有限的，所以这种情况下还拿闪存来做内存交换，就有点太过奢侈了。</p></blockquote><h2 id="内存警告"><a href="#内存警告" class="headerlink" title="内存警告"></a>内存警告</h2><p>当内存不够用时，iOS 的处理是会发出内存警告，告知进程去清理自己的内存。代码中的 <code>didReceiveMemoryWarning() </code>方法就是在内存警告发生时被触发，app 应该去清理一些不必要的内存，来释放一定的空间。</p><h2 id="OOM-崩溃"><a href="#OOM-崩溃" class="headerlink" title="OOM 崩溃"></a>OOM 崩溃</h2><p>如果 app 在发生了内存警告，并进行了清理之后，物理内存还是不够用了，那么就会发生 OOM 崩溃，也就是 <code>Out of Memory Crash</code></p><p>以 iPhone XS Max 为例，总共的可用内存是 3735 MB（比硬件大小小一些，因为系统本身也会消耗一部分内存），而单个 app 可用内存达到 2039 MB，达到了<code> 55%</code>。当 app 使用的内存超过这个临界值，就会发生 OOM 崩溃。可以看出，单个 app 的可用物理内存实际上还是很大的，要发生 OOM 崩溃，绝大多数情况下都是程序本身出了问题。</p><h2 id="iOS系统内存占用"><a href="#iOS系统内存占用" class="headerlink" title="iOS系统内存占用"></a>iOS系统内存占用</h2><p>合理控制 app 使用的内存是非常重要的一件事。那么具体来说，我们需要减少的是哪些部分呢？实际上这就是所谓的 iOS 内存占用（Memory Footprint）的部分。</p><p>内存页也有分类，一般来说分为 <code>clean memory</code> 和 <code>dirty memory</code> 两种，iOS 中也有 <code>compressed memory</code> 的概念。</p><h3 id="Clean-memory-amp-dirty-memory"><a href="#Clean-memory-amp-dirty-memory" class="headerlink" title="Clean memory &amp; dirty memory"></a>Clean memory &amp; dirty memory</h3><p><code>对于一般的桌面操作系统，clean memory 可以认为是能够进行 Page Out 的部分</code>。Page Out 指的是将优先级低的内存数据交换到磁盘上的操作，但 iOS 并没有内存交换机制，所以对 iOS 这样的定义是不严谨的。那么<code>对于 iOS 来说，clean memory 指的是能被重新创建的内存</code>，它主要包含下面几类：</p><ol><li>app 的二进制可执行文件</li><li>framework 中的 _DATA_CONST 段</li><li>文件映射的内存</li><li>未写入数据的内存</li></ol><p>内存映射的文件指的是当 app 访问一个文件时，系统会将文件映射加载到内存中，如果文件只读，那么这部分内存就属于 clean memory。另外需要注意的是，链接的 framework 中 _DATA_CONST 并不绝对属于 clean memory，当 app 使用到 framework 时，就会变成 dirty memory。<br>未写入数据的内存也属于 clean memory</p><p>所有不属于 clean memory 的内存都是 <code>dirty memory。这部分内存并不能被系统重新创建，所以 dirty memory 会始终占据物理内存，直到物理内存不够用之后，系统便会开始清理</code>。</p><h3 id="Compressed-memory"><a href="#Compressed-memory" class="headerlink" title="Compressed memory"></a>Compressed memory</h3><p>当物理内存不够用时，iOS 会将部分物理内存压缩，在需要读写时再解压，以达到节约内存的目的。而压缩之后的内存，就是所谓的 compressed memory。</p><blockquote><p>很多桌面操作系统早已经应用了内存压缩技术，比如 Windows 中的 memory combining 技术。这本质上来说和内存交换机制类似，都是是一种用 CPU 时间换内存空间的方式，只不过内存压缩技术消耗的时间更少，但占用 CPU 更高。不过在文章最开始，我们就已经谈到由于 CPU 算力过剩，在大多数场景下，物理内存的空间相比起 CPU 算力来说显然更为重要，所以内存压缩技术非常有用。</p></blockquote><p>使用 compressed memory 能在内存紧张时，将目标内存压缩至原有的一半以下，同时压缩和解压消耗的时间都非常小。对于 OS X，compressed memory 也能和内存交换技术共用，提高内存交换的效率，毕竟压缩后再进行交换效率明显更高，只是 iOS 没有内存交换，也就不存在这方面的好处了。<br>本质上来讲，compressed memory 也属于 dirty memory。</p><h3 id="内存占用组成"><a href="#内存占用组成" class="headerlink" title="内存占用组成"></a>内存占用组成</h3><p>对于 app 来说，我们主要关心的内存是 dirty memory，当然其中也包含 compressed memory。</p><img src="/2021/11/22/iOS%20Memory%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/05.png" class=""><p>按照正常的思路，app 监听到内存警告时应该主动清理释放掉一些优先级低的内存，这本质上是没错的。不过由于 compressed memory 的特殊性，所以导致内存占用的实际大小考虑起来会有些复杂。</p><img src="/2021/11/22/iOS%20Memory%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/06.png" class=""><p>比如上面这种情况，当我们收到内存警告时，我们尝试将 Dictionary 中的部分内容释放掉，但由于之前的 Dictionary 由于未使用，所以正处于被压缩状态；而解压、释放部分内容之后，Dictionary 处于未压缩状态，可能并没有减少物理内存，甚至可能反而让物理内存更大了。<br>所以，<code>进行缓存更推荐使用 NSCache 而不是 NSDictionary，就是因为 NSCache 不仅线程安全，而且对存在 compressed memory 情况下的内存警告也做了优化，可以由系统自动释放内存</code>。</p><h2 id="iOS内存管理"><a href="#iOS内存管理" class="headerlink" title="iOS内存管理"></a>iOS内存管理</h2><p>一个iOS App对应的进程地址空间大概如下图所示：</p><img src="/2021/11/22/iOS%20Memory%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/07.png" class=""><p>代码段（text） 通常用于存放程序执行代码（CPU执行的机器指令）<br>数据段（Data） 存放<code>程序中已初始化且初始值不为0的全局变量和静态局部变量</code>。数据段属于静态内存分配（静态存储区），可读可写。<br>BSS段： </p><ol><li>未初始化的全局变量和静态局部变量</li><li>初始值为0的全局变量和静态局部变量(依赖于编译器实现)</li><li>未定义且初值不为0的符号(该初值即common block的大小)</li></ol><p>堆（heap）<br>堆用于存放进程运行时动态分配的内存段，可动态扩张或缩减。</p><p>内存映射段（mmap）</p><p>内核将硬盘文件的内容直接映射到内存, 任何应用程序都可通过Linux的mmap()系统调用请求这种映射。内存映射是一种方便高效的文件I&#x2F;O方式，。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read()&#x2F;write()等操作。 因而被用于<code>装载动态共享库</code>。用户也可创建匿名内存映射，该映射没有对应的文件, 可用于存放程序数据</p><p>mmap&#x2F;munmap是常用的一个系统调用，使用场景是：分配内存、读写大文件、连接动态库文件、多进程间共享内存。</p><p>malloc申请内存的大小超过128K就会使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)</p><p>栈（stack）<br>由编译器自动分配释放<br>Linux中ulimit -s命令可查看和设置堆栈最大值，当程序使用的堆栈超过该值时, 发生栈溢出(Stack Overflow)，程序收到一个段错误(Segmentation Fault)。</p><blockquote><p>每个区域实际上都存储相应的内容，其中<code>代码区、常量区、静态区</code>这三个区域都是自动加载，并且在进程结束之后被系统释放，开发者并不需要进行关注。</p></blockquote><blockquote><p>栈区一般存放局部变量、临时变量，由编译器自动分配和释放，<code>每个线程运行时都对应一个栈</code>。而堆区用于动态内存的申请，由程序员分配和释放。一般来说，栈区由于被系统自动管理，速度更快，但是使用起来并不如堆区灵活。</p></blockquote><h3 id="OOM崩溃"><a href="#OOM崩溃" class="headerlink" title="OOM崩溃"></a>OOM崩溃</h3><h4 id="Jstsam机制"><a href="#Jstsam机制" class="headerlink" title="Jstsam机制"></a>Jstsam机制</h4><p>iOS 是一个从 BSD 衍生而来的系统，其内核是 Mach。其中内存警告，以及 OOM 崩溃的处理机制就是 Jetsam 机制，也被称为 Memorystatus。Jetsam 会始终监控内存整体使用情况，当内存不足时会根据优先级、内存占用大小杀掉一些进程，并记录成 JetsamEvent</p><h4 id="如何检测-OOM"><a href="#如何检测-OOM" class="headerlink" title="如何检测 OOM"></a>如何检测 OOM</h4><p>OOM 分为两大类，Foreground OOM &#x2F; Background OOM，简写为 FOOM 以及 BOOM。而其中 FOOM 是指 app 在前台时由于消耗内存过大，而被系统杀死，直接表现为 crash</p><p>Facebook 开源的 FBAllocationTracker</p><p>腾讯开源的 OOMDetector</p><h3 id="OOM-常见原因"><a href="#OOM-常见原因" class="headerlink" title="OOM 常见原因"></a>OOM 常见原因</h3><p> 内存泄漏</p><p><code>UIWebview</code> 缺陷</p><blockquote><p>无论是打开网页，还是执行一段简单的 js 代码，<code>UIWebView</code> 都会占用大量内存，同时旧版本的 css 动画也会导致大量问题，所以最好使用 <code>WKWebView</code></p></blockquote><p>大图片、大视图<br>缩放、绘制分辨率高的大图片，播放 gif 图，以及渲染本身 size 过大的视图（例如超长的 TextView）等，都会占用大量内存，轻则造成卡顿，重则可能在解析、渲染的过程中发生 OOM</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.cn/post/6844903902169710600">iOS Memory 内存详解</a><br><a href="https://www.cnblogs.com/yizhanwillsucceed/p/13578076.html">linux进程地址空间划分</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 内存管理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS Rendering 渲染解析</title>
      <link href="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/"/>
      <url>/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机渲染原理"><a href="#计算机渲染原理" class="headerlink" title="计算机渲染原理"></a>计算机渲染原理</h2><h3 id="CPU与GPU的架构"><a href="#CPU与GPU的架构" class="headerlink" title="CPU与GPU的架构"></a>CPU与GPU的架构</h3><h4 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h4><blockquote><p>CPU 是运算核心与控制核心，需要有很强的运算通用性，兼容各种数据类型，同时也需要能处理大量不同的跳转、中断等指令，因此 CPU 的内部结构更为复杂。</p></blockquote><blockquote><p>而 GPU 则面对的是类型统一、更加单纯的运算，也不需要处理复杂的指令，但也肩负着更大的运算任务。</p></blockquote><span id="more"></span><p>英伟达的CUDA文档里给了这样一幅图：</p><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/01.png" class=""><blockquote><p>ALU就是“算术逻辑单元</p></blockquote><p>从上图中也可以看出</p><ol><li>CPU和GPU进行计算的部分都是ALU，GPU绝大部分的芯片面积都是ALU，而且是超大阵列排布的ALU。这些ALU都是可以并行运行的，所以浮点计算速度就特别高了。</li><li>CPU 拥有更多的缓存空间 Cache 以及复杂的控制单元，计算能力并不是 CPU 的主要诉求。</li><li>CPU大多数面积都需要给控制单元和Cache，因为CPU要承担整个计算机的控制工作，没有GPU那么单纯。</li></ol><p><code>GPU的程序控制能力相比CPU来说不强</code></p><p>GPU的强项是并行运算能力比CPU强（多个不同任务的并行运算GPU也无法胜任 <code>GPU只适合处理单个可并行任务的并行运算</code>） 而不是浮点运算能力强（这个谣言也不知道谁传出来的 非要强调浮点运算 非要说浮点运算的话 不如说大多数老式GPU甚至没有整数运算能力 因为根本没有整数指令 最早设计目的是加速图形渲染 基本都是浮点运算 所以GPU核心的SIMD指令 只有浮点指令 没有整数指令 新型GPU因为不光光用于图形渲染 还想推广到通用计算 就是所谓的GPGPU 所以开始加入整数运算的支持）</p><p><code>CPU每个核心有独立的缓存</code><br><code>GPU基本是所有核心共享一个缓存</code>(GPU主要做图形渲染 所有核心都执行同一份指令 获取同样的数据 CPU主要是执行多个串行任务 每个核心可以处理不同的任务 从不同地方获取不同的数据)</p><p>CPU 是设计目标是低时延，更多的高速缓存也意味着可以更快地访问数据；同时复杂的控制单元也能更快速地处理逻辑分支，更适合串行计算。</p><p>而 GPU 拥有更多的计算单元 Arithmetic Logic Unit，具有更强的计算能力，同时也具有更多的控制单元。GPU 基于大吞吐量而设计，每一部分缓存都连接着一个流处理器（stream processor），更加适合大规模的并行计算。</p><h3 id="图像渲染流水线"><a href="#图像渲染流水线" class="headerlink" title="图像渲染流水线"></a>图像渲染流水线</h3><p>图像渲染流程粗粒度大概分为下面这些步骤</p><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/02.jpeg" class=""><p>上述图像渲染流水线中，除了第一部分 Application 阶段，后续主要都由 GPU 负责<br>Application 应用处理阶段：得到图元<br>Geometry 几何处理阶段：处理图元<br>Rasterization 光栅化阶段：图元转换为像素<br>Pixel 像素处理阶段：处理像素，得到位图</p><h2 id="屏幕成像与卡顿"><a href="#屏幕成像与卡顿" class="headerlink" title="屏幕成像与卡顿"></a>屏幕成像与卡顿</h2><p>GPU最后一步渲染结束之后像素信息，被存在帧缓冲器（Framebuffer）中，之后视频控制器（video controller）会读取帧缓冲器中的信息，经过数模转换传递给显示器（Monitor），进行显示。流程如下图：</p><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/03.png" class=""><p>经过GPU处理之后的像素集合，也就是位图，会被帧缓冲器缓存起来，供之后的显示使用。显示器的电子束会从屏幕的左上角开始逐行扫描，屏幕上的每个点的图像信息都从帧缓冲器中的位图进行读取，在屏幕上对应地显示。扫描的流程如下图：</p><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/04.png" class=""><p>电子束扫描的过程中，屏幕就能呈现出对应的结果，每次整个屏幕被扫描完一次后，就相当于呈现了一幅完整的图像。屏幕不断地刷新，不停呈现新的帧，就能呈现出连续的影像。而这个屏幕刷新的频率，就是<code>帧率</code>（Frame per Second，FPS）。</p><h3 id="屏幕撕裂"><a href="#屏幕撕裂" class="headerlink" title="屏幕撕裂"></a>屏幕撕裂</h3><p>在单一缓存模式下，理想的情况就是一个流畅的流水线：<code>每次电子束从头开始新的一帧的扫描时，CPU+GPU 对于该帧的渲染流程已经结束，渲染好的位图已经放入帧缓冲器中</code>。这种完美的情况是非常脆弱的，很容易产生屏幕撕裂。</p><blockquote><p>在电子束开始扫描新的一帧时，位图还没有渲染好，而是在扫描到屏幕中间时才渲染完成，被放入帧缓冲器中 —- 那么已扫描的部分就是上一帧的画面，而未扫描的部分则会显示新的一帧图像，这就造成屏幕撕裂</p></blockquote><h3 id="垂直同步Vsync-双缓冲机制"><a href="#垂直同步Vsync-双缓冲机制" class="headerlink" title="垂直同步Vsync + 双缓冲机制"></a>垂直同步Vsync + 双缓冲机制</h3><p><code>解决屏幕撕裂、提高显示效率的一个策略就是使用垂直同步信号 Vsync 与双缓冲机制</code> Double Buffering</p><p>垂直同步信号（vertical synchronisation，Vsync）相当于<code>给帧缓冲器加锁</code>：当电子束完成一帧的扫描，将要从头开始扫描时，就会发出一个垂直同步信号。只有当视频控制器接收到 Vsync 之后，才会将帧缓冲器中的位图更新为下一帧，这样就能保证每次显示的都是同一帧的画面，因而避免了屏幕撕裂。</p><p>但是在这种情况下，视频控制器在接受到Vsync之后，就要将下一帧的位图传入，这意味着整个CPU+GPU的渲染流程都要在一瞬间完成，这是明显不现实的。所以双缓冲机制会增加一个备用缓冲器（back buffer）。渲染结果将会预先保存在back buffer中，在接收到Vsync信号的时候，视频控制器会将back buffer中的内容置换到frame buffer中，此时就能保证置换操作几乎在一瞬间完成（实际上是交换了内存地址）。</p><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/05.png" class=""><h3 id="掉帧"><a href="#掉帧" class="headerlink" title="掉帧"></a>掉帧</h3><p><code>启用Vsync信号以及双缓存机制之后，能够解决屏幕撕裂的问题，但是会引入新的问题：掉帧</code> 如果在接收到Vsync之时CPU和GPU还没有渲染好新的位图，视频控制器就不会去替换frame buffer中的位图。这是屏幕就会重新扫描呈现出上一帧一摸一样的画面。相当于两个周期显示了同样的画面，这就是所谓掉帧的情况。</p><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/06.png" class=""><h3 id="三缓冲-Triple-Buffering"><a href="#三缓冲-Triple-Buffering" class="headerlink" title="三缓冲 Triple Buffering"></a>三缓冲 Triple Buffering</h3><p>事实上上述策略还有优化空间，在掉帧的时候，CPU和GPU有一段时间处于闲置状态：当A的内容正在被扫描显示在屏幕上，而B的内容已经被渲染好，此时CPU和GPU就处于闲置状态。那么如果我们增加一个帧缓冲器，就可以利用这段时间进行下一步的渲染，并将渲染结果暂存于新增的帧缓冲器中，从而减少掉帧的次数。</p><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/07.png" class=""><h3 id="屏幕卡顿的本质"><a href="#屏幕卡顿的本质" class="headerlink" title="屏幕卡顿的本质"></a>屏幕卡顿的本质</h3><ol><li>屏幕卡顿的根本原因：CPU 和 GPU 渲染流水线耗时过长，导致掉帧。</li><li>Vsync 与双缓冲的意义：强制同步屏幕刷新，以掉帧为代价解决屏幕撕裂问题。</li><li>三缓冲的意义：合理使用 CPU、GPU 渲染性能，减少掉帧次数</li></ol><h2 id="iOS中渲染框架"><a href="#iOS中渲染框架" class="headerlink" title="iOS中渲染框架"></a>iOS中渲染框架</h2><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/08.png" class=""><p>iOS的渲染框架依然复合<code>渲染流水线</code>的基本架构</p><p>Core Image：Core Image 是一个高性能的图像处理分析的框架，它拥有一系列现成的图像滤镜，能对已存在的图像进行高效的处理。</p><p>Metal：Metal 类似于 OpenGL ES，也是一套第三方标准，具体实现由苹果实现。Core Animation、Core Image、SceneKit、SpriteKit 等等渲染框架都是构建于 Metal 之上的。</p><h3 id="Core-Animation是什么"><a href="#Core-Animation是什么" class="headerlink" title="Core Animation是什么"></a>Core Animation是什么</h3><blockquote><p>Render, compose, and animate visual elements. —- Apple</p></blockquote><p><code>Core Animation</code>，它本质上可以理解为一个复合引擎，主要职责包含：渲染、构建和实现动画。前身叫做 <code>Layer Kit</code></p><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/09.png" class=""><h3 id="CALayer是显示的基础：-存储bitmap"><a href="#CALayer是显示的基础：-存储bitmap" class="headerlink" title="CALayer是显示的基础： 存储bitmap"></a>CALayer是显示的基础： 存储bitmap</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Layer content properties and methods. **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* An object providing the contents of the layer, typically a CGImageRef,</span></span><br><span class="line"><span class="comment"> * but may be something else. (For example, NSImage objects are</span></span><br><span class="line"><span class="comment"> * supported on Mac OS X 10.6 and later.) Default value is nil.</span></span><br><span class="line"><span class="comment"> * Animatable. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">strong</span>) <span class="type">id</span> contents;</span><br></pre></td></tr></table></figure><p>实际上，CALayer 中的 contents 属性保存了由设备渲染流水线渲染好的位图 bitmap（通常也被称为 backing store），而当设备屏幕进行刷新时，会从 CALayer 中读取生成好的 bitmap，进而呈现到屏幕上。</p><h3 id="CALayer-与-UIView的关系"><a href="#CALayer-与-UIView的关系" class="headerlink" title="CALayer 与 UIView的关系"></a>CALayer 与 UIView的关系</h3><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/10.png" class=""><h2 id="Offscreen-Rendering-离屏渲染"><a href="#Offscreen-Rendering-离屏渲染" class="headerlink" title="Offscreen Rendering 离屏渲染"></a>Offscreen Rendering 离屏渲染</h2><p>通常的渲染流程是这样的：</p><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/11.png" class=""><p>离屏渲染的流程是这样的：</p><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/12.png" class=""><p>与普通情况下 GPU 直接将渲染好的内容放入 Framebuffer 中不同，<code>需要先额外创建离屏渲染缓冲区 Offscreen Buffer，将提前渲染好的内容放入其中，等到合适的时机再将 Offscreen Buffer 中的内容进一步叠加、渲染，完成后将结果切换到 Framebuffer 中</code>。</p><h3 id="离屏渲染的效率问题"><a href="#离屏渲染的效率问题" class="headerlink" title="离屏渲染的效率问题"></a>离屏渲染的效率问题</h3><p>离屏渲染时由于App需要提前对部分内容进行额外的渲染并保存到Offscreen Buffer，以及需要在必要时刻对Offscreen Buffer和Frame buffer进行内容切换，所以会需要更长的处理时间</p><p>Offscreen Buffer本身就需要额外的空间，大量的离屏渲染可能造成内存的过大的压力。与此同时，Offscreen Buffer的总大小也有限，不能超过屏幕总像素的2.5倍。</p><p>可见离屏渲染的开销非常大，一旦需要离屏渲染的内容过多，很容易造成掉帧的问题。</p><h3 id="为什么使用离屏渲染"><a href="#为什么使用离屏渲染" class="headerlink" title="为什么使用离屏渲染"></a>为什么使用离屏渲染</h3><p>主要因为下面两个原因</p><ol><li>一些特殊效果需要使用额外的 Offscreen Buffer 来保存渲染的中间状态，所以不得不使用离屏渲染</li><li>处于效率目的，可以将内容提前渲染保存在 Offscreen Buffer 中，达到复用的目的。</li></ol><p>对于第一种情况，一般都是系统自动触发的，比如阴影，圆角等等。</p><p>最常见的情形之一就是：使用 <code>mask</code> 蒙版</p><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/13.jpeg" class=""><p>如图所示，由于最终的内容是由两层渲染结果叠加，所以必须要利用额外的内存空间对中间的渲染结果进行保存，因此系统会默认触发离屏渲染。</p><p>又比如下面这个例子，iOS 8 开始提供的模糊特效 UIBlurEffectView：</p><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/14.png" class=""><p>整个模糊过程分为多步：Pass 1 先渲染需要模糊的内容本身，Pass 2 对内容进行缩放，Pass 3 4 分别对上一步内容进行横纵方向的模糊操作，最后一步用模糊后的结果叠加合成，最终实现完整的模糊特效。</p><p>而第二种情况，为了复用提高效率而使用离屏渲染一般是主动的行为，是通过 CALayer 的 shouldRasterize 光栅化操作实现的。</p><h3 id="shouldRasterize-光栅化"><a href="#shouldRasterize-光栅化" class="headerlink" title="shouldRasterize 光栅化"></a>shouldRasterize 光栅化</h3><blockquote><p>When the value of this property is YES, the layer is rendered as a bitmap in its local coordinate space and then composited to the destination with any other content.</p></blockquote><p>开启光栅化后，会触发离屏渲染，Render Server 会强制将 CALayer 的渲染位图结果 bitmap 保存下来，这样下次再需要渲染时就可以直接复用，从而提高效率。</p><p>而保存的 bitmap 包含 layer 的 subLayer、圆角、阴影、组透明度 group opacity 等，所以如果 layer 的构成包含上述几种元素，结构复杂且需要反复利用，那么就可以考虑打开光栅化。</p><p>圆角、阴影、组透明度等会由系统自动触发离屏渲染，那么打开光栅化可以节约第二次及以后的渲染时间。而多层 subLayer 的情况由于不会自动触发离屏渲染，所以相比之下会多花费第一次离屏渲染的时间，但是可以节约后续的重复渲染的开销</p><p>不过使用光栅化的时候需要注意以下几点：</p><ol><li>如果 layer 不能被复用，则没有必要打开光栅化</li><li>如果 layer 不是静态，需要被频繁修改，比如处于动画之中，那么开启离屏渲染反而影响效率</li><li>离屏渲染缓存内容有时间限制，缓存内容 100ms 内如果没有被使用，那么就会被丢弃，无法进行复用</li><li>离屏渲染缓存空间有限，超过 2.5 倍屏幕像素大小的话也会失效，无法复用</li></ol><h3 id="圆角的离屏渲染"><a href="#圆角的离屏渲染" class="headerlink" title="圆角的离屏渲染"></a>圆角的离屏渲染</h3><p>设置圆角通常会首先像下面这行代码一样进行设置：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.layer.cornerRadius = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>上述代码只会默认设置 backgroundColor 和 border 的圆角，而不会设置 content 的圆角，除非同时设置了 layer.masksToBounds 为 true（对应 UIView 的 clipsToBounds 属性）：</p><p>如果只是设置了 cornerRadius 而没有设置 masksToBounds，由于不需要叠加裁剪，此时是并不会触发离屏渲染的。而当设置了裁剪属性的时候，由于 masksToBounds 会对 layer 以及所有 subLayer 的 content 都进行裁剪，所以不得不触发离屏渲染。</p><blockquote><p>在没有必要使用圆角裁剪的时候，尽量不去触发离屏渲染而影响效率</p></blockquote><h3 id="离屏渲染的具体逻辑"><a href="#离屏渲染的具体逻辑" class="headerlink" title="离屏渲染的具体逻辑"></a>离屏渲染的具体逻辑</h3><p>图层的叠加绘制大概遵循“<code>画家算法</code>”，在这种算法下会按层绘制，首先绘制距离较远的场景，然后用绘制距离较近的场景覆盖较远的部分。</p><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/15.png" class=""><p>在普通的 layer 绘制中，上层的 sublayer 会覆盖下层的 sublayer，下层 sublayer 绘制完之后就可以抛弃了，从而节约空间提高效率。所有 sublayer 依次绘制完毕之后，整个绘制过程完成，就可以进行后续的呈现了。假设我们需要绘制一个三层的 sublayer，不设置裁剪和圆角，那么整个绘制过程就如下图所示：</p><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/16.png" class=""><p>而当我们设置了 cornerRadius 以及 masksToBounds 进行圆角 + 裁剪时，如前文所述，masksToBounds 裁剪属性会应用到所有的 sublayer 上。这也就意味着所有的 sublayer 必须要重新被应用一次圆角+裁剪，这也就意味着所有的 sublayer 在第一次被绘制完之后，并不能立刻被丢弃，而必须要被保存在 Offscreen buffer 中等待下一轮圆角+裁剪，这也就诱发了离屏渲染，具体过程如下：</p><img src="/2021/11/21/iOS%20Rendering%20%E6%B8%B2%E6%9F%93%E8%A7%A3%E6%9E%90/17.png" class=""><p>实际上不只是圆角+裁剪，如果设置了<code>透明度+组透明</code>（layer.allowsGroupOpacity+layer.opacity），<code>阴影属性</code>（shadowOffset 等）都会产生类似的效果，因为组透明度、阴影都是和裁剪类似的，会作用与 layer 以及其所有 sublayer 上，这就导致必然会引起离屏渲染。</p><h3 id="避免圆角离屏渲染"><a href="#避免圆角离屏渲染" class="headerlink" title="避免圆角离屏渲染"></a>避免圆角离屏渲染</h3><p>可行的实现方法大概有下面几种：</p><ol><li>【换资源】直接使用带圆角的图片，或者替换背景色为带圆角的纯色背景图，从而避免使用圆角裁剪。不过这种方法需要依赖具体情况，并不通用。</li><li>【mask】再增加一个和背景色相同的遮罩 mask 覆盖在最上层，盖住四个角，营造出圆角的形状。但这种方式难以解决背景色为图片或渐变色的情况。</li><li>【UIBezierPath】用贝塞尔曲线绘制闭合带圆角的矩形，在上下文中设置只有内部可见，再将不带圆角的 layer 渲染成图片，添加到贝塞尔矩形中。这种方法效率更高，但是 layer 的布局一旦改变，贝塞尔曲线都需要手动地重新绘制，所以需要对 frame、color 等进行手动地监听并重绘。</li><li>【CoreGraphics】重写 drawRect:，用 CoreGraphics 相关方法，在需要应用圆角时进行手动绘制。不过 CoreGraphics 效率也很有限，如果需要多次调用也会有效率问题。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="https://www.zhihu.com/question/20978963/answer/86818933">知乎CPU和GPU的运算能力</a><br>2.<a href="https://juejin.cn/post/6844904162765832206">iOS Rendering 渲染全解析（长文干货）</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> UI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ReactiveObjC基础</title>
      <link href="/2021/11/01/ReactiveObjC%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/11/01/ReactiveObjC%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>RAC 被描述为函数响应式编程</p><span id="more"></span><h3 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h3><ol><li>函数式编程 ：使用高阶函数，例如函数用其他函数作为参数。</li><li>响应式编程：关注于数据流和变化传播。</li><li>链式编程 : 是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。a(1).b(2).c(3),注意点:要想达到链式编程方法的返回值必须是一个( (返回值是本身对象的)block)</li></ol><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="Signal-传递的-data"><a href="#Signal-传递的-data" class="headerlink" title="Signal 传递的 data"></a>Signal 传递的 data</h4><p>Signal 传递的 data 是 event，它所传递的 event 包括 3 种：值事件、完成事件和错误事件。在传递值事件时，可以携带数据.</p><p><code>传递值事件/完成事件/错误事件的本质就是向 sub scriber 发送sendNext:、sendComplete以及sendError:消息</code></p><h4 id="Signal的简单使用"><a href="#Signal的简单使用" class="headerlink" title="Signal的简单使用"></a>Signal的简单使用</h4><p>创建信号、订阅信号、订阅过程å</p><ul><li>创建获取信号</li></ul><ol><li>创建单元信号</li><li>创建动态信号</li><li>通过 Cocoa 桥接</li><li>从别的信号变换而来</li><li>由序列变换而来</li></ol><p>Cocoa桥接</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal6 = [objectrac_signalForSelector:<span class="keyword">@selector</span>(setFrame:)];</span><br><span class="line">RACSignal *signal7 = [control rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">RACSignal *signal8 = [object rac_willDeallocSignal];</span><br><span class="line">RACSignal *signal9 = RACObserve(object, keyPath);</span><br></pre></td></tr></table></figure><p>信号变换</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal10 = [signal1 map:^<span class="type">id</span>(<span class="type">id</span> value) &#123;</span><br><span class="line"><span class="keyword">return</span> someObject;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>序列变换</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal11 = sequence.signal;</span><br></pre></td></tr></table></figure><ul><li>订阅信号</li></ul><p>订阅信号的方式有 3 种：</p><ol><li>通过subscribeNext:error:completed:方法订阅</li><li>RAC 宏绑定</li><li>Cocoa 桥接</li></ol><p>通过subscribeNext:error:completed:方法订阅</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(<span class="type">void</span> (^)(<span class="type">id</span> x))nextBlock</span><br><span class="line">                       error:(<span class="type">void</span> (^)(<span class="built_in">NSError</span> *error))errorBlock</span><br><span class="line">                   completed:(<span class="type">void</span> (^)(<span class="type">void</span>));</span><br></pre></td></tr></table></figure><p>RAC 宏绑定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(view, backgroundColor) = signal10;</span><br></pre></td></tr></table></figure><p>Cocoa 桥接</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[object rac_liftSelector:<span class="keyword">@selector</span>(someSelector:) withSignals:signal1, signal2, <span class="literal">nil</span>];</span><br><span class="line">[object rac_liftSelector:<span class="keyword">@selector</span>(someSelector:) withSignalsFromArray:@[signal1, signal2]];</span><br><span class="line">[object rac_liftSelector:<span class="keyword">@selector</span>(someSelector:) withSignalOfArguments:signal1];</span><br></pre></td></tr></table></figure><ul><li>订阅过程<br>订阅过程指的是信号被订阅的处理逻辑</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendNext:<span class="string">@&quot;1&quot;</span>];</span><br><span class="line">[subscriber sendNext:<span class="string">@&quot;2&quot;</span>];</span><br><span class="line">[subscriber sendCompleted];     </span><br><span class="line">[subscriber sendNext:<span class="string">@&quot;3&quot;</span>];  <span class="comment">// 无效</span></span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;dispose&quot;</span>);       <span class="comment">// 当错误事件或者完成事件产生时，该block被调用</span></span><br><span class="line">&#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;next value is :  %@&quot;</span>, x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;error : %@&quot;</span>, error);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;completed&quot;</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* prints:</span></span><br><span class="line"><span class="comment">next value is :  1</span></span><br><span class="line"><span class="comment">next value is :  2</span></span><br><span class="line"><span class="comment">completed</span></span><br><span class="line"><span class="comment">dispose</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>注意：</li></ul><ol><li>RACSignal的每一个操作都会返回一个RACSignal。</li><li>RACSequence是RAC中的集合类,可以实现OC对象与信号中传递值之间的转换,RAC类库中提供了NSArray,NSDictionary等集合类的分类供其转换</li></ol><h3 id="可能遇到的坑"><a href="#可能遇到的坑" class="headerlink" title="可能遇到的坑"></a>可能遇到的坑</h3><h4 id="接收不到信号"><a href="#接收不到信号" class="headerlink" title="接收不到信号"></a>接收不到信号</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[RACObserve(<span class="keyword">self</span>, selectedRows) subscribeNext:^(<span class="built_in">NSSet</span> *currentlySelected) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Currently selected: %@&quot;</span>, currentlySelected);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.selectedRows = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">- (<span class="type">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">[<span class="keyword">self</span>.selectedRows addObject:indexPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面RACObserve回调只会调用一次，初始化的时候，为什么addObject的时候没有出发信号？<br>因为addObject没有触发KVO事件。解决通过协议触发KVO</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">[[<span class="keyword">self</span> mutableSetValueForKey:<span class="string">@&quot;selectedRows&quot;</span>] addObject:indexPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="需要关联多个信号"><a href="#需要关联多个信号" class="headerlink" title="需要关联多个信号"></a>需要关联多个信号</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(<span class="keyword">self</span>.loginVM,pwdStr)=[RACSignal merge:@[passwordTxt.rac_textSignal,RACObserve(passwordTxt, text)]];</span><br></pre></td></tr></table></figure><h4 id="冷信号和热信号"><a href="#冷信号和热信号" class="headerlink" title="冷信号和热信号"></a>冷信号和热信号</h4><p>冷热信号的概念源于.NET框架Reactive Extensions(RX)中的Hot Observable和Cold Observable，两者的区别是：</p><p>Hot Observable是主动的，尽管你并没有订阅事件，但是它会时刻推送，就像鼠标移动；而Cold Observable是被动的，只有当你订阅的时候，它才会发布消息。 <br>Hot Observable可以有多个订阅者，是一对多，集合可以与订阅者共享信息；而Cold Observable只能一对一，当有不同的订阅者，消息是重新完整发送。</p><ul><li>冷信号</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)racColdSingle</span><br><span class="line">&#123;</span><br><span class="line">RACSignal* coldSingle=[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Signal was created.&quot;</span>);</span><br><span class="line">[[RACScheduler mainThreadScheduler] afterDelay:<span class="number">0.1</span> schedule:^&#123;</span><br><span class="line">    [coldSingle subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Subscriber 1 recveive: %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[[RACScheduler mainThreadScheduler] afterDelay:<span class="number">1</span> schedule:^&#123;</span><br><span class="line">    [coldSingle subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Subscriber 2 recveive: %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2019-09-23 14:14:26.853285+0800 RACDemo[16585:117906] Signal was created.</span><br><span class="line">2019-09-23 14:14:26.956126+0800 RACDemo[16585:117906] Subscriber 1 recveive: 1</span><br><span class="line">2019-09-23 14:14:26.956339+0800 RACDemo[16585:117906] Subscriber 1 recveive: 2</span><br><span class="line">2019-09-23 14:14:26.956559+0800 RACDemo[16585:117906] Subscriber 1 recveive: 3</span><br><span class="line">2019-09-23 14:14:27.888112+0800 RACDemo[16585:117906] Subscriber 2 recveive: 1</span><br><span class="line">2019-09-23 14:14:27.888267+0800 RACDemo[16585:117906] Subscriber 2 recveive: 2</span><br><span class="line">2019-09-23 14:14:27.888363+0800 RACDemo[16585:117906] Subscriber 2 recveive: 3</span><br></pre></td></tr></table></figure><p>信号在14:14:26.853时被创建，14:14:26.956依次接到1、2、3三个值，而在14:14:27.888再依次接到1、2、3三个值。说明了变量名为coldSingle的这个信号，在两个不同时间段的订阅过程中，分别完整地发送了所有的消息。</p><ul><li>热信号</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)racHoltSingal</span><br><span class="line">&#123;</span><br><span class="line">RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">1</span> schedule:^&#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">2</span> schedule:^&#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">3</span> schedule:^&#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">4</span> schedule:^&#123;</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] publish];</span><br><span class="line">    </span><br><span class="line">[connection connect];</span><br><span class="line">RACSignal *signal = connection.signal;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Signal was created.&quot;</span>);</span><br><span class="line">[[RACScheduler mainThreadScheduler] afterDelay:<span class="number">1.1</span> schedule:^&#123;</span><br><span class="line">    [signal subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Subscriber 1 recveive: %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[[RACScheduler mainThreadScheduler] afterDelay:<span class="number">2.1</span> schedule:^&#123;</span><br><span class="line">    [signal subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Subscriber 2 recveive: %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-09-23 14:20:26.214718+0800 RACDemo[16872:122429] Signal was created.</span><br><span class="line">2019-09-23 14:20:28.325190+0800 RACDemo[16872:122429] Subscriber 1 recveive: 2</span><br><span class="line">2019-09-23 14:20:29.274356+0800 RACDemo[16872:122429] Subscriber 1 recveive: 3</span><br><span class="line">2019-09-23 14:20:29.274537+0800 RACDemo[16872:122429] Subscriber 2 recveive: 3</span><br></pre></td></tr></table></figure><p>分析</p><ol><li>创建了一个信号，在1秒、2秒、3秒分别发送1、2、3这三个值，4秒发送结束信号。</li><li>对这个信号调用publish方法得到一个RACMulticastConnection。</li><li>让connection进行连接操作。</li><li>获得connection的信号。</li><li>分别在1.1秒和2.1秒订阅获得的信号。</li></ol><ul><li>热信号的如下特点：</li></ul><ol><li>热信号是主动的，即使你没有订阅事件，它仍然会时刻推送。如第二个例子，信号在50秒被创建，51秒的时候1这个值就推送出来了，但是当时还没有订阅者。而冷信号是被动的，只有当你订阅的时候，它才会发送消息。如第一个例子。</li><li>热信号可以有多个订阅者，是一对多，信号可以与订阅者共享信息。如第二个例子，订阅者1和订阅者2是共享的，他们都能在同一时间接收到3这个值。而冷信号只能一对一，当有不同的订阅者，消息会从新完整发送。如第一个例子，我们可以观察到两个订阅者没有联系，都是基于各自的订阅时间开始接收消息的。</li></ol><ul><li>热信号几种产生方式</li></ul><ol><li><p>[RACSignal publish]、- [RACMulticastConnection connect]、- [RACMulticastConnection signal]这几个操作生成了一个热信号</p></li><li><p>在RAC中，所有的热信号都属于一个类RACSubject</p></li></ol><ul><li>冷信号转化成热信号—广播</li></ul><p>冷信号与热信号的本质区别在于是否保持状态，冷信号的多次订阅是不保持状态的，而热信号的多次订阅可以保持状态，所以一种将冷信号转换为热信号的方法就是，将冷信号订阅，订阅到的每一个时间通过RACSubject发送出去，其它订阅者只订阅这个RACSubject</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://juejin.im/post/6844903443367215112">（RAC）知其所以然（源码分析）</a></li><li><a href="https://tech.meituan.com/tags/reactivecocoa.html">美团ReactiveCocoa</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> RAC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hash思想与hashTable</title>
      <link href="/2021/10/07/Hash%E6%80%9D%E6%83%B3%E4%B8%8EhashTable/"/>
      <url>/2021/10/07/Hash%E6%80%9D%E6%83%B3%E4%B8%8EhashTable/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Hash就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。Hash算法没有一个固定的公式，只要符合Hash思想的算法都可以被称为是Hash算法</p></blockquote><span id="more"></span><h2 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h2><p>哈希表：数据经过哈希算法之后得到的集合。这样关键字和数据在集合中的位置存在一定的关系，可以根据这种关系快速查询</p><p>哈希算法是一种特殊的算法，能将任意数据散列后映射到有限的空间上，通常计算机软件中用作快速查找或加密使用。</p><p>哈希冲突：由于哈希算法被计算的数据是无限的，而计算后的结果范围有限，因此总会存在不同的数据经过计算后得到的值相同，这就是哈希冲突。</p><h3 id="解决哈希冲突的方法"><a href="#解决哈希冲突的方法" class="headerlink" title="解决哈希冲突的方法"></a>解决哈希冲突的方法</h3><p>解决哈希冲突的方法一般有：开放地址法、链地址法（拉链法）、再哈希法、建立公共溢出区等方法</p><h4 id="开放地址法（open-addressing）"><a href="#开放地址法（open-addressing）" class="headerlink" title="开放地址法（open addressing）"></a>开放地址法（open addressing）</h4><p>从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。</p><p>在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。<br>开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。</p><h5 id="线行探查法"><a href="#线行探查法" class="headerlink" title="线行探查法"></a>线行探查法</h5><p>线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。</p><h5 id="平方探查法"><a href="#平方探查法" class="headerlink" title="平方探查法"></a>平方探查法</h5><p>平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。<br> 在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。</p><h5 id="双散列函数探查法"><a href="#双散列函数探查法" class="headerlink" title="双散列函数探查法"></a>双散列函数探查法</h5><p>这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值l；对于平方探查法，探查序列的步长值是探查次数i的两倍减l；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。</p><h4 id="链地址法（拉链法）-chaining"><a href="#链地址法（拉链法）-chaining" class="headerlink" title="链地址法（拉链法） chaining"></a>链地址法（拉链法） chaining</h4><p>链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于<code>经常进行插入和删除</code>的情况。</p><p>如下一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13，哈希函数为H(key)&#x3D;key%13,则链表法结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0       </span><br><span class="line">1  -&gt; 40 -&gt; 27 -&gt; 53 </span><br><span class="line">2</span><br><span class="line">3  -&gt; 16 -&gt; 42</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6  -&gt; 32 -&gt; 71</span><br><span class="line">7  -&gt; 46</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10 -&gt; 36 -&gt; 49</span><br><span class="line">11 -&gt; 24</span><br><span class="line">12 -&gt; 64</span><br></pre></td></tr></table></figure><blockquote><p>Java hashmap就是这么做的,在调用HashMap的put方法或get方法时，都会首先调用hashcode方法，去查找相关的key，当有冲突时，再调用equals方法.<br>JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等</p></blockquote><h4 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h4><p>就是同时构造多个不同的哈希函数：<br> Hi &#x3D; RHi(key)   i&#x3D; 1,2,3 … k;<br> 当H1 &#x3D; RH1(key)  发生冲突时，再用H2 &#x3D; RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p><h4 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h4><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p><h3 id="OC中的Hash"><a href="#OC中的Hash" class="headerlink" title="OC中的Hash"></a>OC中的Hash</h3><h4 id="NSHash​Table-amp-NSMap​Table"><a href="#NSHash​Table-amp-NSMap​Table" class="headerlink" title="NSHash​Table &amp; NSMap​Table"></a>NSHash​Table &amp; NSMap​Table</h4><p>对于<code>NSSet</code>，对象在存储时会被强引用，<code>NSDicionary</code>中值的存储也是一样，对健来说，在<code>NSDictionary</code>中会被拷贝</p><blockquote><p>如果想存储弱引用的值，或者使用一个没有遵守<code>&lt;NSCopying&gt;</code>的对象作为key，可以使用<code>NSValue +valueWithNonretainedObject</code>或者，在iOS 6 上可以使用<code>NSHashTable</code>或<code>NSMapTable</code>分别对应<code>NSSet</code> 和 <code>NSDictionary</code>，是它们的通用版本。</p></blockquote><ul><li>NSHashTable<br>NSHashTable 是 NSSet 的通用版本，和 NSSet &#x2F; NSMutableSet 不同的是，NSHashTable 具有下面这些特性：</li></ul><ol><li>NSSet &#x2F; NSMutableSet 持有成员的强引用，通过 hash 和 isEqual: 方法来检测成员的散列值和相等性。</li><li>NSHashTable 是可变的，没有不可变的对应版本。</li><li>NSHashTable 可以持有成员的弱引用。</li><li>NSHashTable 可以在加入成员时进行 copy 操作。</li><li>NSHashTable 可以存储任意的指针，通过指针来进行相等性和散列检查。</li></ol><ul><li>NSMapTable</li></ul><p><code>NSMapTable</code> 是 <code>NSDictionary</code> 的通用版本。和 <code>NSDictionary</code> &#x2F; <code>NSMutableDictionary</code> 不同的是，<code>NSMapTable</code> 具有下面这些特性：</p><ol><li><code>NSDictionary</code> &#x2F; <code>NSMutableDictionary</code> 对键进行拷贝，对值持有强引用。</li><li><code>NSMapTable</code> 是可变的，没有不可变的对应版本。</li><li><code>NSMapTable</code> 可以持有键和值的弱引用，当键或者值当中的一个被释放时，整个这一项就会被移除掉。</li><li><code>NSMapTable</code> 可以在加入成员时进行 <code>copy</code> 操作。</li><li><code>NSMapTable</code> 可以存储任意的指针，通过指针来进行相等性和散列检查。</li></ol><h2 id="常见Hash的算法及应用"><a href="#常见Hash的算法及应用" class="headerlink" title="常见Hash的算法及应用"></a>常见Hash的算法及应用</h2><p><code>MD5</code>,<code>SHA1</code>, <code>SHA256</code></p><p>Hash算法广泛应用于 <code>错误校正</code>、<code>语音识别</code>、<code>信息安全</code> 中，其在信息安全的应用主要体现在以下几个方面：</p><ul><li><p>文件校验</p><blockquote><p>校验文件是否被篡改。</p></blockquote></li><li><p>数字签名</p><blockquote><p>由于非对称算法的运算速度较慢，所以在数字签名协议中，先对文件进行运算得到其Hash值（其Hash值又被称为【数字摘要】），然后对数字摘要进行数字签名，在统计上认为与对文件本身进行数字签名是等效的。</p></blockquote></li><li><p>鉴权协议</p><blockquote><p>鉴权协议又被称作挑战–认证模式：在传输信道是可被侦听，但不可被篡改的情况下，这是一种简单而安全的方法。</p></blockquote></li></ul><p>Hash算法加密的对象是 文件的二进制内容，只要文件的二进制内容没发生改变，其Hash值不变。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="https://juejin.cn/post/6844903976589066253">Hash与对称加密算法</a><br>2.<a href="https://cloud.tencent.com/developer/article/1672781">解决哈希冲突的常用方法分析</a><br>3.<a href="https://mikechen.cc/6798.html">深入探讨HashMap的底层结构、原理、扩容机制</a><br>4.<a href="https://nshipster.cn/nshashtable-and-nsmaptable/">NSHash​Table &amp; NSMap​Table</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C方法缓存实现</title>
      <link href="/2021/10/05/Objective-C%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/"/>
      <url>/2021/10/05/Objective-C%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>为什么需要学习Objective-C底层实现，因为底层使用的技术都是值得花时间学习的，特别是使用的数据结构，通常都是权衡使用场景，以及考虑后续可持续迭代的优质代码。</p><p>OC为了实现其动态性，将方法的调用包装成了<code>SEL</code>寻找<code>IMP</code>的过程。OC采用了方法缓存的机制来提高调用效率，也就是<code>cache_t</code>，其作用就是缓存已调用的方法。</p><span id="more"></span><h2 id="cache-t-数据结构"><a href="#cache-t-数据结构" class="headerlink" title="cache_t 数据结构"></a>cache_t 数据结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cache_t</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bucket_t</span> *_buckets;  <span class="comment">//8缓存数组，即哈希桶</span></span><br><span class="line">    <span class="type">mask_t</span> _mask;               <span class="comment">//4      typedef uint32_t mask_t;  缓存数组的容量临界值</span></span><br><span class="line">    <span class="type">mask_t</span> _occupied;           <span class="comment">//4缓存数组中已缓存方法数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bucket_t</span> *<span class="built_in">buckets</span>();</span><br><span class="line">    <span class="function"><span class="type">mask_t</span> <span class="title">mask</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">mask_t</span> <span class="title">occupied</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incrementOccupied</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setBucketsAndMask</span><span class="params">(<span class="keyword">struct</span> <span class="type">bucket_t</span> *newBuckets, <span class="type">mask_t</span> newMask)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initializeToEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">mask_t</span> <span class="title">capacity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isConstantEmptyCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canBeFreed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">bytesForCapacity</span><span class="params">(<span class="type">uint32_t</span> cap)</span></span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">bucket_t</span> * <span class="built_in">endMarker</span>(<span class="keyword">struct</span> <span class="type">bucket_t</span> *b, <span class="type">uint32_t</span> cap);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reallocate</span><span class="params">(<span class="type">mask_t</span> oldCapacity, <span class="type">mask_t</span> newCapacity)</span></span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bucket_t</span> * <span class="built_in">find</span>(SEL sel, id receiver);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">bad_cache</span><span class="params">(id receiver, SEL sel, Class isa)</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">mask_t</span> <span class="title">cache_t::mask</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _mask; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">mask_t</span> <span class="title">cache_t::capacity</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mask</span>() ? <span class="built_in">mask</span>()+<span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">uintptr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uintptr_t</span> <span class="type">cache_key_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bucket_t</span> &#123;</span><br><span class="line">    <span class="type">cache_key_t</span> _key;</span><br><span class="line">    MethodCacheIMP _imp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>_buckets</code>：一个指向<code>bucket_t</code>结构体的数组，bucket_t是用来存放方法的<code>SEL内存地址</code>和<code>IMP</code>的；<br> <code>_mask</code>的大小是数组大小 - 1，用作掩码（因为这里维护的数组大小都是2的整数次幂，所以_mask的二进制位000011, 000111, 001111）刚好可以用作hash取余数的掩码。刚好保证相与后不超过缓存大小。<br><code>_occupied</code>是当前已缓存的方法数。即数组中已使用了多少位置</p><p><code>_key</code>:<code>cache_key_t</code> 就是 <code>unsigned long</code>类型，用来存储<code>SEL</code>的内存地址。SEL应该是<code>char*</code>类型的字符串，<code>char*</code>强转<code>unsigned long</code>，其实就是<code>SEL</code>的内存地址。代码如下<br><code>_imp</code>就是方法实现IMP了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">cache_key_t</span> key = <span class="built_in">getKey</span>(sel);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">cache_key_t</span> <span class="title">getKey</span><span class="params">(SEL sel)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(sel);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">cache_key_t</span>)sel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="掩码-mask设计"><a href="#掩码-mask设计" class="headerlink" title="掩码_mask设计"></a>掩码<code>_mask</code>设计</h3><p>如果<code>_mask</code>是0，说明未调用实例方法，即桶的容量为0；<br>当<code>_mask</code>不等于0的时候，意味着已经调用过实例方法，此时桶的容量为_mask + 1。故，_mask从侧面反映了桶的容量。</p><blockquote><p><code>掩码</code>（Mask）在计算机科学及数字逻辑中指的是一串二进制数字，通过与目标数字的按位操作，达到屏蔽指定位而实现需求。（eg：子网掩码）</p></blockquote><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><ul><li><p>使用<code> @selector(hello)</code> 生成的选择子，是否会因为类的不同而不同？<br>使用 <code>@selector()</code> 生成的选择子不会因为类的不同而改变，其内存地址在编译期间就已经确定了。也就是说向不同的类发送相同的消息时，其生成的选择子是完全相同的。</p></li><li><p>SEL特性</p></li></ul><ol><li><code>Objective-C</code> 为我们维护了一个巨大的选择子表</li><li>在使用 @selector() 时会从这个选择子表中根据选择子的名字查找对应的 SEL。如果没有找到，则会生成一个 SEL 并添加到表中</li><li>在编译期间会扫描全部的头文件和实现文件将其中的方法以及使用 @selector() 生成的选择子加入到选择子表中</li></ol><h2 id="cache-t方法缓存原理"><a href="#cache-t方法缓存原理" class="headerlink" title="cache_t方法缓存原理"></a>cache_t方法缓存原理</h2><p>OC方法的本质是消息发送（<code>objc_msgSend</code>),底层是通过方法的<code>SEL</code>查找<code>IMP</code></p><h3 id="cache-t的存入"><a href="#cache-t的存入" class="headerlink" title="cache_t的存入"></a>cache_t的存入</h3><ol><li><p>先看缓存中是否已经存在了该方法，如果已经存在，直接return，不再缓存</p></li><li><p>从class中拿到cache列表，将sel转换为内存地址</p></li></ol><ul><li>如果当前cache还没被初始化，则分配一个大小为4的数组，并设置<code>_mask</code>为3</li><li>如果存入缓存后的大小小于当前大小的3&#x2F;4，则当前缓存大小还可以使用，无需扩容</li><li>否则缓存太满，需要扩容，扩容为原来大小的2倍，放弃旧的缓存，新扩容的缓存为空。</li></ul><ol start="3"><li>将_key与_mask相与，因为_mask是原数组的大小-1，所以得到的结果刚好小于数组的大小</li><li>如果得到的位置已经被占用，则往后寻找，直到找到空的位置，把缓存设置到这个位置。</li></ol><h3 id="cache-fill-nolock-方法"><a href="#cache-fill-nolock-方法" class="headerlink" title="cache_fill_nolock 方法"></a><code>cache_fill_nolock</code> 方法</h3><p>这个函数的作用是将方法的SEL和IMP写入<code>_buckets</code>,同时更新<code>_mask</code>和<code>_occupied</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cache_fill</span><span class="params">(Class cls, SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 因为cache_t内部用来储存的结构其实就是个数组</span></span><br><span class="line">    <span class="comment">// 所以操作的时候需要先加个锁，保证线程安全。</span></span><br><span class="line">    <span class="function"><span class="type">mutex_locker_t</span> <span class="title">lock</span><span class="params">(cacheUpdateLock)</span></span>;</span><br><span class="line">    <span class="built_in">cache_fill_nolock</span>(cls, sel, imp, receiver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">cache_fill_nolock</span><span class="params">(Class cls, SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cacheUpdateLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Never cache before +initialize is done</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;<span class="built_in">isInitialized</span>()) <span class="keyword">return</span>; <span class="comment">//如果类未初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the entry wasnot added to the cache by some other thread </span></span><br><span class="line">    <span class="comment">// before we grabbed the cacheUpdateLock.</span></span><br><span class="line">    <span class="comment">//判断方法是否已经缓存了，如果缓存了，直接返回，如果没有，则进入下面的逻辑进行缓存。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cache_getImp</span>(cls, sel)) <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">    <span class="type">cache_t</span> *cache = <span class="built_in">getCache</span>(cls);</span><br><span class="line">     <span class="comment">// 将方法名转成对应的key</span></span><br><span class="line">    <span class="type">cache_key_t</span> key = <span class="built_in">getKey</span>(sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the cache as-is if it is less than 3/4 full</span></span><br><span class="line">    <span class="comment">// 通过cache获取已经缓存的数量occupied，并且+1，得到新的缓存数量。</span></span><br><span class="line">    <span class="type">mask_t</span> newOccupied = cache-&gt;<span class="built_in">occupied</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="type">mask_t</span> capacity = cache-&gt;<span class="built_in">capacity</span>();</span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;<span class="built_in">isConstantEmptyCache</span>()) &#123;</span><br><span class="line">       <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">        cache-&gt;<span class="built_in">reallocate</span>(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newOccupied &lt;= capacity / <span class="number">4</span> * <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// Cache is less than 3/4 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Cache is too full. Expand it.</span></span><br><span class="line">        cache-&gt;<span class="built_in">expand</span>();<span class="comment">//如果大于3/4，就需要expand()即缓存扩容。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for the first unused slot and insert there.</span></span><br><span class="line">    <span class="comment">// There is guaranteed to be an empty slot because the </span></span><br><span class="line">    <span class="comment">// minimum size is 4 and we resized at 3/4 full.</span></span><br><span class="line">    <span class="comment">// 根据sel获取bucket，此bucket的sel一般为0（说明这个位置还没缓存方法），</span></span><br><span class="line">    <span class="comment">// 也可能与实参sel相等（hash冲突，可能性很低）</span></span><br><span class="line">    <span class="type">bucket_t</span> *bucket = cache-&gt;<span class="built_in">find</span>(sel, receiver);</span><br><span class="line">    <span class="comment">// 当且仅当bucket的sel为0时，执行_occupied++</span></span><br><span class="line">    <span class="keyword">if</span> (bucket-&gt;<span class="built_in">sel</span>() == <span class="number">0</span>) cache-&gt;<span class="built_in">incrementOccupied</span>();</span><br><span class="line">    <span class="comment">// 更新bucket的sel和imp</span></span><br><span class="line">    bucket-&gt;<span class="built_in">set</span>&lt;Atomic&gt;(sel, imp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// INIT_CACHE_SIZE 即为4</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">2</span>,</span><br><span class="line">    INIT_CACHE_SIZE      = (<span class="number">1</span> &lt;&lt; INIT_CACHE_SIZE_LOG2)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">cache_t</span> *<span class="title">getCache</span><span class="params">(Class cls)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(cls);</span><br><span class="line">    <span class="keyword">return</span> &amp;cls-&gt;cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">mask_t</span> <span class="title">cache_t::capacity</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mask</span>() ? <span class="built_in">mask</span>()+<span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>cache_getImp</code>的实现是不开源的，同时也是用汇编实现</p></blockquote><h3 id="expand"><a href="#expand" class="headerlink" title="expand"></a>expand</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cache_t::expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cacheUpdateLock.<span class="built_in">assertLocked</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前总容量，即_mask+1</span></span><br><span class="line">    <span class="type">uint32_t</span> oldCapacity = <span class="built_in">capacity</span>();</span><br><span class="line">    <span class="comment">// 新的容量 = 旧容量 * 2</span></span><br><span class="line">    <span class="type">uint32_t</span> newCapacity = oldCapacity ? oldCapacity*<span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uint32_t</span>)(<span class="type">mask_t</span>)newCapacity != newCapacity) &#123;</span><br><span class="line">        <span class="comment">// mask overflow - can&#x27;t grow further</span></span><br><span class="line">        <span class="comment">// fixme this wastes one bit of mask</span></span><br><span class="line">        newCapacity = oldCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reallocate</span>(oldCapacity, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>在不超过<code>uint32_t</code>大小（4字节）时，每次扩容为原来的2倍</li><li>如果超过了<code>uint32_t</code>，则重新申请跟原来一样大小的<code>buckets</code></li></ol><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find具体做的事情就是根据方法的<code>SEL</code>，返回一个复合要求的<code>bucket</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bucket_t</span> * <span class="title">cache_t::find</span><span class="params">(SEL s, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(s != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">bucket_t</span> *b = <span class="built_in">buckets</span>(); <span class="comment">// 获取当前buckets，即_buckets</span></span><br><span class="line">    <span class="type">mask_t</span> m = <span class="built_in">mask</span>(); <span class="comment">// 获取当前mask，即_mask</span></span><br><span class="line"></span><br><span class="line">    <span class="type">mask_t</span> begin = <span class="built_in">cache_hash</span>(s, m);</span><br><span class="line">    <span class="type">mask_t</span> i = begin;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// sel为0：说明 i 这个位置尚未缓存方法；</span></span><br><span class="line">    <span class="comment">// sel等于s：命中缓存，说明 i 这个位置已缓存方法，可能是hash冲突</span></span><br><span class="line">        <span class="keyword">if</span> (b[i].<span class="built_in">sel</span>() == <span class="number">0</span>  ||  b[i].<span class="built_in">sel</span>() == s) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((i = <span class="built_in">cache_next</span>(i, m)) != begin); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hack</span></span><br><span class="line">    <span class="comment">// 找不到多余的哈希桶（出错的处理，打印问题）</span></span><br><span class="line">    Class cls = (Class)((<span class="type">uintptr_t</span>)<span class="keyword">this</span> - <span class="built_in">offsetof</span>(objc_class, cache));</span><br><span class="line">    <span class="type">cache_t</span>::<span class="built_in">bad_cache</span>(receiver, (SEL)s, cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">mask_t</span> <span class="title">cache_hash</span><span class="params">(SEL sel, <span class="type">mask_t</span> mask)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">mask_t</span>)(<span class="type">uintptr_t</span>)sel &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">mask_t</span> <span class="title">cache_next</span><span class="params">(<span class="type">mask_t</span> i, <span class="type">mask_t</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i+<span class="number">1</span>) &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>find</code>找<code>bucket</code>的方式用到了<code>hash</code>的思想：以<code>_buckets</code>作为哈希桶，以<code>cache_hash</code>作为哈希函数，进行哈希运算后得出索引值<code>index</code>（<code>xx &amp; mask</code>，所以<code>index</code>最大值就是<code>_mask</code>的值）.由于所以值是通过哈希运算得出的，其结果自然是无序的。</p><h3 id="mask的作用"><a href="#mask的作用" class="headerlink" title="_mask的作用"></a>_mask的作用</h3><ol><li>反映了cache_t中哈希桶的数量（哈希桶的数量&#x3D;_mask+1）,保证了查找哈希桶时不会出现越界的情况。</li></ol><p>哈希桶的数量一定是<code>&gt;=4且能被4整除</code>的，<code>_mask</code>则等于哈希桶的数量-1，也就是说<code>_mask</code>的二进制位上全都是1，而索引是由<code>xx &amp; _mask</code> 运算得出，因此索引值是小于哈希桶的数量的<code>(index&lt;=_mask</code>,故<code>index&lt;capacity</code>),也就不会出现越界的问题</p><h3 id="扩容临界点3-x2F-4的讨论"><a href="#扩容临界点3-x2F-4的讨论" class="headerlink" title="扩容临界点3&#x2F;4的讨论"></a>扩容临界点3&#x2F;4的讨论</h3><p>一般设定临界点就不得不权衡 <code>空间利用率</code> 和 <code>时间利用率</code> 。在 3&#x2F;4 这个临界点的时候，空间利用率比较高，同时又避免了相当多的哈希冲突，时间利用率也比较高。</p><h2 id="cache-t的取出"><a href="#cache-t的取出" class="headerlink" title="cache_t的取出"></a>cache_t的取出</h2><p><code>cache_t</code>的取出操作为<code>cache_getImp(cls,sel)</code>，该代码是使用汇编语言实现。<code>cache_getImp</code>方法将参数<code>cls</code>放到<code>r10</code>寄存器，然后调用了<code>CacheLookup</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY _cache_getImp</span><br><span class="line"></span><br><span class="line">// do lookup</span><br><span class="line">movq%a1, %r10// move class to r10 for CacheLookup</span><br><span class="line">CacheLookup NORMAL, GETIMP// returns IMP on success</span><br></pre></td></tr></table></figure><p>将<code>sel</code>放进<code>r11</code>寄存器，然后将 <code>sel</code>和<code>cls-&gt;cache.mask</code>相与的结果放进<code>r11</code>寄存器，找到key与现有的sel比较</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.macroCacheLookup</span><br><span class="line">movq%a2, %r11// r11 = _cmd</span><br><span class="line">andl24(%r10), %r11d// r11 = _cmd &amp; class-&gt;cache.mask</span><br><span class="line">shlq$$4, %r11// r11 = offset = (_cmd &amp; mask)&lt;&lt;4</span><br><span class="line">addq16(%r10), %r11// r11 = class-&gt;cache.buckets + offset</span><br><span class="line"></span><br><span class="line">cmpqcached_sel(%r11), %a2// if (bucket-&gt;sel != _cmd)</span><br><span class="line">jne 1f//     scan more</span><br><span class="line">// CacheHit must always be preceded by a not-taken `jne` instruction</span><br><span class="line">CacheHit $0, $1// call or return imp</span><br><span class="line"></span><br><span class="line">1:</span><br><span class="line">// loop</span><br><span class="line">cmpq$$1, cached_sel(%r11)</span><br><span class="line">jbe3f// if (bucket-&gt;sel &lt;= 1) wrap or miss</span><br><span class="line"></span><br><span class="line">addq$$16, %r11// bucket++</span><br><span class="line">2:</span><br><span class="line">cmpqcached_sel(%r11), %a2// if (bucket-&gt;sel != _cmd)</span><br><span class="line">jne 1b//     scan more</span><br><span class="line">// CacheHit must always be preceded by a not-taken `jne` instruction</span><br><span class="line">CacheHit $0, $1// call or return imp</span><br><span class="line"></span><br><span class="line">3:</span><br><span class="line">// wrap or miss</span><br><span class="line">jbLCacheMiss_f// if (bucket-&gt;sel &lt; 1) cache miss</span><br><span class="line">// wrap</span><br><span class="line">movqcached_imp(%r11), %r11// bucket-&gt;imp is really first bucket</span><br><span class="line">jmp 2f</span><br><span class="line"></span><br><span class="line">// Clone scanning loop to miss instead of hang when cache is corrupt.</span><br><span class="line">// The slow path may detect any corruption and halt later.</span><br><span class="line"></span><br><span class="line">1:</span><br><span class="line">// loop</span><br><span class="line">cmpq$$1, cached_sel(%r11)</span><br><span class="line">jbe3f// if (bucket-&gt;sel &lt;= 1) wrap or miss</span><br><span class="line"></span><br><span class="line">addq$$16, %r11// bucket++</span><br><span class="line">2:</span><br><span class="line">cmpqcached_sel(%r11), %a2// if (bucket-&gt;sel != _cmd)</span><br><span class="line">jne 1b//     scan more</span><br><span class="line">// CacheHit must always be preceded by a not-taken `jne` instruction</span><br><span class="line">CacheHit $0, $1// call or return imp</span><br><span class="line"></span><br><span class="line">3:</span><br><span class="line">// double wrap or miss</span><br><span class="line">jmpLCacheMiss_f</span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>cache_t</code>是一个开放地址法的hash表</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="https://juejin.cn/post/6844904070596001806">OC源码分析之方法的缓存原理</a><br>2.<a href="https://draveness.me/message/">从源代码看 ObjC 中消息的发送</a><br>3.<a href="https://juejin.cn/post/6844903858762678286">iOS的方法缓存（cache_t）是如何实现</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Objective-C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【读书笔记】Objective-C编程之道：iOS设计模式解析  下</title>
      <link href="/2021/09/26/iOS%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%E4%B8%8B/"/>
      <url>/2021/09/26/iOS%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>iOS应用程序的基础框架Cocoa Touch框架内容丰富、结构优美，通过将各种设计模式应用到其基础结构中，为第三方开发者提供了很好的可扩展性和灵活性。因此，要充分利用这一框架，应当深刻理解<br>并恰当应用设计模式。</p></blockquote><span id="more"></span><h2 id="抽象集合"><a href="#抽象集合" class="headerlink" title="抽象集合"></a>抽象集合</h2><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>把组合想象为一个实体，它包含着同一类型的其他实体。整个结构就像由父节点实体和子节点实体连接而成的树，这种树状结构形成<code>部分-整体</code>的层次结构</p><p>组合模式的静态结构类图如下</p><blockquote><p>将对象组合成树形结构以表示“部分-整体”的层次结构，组合使得用户对单个对象和组合对象的使用具有一致性。</p></blockquote><ul><li>在Cocoa Touch框架中使用组合模式</li></ul><p><code>UIView</code>被组织成一个组合结构，每个UIView的实例可以包含UIView的其他实例，形成统一的树形结构，让客户端对单个UIView对象和UIView的组合统一对待。</p><p>总结</p><p>组合模式的主要意图是让树形结构中的每个节点具有相同的抽象接口。这样整个结构可作为一个统一的抽象结构使用，而不暴露其内部表示。对每个节点（叶节点或组合体）的任何操作，可以通过协议或抽象基类中定义的相同接口来表示。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器提供了一种顺序访问聚合对象（集合）中元素的方法，而无需暴露结构的底层表示和细节。</p><ul><li>Cocoa Touch中使用迭代器模式<br>基础框架中NSEnumarator类实现了迭代器模式。抽象NSEnumater类的私有具体子类返回枚举器对象，能够顺序遍历各种集合-数组、集、字典，把集合中的对象返回给客户端</li></ul><p>总结<br>迭代器模式与访问者模式有些类似，尤其是把便利算法放到访问者模式中或者在便利聚合体时让内部迭代器对元素执行操作的时候。组合模式常常依靠迭代器来便利其递归结构。</p><h2 id="行为扩展"><a href="#行为扩展" class="headerlink" title="行为扩展"></a>行为扩展</h2><h3 id="访问者"><a href="#访问者" class="headerlink" title="访问者"></a>访问者</h3><p>访问者模式涉及两个关键组件，访问者和它访问的元素。元素可以是任何对象，但通常是“部分-整体”结构中的节点</p><blockquote><p>访问者模式：表示一个作用于某对象结构中各元素的操作，它让我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作</p></blockquote><p>访问者模式时扩展组合结构功能的一种强有力的方式，如果组合结构具有精心设计的基本操作，而且结构将来也不会变更，就可以使用访问者模式，用各种不同用途的访问者，以同样的方式访问这个组合结构。</p><h3 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h3><blockquote><p>动态地给一个对象添加一些职责，就扩展功能来说，装饰模式相比生成子类更为灵活。</p></blockquote><ul><li>Cocoa Touch中使用装饰模式<br><code>Categoty</code>是一个<code>Objective-C</code>的语言功能，通过它可以向类添加行为（方法的接口与实现），而不必进行子类化。然而，<code>Categoty</code>并不是一种严格的实现，它实现了模式的意图，但确是一种变体，由<code>Category</code>添加的行为是编译时绑定的，虽然<code>Objective-C</code>原本支持动态绑定。<code>Category</code>实际上没有封装被扩展的类的实例。</li></ul><h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h3><p>对象引用了同一类型的另一个对象，形成一条链，链中的每个对象实现了同样的方法，处理链中第一个对象发起的同一个请求。如果一个对象不知道如何处理请求，它就把请求传给下一个响应器。这个过程会一直进行下去，直到请求被传到链中的最后一个Handller</p><h2 id="算法封装"><a href="#算法封装" class="headerlink" title="算法封装"></a>算法封装</h2><h3 id="模版方法"><a href="#模版方法" class="headerlink" title="模版方法"></a>模版方法</h3><p>在抽象类的一个方法中定义“标准”算法。在这个方法中调用的基本操作应由子类重载予以实现。这个方法被称为<code>模版</code></p><blockquote><p>模版方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中，模版方法使子类可以重定义算法的某些特定步骤而不改变该算法的结构。</p></blockquote><ul><li>Cocoa Touch框架中使用模版方法<br>框架设计师可以把算法中应用程序相关的元素留给应用程序去实现。</li></ul><ol><li>UIView类中的定制绘图<code>-（void）drawRect：（CGRect）rect</code></li><li>UIViewController定义了一些让用户程序处理设备不同方向的方法。</li></ol><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>策略模式中的一个关键组件是策略类，它为所有支持的或相关的算法声明了一个共同接口。</p><blockquote><p>定义一系列算法，把它们一个个封装起来，并且使他们可相互替换。本模式可使得算法可独立于使用它的客户而变化。</p></blockquote><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>把指令封装在各种命令对象中，命令对象可以被传递并且在指定时刻被不同的客户端复用。</p><blockquote><p>命令模式：将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p></blockquote><p>命令对象另一个为人熟知的应用是推迟调用器的执行。</p><ul><li>Cocoa Touch框架中使用命令模式<br>NSInvocation、NSUndoManager和目标-动作机制是框架中对这个模式的典型应用。</li></ul><h2 id="性能与对象访问"><a href="#性能与对象访问" class="headerlink" title="性能与对象访问"></a>性能与对象访问</h2><h3 id="享元（Flyweight-pattern）"><a href="#享元（Flyweight-pattern）" class="headerlink" title="享元（Flyweight pattern）"></a>享元（Flyweight pattern）</h3><p>专门用于设计可共享对象的一种设计模式。<br>实现享元模式需要两个关键组件，通常是可共享的享元对象和保存它们的池。</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理的一个常见用处是作为一个轻量的替身对象，它允许客户端首先访问某些廉价的信息或功能。</p><blockquote><p>代理模式：为其他对象提供一种代理以控制对这个对象的访问。</p></blockquote><ul><li>Cocoa Touch框架中使用代理模式<br>NSProxy实现了NSObject协议，所以NSProxy对象实际上也是NSObject类型，NSProxy的主要作用是，为其他对象的替身对象定义一个API。发给代理对象的消息会被转发给实体对象，或者，让代理加载实体对象或把代理自身变成实体对象</li></ul><h2 id="对象状态"><a href="#对象状态" class="headerlink" title="对象状态"></a>对象状态</h2><h3 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h3><p>用来保存对象的状态并在后来进行恢复</p><blockquote><p>备忘录模式：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p></blockquote><ul><li>Cocoa Touch框架中的备忘录模式<br>Cocoa Touch框架在归档、属性列表序列化、和核心数据中采用了备忘录模式。Cocoa的归档是对对象及其熟悉还有其他对象间的关系进行编码，形成一个文档，该文档可保存于文件系统，也可在进程或网络间传送。被编码与解码的对象必须遵守NSCoding协议并实现一下方法：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-（<span class="type">id</span>）initWithCoder：（<span class="built_in">NSCoder</span>*）coer；</span><br><span class="line">-（<span class="type">void</span>）encodeWithCoder：（<span class="built_in">NSCoder</span>*）coder；</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【读书笔记】Objective-C编程之道：iOS设计模式解析 上</title>
      <link href="/2021/09/21/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%E4%B8%8A/"/>
      <url>/2021/09/21/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<img src="/2021/09/21/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%E4%B8%8A/iOS_design_01.png" class=""><span id="more"></span><blockquote><p>iOS应用程序的基础框架Cocoa Touch框架内容丰富、结构优美，通过将各种设计模式应用到其基础结构中，为第三方开发者提供了很好的可扩展性和灵活性。因此，要充分利用这一框架，应当深刻理解<br>并恰当应用设计模式。本书受到GoF的经典著作《设计模式》的启发，旨在引导大家掌握如何在iOS平台上以Objective-C语言实现Cocoa Touch开发所要用到的传统设计模式。</p></blockquote><h2 id="设计模式初体验"><a href="#设计模式初体验" class="headerlink" title="设计模式初体验"></a>设计模式初体验</h2><h3 id="你好，设计模式"><a href="#你好，设计模式" class="headerlink" title="你好，设计模式"></a>你好，设计模式</h3><p>设计模式是有用的抽象化工具，用于解决工程和建筑等其他领域的设计问题。在软件领域，设计模式是为特定场景下的问题而定制的解决方案。</p><p>通过给程序的变动部分定义接口而对其封装和隔离，这些部分的变动就独立于程序的其他部分，因为他们不依赖于任何细节。以后就可以变更或扩展这些可变的部分而不影响程序的其他部分。</p><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><ol><li>在模型对象中封装数据和基本行为<br>理想状况下，模型对象同用于对其进行显示和编辑的用户界面之间不应有任何直接的关联。</li><li>使用视图对象向用户展示信息<br>视图对象通常从应用程序的模型数据获取数据用以展示，它可以跟一个模型对象的部分、整体或者多个模型对象合作。</li><li>用控制器对象联系起模型和视图<br>控制器对象就像视图对象和模型对象的中间人。它建立起沟通渠道，使视图得以知晓模型的变更而给予响应。</li></ol><p>MVC本身并不是最基本的设计模式，它包含了若干更加基本的设计模式。Cocoa Touch的MVC用到的设计模式有：组合、命令、中介者、策略、观察者。</p><p>组合：视图对象之间的协作方式构成一个视图层次体系。其中既可以有复合视图（UITableView），也可以有独立视图（UITextFIeld和UIButton）。每个层次的每个视图节点都可以响应用户的操作并把自己绘制到屏幕上。</p><p>命令：这是一种“目标-动作”机制，视图对象可以延迟其他对象（比如控制器）的执行，让其他对象等到发生了某些事件后再执行。</p><p>中介者： 控制器对象起着中间人的作用。它构成了在模型和视图对象之间传递数据的双向通道。</p><p>策略： 控制器可以是视图对象的一个“策略”。视图对象将自身隔离，以期维持其作为数据展示器的唯一职责，而将一切应用程序特有的界面行为的决定委派给它的“策略”对象。</p><p>观察者：模型对象向它所关注的控制器对象发出内部状态变化的通知。</p><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p>针对接口编程，而不是针对实现编程</p><ul><li>类继承与接口继承（子类型化）的区别在哪里？</li></ul><p>接口定义了类型，接口继承（子类型化）让我们可以用一个对象代替另一个对象。</p><p>类继承是通过复用父类的功能或者只是简单地共享代码和表述，来定义对象的实现和类型的一种机制。</p><p><strong>区别在于一个对象可以具有多种类型而不同类的对象可以有相同的类型</strong></p><p>子类型的所有对象，都可以针对协议或抽象类的接口的请求作出应答。</p><ul><li>使用协议还是抽象基类？<br>协议（@protocol）并不定义任何实现，而只声明方法，以确定符合协议的类的行为。因此协议是只定义了抽象行为的“接口”</li></ul><p>抽象基类（Abstract Base Class） 通过抽象基类，我们可以生成一些其他子类可以共享的默认行为。</p><p><strong>抽象基类与通常的类相似，只是预留了一些可以或应该由子类重载的行为</strong></p><p>变更过去定义的协议可能会破坏实现该协议的类，协议是抽象类型与具体类型之间的一种合约，如果变更合约，所有相关的事项也需要变更。唯一例外是，只使用@optional指定将协议的部分方法变为“可选的”</p><p>抽象基类在接口变更方面要稍微灵活一些。可以向抽象基类随意追加新的方法，而不会破坏继承链的其他部分。而且，对于子类可能用到的占位方法中定义的默认行为，可以随意地进行追加、删除或分解。</p><p>只对一个抽象类型进行子类化的类，可以让它们直接对抽象类型进行子类化。若是以后更改设计，以使抽象类型也能够是UIView等的子类，通常的灵活做法是，首先为不需要子类化其他类的类定义一个抽象基类，然后可以定义一个同名协议，让包括这个抽象基类在内的其他类去实现。例如NSObject基类符合NSObject协议。</p><p>对象组合与类继承<br>子类化常常被称为白箱复用，因为父类的内部描述与细节通常对子类可见<br>对象组合要求被组合的对象具有定义良好的接口，并且通过从其他对象得到的引用在运行时动态定义。所以可以将对象组合到其他对象中，以构建更加复杂的功能。由于对象的内部细节对其他对象不可见，这种类型的复用称为黑箱复用。</p><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>在许多面向对象的应用程序中，有些对象的创建代价过大或过于复杂，要是可以重建相同的对象并作轻微的改动，事情会容易很多。应用于“复制”操作的模式称为原型（Protorype）模式。复制（cloning）指用同一模具生产一系列的产品。</p><blockquote><p>指针只是存储内存中资源地址的占位符</p></blockquote><ul><li>Cocoa Touch框架中对象复制<br>框架为NSObject的派生类提供了实现深复制的协议，NSObject的子类需要实现NSCopying协议及其方法<code>(id)copywithZone:(NSZone*)zone</code></li></ul><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>工厂方法也称为虚构造器。它适用于这种情况：一个类无法预期需要生成哪个类的对象，想让其子类来指定所生成的对象。</p><ul><li>Cocoa Touch 框架中应用工厂方法<br><code>[[SomeClass alloc]init]</code>.NSNumber有很多numberWith*方法：numberWithBool：和numberWithChar：</li></ul><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>抽象工厂提供一个固定的接口，用于创建一系列有关联或相依存的对象，而不必指定其具体类或其创建的细节。</p><blockquote><p>软件设计的黄金法则：变动需要抽象</p></blockquote><ul><li>Cocoa Touch框架中使用抽象工厂<br>创建Cocoa Touch对象有两种方式，使用allloc再init的方法，或者使用类中的+className…方法。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span>* boolNumber = [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSNUmber</span>* charNumber=[<span class="built_in">NSNumber</span> numberWithChar:<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>接受不同类型的参数并返回NSNumber实例的类方法是类工厂方法</p><p>类簇是基础框架中一种常见的设计模式，基于抽象工厂模式的思想。将若干相关的私有具体工厂子类集合到一个公有的抽象超类之下。类簇是抽象工厂的一种形式。比如NSNumber本身是一个高度抽象的工厂，而NSCFBollean和NSCFNumber是具体的工厂子类。</p><blockquote><p>其它实现为类簇的基础类有NSData、NSArray、NSDictionary、NSString</p></blockquote><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>有时构建某些对象有多种不同方式，如果这些逻辑包含在构建这些对象的类的单一方法中，其构建的逻辑会非常混乱（针对各种构建需要一大片嵌套if-else或者swifth-case）。如果能够把构建过程分解为客户-指导者-生成器的关系，那么过程将更容易管理与复用。</p><p>生成器模式能够帮助构建涉及部件与表现的各种组合的对象。</p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><blockquote><p>singleton定义为“有且仅有一个元素的集合”</p></blockquote><p>单例类总是返回自己的同一个实例，它提供了对类的对象所提供的资源的全局访问点。</p><ul><li>在Cocoa Touch框架中使用单例模式<br>UIApplication、UIAccelerometer、NSFileManager</li></ul><h2 id="接口适配"><a href="#接口适配" class="headerlink" title="接口适配"></a>接口适配</h2><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>适配器模式，用于连接两种不同种类的对象，使其毫无问题地协同工作。（把类的接口变换为客户端要求的另一种接口）</p><ul><li>两种实现适配器的方式</li></ul><p>第一种是通过继承来适配两个接口，称为类适配器。（c++中类适配器是通过多重继承实现的，Objectivve-C中，类可以实现协议，同时又继承超类，达到C++的多重继承的效果）</p> <img src="/2021/09/21/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%E4%B8%8A/iOS_design_02.png" class=""><p> 第二种方式称为对象适配器，对象适配器不继承被适配者，而是组合了一个对它的引用。</p>  <img src="/2021/09/21/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%E4%B8%8A/iOS_design_03.png" class=""><ul><li>在Cocoa Touch框架中使用委托模式<br>  Delegate是Cocoa Touch框架所采用的委托模式的一种形式，这里的客户端是Cocoa Touch框架中的类，Target是委托协议，实现协议的类会是个适配器，应用程序中的其它类是与框架不匹配而需要适配的类。</li></ul><h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h3><p>桥接模式的目的是把抽象层次结构从其实现中分离出来，使其能够独立变更。抽象层定义了供客户端使用的上层的抽象接口，实现层定义了供抽象层次使用的底层接口。实现类的引用被封装于抽象层的实例中时，桥接就形成了。</p>  <img src="/2021/09/21/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%E4%B8%8A/iOS_design_04.png" class=""><h3 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h3><p>为系统中的一组接口提供一个统一的接口，外观定一个一个高层接口，让子系统更易于使用</p><h2 id="对象去耦"><a href="#对象去耦" class="headerlink" title="对象去耦"></a>对象去耦</h2><h3 id="中介者"><a href="#中介者" class="headerlink" title="中介者"></a>中介者</h3><p>用一个对象来封装一系列对象的交互方式。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><blockquote><p>中介者模式以中介者内部的复杂性代替交互的复杂性，因为中介者封装与合并了客户端的各种协作逻辑，自身可能变得比它们任何一个都复杂，这会让中介者本身成为无所不知的庞然大物，并且难以维护，此时，可以考虑使用另一种设计模式把它分解，要创造性的混用和组合设计模式解决同一个问题，每个设计模式就像一个乐高积木块，整个应用程序可能要使用彼此配合的各种“积木块”来建造。</p></blockquote><h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>观察者模式也叫做发布-订阅模式。定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都能得到通知并被自动更新。</p><ul><li>Cocoa Touch中使用观察者模式</li></ul><ol><li>通知NSNotificationCenter</li><li>健-值观察KVO（基于NSKeyValueObserving非正式协议）</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="">Objective-C 编程之道：iOS设计模式解析</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门</title>
      <link href="/2021/08/22/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/08/22/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Git从入门到熟练"><a href="#Git从入门到熟练" class="headerlink" title="Git从入门到熟练"></a>Git从入门到熟练</h2><h3 id="1-分布式版本控制"><a href="#1-分布式版本控制" class="headerlink" title="1. 分布式版本控制"></a>1. 分布式版本控制</h3><ul><li>集中式VS分布式</li></ul><img src="/2021/08/22/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/cvcs.png" class="&#x3D;"><img src="/2021/08/22/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/dvcs.png" class="&#x3D;"><span id="more"></span><h3 id="保存更新时的文件快照而非差异"><a href="#保存更新时的文件快照而非差异" class="headerlink" title="保存更新时的文件快照而非差异"></a>保存更新时的文件快照而非差异</h3><p>（快照 ：是文件系统中的概念或者技术；来自照相领域的概念，是指特定时间点的一个状态）</p><p>其他系统在每个版本中记录着各个文件的具体差异</p><img src="/2021/08/22/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/delta-record-style.png" class="&#x3D;"><p>Git 保存每次更新时的文件快照，Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件做快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览所有文件的指纹信息并对文件做快照，然后保存一个指向这次快照的索引。对于没有发生变化的文件，Git 不会再次保存，只做一个链接指向上次保存的快照来提高性能。Git 更像是一个小型的文件系统。</p><img src="/2021/08/22/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/snapshot-record-style.png" class="&#x3D;"><ul><li>Git Patch 应用  打补丁，不等同于快照</li><li>git format-patch 用法</li></ul><p>基于上几次内容打包<br>git format-patch HEAD^  有几个^就会s打几个patch，从最近一次打起<br>git format-patch HEAD^^ 最近的二个patch内容<br>以下代码作用同上<br>git format-patch -1 <br>git format-patch -2</p><p>* </p><p>应用patch<br>git am -s &lt; 0001-minor-fix.patch</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>Git初探<a href="Git%E5%88%9D%E6%8E%A2">http://www.samirchen.com/git-commands/</a></li><li>快照技术详解<a href="">http://blog.csdn.net/sky1203850702/article/details/46830851</a></li><li>Patch 使用<a href="">http://blog.csdn.net/xzongyuan/article/details/9425739</a><a href="">https://www.jianshu.com/p/814fb6606734</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UML统一建模语言</title>
      <link href="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/"/>
      <url>/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>UML 明明是一种图形，为什么说是语言呢？</p><p>语言是包括文字和图形的，有很多内容文字是无法表达的。</p><p>你见过建筑设计图纸吗？里面还不是很多图形，光用文字能表达清楚建筑设计吗？在建筑界，有一套标准来描述设计，同样道理，在软件开发界，我们也需要一套标准来帮助我们做好软件开发的工作。</p><span id="more"></span><h2 id="基本构件"><a href="#基本构件" class="headerlink" title="基本构件"></a>基本构件</h2><p>UML 建模的核心是模型，模型是现实的简化、真实系统的抽象。</p><p>描述模型所使用的语言被称为建模语言。在 UML 中，所有的描述由<code>事物</code>、<code>关系</code>和<code>图</code>这些构件组成。</p><img src="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML001.png" class=""><h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><p>事物是抽象化的最终结果，分为结构事物、行为事物、分组事物和注释事物。</p><ol><li>结构事物<br>结构事物是模型中的静态部分，用以呈现概念或实体的表现元素，如下表所示。</li></ol><img src="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML002.png" class=""><ol start="2"><li>行为事物<br>行为事物指 UML 模型中的动态部分，如下表所示</li></ol><img src="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML003.png" class=""><ol start="3"><li>分组事物<br>目前只有一种分组事物，即包。包纯碎是概念上的，只存在于开发阶段，结构事物、行为事物甚至分组事物都有可能放在一个包中，如下表所示。</li></ol><img src="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML004.png" class=""><ol start="4"><li>注释事物<br>注释事物是解释 UML 模型元素的部分，如下表所示。<img src="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML005.png" class=""></li></ol><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>UML2.0 一共有 13 种图</p><img src="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML006.png" class=""><h2 id="类、接口和类图"><a href="#类、接口和类图" class="headerlink" title="类、接口和类图"></a>类、接口和类图</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。</p><p>(1) 类名（Name）是一个字符串，例如，Student。</p><p>(2) 属性（Attribute）是指类的特性，即类的成员变量。</p><p>UML 按以下格式表示：</p><p>[可见性]属性名:类型[&#x3D;默认值]</p><p>例如：-name:String</p><p>注意：“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示</p><p>(3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。</p><p>UML 按以下格式表示：<br>[可见性]名称(参数列表)[:返回类型]<br>例如：+display():void</p><p>如下所示是学生类的 UML 表示<br>￼</p><img src="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML007.gif" class=""><p>类图用 3 个矩形拼接表示，最上面的部分标识类的名称，中间的部分标识类的属性，最下面的部分标识类的方法</p><p>类图中，需注意以下几点：</p><ul><li>抽象类或抽象方法用斜体表示</li><li>如果是接口，则在类名上方加 &lt;<Interface>&gt;</li><li>字段和方法返回值的数据类型非必需</li><li>静态类或静态方法加下划线</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。</p><p>如下所示是图形类接口的 UML 表示</p><img src="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML008.gif" class=""><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。</p><p>类图中的类可以通过某种编程语言直接实现。类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。</p><p>如下所示是“计算长方形和圆形的周长与面积”的类图，图形接口有计算面积和周长的抽象方法，长方形和圆形实现这两个方法供访问类调用。</p><img src="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML009.gif" class=""><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><p>UML 将事物之间的联系归纳为 6 种，并用对应的图形类表示。<br>下面根据类与类之间的耦合度从弱到强排列。UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。</p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p><p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。</p><p>如下是人与手机的关系图，人通过手机的语音传送方法打电话</p><img src="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML010.gif" class=""><h3 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h3><p>关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。</p><p>关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。</p><p>在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。</p><p>如下是老师和学生的关系图，每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联</p><img src="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML011.gif" class=""><h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。</p><p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。<br>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。</p><p>如下是大学和教师的关系图</p><img src="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML012.gif" class=""><h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系</p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。</p><p>例如，头和嘴的关系，没有了头，嘴也就不存在了</p><p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。</p><p>如下是头和嘴的关系图。</p><img src="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML013.gif" class=""><h3 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h3><p>泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。<br>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。</p><p>Student 类和 Teacher 类都是 Person 类的子类，其类图如下所示</p><img src="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML015.gif" class=""><h3 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h3><p>实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。</p><p>例如，汽车和船实现了交通工具，其类图如下所示</p><img src="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML016.gif" class=""><h3 id="类关系总结"><a href="#类关系总结" class="headerlink" title="类关系总结"></a>类关系总结</h3><ul><li><p>关系可以解读如下:<br>(依赖)Dependency : A类使用了B类<br>(关联)Association：A类有B类有逻辑上的连接<br>(聚合)Aggregation : A类有一个B类<br>(组合)Composition : A类拥有一个B类<br>(继承)Inheritance : B类是一个A类  (或者B类扩展A类)<br>(实现)Realization : B类实现了接口A</p></li><li><p>类关系记忆技巧总结如下表所示</p></li></ul><img src="/2021/06/17/UML%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/UML017.png" class=""><p>注意：UML 的标准类关系图中，没有实心箭头。有些 Java 编程的 IDE 自带类生成工具可能出现实心箭头，主要目的是降低理解难度。</p><p>下面用一个经典案例来加深和巩固对类图的理解。下图是对动物衍生关系描述的类图。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="http://c.biancheng.net/view/8373.html">UML统一建模语言是什么</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>程序员的健康修养（高尿酸血症）</title>
      <link href="/2021/06/15/%E9%AB%98%E5%B0%BF%E9%85%B8%E8%A1%80%E7%97%87/"/>
      <url>/2021/06/15/%E9%AB%98%E5%B0%BF%E9%85%B8%E8%A1%80%E7%97%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>19年体检，查出尿酸偏高 452 umol&#x2F;L，查了下有什么潜在疾病风险，其中就有痛风<br>21年体检，尿酸偏高441 umol&#x2F;L，两周后，右脚大拇指关节处剧痛，痛风来了。</p></blockquote><blockquote><p>高尿酸血症和痛风的发病率呈逐年上升趋势，我国高尿酸血症患病率约为13.3%，约1&#x2F;3的高尿酸血症患者最终发展为痛风。 痛风可表现为关节炎、皮肤病变及肾脏损害等，严重影响生活质量</p></blockquote><span id="more"></span><h3 id="人类为什么要尿尿"><a href="#人类为什么要尿尿" class="headerlink" title="人类为什么要尿尿"></a>人类为什么要尿尿</h3><p>尿尿不是所有的动物都有的，通常只有哺乳动物才有</p><ul><li>为什么人类要有尿呢？</li></ul><ol><li>可以调节我们体内水和电解质的平衡，清除代谢废物</li><li>散热</li></ol><ul><li>尿是如何形成的呢？</li></ul><p>我们的心脏就像一个发动机一直推着血液在全身走，血液经过两个<code>肾</code>的时候，其中的水分以及晶体物会被<code>肾小球</code>过滤，肾小球会确保比较大的蛋白质还保留在血液里，过滤出来的物质会进入<code>肾小管</code>，肾小管又会把里面的营养物质（大部分水分以及无机盐）重新吸收回血液，最后剩下来的主要是蛋白质代谢后产生的<code>尿素</code>以及<code>尿酸</code>,<code>氨</code>等非蛋白氮化合物。</p><blockquote><p>尿液约95%是水，5%是废弃产物</p></blockquote><p> 这个是啥？<br><code>细菌可以分解尿素，产生氨的气味</code></p><ul><li>尿的作用</li></ul><blockquote><p>人尿，气味咸，寒，无毒，主治温热头痛，童男者尤良       《本草纲目》</p></blockquote><blockquote><p>症积满腹，诸药不愈者，人溺服一升，二十日即出也  记载过使用尿液治疗胃癌的例子   《唐本草》</p></blockquote><p>通常哺乳类动物，喜欢用尿液来标识领土，宣誓主权。</p><h3 id="高尿酸是什么"><a href="#高尿酸是什么" class="headerlink" title="高尿酸是什么"></a>高尿酸是什么</h3><h4 id="尿酸"><a href="#尿酸" class="headerlink" title="尿酸"></a>尿酸</h4><p>分子式为<code>C₅H₄N₄O₃</code>，</p><img src="/2021/06/15/%E9%AB%98%E5%B0%BF%E9%85%B8%E8%A1%80%E7%97%87/001.png" class=""><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>高尿酸症状的医学说法叫：高尿酸血症（hyperuricemia，简称 HUA）。</p><p>高尿酸是指血液中尿酸的浓度超过了健康人的指标。血尿酸正常值：</p><p>成人男性为<code> 149～416μmol/L</code> ；女性为 <code>89～357μmol/L</code>。<br>年龄大于 60 岁的男性为：<code>250～476μmol/L</code>； 女性为：<code>190～434μmol/L</code></p><blockquote><p>痛风是一种因嘌呤代谢障碍而尿酸累积而引起的疾病</p></blockquote><blockquote><p>痛风性关节炎是由于尿酸盐沉积在关节囊、滑囊、软骨、骨质和其他组织中而引起病损及炎性反应，其多有遗传因素，好发于40岁以上男性，多见于第一跖趾关节，也可发生于其他较大关节，尤其是踝部与足部关节</p></blockquote><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>尿酸在血液中的浓度如果过高，就不能完全溶解于血液中，于是就会出现析出结晶。这些结晶在关节处累积，就会诱发痛风。</p><h4 id="来源和排泄"><a href="#来源和排泄" class="headerlink" title="来源和排泄"></a>来源和排泄</h4><p>尿酸在人体内是<code>嘌呤</code>的最终代谢物.</p><p>整体上人体的尿酸来自两类：</p><p>内源性。依赖于自身代谢产生，这部分占到体内尿酸总量的 80%。<br>外源性。从饮食中直接摄入的，这部分占到体内尿酸总量的 20%。</p><p>尿酸产生之后，主要通过肾脏排泄（占比 70%），其余通过消化道排泄。</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><blockquote><p>腹部有肥胖、经常饮水过少、经常进行无氧运动而不事后按摩舒缓、先天体质特殊，很容易在新陈代谢过程中，无法将摄取的嘌呤进一步代谢成为可以从肾脏中经尿液排出的排泄物。而这些物质最终形成过多尿酸，再经血液流向（软）结缔组织，以结晶体积存于其中，如果有诱因引起沉积在软组织如关节膜里的尿酸结晶释出，那便导致身体免疫系统过度反应（敏感）而造成炎症（痛风症）</p></blockquote><ul><li>产生高尿酸的原因主要是两种：</li></ul><ol><li>来源来得太多了。主要包括自身代谢紊乱（内源性）或者饮食中摄入（外源性）太多。</li><li>排泄得太少。主要是肾脏排泄能力下降导致。</li></ol><p>当你体检时发现尿酸高的时候，医生或者朋友第一个建议你的事情就是：在饮食上进行控制，进行低嘌呤饮食。嘌呤主要来源于<code>海鲜、内脏以及肉汤</code>。</p><p>这部分只占到体内尿酸生成总量的 20%。所以如果是自身代谢紊乱或者肾脏排泄能力下降的话，即便是低嘌呤饮食也无法降低尿酸。</p><p>医生可以通过测量 24 小时尿尿酸来判断是否排泄减少：</p><p>小于 600mg(3.6mmol) 定义为尿酸排泄减少型<br>超过 800mg(4.8mmol) 定为尿酸产生过多型<br>研究表明，有 90% 的原发性高尿酸都是排泄减少型。对于排泄减少型，即使你坚持低嘌呤饮食，影响也相当有限。</p><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p>精确地测量尿酸值，需要到医院抽晨血（抽血前不能进食）。</p><p>可以购买尿酸测试仪在家自行测量</p><h3 id="治疗"><a href="#治疗" class="headerlink" title="治疗"></a>治疗</h3><h4 id="低嘌呤饮食"><a href="#低嘌呤饮食" class="headerlink" title="低嘌呤饮食"></a>低嘌呤饮食</h4><p>饮食对于尿酸的影响占比是20%</p><p>严禁的食物是：</p><ol><li>动物内脏，比如鹅肝。</li><li>海鲜。</li><li>浓肉汤和肉汁。</li><li>酒。</li></ol><p>高尿酸鼓励吃的食物是：</p><ol><li>脱脂或低脂奶制品</li><li>鸡蛋</li><li>蔬菜</li><li>低生糖指数谷物</li><li>饮水大于 2000 ML</li></ol><blockquote><p>现在研究只能证明啤酒和烈酒会引发痛风，而红酒与痛风的相关性证据还不足，所以你如果实在忍不住，就喝红酒吧。</p></blockquote><h4 id="药物治疗（别嘌醇片）"><a href="#药物治疗（别嘌醇片）" class="headerlink" title="药物治疗（别嘌醇片）"></a>药物治疗（别嘌醇片）</h4><p>药物治疗帮助排泄尿酸，常用的有别嘌醇、洛芬待因，秋水仙碱可以缓解痛风发作时的症状，但不会降低尿酸的水平</p><p>别嘌醇是一个老药，1966 年在美国被FDA批准上市，到现在已经经过了半个世纪的使用</p><p>别嘌醇的用量：</p><p>初使剂量：50mg，一天1-2次。<br>一般剂量：200-300mg 一天。<br>最高剂量：600mg 一天。</p><p>风险：<br>别嘌醇对部分人会有超敏反应，严重情况致死。所以服用初期要密切关注身体状况。后来人们研究发现，超敏反应与白细胞 HLA-B5801 基因相关，所以在国内，有条件的医院就会在患者服用别嘌醇前，给他开HLA-B5801 基因的检测</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【读书笔记】核心动画高级技巧</title>
      <link href="/2021/05/30/%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/05/30/%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Core Animation 是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的图层，存储在一个叫做图层树的体系之中</p></blockquote><p><em>iOS核心动画高级技巧书籍笔记，再结合项目最近遇到的动画做个总结。</em></p><span id="more"></span><h4 id="图层树"><a href="#图层树" class="headerlink" title="图层树"></a>图层树</h4><p>每一个UIView都有一个CALayer实例的图层属性，也就是所谓的bcking layer，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。</p><p><strong>为什么iOS要基于UIVIew和CALayer提供两个平行的层级关系？</strong><br>原因在于要做职责分离，在iOS和Mac OS两个平台上，事件和用户交互方式不同，一个基于多点触控，一个基于鼠标键盘，iOS有UIKit和UIView，Mac OS有Appkit和NSView。但是绘图，布局和动画，这部分就是类似的，把这种功能逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码。</p><p><strong>UIVIew没有暴露出来的CALayer功能</strong></p><ol><li>阴影，圆角，带颜色的边框</li><li>3D变换</li><li>非矩形范围</li><li>透明遮罩</li><li>多级非线形动画</li></ol><p><strong>什么时候使用CALayer而不是UIView</strong></p><ol><li>开发同时可以在Mac OS上运行的跨平台应用</li><li>使用多种CALayer的子类，并且不想创建额外的UIVIew去包封装它们所有</li><li>做一些对性能特别挑剔的工作</li></ol><h4 id="寄宿图"><a href="#寄宿图" class="headerlink" title="寄宿图"></a>寄宿图</h4><p><strong>contentsScale</strong><br>contentsScale定义了寄宿图的像素尺寸和视图大小的比例。默认情况下它是一个值为1.0的浮点数</p><p><code> layer.contentsScale = [UIScreen mainScreen].scale;</code></p><p><strong>contentsRect</strong><br>CALayer的contentsRect属性允许我们在图层边框里显示寄宿图的一个子域。它使用单位坐标。默认的 contentsRect 是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的</p><p>点（点就是虚拟的像素，也叫做逻辑像素，在Retina设备上，一个点等于2*2个像素）</p><p>单位（对于图片大小或是图层边界相关，当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多）</p><img src="/2021/05/30/%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/contentsRect.png" class=""><p><strong>contentsCenter</strong><br>contetnsCenter是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。默认情况下， 是{0, 0, 1, 1}</p><p>设置为{0.25, 0.25, 0.5, 0.5}的效果</p><img src="/2021/05/30/%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/contentsCenter.png" class=""><p><strong>寄宿图赋值的方式</strong></p><ol><li><code> layer.contents = (__bridge id)image.CGImage;</code></li><li>Core Graphics直接绘制寄宿图,通过继承UIView并实现 <code>-drawRect: </code>方法 来自定义绘制</li></ol><p>-drawRect:方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到drawRect方法被调用，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以contentsScale的值</p><p><em>不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容，它把重绘的决定权交给了开发者</em></p><h4 id="图层几何学"><a href="#图层几何学" class="headerlink" title="图层几何学"></a>图层几何学</h4><p>UIView三个布局属性frame，bounds，center，CALayer对应frame，bounds，position</p><h4 id="视觉效果"><a href="#视觉效果" class="headerlink" title="视觉效果"></a>视觉效果</h4><h5 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h5><p>阴影的表现由三个属性 shadowColor，shadowOffset，shadowRadius</p><p>shadowOffset控制着阴影的方向和距离，是一个CGSize值，宽度控制横向位移，高度控制纵向位移，默认值为{0,-3}，意即阴影相对于Y轴有3个点的向上位移。</p><p>shadowRadius控制阴影的模糊度，为0的时候，阴影就和视图一样有一个非常确定的边界线，值越大，边界线就会越来越模糊和自然</p><p><strong>阴影和裁剪同时存在的时候？</strong><br>阴影通常就是在Layer的边界之外，如果你开启了masksToBounds属性，所有图层中突出来的内容都会被裁减掉。这个时候需要用到两个图层，一个只画阴影的空的外图层，和一个用maskToBounds裁剪内容的内图层。</p><p>shadowPath属性<br>用来指定阴影的形状，是一个CGPathRef类型（一个指向CGPath的指针），CGPath是一个Core Graphics对象，用来指定任意的一个矢量图形。</p><h5 id="图层蒙版"><a href="#图层蒙版" class="headerlink" title="图层蒙版"></a>图层蒙版</h5><p>masksToBounds属性可以沿边界裁剪图形，使用图层蒙版可以将展示内容不是在一个矩形或圆角矩形。</p><p><em>使用一个32位有alpha通道的png图片通常是创建一个无矩形视图最方便的方法，可以给它指定一个透明蒙版来实现。</em></p><p>mask图层定义了父图层的部分可见区域。mask图层的属性是无关紧要的，真正重要的是图层的轮廓，</p><p><em>蒙版层不局限于静态图，任何有图层构成的都可以作为mask属性，这意味着你的梦版可以通过代码甚至是动画实时生成</em></p><h5 id="组透明"><a href="#组透明" class="headerlink" title="组透明"></a>组透明</h5><p>UIView有一个叫做alpha的属性来确定视图的透明度，CALayer有一个等同的属性叫做opacity。这两个属性都是影响子层级的。</p><p>当显示一个50%透明度的图层时，图层的每个像素都会一半显示自己的颜色，另一半显示图层下面的颜色。当你设置了一个图层的透明度，你希望它包含的整个图层树像一个整体一样的透明效果，可以通过设置CALayer的shouldRasterize属性来实线组透明效果。如果它被设置成YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了。</p><blockquote><p>CALayer 有一个叫做 doubleSided 的属性来控 制图层的背面是否要被绘制。这 是一个 BOOL 类型，默认为 YES ，如果设置为 NO ，那么当图层正面从相机视角 消失的时候，它将不会被绘制</p></blockquote><h4 id="专用图层"><a href="#专用图层" class="headerlink" title="专用图层"></a>专用图层</h4><h5 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h5><p>一个通过矢量图形而不是bitmap来绘制的图层子集，指定诸如颜色和线宽等属性，用CGPath来定义想要绘制的图形，最后CAShapeLayer就自动渲染出来了。</p><p>优点<br>CAShapeLayer使用了硬件加速，绘制同一图形会比用CoreGraphics快很多<br>不需要像普通CALayer一样创建一个寄宿图，所以无论有多大，都不会占用太多内存。</p><h5 id="CAReplicatorLayer"><a href="#CAReplicatorLayer" class="headerlink" title="CAReplicatorLayer"></a>CAReplicatorLayer</h5><p>可以高效生成许多相似的图层。</p><h5 id="CATiledLayer"><a href="#CATiledLayer" class="headerlink" title="CATiledLayer"></a>CATiledLayer</h5><p>为载入大图造成的性能问题提供了一个解决方案，将大图分解成小片，然后将他们单独按需载入。CATiledLayer支持多线程绘制，<code>drawLayer:inContext:</code>方法可以在多个线程中同时地并发调用。</p><h4 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h4><h5 id="隐式动画-1"><a href="#隐式动画-1" class="headerlink" title="隐式动画"></a>隐式动画</h5><p>把改变属性时 CALayer 自动应用的动画称作隐式动画</p><p>动画执行的时间取决于当前事务的设置，动画类型取决于图层行为。</p><p><strong>隐士动画如何实现</strong><br>当 CALayer 的属性被修 改时候，它会调用 -actionForKey: 方法，传递属性的名称。剩下的操作都 在 CALayer 的头文件中有详细的说明，实质上是如下几步：</p><ol><li>图层首先检测它是否有委托，并且是否实现 CALayerDelegate 协议指定的 - actionForLayer:forKey 方法。如果有，直接调用并返回结果。</li><li>如果没有委托，或者委托没有实现 -actionForLayer:forKey 方法，图层接 着检查包含属性名称对应行为映射的 actions 字典。</li><li>如果 actions字典 没有包含对应的属性，那么图层接着在它的 style 字典接 着搜索属性名。 </li><li>最后，如果在 style 里面也找不到对应的行为，那么图层将会直接调用定义 了每个属性的标准行为的 -defaultActionForKey: 方法。</li></ol><p>一轮完整的搜索结束之后， -actionForKey: 要么返回空（这种情况下将不 会有动画发生），要么是 CAAction 协议对应的对象，最后 CALayer 拿这个结果 去对先前和当前的值做动画。</p><p><strong>UIKit是如何禁用隐式动画的？</strong><br>每个 UIView 对它关联的图层都扮 演了一个委托，并且提供了 -actionForLayer:forKey 的实现方法。当不在一个 动画块的实现中， UIView 对所有图层行为返回 nil ，但是在动画block范围之 内，它就返回了一个非空值</p><h5 id="事务-（CATransaction）"><a href="#事务-（CATransaction）" class="headerlink" title="事务 （CATransaction）"></a>事务 （CATransaction）</h5><p>事务实际上是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，，而是当事务一旦提交的时候开始用一个动画过度到新值。</p><p>Core Animation在每个run loop周期中自动开始一次新的事务（run loop是iOS负责 收集用户输入，处理定时器或者网络事件并且重新绘制屏幕的东西），即使你不显 式的用 [CATransaction begin] 开始一次事务，任何在一次run loop循环中属性 的改变都会被集中起来，然后做一次0.25秒的动画</p><h5 id="呈现于模型"><a href="#呈现于模型" class="headerlink" title="呈现于模型"></a>呈现于模型</h5><p><strong>改变一个图层的属性并没有立刻生效，而是通过一段时间渐变更新，如何实现的？</strong><br>当你改变一个图层的属性，属性值的确是立刻更新的，但是屏幕上没有马上发生改变，这是因为你设置的属性并没有直接调整图层的外观，相反它只是定义了图层动画结束后将要变化的外观。</p><p>设置CALayer属性，实际上是在定义当前事务结束之后图层如何显示的模型，Core Animation扮演了一个控制器的角色，并且负责根据图层行为和事务设置去不断更新视图的这些属性在屏幕上的状态。</p><p>每个图层属性的显示值都被存储在一个叫做呈现图层的独立图层当中，他可以通 过 -presentationLayer 方法来访问。它的属性值代表了在任何指定时刻当前外观效果。换句话说，你可以通过呈现 图层的值来获取当前屏幕上真正显示出来的值</p><h4 id="显式动画"><a href="#显式动画" class="headerlink" title="显式动画"></a>显式动画</h4><p>它能够对一些属性做指定的自定义动画，或者创 建非线性动画，比如沿着任意一条曲线移动</p><p>过渡动画</p><p>过渡动画做基础的原则就是对原始的图层 外观截图，然后添加一段动画，平滑过渡到图层改变之后那个截图的效果</p><h4 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h4><p>尽可能把屏幕渲染的工作交给硬件（GPU）去处理</p><p>动画和屏幕上组合的图层实际上被一个单独的进程管理，而不是你的应用程序。 这个进程就是所谓的渲染服务</p><p>应用内的FPS显示并不能够完全真实测量 出Core Animation性能，因为它仅仅测出应用内的帧率。我们知道很多动画都在应 用之外发生（在渲染服务器进程中处理）</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS内存泄漏总结</title>
      <link href="/2021/01/28/iOS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2021/01/28/iOS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="内存泄漏和内存溢出"><a href="#内存泄漏和内存溢出" class="headerlink" title="内存泄漏和内存溢出"></a>内存泄漏和内存溢出</h4><blockquote><p>内存泄漏（memory leak）：是指申请的内存空间使用完毕之后未回收。 一次内存泄露危害可以忽略，但若一直泄漏，无论有多少内存，迟早都会被占用光，最终导致程序crash</p></blockquote><blockquote><p>内存溢出（out of memory）：是指程序在申请内存时，没有足够的内存空间供其使用。<br>通俗理解就是内存不够用了，通常在运行大型应用或游戏时，应用或游戏所需要的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。最终导致机器重启或者程序crash</p></blockquote><span id="more"></span><h4 id="内存泄漏常见场景"><a href="#内存泄漏常见场景" class="headerlink" title="内存泄漏常见场景"></a>内存泄漏常见场景</h4><h5 id="非OC对象内存处理"><a href="#非OC对象内存处理" class="headerlink" title="非OC对象内存处理"></a>非OC对象内存处理</h5><ol><li>CF类型内存以creat,copy作为关键字的函数都是需要释放内存的，注意配对使用。比如：<code>CGColorCreate&lt;--&gt;CGColorRelease</code></li><li>CoreFoundation类型</li><li>C语言代码中的malloc等需要对应free等</li></ol><h5 id="delegate循环引用"><a href="#delegate循环引用" class="headerlink" title="delegate循环引用"></a>delegate循环引用</h5><p>注意将代理属性修饰为weak即可. 例如:<br>ViewController的self.view持有了UITableView. 所以UITableView的delegate和dataSource就不能持有ViewController. 所以要使用weak来修饰.</p><h5 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h5><p>NSTimer会造成循环引用，timer会强引用target即self，一般self又会持有timer作为属性，这样就造成了循环引用。</p><p>只要申请了timer，加入了runloop，并且target是self，虽然不是循环引用，但是self却没有释放的时机。如下方式申请的定时器，self已经无法释放了。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">5</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(commentAnimation) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决方案：</p><p>NSProxy方式<br>建立一个proxy类，让timer强引用这个实例，这个类中对timer的使用者target采用弱引用的方式，再把需要执行的方法都转发给timer的使用者。</p><h5 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h5><p>使用block的方式增加notification，引用了self，在删除notification之前，self不会被释放，与timer的场景类似，其实这段代码已经声明了weakself，但是调用_eventManger方法还是引起了循环引用。<br>也就是说，即使我们没有调用self方法，_xxx也会造成循环引用。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:kUserSubscribeNotification object:<span class="literal">nil</span> queue:<span class="literal">nil</span> usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123;</span><br><span class="line">    <span class="keyword">if</span> (note) &#123;</span><br><span class="line">        Model *model=(Model *)note.object;</span><br><span class="line">        <span class="keyword">if</span> ([model.subId integerValue] == [weakSelf.subId integerValue]) &#123;</span><br><span class="line">            [_eventManger playerSubsciption:<span class="literal">NO</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h5><p>block中导致的内存泄漏常常就是因为强引用互相之间持有而发生了循环引用无法释放. AFNetWorking上的经典代码, 防止循环引用.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建__weak弱引用，防止强引用互相持有</span></span><br><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">    <span class="comment">//创建局部__strong强引用，防止多线程情况下weakSelf被析构</span></span><br><span class="line">     __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line">    strongSelf.networkReachabilityStatus = status;</span><br><span class="line">    <span class="keyword">if</span> (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">         strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="大次数循环内存暴涨问题"><a href="#大次数循环内存暴涨问题" class="headerlink" title="大次数循环内存暴涨问题"></a>大次数循环内存暴涨问题</h5><p>循环内产生大量的临时对象, 直至循环结束才释放, 可能导致内存泄漏, 解决方法为在循环中创建自己的autoReleasePool, 及时释放占用内存大的临时变量, 减少内存占用峰值.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">or (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">       <span class="built_in">NSString</span> *string = <span class="string">@&quot;Abc&quot;</span>;</span><br><span class="line">       string = [string lowercaseString];</span><br><span class="line">       string = [string stringByAppendingString:<span class="string">@&quot;xyz&quot;</span>];</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, string);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="RAC中潜在的内存泄漏"><a href="#RAC中潜在的内存泄漏" class="headerlink" title="RAC中潜在的内存泄漏"></a>RAC中潜在的内存泄漏</h5><h6 id="RACObserve内存泄漏"><a href="#RACObserve内存泄漏" class="headerlink" title="RACObserve内存泄漏"></a>RACObserve内存泄漏</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123; <span class="comment">//1</span></span><br><span class="line">        MTModel *model = [[MTModel alloc] init]; <span class="comment">// MTModel有一个名为的title的属性</span></span><br><span class="line">        [subscriber sendNext:model];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">self</span>.flattenMapSignal = [signal flattenMap:^RACStream *(MTModel *model) &#123; <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">return</span> RACObserve(model, title);</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.flattenMapSignal subscribeNext:^(<span class="type">id</span> x) &#123; <span class="comment">//3</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;subscribeNext - %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器返回时，控制器并没有被释放,看下RACObserve的定义：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RACObserve(TARGET, KEYPATH) \</span></span><br><span class="line"><span class="meta">(&#123; \</span></span><br><span class="line"><span class="meta">_Pragma(<span class="string">&quot;clang diagnostic push&quot;</span>) \</span></span><br><span class="line"><span class="meta">_Pragma(<span class="string">&quot;clang diagnostic ignored \&quot;-Wreceiver-is-weak\&quot;&quot;</span>) \</span></span><br><span class="line"><span class="meta">__weak id target_ = (TARGET); \</span></span><br><span class="line"><span class="meta">[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \</span></span><br><span class="line"><span class="meta">_Pragma(<span class="string">&quot;clang diagnostic pop&quot;</span>) \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><p>注意这一句：<code>[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self];</code> 如果将宏简单展开就变成了下面这样：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span> &lt; RACSubscriber &gt; subscriber) &#123; <span class="comment">//1</span></span><br><span class="line">        GJModel *model = [[GJModel alloc] init];</span><br><span class="line">        [subscriber sendNext:model];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;]; </span><br><span class="line">    <span class="keyword">self</span>.flattenMapSignal = [signal flattenMap:^RACStream *(GJModel *model) &#123;<span class="comment">//2</span></span><br><span class="line">        __<span class="keyword">weak</span> GJModel *target_ = model;</span><br><span class="line">        <span class="keyword">return</span> [target_ rac_valuesForKeyPath:@keypath(target_, title) observer:<span class="keyword">self</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.flattenMapSignal subscribeNext:^(<span class="type">id</span> x) &#123;<span class="comment">//3</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;subscribeNext - %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flattenMap操作接收的block里面出现了self，对self进行了持有，而flattenMap操作返回的信号又由self的属性flattenMapSignal进行了持有，这就造成了循环引用。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span> &lt; RACSubscriber &gt; subscriber) &#123;</span><br><span class="line">        GJModel *model = [[GJModel alloc] init];</span><br><span class="line">        [subscriber sendNext:model];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    @weakify(<span class="keyword">self</span>); <span class="comment">//</span></span><br><span class="line">    <span class="keyword">self</span>.signal = [signal flattenMap:^RACStream *(GJModel *model) &#123;</span><br><span class="line">        @strongify(<span class="keyword">self</span>); <span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> RACObserve(model, title);</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.signal subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;subscribeNext - %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="RACSubject内存泄漏"><a href="#RACSubject内存泄漏" class="headerlink" title="RACSubject内存泄漏"></a>RACSubject内存泄漏</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    RACSubject *subject = [RACSubject subject]; </span><br><span class="line">    [subject.rac_willDeallocSignal subscribeCompleted:^&#123; </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;subject dealloc&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[subject map:^<span class="type">id</span>(<span class="built_in">NSNumber</span> *value) &#123; </span><br><span class="line">        <span class="keyword">return</span> @([value integerValue] * <span class="number">3</span>);</span><br><span class="line">    &#125;] subscribeNext:^(<span class="type">id</span> x) &#123; </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;next = %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    [subject sendNext:@<span class="number">1</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<code>2016-06-13 09:21:42.450 RAC[5404:248584] next = 3</code>,可以看到subject dealloc没有输出，也就是说subject没有释放，将RACSubject换成RACSignal</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    [signal.rac_willDeallocSignal subscribeCompleted:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;signal dealloc&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    [[signal map:^<span class="type">id</span>(<span class="built_in">NSNumber</span> *value) &#123;</span><br><span class="line">        <span class="keyword">return</span> @([value integerValue] * <span class="number">3</span>);</span><br><span class="line">    &#125;] subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;next = %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">2016</span><span class="number">-06</span><span class="number">-12</span> <span class="number">23</span>:<span class="number">32</span>:<span class="number">31.669</span> RACDemo[<span class="number">5085</span>:<span class="number">217082</span>] next = <span class="number">3</span></span><br><span class="line"><span class="number">2016</span><span class="number">-06</span><span class="number">-12</span> <span class="number">23</span>:<span class="number">32</span>:<span class="number">31.674</span> RACDemo[<span class="number">5085</span>:<span class="number">217082</span>] signal dealloc</span><br></pre></td></tr></table></figure><p>同样的逻辑，signal能正常释放，subject却不能正常释放, 给RACSubject发送一个完成信号：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    RACSubject *subject = [RACSubject subject]; </span><br><span class="line">    [subject.rac_willDeallocSignal subscribeCompleted:^&#123; </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;subject dealloc&quot;</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[subject map:^<span class="type">id</span>(<span class="built_in">NSNumber</span> *value) &#123; </span><br><span class="line">        <span class="keyword">return</span> @([value integerValue] * <span class="number">3</span>);</span><br><span class="line">    &#125;] subscribeNext:^(<span class="type">id</span> x) &#123; </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;next = %@&quot;</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    [subject sendNext:@<span class="number">1</span>]; </span><br><span class="line">    [subject sendCompleted];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-06</span><span class="number">-12</span> <span class="number">23</span>:<span class="number">40</span>:<span class="number">19.148</span> RAC_bindSample[<span class="number">5168</span>:<span class="number">221902</span>] next = <span class="number">3</span></span><br><span class="line"><span class="number">2016</span><span class="number">-06</span><span class="number">-12</span> <span class="number">23</span>:<span class="number">40</span>:<span class="number">19.153</span> RAC_bindSample[<span class="number">5168</span>:<span class="number">221902</span>] subject dealloc</span><br></pre></td></tr></table></figure><p>subject被释放了</p><blockquote><p>RACSignal和RACSubject虽然都是信号，但是它们有一个本质的区别： RACSubject会持有订阅者（因为RACSubject是热信号，为了保证未来有事件发送的时候，订阅者可以收到信息，所以需要对订阅者保持状态，做法就是持有订阅者），而RACSignal不会持有订阅者。</p></blockquote><p>原因：map函数内部会调用bind，来看下bind的实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)bind:(RACStreamBindBlock (^)(<span class="type">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -bind: should:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. Subscribe to the original signal of values.</span></span><br><span class="line"><span class="comment"> * 2. Any time the original signal sends a value, transform it using the binding block.</span></span><br><span class="line"><span class="comment"> * 3. If the binding block returns a signal, subscribe to it, and pass all of its values through to the subscriber as they&#x27;re received.</span></span><br><span class="line"><span class="comment"> * 4. If the binding block asks the bind to terminate, complete the _original_ signal.</span></span><br><span class="line"><span class="comment"> * 5. When _all_ signals complete, send completed to the subscriber.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If any signal sends an error at any point, send that to the subscriber.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACStreamBindBlock bindingBlock = block();</span><br><span class="line"><span class="built_in">NSMutableArray</span> *signals = [<span class="built_in">NSMutableArray</span> arrayWithObject:<span class="keyword">self</span>];</span><br><span class="line"><span class="comment">// 此处省略了80行代码</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@&quot;[%@] -bind:&quot;</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在didSubscribe的开头，就创建了一个数组signals，并且持有了self，也就是源信号：<code>NSMutableArray *signals = [NSMutableArray arrayWithObject:self];</code></p><p>为什么发送完成可以修复内存泄漏？ </p><p>发送完成调用了一下completeSignal这个block。再看下这个block内部在干嘛：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (^completeSignal)(RACSignal *, RACDisposable *) = ^(RACSignal *signal, RACDisposable *finishedDisposable) &#123;</span><br><span class="line">    <span class="type">BOOL</span> removeDisposable = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">@synchronized</span> (signals) &#123;</span><br><span class="line">        [signals removeObject:signal]; <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span> (signals.count == <span class="number">0</span>) &#123;</span><br><span class="line">            [subscriber sendCompleted]; <span class="comment">//2</span></span><br><span class="line">            [compoundDisposable dispose]; <span class="comment">//3</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeDisposable = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (removeDisposable) [compoundDisposable removeDisposable:finishedDisposable]; <span class="comment">//4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总之，一句话： <strong>使用ReactiveCocoa必须要保证信号发送完成或者发送错误</strong>。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol><li><a href="https://tech.meituan.com/2016/08/19/potential-memory-leak-in-reactivecocoa.html">ReactiveCocoa中潜在的内存泄漏及解决方案</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 内存管理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ReactiveObjC 使用</title>
      <link href="/2020/12/22/ReactiveObjC%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/12/22/ReactiveObjC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ReactiveCocoa 在设计上很大程度借鉴了 Reactive Extension 中的概念，可以说 ReactiveCocoa 是 <a href="http://reactivex.io/languages.html">Rx</a> 在 Objective-C 语言中的实现</p></blockquote><p> Rx 中主要的两个概念信号和序列都在 ReactiveCocoa 中有着相对应的组件 <code>RACSignal</code> 和 <code>RACSequence</code></p><span id="more"></span><h3 id="RACSignal-和-RACSequence"><a href="#RACSignal-和-RACSequence" class="headerlink" title="RACSignal 和 RACSequence"></a>RACSignal 和 RACSequence</h3><p>最大区别就是：</p><ol><li><p>RACSignal 是推驱动的，也就是在每次信号中的出现新的数据时，所有的订阅者都会自动接受到最新的值；</p></li><li><p>RACSequence 作为拉驱动的数据流，在改变时并不会通知使用当前序列的对象，只有使用者再次从这个 RACSequence 对象中获取数据才能更新，它的更新是需要使用者自己拉取的。</p></li></ol><p>eg：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)setupRAC</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.networkingRAC.executionSignal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span>&lt;WSFOrderAddressRegionModel*&gt;*  origionModelAry=[<span class="keyword">self</span>.adrRegionAPi fetchDataFromModel:WSFOrderAddressRegionModel.class];</span><br><span class="line">        </span><br><span class="line">        RACSequence *origionModelSeq = [origionModelAry.rac_sequence map:^<span class="type">id</span>(WSFOrderAddressRegionModel *model) &#123;</span><br><span class="line">            <span class="keyword">return</span> [[YWAddressModel alloc] initWithModel:model];</span><br><span class="line">        &#125;];</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">self</span>.orderAddrAry=origionModelSeq.array;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RACSignal-和-RACSequence转换"><a href="#RACSignal-和-RACSequence转换" class="headerlink" title="RACSignal 和 RACSequence转换"></a>RACSignal 和 RACSequence转换</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RACSequence *sequence = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>].rac_sequence;</span><br><span class="line">RACSignal *signal = sequence.signal;</span><br><span class="line">[signal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">    [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, signal.toArray.rac_sequence);</span><br></pre></td></tr></table></figure><h3 id="热信号-RACSubject"><a href="#热信号-RACSubject" class="headerlink" title="热信号 RACSubject"></a>热信号 RACSubject</h3><p>RACSubject 是 RACSignal 的子类,RACSubject 在 RACSignal 对象之上进行了简单的修改，将原有的冷信号改造成了热信号，将不可变变成了可变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSubject 存储了一个遵循 RACSubscriber 协议的对象列表以及所有的消息，</span><br></pre></td></tr></table></figure><ul><li>RACSubject 对外的接口</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACSubject</span> : <span class="title">RACSignal</span> &lt;<span class="title">RACSubscriber</span>&gt;</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)subject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>它与 RACSignal 最大的不同就是：RACSubject 实现了 RACSubscriber 协议</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RACSubscriber</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)sendNext:(<span class="keyword">nullable</span> <span class="type">id</span>)value;</span><br><span class="line">- (<span class="type">void</span>)sendError:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error;</span><br><span class="line">- (<span class="type">void</span>)sendCompleted;</span><br><span class="line">- (<span class="type">void</span>)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="冷热信号"><a href="#冷热信号" class="headerlink" title="冷热信号"></a>冷热信号</h4><p>冷信号是被动的，只会在被订阅时向订阅者发送通知；热信号是主动的，它会在任意时间发出通知，与订阅者的订阅时间无关。</p><p>也就是说冷信号所有的订阅者会在订阅时收到完全相同的序列；而订阅热信号之后，只会收到在订阅之后发出的序列。</p><p>热信号的订阅者能否收到消息取决于订阅的时间。</p><p>eg:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//冷信号 RACSingal</span></span><br><span class="line">-(<span class="type">void</span>)setupRAC&#123;</span><br><span class="line">    @weakify(<span class="keyword">self</span>)</span><br><span class="line">    [[RACObserve(<span class="keyword">self</span>, cellModel) skip:<span class="number">1</span>] subscribeNext:^(WSFOrderLogisticsCompanyLastestModel*  _Nullable model) &#123;</span><br><span class="line">        @strongify(<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">if</span> (model.isSelected) &#123;</span><br><span class="line">            <span class="keyword">self</span>-&gt;itemBtn.selected=<span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">self</span>-&gt;itemBtn.selected=<span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [ <span class="keyword">self</span>-&gt;itemBtn setTitle:model.shipperName forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 热信号 RACSubject</span></span><br><span class="line"><span class="comment">// 直接指派</span></span><br><span class="line">    <span class="keyword">if</span> (kAppDelegate.appHadEnterBackground) &#123;</span><br><span class="line">        [<span class="keyword">self</span> placeOrderWithAccountModel:acctountModel ServiceType:serviceType];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//第一次启动</span></span><br><span class="line">    &#123;</span><br><span class="line">        __block RACDisposable* disposable= [WSFUSERManger.userPermissionUpdatedSub subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">            [<span class="keyword">self</span> placeOrderWithAccountModel:acctountModel ServiceType:serviceType];</span><br><span class="line">            [disposable dispose];</span><br><span class="line">         &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用户权限</span></span><br><span class="line">       <span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)RACSubject* userPermissionUpdatedSub;<span class="comment">//用户权限更新</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        [[<span class="keyword">self</span>.networkingRACs[UserPermissionApiIdentifier] executionSignal] subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">        @strongify(<span class="keyword">self</span>);</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *tempDic = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="built_in">NSArray</span> *permissionModelArys = [<span class="keyword">self</span>.userPermissionApi fetchDataFromModel:WSFMenuPermissionModel.class];</span><br><span class="line">        [permissionModelArys enumerateObjectsUsingBlock:^(WSFMenuPermissionModel *obj, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([obj.permission isEqualToString:<span class="string">@&quot;allow&quot;</span>]) &#123;</span><br><span class="line">                obj.isPermissionAllow = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([obj.permission isEqualToString:<span class="string">@&quot;deny&quot;</span>]) &#123;</span><br><span class="line">                obj.isPermissionAllow = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tempDic[obj.nameEN] = obj;</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="keyword">self</span>.menuPermissionModelDics = tempDic;</span><br><span class="line">        [<span class="keyword">self</span>.userPermissionUpdatedSub sendNext:<span class="literal">nil</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="RACBehaviorSubject-与-RACReplaySubject"><a href="#RACBehaviorSubject-与-RACReplaySubject" class="headerlink" title="RACBehaviorSubject 与 RACReplaySubject"></a>RACBehaviorSubject 与 RACReplaySubject</h4><p>RACBehaviorSubject 在订阅时会向订阅者发送最新的消息，<br>RACReplaySubject   在订阅之后可以重新发送之前的所有消息序列。</p><h5 id="RACBehaviorSubject"><a href="#RACBehaviorSubject" class="headerlink" title="RACBehaviorSubject"></a>RACBehaviorSubject</h5><p>RACBehaviorSubject，它在内部会保存一个 currentValue 对象，也就是最后一次发送的消息：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACBehaviorSubject</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> currentValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)sendNext:(<span class="type">id</span>)value &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">self</span>.currentValue = value;</span><br><span class="line">[<span class="variable language_">super</span> sendNext:value];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向最新的订阅者发送之前的消息，这是通过覆写 -subscribe: 方法实现的</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(<span class="type">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">RACDisposable *subscriptionDisposable = [<span class="variable language_">super</span> subscribe:subscriber];</span><br><span class="line"></span><br><span class="line">RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">[subscriber sendNext:<span class="keyword">self</span>.currentValue];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line">[schedulingDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="RACReplaySubject"><a href="#RACReplaySubject" class="headerlink" title="RACReplaySubject"></a>RACReplaySubject</h5><p>RACReplaySubject 相当于一个自带 buffer 的 RACBehaviorSubject，它可以在每次有新的订阅者订阅之后发送之前的全部消息。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACReplaySubject</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> capacity;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSMutableArray</span> *valuesReceived;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h3><p>RACCommand 并不表示数据流，它只是一个继承自 NSObject 的类,是一个用于管理 RACSignal 的创建与订阅的类</p><h4 id="RACCommand-的初始化与执行"><a href="#RACCommand-的初始化与执行" class="headerlink" title="RACCommand 的初始化与执行"></a>RACCommand 的初始化与执行</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithSignalBlock:(RACSignal&lt;ValueType&gt; * (^)(InputType _Nullable input))signalBlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)execute:(<span class="keyword">nullable</span> InputType)input;</span><br></pre></td></tr></table></figure><ul><li>注意</li></ul><p>在默认情况下 RACCommand 都是不支持并发操作的，需要在上一次命令执行之后才可以发送下一次操作，否则就会返回错误信号 RACErrorSignal，这些错误可以通过订阅 command.errors 获得</p><h4 id="RACCommand-接口中的高阶信号"><a href="#RACCommand-接口中的高阶信号" class="headerlink" title="RACCommand 接口中的高阶信号"></a>RACCommand 接口中的高阶信号</h4><p>它在接口中暴露出的四个信号</p><ol><li><p>executionSignals<br>在每次执行 -execute: 方法时，最终都会向 executionSignals 中传入一个最新的信号</p></li><li><p>executing<br>executing 是一个表示当前是否有任务执行的信号</p></li><li><p>enabled</p></li></ol><p>enabled 信号流表示当前的命令是否可以再次被执行，也就是 -execute: 方法能否可以成功执行新的任务；</p><ol start="4"><li>errors</li></ol><p>为了保证 RACCommand 对此执行 -execute: 方法也可以继续运行，我们只能将所有的错误以其它的形式发送到 errors 信号中，防止向 executionSignals 发送错误信号后，executionSignals 信号就会中止的问题。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RACMulticastConnection *errorsConnection = [[[<span class="keyword">self</span>.addedExecutionSignalsSubject</span><br><span class="line">    flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[signal</span><br><span class="line">            ignoreValues]</span><br><span class="line">            catch:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                <span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:error];</span><br><span class="line">            &#125;];</span><br><span class="line">    &#125;]</span><br><span class="line">    deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">    publish];</span><br><span class="line"></span><br><span class="line">_errors = [errorsConnection.signal setNameWithFormat:<span class="string">@&quot;%@ -errors&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line">[errorsConnection connect];</span><br></pre></td></tr></table></figure><h3 id="RACChannel双向绑定"><a href="#RACChannel双向绑定" class="headerlink" title="RACChannel双向绑定"></a>RACChannel双向绑定</h3><p>一对一的双向数据流 RACChannel，RACChannel 可以被理解为一个双向的连接，这个连接的两端都是 RACSignal 实例，它们可以向彼此发送消息</p><p>RACChannel 内部封装了两个 RACChannelTerminal 对象，它们都是 RACSignal 的子类：</p><p>eg:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下单 上门信息   ViewModel</span></span><br><span class="line">WSFPlaceOrderParamModel* modelName=[[WSFPlaceOrderParamModel alloc] init];</span><br><span class="line">    modelName.showTipText=<span class="literal">false</span>;</span><br><span class="line">    modelName.tilteParam=<span class="string">@&quot;姓名&quot;</span>;</span><br><span class="line">    modelName.valueTipParam=<span class="string">@&quot;请输入姓名&quot;</span>;</span><br><span class="line">    modelName.valuePlaceHolder=<span class="string">@&quot;请输入姓名&quot;</span>;</span><br><span class="line">    modelName.valuePlaceParam=<span class="literal">nil</span>;</span><br><span class="line">    modelName.modelType=WSFPlaceOrderCellTypeInput;</span><br><span class="line">    modelName.modelId=WSFPlaceOrderModelIdAddrName;</span><br><span class="line">    </span><br><span class="line">    RACChannelTo(modelName, valuePlaceParam)=RACChannelTo(WSFOrderManager,orderExtraData.buyerName);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// View    WSFPlaceOrderSingleLineInputCell</span></span><br><span class="line">  -(<span class="type">void</span>)setupRAC</span><br><span class="line">&#123;</span><br><span class="line">    @weakify(<span class="keyword">self</span>);</span><br><span class="line">    [[<span class="keyword">self</span>-&gt;_valueTxt.rac_textSignal filter:^<span class="type">BOOL</span>(<span class="built_in">NSString</span> * _Nullable value) &#123;</span><br><span class="line">        @strongify(<span class="keyword">self</span>);</span><br><span class="line">        &#125;]subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">            @strongify(<span class="keyword">self</span>);</span><br><span class="line">            <span class="keyword">self</span>.cellModel.valuePlaceParam=x;</span><br><span class="line">    &#125;];   </span><br></pre></td></tr></table></figure><h3 id="多播的RACMulticastConnection（一对多）"><a href="#多播的RACMulticastConnection（一对多）" class="headerlink" title="多播的RACMulticastConnection（一对多）"></a>多播的RACMulticastConnection（一对多）</h3><blockquote><p>将冷信号转变成热信号，并在合适的时间触发，向所有的订阅者发送消息</p></blockquote><p>使用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Send Request&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;] publish];</span><br><span class="line"></span><br><span class="line">[connection.signal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;product: %@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[connection.signal subscribeNext:^(<span class="type">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *productId = [x objectForKey:<span class="string">@&quot;id&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;productId: %@&quot;</span>, productId);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[connection connect];</span><br></pre></td></tr></table></figure><p>使用 -publish 方法生成实例，订阅者不再订阅源信号，而是订阅 RACMulticastConnection 中的 RACSubject 热信号，最后通过 -connect 方法触发源信号中的任务。</p><h4 id="publish-和-multicast-方法"><a href="#publish-和-multicast-方法" class="headerlink" title="publish 和 multicast 方法"></a>publish 和 multicast 方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (RACMulticastConnection *)publish &#123;</span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">RACMulticastConnection *connection = [<span class="keyword">self</span> multicast:subject];</span><br><span class="line"><span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACMulticastConnection *)multicast:(RACSubject *)subject &#123;</span><br><span class="line">RACMulticastConnection *connection = [[RACMulticastConnection alloc] initWithSourceSignal:<span class="keyword">self</span> subject:subject];</span><br><span class="line"><span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 -publish 方法调用时相当于向 -multicast: 传入了 RACSubject。</p><p>在使用 -multicast: 方法时，传入的信号其实就是用于广播的信号；这个信号必须是一个 RACSubject 本身或者它的子类</p><h4 id="订阅源信号的时间点"><a href="#订阅源信号的时间点" class="headerlink" title="订阅源信号的时间点"></a>订阅源信号的时间点</h4><p>只有在调用 -connect 方法之后，RACSubject 才会订阅源信号 sourceSignal。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)connect &#123;</span><br><span class="line"><span class="keyword">self</span>.serialDisposable.disposable = [<span class="keyword">self</span>.sourceSignal subscribe:_signal];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.serialDisposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时源信号的 didSubscribe 代码块才会执行，向 RACSubject 推送消息，消息向下继续传递到 RACSubject 所有的订阅者中。</p><p> <code>-connect</code> 方法通过<code> -subscribe:</code> 实际上建立了 RACSignal 和 RACSubject 之间的连接，这种方式保证了 RACSignal 中的 didSubscribe 代码块只执行了一次。</p><p>所有的订阅者不再订阅原信号，而是订阅 RACMulticastConnection 持有的热信号 RACSubject，实现对冷信号的一对多传播。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://draveness.me/racsignal/">『状态』驱动的世界：ReactiveCocoa</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> RAC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MLeadksFinder使用</title>
      <link href="/2020/12/21/MLeadksFinder%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/12/21/MLeadksFinder%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="MLeaksFinder"><a href="#MLeaksFinder" class="headerlink" title="MLeaksFinder"></a><a href="https://github.com/Tencent/MLeaksFinder">MLeaksFinder</a></h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><blockquote><p>MLeaksFinder helps you find memory leaks in your iOS apps at develop time</p></blockquote><h4 id="优点-VS-Instrument"><a href="#优点-VS-Instrument" class="headerlink" title="优点  VS Instrument"></a>优点  VS Instrument</h4><p>MLeaksFinder 具备以下优点：</p><ol><li>使用简单，不侵入业务逻辑代码，不用打开 Instrument</li><li>不需要额外的操作，你只需开发你的业务逻辑，在你运行调试时就能帮你检测</li><li>内存泄露发现及时，更改完代码后一运行即能发现（这点很重要，你马上就能意识到哪里写错了）</li><li>精准，能准确地告诉你哪个对象没被释放</li></ol><span id="more"></span><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Memory Leak</span><br><span class="line">(</span><br><span class="line">    MyTableViewController,</span><br><span class="line">    UITableView,</span><br><span class="line">    UITableViewWrapperView,</span><br><span class="line">    MyTableViewCell</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>MLeaksFinder can automatically find leaks in UIView and UIViewController objects. 通过断言的方式弹窗展示未被释放的UIView或UIViewController对象</p><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>一些不应该被释放的对象比如全局对象，static，单例，又不想被弹窗误报override</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="Podspec文件"><a href="#Podspec文件" class="headerlink" title="Podspec文件"></a>Podspec文件</h5><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Pod::Spec</span>.new <span class="keyword">do</span> |<span class="params">s</span>|</span><br><span class="line">  s.name             = <span class="string">&quot;MLeaksFinder&quot;</span></span><br><span class="line">  s.version          = <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">  s.summary          = <span class="string">&quot;Find memory leaks in your iOS app at develop time.&quot;</span></span><br><span class="line">  s.homepage         = <span class="string">&quot;https://github.com/Zepo/MLeaksFinder&quot;</span></span><br><span class="line">  <span class="comment"># s.screenshots     = &quot;www.example.com/screenshots_1&quot;, &quot;www.example.com/screenshots_2&quot;</span></span><br><span class="line">  s.license          = <span class="string">&#x27;MIT&#x27;</span></span><br><span class="line">  s.author           = &#123; <span class="string">&quot;Zeposhe&quot;</span> =&gt; <span class="string">&quot;zeposhe@163.com&quot;</span> &#125;</span><br><span class="line">  s.source           = &#123; <span class="symbol">:git</span> =&gt; <span class="string">&quot;https://github.com/Zepo/MLeaksFinder.git&quot;</span>, <span class="symbol">:tag</span> =&gt; s.version &#125;</span><br><span class="line">  <span class="comment"># s.social_media_url = &#x27;https://twitter.com/&lt;TWITTER_USERNAME&gt;&#x27;</span></span><br><span class="line">  s.ios.deployment_target = <span class="string">&#x27;6.0&#x27;</span></span><br><span class="line">  s.source_files = <span class="string">&#x27;MLeaksFinder/**/*&#x27;</span></span><br><span class="line">  <span class="comment"># s.resource_bundles = &#123;</span></span><br><span class="line">  <span class="comment">#   &#x27;MLeaksFinder&#x27; =&gt; [&#x27;MLeaksFinder/Assets/*.png&#x27;]</span></span><br><span class="line">  <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">  s.public_header_files = <span class="string">&#x27;MLeaksFinder/MLeaksFinder.h&#x27;</span>, <span class="string">&#x27;MLeaksFinder/NSObject+MemoryLeak.h&#x27;</span></span><br><span class="line">  <span class="comment"># s.frameworks = &#x27;UIKit&#x27;, &#x27;MapKit&#x27;</span></span><br><span class="line">  <span class="comment"># s.dependency &#x27;FBRetainCycleDetector&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">重要: FBRetainCycleDetector is removed from the podspec due to Facebook&#x27;s BSD-plus-Patents license. If you </span><br><span class="line">want to use FBRetainCycleDetector to find retain cycle, add pod &#x27;FBRetainCycleDetector&#x27; to your project&#x27;s </span><br><span class="line">Podfile and turn the macro MEMORY_LEAKS_FINDER_RETAIN_CYCLE_ENABLED on in MLeaksFinder.h.</span><br></pre></td></tr></table></figure><h5 id="willDealloc方法"><a href="#willDealloc方法" class="headerlink" title="willDealloc方法"></a>willDealloc方法</h5><p>为基类 NSObject 添加一个方法 -willDealloc 方法，该方法的作用是，先用一个弱指针指向 self，并在一小段时间(3秒)后，通过这个弱指针调用 -assertNotDealloc，而 -assertNotDealloc 主要作用是直接中断言。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="type">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [weakSelf assertNotDealloc];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)assertNotDealloc &#123;</span><br><span class="line">     <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, @“”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果3秒后它被释放成功，weakSelf 就指向 nil，不会调用到 -assertNotDealloc 方法，也就不会中断言，如果它没被释放（泄露了），-assertNotDealloc 就会被调用中断言</p><h3 id="FBRetainCycleDetector"><a href="#FBRetainCycleDetector" class="headerlink" title="FBRetainCycleDetector"></a><a href="https://github.com/facebook/FBRetainCycleDetector">FBRetainCycleDetector</a></h3><blockquote><p>An iOS library that finds retain cycles using runtime analysis<br>用于检测引起内存泄漏对象的环形引用链</p></blockquote><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FBRetainCycleDetector *detector = [FBRetainCycleDetector new];</span><br><span class="line">[detector addCandidate:myObject];</span><br><span class="line"><span class="built_in">NSSet</span> *retainCycles = [detector findRetainCycles];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, retainCycles);</span><br></pre></td></tr></table></figure><h4 id="如何检测饮用成环"><a href="#如何检测饮用成环" class="headerlink" title="如何检测饮用成环"></a>如何检测饮用成环</h4><p>点击 “Retain Cycle” 按钮，MLeaksFinder 将调用 FBRetainCycleDetector 进行详细问题检测</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> _INTERNAL_MLF_RC_ENABLED</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        FBRetainCycleDetector *detector = [FBRetainCycleDetector new];</span><br><span class="line">        [detector addCandidate:<span class="keyword">self</span>.object];</span><br><span class="line">        <span class="built_in">NSSet</span> *retainCycles = [detector findRetainCyclesWithMaxCycleLength:<span class="number">20</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">BOOL</span> hasFound = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSArray</span> *retainCycle <span class="keyword">in</span> retainCycles) &#123;</span><br><span class="line">            <span class="built_in">NSInteger</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (FBObjectiveCGraphElement *element <span class="keyword">in</span> retainCycle) &#123;</span><br><span class="line">                <span class="keyword">if</span> (element.object == object) &#123;</span><br><span class="line">                    <span class="built_in">NSArray</span> *shiftedRetainCycle = [<span class="keyword">self</span> shiftArray:retainCycle toIndex:index];</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        [MLeaksMessenger alertWithTitle:<span class="string">@&quot;Retain Cycle&quot;</span></span><br><span class="line">                                                message:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, shiftedRetainCycle]];</span><br><span class="line">                    &#125;);</span><br><span class="line">                    hasFound = <span class="literal">YES</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hasFound) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasFound) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [MLeaksMessenger alertWithTitle:<span class="string">@&quot;Retain Cycle&quot;</span></span><br><span class="line">                                        message:<span class="string">@&quot;Fail to find a retain cycle&quot;</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="NSObject对象循环引用"><a href="#NSObject对象循环引用" class="headerlink" title="NSObject对象循环引用"></a>NSObject对象循环引用</h5><blockquote><p>FBRetainCycleDetector 基于外部传入的object 以及查找深度，进行深度优先遍历所有强引用属性，和动态运行时关联的强引用属性，同时将这些 关联对象的地址 放入 objectSet （set）的集合中, 将对象信息计入 objectOnPath 集合中（set）, 并且将对象在对象栈 stack 中存储一份，便于查找对应环。</p></blockquote><p>首先判断 如果传入的 object 是 NSObject 的话，获取对象的 class，使用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">char</span> *class_getIvarLayout(Class cls);</span><br></pre></td></tr></table></figure><p>获取 class 的所有定义的 property 的布局信息，取出 object 对应的 property 的value值，将value 对象的地址（数字）加入 objectSet 中，将对象指针加入到 objectOnPath，在整个树形遍历中，如果遍历到的新节点，在原来的 objectSet 地址表中已经存在了，代表形成了引用环，即原本的树形结构连成了图。此时可以根据 stack中记录的路径，结合 重复的 object构建一个环形图，作为环形引用链返回。</p><p><code>树是没有环的图</code></p><h5 id="NSBlock类型对像"><a href="#NSBlock类型对像" class="headerlink" title="NSBlock类型对像"></a>NSBlock类型对像</h5><p>在C的结构体中是不存在强弱引用区分的，在编译期，编译器会将所谓的强引用通过一个 copy_helper 的function 做copy 操作，并为 block 生成的 struct 构造 dispose_helper 的 function，dispose_helper 负责在 struct 将要释放时，去释放它所引用的对象。下面是编译器生成的 dispose_helper function 的定义 ，入参为 struct 的地址 _Block_object_dispose 是编译器的 funtion</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __block_dispose_4(<span class="keyword">struct</span> __block_literal_4 *src) &#123;</span><br><span class="line">     <span class="comment">// was _Block_destroy</span></span><br><span class="line">     _Block_object_dispose(src-&gt;existingBlock, BLOCK_FIELD_IS_BLOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者利用黑盒测试，基于原有的 block对象 ，拿到对应block对象的 descriptor指针 ，descriptor记录了block对象释放的时候要执行的 dispose_helper 方法和block对象所有引用对象的数组，<br>这个数组包括了强引用对象和弱应用对象 *src。 也就是说，block被释放时，执行的 dispose_helper 方法的入参 是 *scr；那么只需要伪装一个被引用的数组，传入dispose_helper 做个测试，数组中哪一个对象呗调用了 release 方法，那么谁就是被强引用的，记住src对应下标的地址就好。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p>对于某些特殊情况，释放的时机不大一样（比如系统手势返回时，在划到一半时 hold 住，虽然已被 pop，但这时还不会被释放，ViewController 要等到完全 disappear 后才释放），需要做特殊处理，具体的特殊处理视具体情况而定。</p><h4 id="系统View"><a href="#系统View" class="headerlink" title="系统View"></a>系统View</h4><p>某些系统的私有 View，不会被释放（可能是系统 bug 或者是系统出于某些原因故意这样做的，这里就不去深究了），因此需要建立白名单</p><h4 id="手动扩展"><a href="#手动扩展" class="headerlink" title="手动扩展"></a>手动扩展</h4><p>MLeaksFinder目前只检测 ViewController 跟 View 对象。为此，MLeaksFinder 提供了一个手动扩展的机制，你可以从 UIViewController 跟 UIView 出发，去检测其它类型的对象的内存泄露。如下所示，我们可以检测 UIViewController 底下的 View Model：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="variable language_">super</span> willDealloc]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MLCheck(<span class="keyword">self</span>.viewModel);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://wereadteam.github.io/2016/02/22/MLeaksFinder/">MLeaksFinder：精准 iOS 内存泄露检测工具</a></li><li><a href="https://www.jianshu.com/p/76250de94b93">FBRetainCycleDetector + MLeaksFinder 阅读</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 内存管理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多分支 if-else 重构</title>
      <link href="/2020/10/25/%E5%A4%9A%E5%88%86%E6%94%AF%20if-else%E9%87%8D%E6%9E%84/"/>
      <url>/2020/10/25/%E5%A4%9A%E5%88%86%E6%94%AF%20if-else%E9%87%8D%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="多分支-if-else-重构"><a href="#多分支-if-else-重构" class="headerlink" title="多分支 if-else 重构"></a>多分支 if-else 重构</h2><p><code>if-else不外乎两种场景：异常逻辑处理和不同状态处理</code></p><span id="more"></span><p>重构if-else时，心中无时无刻把握一个原则：</p><p> <strong>尽可能地维持正常流程代码在最外层。</strong></p><blockquote><p>意思是说，可以写if-else语句时一定要尽量保持主干代码是正常流程，避免嵌套过深。</p></blockquote><blockquote><p>实现的手段有：减少嵌套、移除临时变量、条件取反判断、合并条件表达式等</p></blockquote><h3 id="异常逻辑处理型重构"><a href="#异常逻辑处理型重构" class="headerlink" title="异常逻辑处理型重构"></a>异常逻辑处理型重构</h3><h4 id="合并表达式"><a href="#合并表达式" class="headerlink" title="合并表达式"></a>合并表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">disablityAmount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_seniority &lt; <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(_monthsDisabled &gt; <span class="number">12</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(_isPartTime)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//do somethig</span></span><br></pre></td></tr></table></figure><p>如果有一系列条件测试都得到相同结果，将这些结果测试合并为一个条件表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">disablityAmount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_seniority &lt; <span class="number">2</span> || _monthsDisabled &gt; <span class="number">12</span> || _isPartTime) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//do somethig</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAdjustedCapital</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(_capital &gt; <span class="number">0.0</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(_intRate &gt; <span class="number">0</span> &amp;&amp; _duration &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            resutl = (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAdjustedCapital</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_capital &lt;= <span class="number">0.0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(_intRate &gt; <span class="number">0</span> &amp;&amp; _duration &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这样重构后，还不够，因为主要的语句<code>(_income / _duration) *ADJ_FACTOR;</code>在if内部，并非在最外层，根据优化原则（尽可能地维持正常流程代码在最外层），可以再继续重构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAdjustedCapital</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_capital &lt;= <span class="number">0.0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(_intRate &lt;= <span class="number">0</span> || _duration &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这才是好的代码风格，逻辑清晰，一目了然，没有if-else嵌套难以理解的流程。</p><p> 这里用到的重构方法是：<code>将条件反转使异常情况先退出，让正常流程维持在主干流程</code>。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查找年龄大于18岁且为男性的学生列表 */</span></span><br><span class="line">  <span class="keyword">public</span> ArrayList&lt;Student&gt; <span class="title function_">getStudents</span><span class="params">(<span class="type">int</span> uid)</span>&#123;</span><br><span class="line">      ArrayList&lt;Student&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">      <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> getStudentByUid(uid);</span><br><span class="line">      <span class="keyword">if</span> (stu != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> stu.getTeacher();</span><br><span class="line">          <span class="keyword">if</span>(teacher != <span class="literal">null</span>)&#123;</span><br><span class="line">              ArrayList&lt;Student&gt; students = teacher.getStudents();</span><br><span class="line">              <span class="keyword">if</span>(students != <span class="literal">null</span>)&#123;</span><br><span class="line">                  <span class="keyword">for</span>(Student student : students)&#123;</span><br><span class="line">                      <span class="keyword">if</span>(student.getAge() &gt; = <span class="number">18</span> &amp;&amp; student.getGender() == MALE)&#123;</span><br><span class="line">                          result.add(student);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                  logger.error(<span class="string">&quot;获取学生列表失败&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              logger.error(<span class="string">&quot;获取老师信息失败&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          logger.error(<span class="string">&quot;获取学生信息失败&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>典型的”箭头型”代码，最大的问题是嵌套过深，解决方法是异常条件先退出，保持主干流程是核心流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查找年龄大于18岁且为男性的学生列表 */</span></span><br><span class="line">  <span class="keyword">public</span> ArrayList&lt;Student&gt; <span class="title function_">getStudents</span><span class="params">(<span class="type">int</span> uid)</span>&#123;</span><br><span class="line">      ArrayList&lt;Student&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">      <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> getStudentByUid(uid);</span><br><span class="line">      <span class="keyword">if</span> (stu == <span class="literal">null</span>) &#123;</span><br><span class="line">          logger.error(<span class="string">&quot;获取学生信息失败&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> stu.getTeacher();</span><br><span class="line">      <span class="keyword">if</span>(teacher == <span class="literal">null</span>)&#123;</span><br><span class="line">          logger.error(<span class="string">&quot;获取老师信息失败&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      ArrayList&lt;Student&gt; students = teacher.getStudents();</span><br><span class="line">      <span class="keyword">if</span>(students == <span class="literal">null</span>)&#123;</span><br><span class="line">          logger.error(<span class="string">&quot;获取学生列表失败&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span>(Student student : students)&#123;</span><br><span class="line">          <span class="keyword">if</span>(student.getAge() &gt; <span class="number">18</span> &amp;&amp; student.getGender() == MALE)&#123;</span><br><span class="line">              result.add(student);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="状态处理型重构"><a href="#状态处理型重构" class="headerlink" title="状态处理型重构"></a>状态处理型重构</h3><h4 id="公共函数封装"><a href="#公共函数封装" class="headerlink" title="公共函数封装"></a>公共函数封装</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getPayAmount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> getObj();</span><br><span class="line">    <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj.getType == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">ObjectA</span> <span class="variable">objA</span> <span class="operator">=</span> obj.getObjectA();</span><br><span class="line">        money = objA.getMoney()*obj.getNormalMoneryA();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj.getType == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">ObjectB</span> <span class="variable">objB</span> <span class="operator">=</span> obj.getObjectB();</span><br><span class="line">        money = objB.getMoney()*obj.getNormalMoneryB()+<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重构后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getPayAmount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> getObj();</span><br><span class="line">    <span class="keyword">if</span> (obj.getType == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getType1Money(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj.getType == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getType2Money(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">double</span> <span class="title function_">getType1Money</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="type">ObjectA</span> <span class="variable">objA</span> <span class="operator">=</span> obj.getObjectA();</span><br><span class="line">    <span class="keyword">return</span> objA.getMoney()*obj.getNormalMoneryA();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">double</span> <span class="title function_">getType2Money</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="type">ObjectB</span> <span class="variable">objB</span> <span class="operator">=</span> obj.getObjectB();</span><br><span class="line">    <span class="keyword">return</span> objB.getMoney()*obj.getNormalMoneryB()+<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重构方法是：<code>把if-else内的代码都封装成一个公共函数。函数的好处是屏蔽内部实现，缩短if-else分支的代码。代码结构和逻辑上清晰，能一下看出来每一个条件内做的功能</code>。</p><h4 id="用多态取代条件表达式"><a href="#用多态取代条件表达式" class="headerlink" title="用多态取代条件表达式"></a>用多态取代条件表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(_type)&#123;</span><br><span class="line">        <span class="keyword">case</span> EUROPEAN:</span><br><span class="line">            <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">        <span class="keyword">case</span> AFRICAN:</span><br><span class="line">            <span class="keyword">return</span> getBaseSpeed()-getLoadFactor()*_numberOfCoconuts;</span><br><span class="line">        <span class="keyword">case</span> NORWEGIAN_BLUE:</span><br><span class="line">            <span class="keyword">return</span> (_isNailed)?<span class="number">0</span>:getBaseSpeed(_voltage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 重构后：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">European</span> <span class="keyword">extends</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">African</span> <span class="keyword">extends</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseSpeed()-getLoadFactor()*_numberOfCoconuts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NorwegianBlue</span> <span class="keyword">extends</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (_isNailed)?<span class="number">0</span>:getBaseSpeed(_voltage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h4 id="策略模式-工厂方法消除-if-else"><a href="#策略模式-工厂方法消除-if-else" class="headerlink" title="策略模式+工厂方法消除 if else"></a>策略模式+工厂方法消除 if else</h4><p>假设需求为，根据不同勋章类型，处理相对应的勋章服务，优化前有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">medalType</span> <span class="operator">=</span> <span class="string">&quot;guest&quot;</span>;</span><br><span class="line">   <span class="keyword">if</span> (<span class="string">&quot;guest&quot;</span>.equals(medalType)) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;嘉宾勋章&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;vip&quot;</span>.equals(medalType)) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;会员勋章&quot;</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;guard&quot;</span>.equals(medalType)) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;展示守护勋章&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>首先，我们把每个条件逻辑代码块，抽象成一个公共的接口，可以得出以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//勋章接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMedalService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showMedal</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们根据每个逻辑条件，定义相对应的策略实现类，可得以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//守护勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuardMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IMedalService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMedal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;展示守护勋章&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//嘉宾勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuestMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IMedalService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMedal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;嘉宾勋章&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//VIP勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VipMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IMedalService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMedal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;会员勋章&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们再定义策略工厂类，用来管理这些勋章实现策略类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//勋章服务工产类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MedalServicesFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IMedalService&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">&quot;guard&quot;</span>, <span class="keyword">new</span> <span class="title class_">GuardMedalServiceImpl</span>());</span><br><span class="line">        map.put(<span class="string">&quot;vip&quot;</span>, <span class="keyword">new</span> <span class="title class_">VipMedalServiceImpl</span>());</span><br><span class="line">        map.put(<span class="string">&quot;guest&quot;</span>, <span class="keyword">new</span> <span class="title class_">GuestMedalServiceImpl</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IMedalService <span class="title function_">getMedalService</span><span class="params">(String medalType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(medalType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用了策略+工厂模式之后，代码变得简洁多了，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">medalType</span> <span class="operator">=</span> <span class="string">&quot;guest&quot;</span>;</span><br><span class="line">        <span class="type">IMedalService</span> <span class="variable">medalService</span> <span class="operator">=</span> MedalServicesFactory.getMedalService(medalType);</span><br><span class="line">        medalService.showMedal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="iOS-使用策略模式来去除繁琐的if-else"><a href="#iOS-使用策略模式来去除繁琐的if-else" class="headerlink" title="[iOS]使用策略模式来去除繁琐的if-else"></a>[iOS]使用策略模式来去除繁琐的if-else</h4><p>通过传入的三种类型来获取对应的id,例如id 001-&gt;类型1,id 002-&gt;类型2,id 003-&gt;类型3</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (type == 类型<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">001</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type == 类型<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">002</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type == 类型<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">003</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>用策略模式如何实现呢?</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *dict =@&#123;</span><br><span class="line">                          <span class="string">@&quot;类型1&quot;</span> : @<span class="number">001</span>,</span><br><span class="line">                          <span class="string">@&quot;类型2&quot;</span> : @<span class="number">002</span>,</span><br><span class="line">                          <span class="string">@&quot;类型3&quot;</span> : @<span class="number">003</span></span><br><span class="line">                          &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> <span class="type">id</span> = dict[type];<span class="comment">//type 为类型1,类型2,类型3</span></span><br></pre></td></tr></table></figure><p>这个dict就是一个策略的集合,我们通过type来取出对应的结果.</p><p>题目:小明在每个星期每天都会做不同的事</p><ol><li> 周一打篮球</li><li>周二逛街</li><li>周三洗衣服</li><li>周四打游戏</li><li>周五唱歌</li><li>周六看电影</li><li>周末爬山</li></ol><p>用分支来写,应该是这样的:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(day == 周一)&#123;</span><br><span class="line">      result = [xiaoming playBasketball];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (day == 周二)&#123;</span><br><span class="line">      result =  [xiaoming shopping];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (day == 周三)&#123;</span><br><span class="line">      result =  [xiaoming washClothes];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="comment">//很烦,写不下去了</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;xiaoming 今天%@&quot;</span>,result);</span><br></pre></td></tr></table></figure><p>策略优化后</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.将复杂的业务逻辑包装成invocation,这里传入的每天做的事,例如playBasketball</span></span><br><span class="line">- (<span class="built_in">NSInvocation</span> *)invocationWithMethod:(SEL)selector&#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span>*signature = [CurrentClass instanceMethodSignatureForSelector:<span class="keyword">@selector</span>(selector)];</span><br><span class="line">    <span class="built_in">NSInvocation</span>*invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:signature];</span><br><span class="line">    invocation.target = <span class="keyword">self</span>;</span><br><span class="line">    invocation.selector = <span class="keyword">@selector</span>(selector);</span><br><span class="line">    <span class="keyword">return</span> invocation;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.将每天做的事进行整合</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)Strategies&#123;</span><br><span class="line">   <span class="built_in">NSDictionary</span> *Strategies = @&#123;</span><br><span class="line">                           <span class="string">@&quot;day1&quot;</span> : [<span class="keyword">self</span> invocationWithMethod:<span class="keyword">@selector</span>(playBasketball)],</span><br><span class="line">                           <span class="string">@&quot;day2&quot;</span> : [<span class="keyword">self</span> invocationWithMethod:<span class="keyword">@selector</span>(shopping)],</span><br><span class="line">                           <span class="string">@&quot;day3&quot;</span> : [<span class="keyword">self</span> invocationWithMethod:<span class="keyword">@selector</span>(washClothes)],</span><br><span class="line">                           <span class="string">@&quot;day4&quot;</span> : [<span class="keyword">self</span> invocationWithMethod:<span class="keyword">@selector</span>(playGames)],</span><br><span class="line">                           <span class="string">@&quot;day5&quot;</span> : [<span class="keyword">self</span> invocationWithMethod:<span class="keyword">@selector</span>(sing)],</span><br><span class="line">                           <span class="string">@&quot;day6&quot;</span> : [<span class="keyword">self</span> invocationWithMethod:<span class="keyword">@selector</span>(watchMovie)],</span><br><span class="line">                           <span class="string">@&quot;day7&quot;</span> : [<span class="keyword">self</span> invocationWithMethod:<span class="keyword">@selector</span>(climbing)],</span><br><span class="line">                           &#125;;</span><br><span class="line">   <span class="keyword">return</span> Strategies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.找出小明哪天做的事</span></span><br><span class="line">    <span class="built_in">NSInvocation</span> *doWhat = <span class="keyword">self</span>.Strategies[whichDay];</span><br><span class="line">    [doWhat invoke];</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><p><a href="https://blog.csdn.net/qq_35440678/article/details/77939999">6个实例详解如何把if-else代码重构成高质量代码</a></p></li><li><p><a href="https://juejin.im/post/6844904083665453063">if-else代码优化的八种方案</a></p></li><li><p><a href="https://www.jianshu.com/p/0690516e5f17">[iOS]使用策略模式来去除繁琐的if-else</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS可复用项目框架搭建</title>
      <link href="/2020/10/03/iOS%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/10/03/iOS%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>入职了一家公司，刚好处于项目启动阶段，花了一周时间搭建了项目框架，现在总结一下。</p><span id="more"></span><h3 id="框架设计目的"><a href="#框架设计目的" class="headerlink" title="框架设计目的"></a>框架设计目的</h3><p>软件系统的框架设计跟盖房子搭框架原理相似，根基打牢了，框架搭好了，后续就是往里面填业务逻辑了。框架系统的搭建所遵循的原则如下</p><ol><li>DRY即Don’t repeat yourself</li><li>Kiss即Keep It Simple，Stupid</li><li>六大设计原则（Solid）</li></ol><p><code>让工程架构更简洁易懂，隐藏复杂的细节提供易用的API</code></p><ul><li>框架设计模式</li></ul><p>这里项目采用的MVVM的框架设计模式，因为VM作为中间层，可以适应不同业务层的数据逻辑处理，从而提高Controller作为View的复用率。</p><img src="/2020/10/03/iOS%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/ViewModel.png" class=""><p>ViewModel其实是View的数据层的影子，它的神奇之处在于这个影子是可以被改变然后映射到实体上。这个过程中ViewModel抽象出UI的数据，然后将这些与UI上的属性进行绑定</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="APP业务无关的功能模块进行封装"><a href="#APP业务无关的功能模块进行封装" class="headerlink" title="APP业务无关的功能模块进行封装"></a>APP业务无关的功能模块进行封装</h4><ol><li>常用分类Category</li></ol><p>为了提高可复用性，通过将一些通用（Kit、Foundation相关）业务无关的功能封装成私有库，这里用私有Pod来管理，避免开发其他App时重复工作，暂时就封装了两个私有库，一个Kit，一个Foundation，两个库的实现都是借鉴YYCategories里面的功能，因为作者写得实在太好，无法超越….同时将一些常用的与业务无关的宏定义也分别放在了私有库里面了。</p><ol start="2"><li><p>网络层<br>公司都会有自己的网络层，集中型或者分散型，目前主流的是借鉴猿题库的YTKNetwork，把每个网络请求实例化，便于定制缓存，请求管理和依赖，这里我借鉴的是网上的一个基于MVVM的网络框架，也是将每个请求实例化，通过代理的方式（没有使用Block捕获对象导致对象延迟释放问题），定义一个请求的基类，基于基类又封装了一个分页的请求基类</p></li><li><p>后续会将一些通用的自定义View封装成库</p></li></ol><h4 id="PCH文件"><a href="#PCH文件" class="headerlink" title="PCH文件"></a>PCH文件</h4><p>PCH的作用：</p><ol><li>存放一些全局的宏(整个项目中都用得上的宏)  一个用来定义APP相关的主题类（UIColor，UIFont）宏文件，一个第三方参数的宏文件</li><li>用来包含一些全部的头文件(整个项目中都用得上的头文件)</li><li>能自动打开或者关闭日志输出功能</li></ol><h4 id="Base基类"><a href="#Base基类" class="headerlink" title="Base基类"></a>Base基类</h4><p>继承作为一种强关联的高耦合方式，在开发的时候是要慎用的，一般都是建议使用组合方式进行替换，基于OC的语言特性，可以使用相应的分类实现。(实际中组合(Composition)往往结合接口、委托(delegation)这两种技术手段来解决继承的问题 )</p><p><code>继承是一种is-a的关系，而组合是一种has-a关系</code></p><ul><li>BaseViewController</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WSFBaseViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  修改状态栏颜色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UIStatusBarStyle</span> StatusBarStyle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)<span class="built_in">UIInterfaceOrientationMask</span> supportedOrientationMask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">UITableView</span> * tableView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">UICollectionView</span> * collectionView;</span><br><span class="line"></span><br><span class="line">-(<span class="type">void</span>)didInitialized  <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark --  加载 ViewController</span></span><br><span class="line"><span class="comment">//是否为刷新状态</span></span><br><span class="line">- (<span class="type">BOOL</span>)isShowReFreshingStatus;</span><br><span class="line"><span class="comment">//显示菊花</span></span><br><span class="line">- (<span class="type">void</span>)showReFreshingViewWithTip:(<span class="built_in">NSString</span> *)tip;</span><br><span class="line"><span class="comment">//关闭菊花</span></span><br><span class="line">- (<span class="type">void</span>)hiddenReFreshingView;</span><br><span class="line"><span class="comment">//显示错误</span></span><br><span class="line">- (<span class="type">void</span>)showErrorViewWithTip:(<span class="built_in">NSString</span> *)tip;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span>  mark -  导航栏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  是否显示返回按钮,默认情况是YES</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> isShowLeftBack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 是否隐藏导航栏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> isHidenNaviBar;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 导航栏添加文本按钮</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param titles 文本数组</span></span><br><span class="line"><span class="comment"> @param isLeft 是否是左边 非左即右</span></span><br><span class="line"><span class="comment"> @param target 目标</span></span><br><span class="line"><span class="comment"> @param action 点击方法</span></span><br><span class="line"><span class="comment"> @param tags tags数组 回调区分用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)addNavigationItemWithTitles:(<span class="built_in">NSArray</span> *)titles isLeft:(<span class="type">BOOL</span>)isLeft target:(<span class="type">id</span>)target action:(SEL)action tags:(<span class="built_in">NSArray</span> *)tags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 导航栏添加图标按钮</span></span><br><span class="line"><span class="comment"> @param imageNames 图标数组</span></span><br><span class="line"><span class="comment"> @param isLeft 是否是左边 非左即右</span></span><br><span class="line"><span class="comment"> @param target 目标</span></span><br><span class="line"><span class="comment"> @param action 点击方法</span></span><br><span class="line"><span class="comment"> @param tags tags数组 回调区分用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)addNavigationItemWithImageNames:(<span class="built_in">NSArray</span> *)imageNames isLeft:(<span class="type">BOOL</span>)isLeft target:(<span class="type">id</span>)target action:(SEL)action tags:(<span class="built_in">NSArray</span> *)tags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  默认返回按钮的点击事件，默认是返回，子类可重写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)backBtnClicked;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WSFBaseViewController</span> (<span class="title">WSFSubclassViewController</span>)</span></span><br><span class="line">- (<span class="type">void</span>)initSubviews <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line">-(<span class="type">void</span>)addConstraint;</span><br><span class="line">-(<span class="type">void</span>)setup</span><br></pre></td></tr></table></figure><ul><li>LoadPageView</li></ul><p>每个页面都会有NoData，网络故障等通用状态显示页面，这里单独封装成一个对象</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://juejin.im/post/6844903487721963527">YTKNetwork学习</a></li><li><a href="https://www.jianshu.com/p/985f662e15e3">iOS项目架构设计</a></li><li><a href="https://juejin.im/post/6844903623252525064">今日头条：iOS 架构设计杂谈</a></li><li><a href="https://github.com/JackWchen2015/UniversalProject">Demo</a></li><li><a href="https://github.com/XuYang8026/UniversalProject">Code</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BST数据结构</title>
      <link href="/2020/07/20/BST%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/07/20/BST%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>二叉查找树（Binary Search Treee），也称二叉搜索树，是指一课空树或者具有下列性质的二叉树：</p><ol><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉搜索树；</li></ol><p>二叉搜索树相比其他数据结构的优势在于查找、插入的时间复杂度较低。为O（log n）</p><span id="more"></span><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>向一个二叉搜索树b中插入一个节点s的算法过程为：</p><ol><li>若b是空树，则将s所指节点作为根节点插入，否则：</li><li>若s-&gt;data 等于b的根节点的数据域之值，则返沪，否则：</li><li>若s-&gt;data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：</li><li>把s所指节点插入到右子树中。（新插入节点总是叶子节点）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当二元搜尋樹T中不存在关键字等于e.key的数据元素时，插入e并返回TRUE，否则返回 FALSE */</span></span><br><span class="line">Status <span class="title function_">InsertBST</span><span class="params">(BiTree *&amp;T, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) &#123;</span><br><span class="line">        s = new BiTNode;</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        T = s; <span class="comment">// 被插節点*s为新的根结点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.key == T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 关键字等于e.key的数据元素，返回錯誤</span></span><br><span class="line">    <span class="keyword">if</span> (e.key &lt; T-&gt;data.key)</span><br><span class="line">        InsertBST(T-&gt;lchild, e);  <span class="comment">// 將 e 插入左子樹</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        InsertBST(T-&gt;rchild, e);  <span class="comment">// 將 e 插入右子樹</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>在二叉搜索树b中查找x的过程为：</p><ol><li>若b是空树，则搜索失败，否则：</li><li>若x等于b的根节点的数据域之值，则查找成功；否则：</li><li>若x小于b的根节点的数据域之值，则搜索左子树；否则：</li><li>查找右子树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BiTree T, KeyType key, BiTree f, BiTree &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在根指针T所指二元查找樹中递归地查找其關键字等於key的數據元素，若查找成功，</span></span><br><span class="line">    <span class="comment">// 則指针p指向該數據元素節點，并返回TRUE，否則指针指向查找路徑上訪問的最後</span></span><br><span class="line">    <span class="comment">// 一個節點并返回FALSE，指针f指向T的雙親，其初始调用值為NULL</span></span><br><span class="line">    <span class="keyword">if</span> (!T) &#123; <span class="comment">// 查找不成功</span></span><br><span class="line">        p = f;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == T-&gt;data.key) &#123; <span class="comment">// 查找成功</span></span><br><span class="line">        p = T;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data.key) <span class="comment">// 在左子樹中繼續查找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;lchild, key, T, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 在右子樹中繼續查找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;rchild, key, T, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>中序遍历   二叉查找树的Python代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">traverse_binary_tree(node.leftChild, callback)</span><br><span class="line">callback(node.value)</span><br><span class="line">traverse_binary_tree(node.rightChild, callback)</span><br></pre></td></tr></table></figure><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>&#96;&#96;&#96;cpp<br>#include <iostream></p><p> struct TreeNode {<br>    int val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    TreeNode(int x) : val(x), left(NULL), right(NULL) {}<br>};</p><p>bool addElem(TreeNode*&amp; node, int i)<br>{<br>    if (!node) {<br>        node &#x3D; new TreeNode(i);<br>        return true;<br>    } else {<br>        if (node-&gt;val&#x3D;&#x3D;i) {<br>            return false;<br>        }<br>        else if (node-&gt;val&lt;i) {<br>            addElem(node-&gt;right,i);<br>        }<br>        else{<br>            addElem(node-&gt;left,i);<br>        }<br>        return true;<br>    }<br>}</p><p>bool searchBST(TreeNode* tree,TreeNode node)<br>{<br>    if (!tree) {<br>        return false;<br>    }<br>    else<br>    {<br>        if (tree-&gt;val&#x3D;&#x3D;node.val) {<br>            return true;<br>        }<br>        else if (tree-&gt;val&gt;node.val)<br>        {<br>           return  searchBST(tree-&gt;left, node);<br>        }<br>        else<br>        {<br>           return  searchBST(tree-&gt;right, node);<br>        }<br>    }<br>}<br>void  inOrderTraversal(TreeNode* node)<br>{<br>    if (node) {<br>        inOrderTraversal(node-&gt;left);<br>        printf(“%d “,node-&gt;val);<br>        inOrderTraversal(node-&gt;right);<br>    }</p><p>}<br>int main(int argc, const char * argv[]) {<br>     TreeNode*  head&#x3D;NULL;</p><pre><code> addElem(head,8); addElem(head,3); addElem(head,5); addElem(head,6); addElem(head,9); addElem(head,7); inOrderTraversal(head);TreeNode tmp=TreeNode(10);TreeNode tmp2=TreeNode(5);printf(&quot;\n search tmp %d tmp2 %d\n&quot;,searchBST(head,tmp),searchBST(head,tmp2));return 0;</code></pre><p>}&#96;&#96;&#96;</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2020/07/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/07/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><span id="more"></span><h4 id="严蔚敏版数据结构解法"><a href="#严蔚敏版数据结构解法" class="headerlink" title="严蔚敏版数据结构解法"></a>严蔚敏版数据结构解法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort_Book</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pivot=<span class="built_in">quick_sort_pivot</span>(nums,left,right);</span><br><span class="line">        <span class="built_in">quick_sort_Book</span>(nums,left,pivot<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quick_sort_Book</span>(nums,pivot+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_sort_pivot</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=nums[right];</span><br><span class="line">    <span class="type">int</span> begin=left,end=right<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(begin&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[begin]&lt;mid&amp;&amp;begin&lt;end) begin++;</span><br><span class="line">        <span class="keyword">while</span>(nums[end]&gt;=mid&amp;&amp; begin&lt;end) end--;</span><br><span class="line">        <span class="built_in">swap</span>(nums[begin],nums[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[begin]&gt;=nums[right])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[begin],nums[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> begin++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort_recursive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> start,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left=start,right=end<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mid=nums[end];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从左边找一个比mid大的数</span></span><br><span class="line">            <span class="keyword">while</span>(nums[left]&lt;mid&amp;&amp; left&lt;right)</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">while</span>(nums[right]&gt;=mid&amp;&amp;left&lt;right)</span><br><span class="line">            right--;</span><br><span class="line"></span><br><span class="line">            std::<span class="built_in">swap</span>(nums[left],nums[right]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[left]&gt;=nums[end])</span><br><span class="line">        <span class="built_in">swap</span>(nums[left],nums[end]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        left++;</span><br><span class="line">        <span class="built_in">quick_sort_recursive</span>(nums,start,left<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quick_sort_recursive</span>(nums,left+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.runoob.com/w3cnote/quick-sort-2.html">快速排序</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Block</title>
      <link href="/2020/07/03/%E5%85%B3%E4%BA%8EBlock/"/>
      <url>/2020/07/03/%E5%85%B3%E4%BA%8EBlock/</url>
      
        <content type="html"><![CDATA[<p>几个关于block的问题</p><ol><li>block的内部实现，结构体是什么样的</li><li>block是类吗，有哪些类型</li><li>一个int变量被 __block 修饰与否的区别？block的变量截获</li><li>block在修改NSMutableArray，需不需要添加__block</li><li>怎么进行内存管理的</li><li>block可以用strong修饰吗</li><li>解决循环引用时为什么要用__strong、__weak修饰</li><li>block发生copy时机</li><li>Block访问对象类型的auto变量时，在ARC和MRC下有什么区别</li></ol><span id="more"></span><h3 id="闭包和block"><a href="#闭包和block" class="headerlink" title="闭包和block"></a>闭包和block</h3><blockquote><p>闭包是一个函数（或指向函数的指针），再加上该函数执行的外部的上下文变量（有时候也称作自由变量）。</p></blockquote><p><code>block实际上就是Objcective-C对于闭包的实现</code></p><h3 id="block的内部实现，数据结构是什么样的？"><a href="#block的内部实现，数据结构是什么样的？" class="headerlink" title="block的内部实现，数据结构是什么样的？"></a>block的内部实现，数据结构是什么样的？</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="type">void</span> (^block)(<span class="type">void</span>) =  ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>,age);</span><br><span class="line"> &#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>通过clang编译成cpp文件<br><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code></p><p>block结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// block的定义</span></span><br><span class="line"><span class="built_in">void</span> (*block)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br><span class="line"><span class="comment">// block的调用</span></span><br><span class="line">((<span class="built_in">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除掉一些强制转换的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">void</span> (*block)(<span class="type">void</span>) = &amp;__main_block_impl_0(</span><br><span class="line">__main_block_func_0, </span><br><span class="line">&amp;__main_block_desc_0_DATA, </span><br><span class="line">age</span><br><span class="line">);</span><br><span class="line"><span class="comment">// block的调用</span></span><br><span class="line">block-&gt;<span class="built_in">FuncPtr</span>(block);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>block本质就是一个结构体对象，结构体<code>__main_block_imp_0</code>结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//构造函数(类似于OC中的init方法) _age是外面传入的</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> _age, <span class="type">int</span> flags=<span class="number">0</span>) : age(_age) &#123;</span><br><span class="line">    <span class="comment">//isa指向_NSConcreteStackBlock 说明这个block就是_NSConcreteStackBlock类型的</span></span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结构体中第一个变量是<code>struct __block_impl impl</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">      <span class="type">void</span> *isa;</span><br><span class="line">      <span class="type">int</span> Flags;</span><br><span class="line">      <span class="type">int</span> Reserved;</span><br><span class="line">      <span class="type">void</span> *FuncPtr;</span><br><span class="line">&#125;;       </span><br></pre></td></tr></table></figure><p>结构体中第二个变量是<code>__main_block_desc_0</code>;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size; <span class="comment">// 结构体__main_block_impl_0 占用的内存大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="block数据类型"><a href="#block数据类型" class="headerlink" title="block数据类型"></a>block数据类型</h4><p>block中有isa指针，block是一个OC对象</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (^block)(<span class="type">void</span>) =  ^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;123&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block.class = %@&quot;</span>,[block <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block.class.superclass = %@&quot;</span>,[[block <span class="keyword">class</span>] superclass]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block.class.superclass.superclass = %@&quot;</span>,[[[block <span class="keyword">class</span>] superclass] superclass]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block.class.superclass.superclass.superclass = %@&quot;</span>,[[[[block <span class="keyword">class</span>] superclass] superclass] superclass]);</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iOS-block[18429:234959] block.class = __NSGlobalBlock__</span><br><span class="line">iOS-block[18429:234959] block.class.superclass = __NSGlobalBlock</span><br><span class="line">iOS-block[18429:234959] block.class.superclass.superclass = NSBlock</span><br><span class="line">iOS-block[18429:234959] block.class.superclass.superclass.superclass = NSObject</span><br></pre></td></tr></table></figure><p>继承关系可以表示为<code>__NSGlobalBlock__ : __NSGlobalBlock : NSBlock : NSObject</code></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>isa：由此可知，block也是一个对象类型，具体类型包括_NSConcreteGlobalBlock、_NSConcreteStackBlock、_NSConcreteMallocBlock</li><li>block在Clang编译器前端得到实现，可以生成C中间代码。</li><li>实际上block就是指向结构体的指针</li><li>block本质上也是一个OC对象，它内部也有isa指针，block是封装了函数调用以及函数调用环境的OC对象</li></ol><h3 id="一个int变量被-block-修饰与否的区别？block的变量截获？"><a href="#一个int变量被-block-修饰与否的区别？block的变量截获？" class="headerlink" title="一个int变量被 __block 修饰与否的区别？block的变量截获？"></a>一个int变量被 __block 修饰与否的区别？block的变量截获？</h3><p>没有被__block修饰的int，block体中对这个变量的引用是值拷贝<br>通过__block修饰的int，block体中对这个变量的引用是指针拷贝</p><h4 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h4><p>auto修饰的局部变量，离开作用域就销毁了，指针传递的话，可能导致访问的时候，该变量已经销毁了，程序就会出问题，而全局变量本来就是在哪里都可以访问的，所以无需捕获。</p><img src="/2020/07/03/%E5%85%B3%E4%BA%8EBlock/block01.png" class=""><h3 id="block怎么进行内存管理的？"><a href="#block怎么进行内存管理的？" class="headerlink" title="block怎么进行内存管理的？"></a>block怎么进行内存管理的？</h3><p>block按照内存分布，分三种类型：全局内存中的block、栈内存中的block、堆内存中的block。</p><h4 id="block的3种类型"><a href="#block的3种类型" class="headerlink" title="block的3种类型"></a>block的3种类型</h4><p>可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型</p><img src="/2020/07/03/%E5%85%B3%E4%BA%8EBlock/block02.png" class=""><h4 id="在MRC和ARC下block的分布情况"><a href="#在MRC和ARC下block的分布情况" class="headerlink" title="在MRC和ARC下block的分布情况"></a>在MRC和ARC下block的分布情况</h4><ul><li>MRC下：</li></ul><p>当block内部引用全局变量或者不引用任何外部变量时，该block是在全局内存中的。</p><p>当block内部引用了外部的非全局变量的时候，该block是在栈内存中的。</p><p>当栈中的block进行copy操作时，会将block拷贝到堆内存中。</p><p>通过__block修饰的变量，不会对其应用计数+1，不会造成循环引用。</p><ul><li>ARC下：</li></ul><p>当block内部引用全局变量或者不引用任何外部变量时，该block是在全局内存中的。</p><p>当block内部引用了外部的非全局变量的时候，该block是在堆内存中的。</p><p>也就是说，<code>ARC下只存在全局block和堆block</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过__block修饰的变量，在block内部依然会对其引用计数+1，可能会造成循环引用。</span><br><span class="line"></span><br><span class="line">通过__weak修饰的变量，在block内部不会对其引用计数+1，不会造成循环引用。</span><br></pre></td></tr></table></figure><h3 id="block可以用strong修饰吗？"><a href="#block可以用strong修饰吗？" class="headerlink" title="block可以用strong修饰吗？"></a>block可以用strong修饰吗？</h3><p>在MRC环境中，是不可以的，strong修饰符会对修饰的变量进行retain操作，这样并不会将栈中的block拷贝到堆内存中，而执行的block是在堆内存中，所以用strong修饰的block会导致在执行的时候因为错误的内存地址，导致闪退。</p><p>在ARC环境中，是可以的，因为在ARC环境中的block只能在堆内存或全局内存中，因此不涉及到从栈拷贝到堆中的操作。</p><h3 id="解决循环引用时为什么要用-strong、-weak修饰？"><a href="#解决循环引用时为什么要用-strong、-weak修饰？" class="headerlink" title="解决循环引用时为什么要用__strong、__weak修饰？"></a>解决循环引用时为什么要用__strong、__weak修饰？</h3><p>__weak修饰的变量，不会出现引用计数+1，也就不会造成block强持有外部变量，这样也就不会出现循环引用的问题了。</p><p>但是，我们的block内部执行的代码中，有可能是一个异步操作，或者延迟操作，此时引用的外部变量可能会变成nil，导致意想不到的问题，而我们在block内部通过__strong修饰这个变量时，block会在执行过程中强持有这个变量，此时这个变量也就不会出现nil的情况，当block执行完成后，这个变量也就会随之释放了（自动变量，作用域只在block里）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">block内部的strongSelf仅仅是个局部变量，存在栈中，会在block执行结束之后回收，不会再造成循环引用，并且会使页面返回上一级</span><br><span class="line">时，不执行dealloc方法，直到block执行完，控制器执行dealloc方法，内存释放！</span><br></pre></td></tr></table></figure><h3 id="block发生copy时机？"><a href="#block发生copy时机？" class="headerlink" title="block发生copy时机？"></a>block发生copy时机？</h3><p>一般情况在ARC环境中，编译器将创建在栈中的block会自动拷贝到堆内存中，而block作为方法或函数的参数传递时，编译器不会做copy操作。如下情况，编译器会自动copy</p><ol><li>block作为方法或函数的返回值时，编译器会自动完成copy操作。</li><li>当block赋值给通过strong或copy修饰的id或block类型的成员变量时。</li><li>当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。</li></ol><h3 id="Block访问对象类型的auto变量时，在ARC和MRC下有什么区别"><a href="#Block访问对象类型的auto变量时，在ARC和MRC下有什么区别" class="headerlink" title="Block访问对象类型的auto变量时，在ARC和MRC下有什么区别?"></a>Block访问对象类型的auto变量时，在ARC和MRC下有什么区别?</h3><p>首先我们知道，在ARC下，栈区创建的block会自动copy到堆区；而MRC下，就不会自动拷贝了，需要我们手动调用copy函数。</p><p>我们再说说block的copy操作，当block从栈区copy到堆区的过程中，也会对block内部访问的外部变量进行处理，它会调用Block_object_assign函数对变量进行处理，根据外部变量是strong还会weak对block内部捕获的变量进行引用计数+1或-1，从而达到强引用或弱引用的作用。</p><p>因此</p><p>在ARC下，由于block被自动copy到了堆区，从而对外部的对象进行强引用，如果这个对象同样强引用这个block，就会形成循环引用。</p><p>在MRC下，由于访问的外部变量是auto修饰的，所以这个block属于栈区的，如果不对block手动进行copy操作，在运行完block的定义代码段后，block就会被释放，而由于没有进行copy操作，所以这个变量也不会经过Block_object_assign处理，也就不会对变量强引用。</p><p>简单说就是：</p><p><code>ARC下会对这个对象强引用，MRC下不会</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://juejin.im/post/5d3171d7f265da1bd26126a0#heading-30">深入理解iOS的block</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Objective-C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iDA Pro安装</title>
      <link href="/2020/06/25/iDA%20Pro%E5%AE%89%E8%A3%85/"/>
      <url>/2020/06/25/iDA%20Pro%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是一次失败的安装，起因是前几天面试被问到，有没有用过iDA这个工具</p></blockquote><span id="more"></span><h2 id="iDA-Pro"><a href="#iDA-Pro" class="headerlink" title="iDA Pro"></a><a href="https://www.hex-rays.com/">iDA Pro</a></h2><p>简单来说，就是国外开发的收费的专业的逆向分析工具，至于具体有多专业，因为我也没有安装成功，就不做评价。</p><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>环境：mac OS Catalina （10.15.5），Mac mini（Late 2014）， <em><a href="https://xclient.info/s/hex-rays-ida-pro.html">IDA Pro 7.0</a></em></p><p>下载完成后，双击app，直接退出…，进入application里的安装包看看，…&#x2F;Applicaiton&#x2F;Contents&#x2F;MacOS&#x2F;目录下，有installbuilder.sh的脚本，推测双击app会执行这个安装脚本，然后在terminal下执行看看有没有问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Jack@Mac-mini MacOS % sh installbuilder.sh</span><br><span class="line">installbuilder.sh: line 18: ./osx-intel: Bad CPU <span class="built_in">type</span> <span class="keyword">in</span> executable</span><br></pre></td></tr></table></figure><p>分析 shell 18行代码的问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 1 <span class="comment">#!/bin/sh</span></span><br><span class="line"> 2</span><br><span class="line"> 3 os_version=`<span class="built_in">uname</span> -r`</span><br><span class="line"> 4 machine_platform=`<span class="built_in">uname</span> -p`</span><br><span class="line"> 5 <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;os_version:0:1&#125;</span>&quot;</span> == <span class="string">&quot;6&quot;</span> ];<span class="keyword">then</span></span><br><span class="line"> 6     executable=<span class="string">&quot;none&quot;</span></span><br><span class="line"> 7 <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$&#123;machine_platform&#125;</span>&quot;</span> == <span class="string">&quot;i386&quot;</span> ];<span class="keyword">then</span></span><br><span class="line"> 8     executable=<span class="string">&quot;osx-intel&quot;</span></span><br><span class="line"> 9 <span class="keyword">else</span></span><br><span class="line">10     executable=<span class="string">&quot;none&quot;</span></span><br><span class="line">11 <span class="keyword">fi</span></span><br><span class="line">12</span><br><span class="line">13 <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$executable</span>&quot;</span> == <span class="string">&quot;none&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">14     <span class="built_in">echo</span> <span class="string">&quot;The current OS X version is not supported&quot;</span></span><br><span class="line">15     <span class="built_in">exit</span> 1</span><br><span class="line">16 <span class="keyword">fi</span></span><br><span class="line">17</span><br><span class="line">18         <span class="string">&quot;`dirname \&quot;<span class="variable">$&#123;0&#125;</span>\&quot;`/<span class="variable">$executable</span>&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure><p>也就是说  i386 导致的  <code>./osx-intel: Bad CPU type in executable</code>这个错误，一脸懵逼，然后就去查了下Bad CPU type in executable这个错误，结果找到这个<a href="https://discussions.apple.com/thread/250777998">结果</a>，于是我以为是默认bash的问题，然后有了下面的部分。</p><h3 id="shell、bash、zsh"><a href="#shell、bash、zsh" class="headerlink" title="shell、bash、zsh"></a>shell、bash、zsh</h3><p>查看当前shell使用 <code>echo $SHELL</code></p><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><ol><li><p>shell是一个命令行解释器</p></li><li><p>Login 和 Non-login<br>login shell 是指登陆系统后获得的顶层shell，比如最常用的ssh登陆，登录完成后得到一个login shell，如果已经登录了桌面电脑，打开terminal进入的shell就是Non-login shell。</p></li></ol><h4 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h4><p>Bash是最常见的shell，Mac中默认shell就是bash，唤起bash shell时加载的不同文件，login shell 加载 <code>～/.bash_profile</code><br>,而non-login shell加载 <code>~/.bashrc</code></p><h4 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h4><p>很多mac中会使用zsh而不是bash，一大半是因为oh-my-zsh这个配置集，它兼容bash，还有自动补全等好用的功能。zsh的配置文件<code>~/.zshrc</code></p><h3 id="更改shell路径-error"><a href="#更改shell路径-error" class="headerlink" title="更改shell路径 error"></a>更改shell路径 error</h3><p><code>chsh: /usr/bin/zsh: non-standard shell</code></p><p>说明：zsh路径不对</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. which zsh</span><br><span class="line">2. chsh -s /bin/zsh</span><br><span class="line">3. Restart your machine</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="安装继续"><a href="#安装继续" class="headerlink" title="安装继续"></a>安装继续</h3><p>更改完Shell为zsh后，继续安装，发现还是报错，看来是走了弯路，再去看下那个报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Jack@Mac-mini MacOS % file osx-intel</span><br><span class="line">osx-intel: Mach-O executable i386</span><br></pre></td></tr></table></figure><p>查了下资料才发现 <code>自 macOS 10.15.1/Catalina 后终止了对 32 位可执行程序的兼容</code> ….</p><h3 id="曙光到来"><a href="#曙光到来" class="headerlink" title="曙光到来"></a>曙光到来</h3><p>找到了 Catalina下的版本 <a href="https://github.com/swfangzhang/IDA-pro-7-for-Catalina-OSX-15">IDA-pro-7-for-Catalina-OSX-15</a></p><p>可用</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我的系统和CPU都是64位的,但是为什么<code>uname -p</code>返回的是 i386？这个-p代表的是什么？没查到….</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Jack@Mac-mini ~ % uname -a</span><br><span class="line">Darwin Mac-mini.local 19.5.0 Darwin Kernel Version 19.5.0: Tue May 26 20:41:44 PDT 2020; root:xnu-6153.121.2~2/RELEASE_X86_64 x86_64</span><br><span class="line">Jack@Mac-mini ~ % uname -p</span><br><span class="line">i386</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/u010953692/article/details/94907317#1IDA_Pro_70_macOS__1">IDA Pro 7.0 macOS 安装</a></li><li><a href="https://github.com/swfangzhang/IDA-pro-7-for-Catalina-OSX-15">IDA-pro-7-for-Catalina-OSX-15</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS逆向攻防</title>
      <link href="/2020/05/20/iOS%E9%80%86%E5%90%91%E6%94%BB%E9%98%B2/"/>
      <url>/2020/05/20/iOS%E9%80%86%E5%90%91%E6%94%BB%E9%98%B2/</url>
      
        <content type="html"><![CDATA[<p>OC的消息传递，可以通过Method Swizzle进行Hook，但是遇到共享库里的C函数呢，如何Hook？</p><span id="more"></span><h2 id="fishhook"><a href="#fishhook" class="headerlink" title="fishhook"></a>fishhook</h2><p>fishhook是Facebook提供的一个动态修改链接mach-o文件的工具，它利用Mach-o文件加载原理，通过修改懒加载和非懒加载两个表的指针达到<code>Hook C函数</code>的目的。</p><h3 id="Hook使用"><a href="#Hook使用" class="headerlink" title="Hook使用"></a>Hook使用</h3><p>只有两个文件 “fishhook.h”和“fishhook.c”,它提供的接口仅有一个结构体和两个函数:<br>rebinding结构体用来确定你要HOOK的函数和要交换的函数地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struce rebinding&#123;</span><br><span class="line">constchar*  name;<span class="comment">//需要hook的函数名称，C字符串</span></span><br><span class="line"><span class="type">void</span> * replaement；<span class="comment">//新函数的地址</span></span><br><span class="line"><span class="type">void</span>** replaced；<span class="comment">//原始函数地址的指针！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     arg1: 存放rebinding 结构体的数组</span></span><br><span class="line"><span class="comment">     arg2: 数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rebind_symbols</span><span class="params">(<span class="keyword">struct</span> rebinding rebindings[], <span class="type">size_t</span> rebindings_nel)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rebind_symbols_image</span><span class="params">(<span class="type">void</span> *header,<span class="type">intptr_t</span> slide,<span class="keyword">struct</span> rebinding rebindings[],<span class="type">size_t</span> rebindings_nel)</span>;</span><br></pre></td></tr></table></figure><p>eg:使用Demo Hook一下NSLog</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数指针</span></span><br><span class="line">staticvoid(*sys_nslog)(<span class="built_in">NSString</span>* format,...);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个新的函数。HOOK成功后NSLog调用时，会来到这里</span></span><br><span class="line"><span class="type">void</span> myNSLog(<span class="built_in">NSString</span>* format,...)&#123;</span><br><span class="line">    format = [format stringByAppendingString:<span class="string">@&quot;\n上钩了！\n\n&quot;</span>];</span><br><span class="line">    sys_nslog(format);<span class="comment">//调用系统的NSLog，HOOK成功后sys_nslog指针保存的是Fundation中NSLog的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//准备rebinding结构体</span></span><br><span class="line">    <span class="keyword">struct</span> rebinding nslog;</span><br><span class="line">    nslog.name = <span class="string">&quot;NSLog&quot;</span>;</span><br><span class="line">    <span class="comment">//需要HOOK的函数名称</span></span><br><span class="line">    nslog.replacement = myNSLog;</span><br><span class="line">    <span class="comment">//新函数的地址</span></span><br><span class="line">    nslog.replaced = (<span class="type">void</span> *)&amp;sys_nslog;</span><br><span class="line">    <span class="comment">//原始函数指针</span></span><br><span class="line">    <span class="comment">//准备数组，将一个或多个 rebinding 结构体放进去。</span></span><br><span class="line">    <span class="keyword">struct</span> rebinding rebs[<span class="number">1</span>] = &#123;nslog&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     arg1: 存放rebinding 结构体的数组</span></span><br><span class="line"><span class="comment">     arg2: 数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rebind_symbols(rebs, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><h4 id="MachO"><a href="#MachO" class="headerlink" title="MachO"></a>MachO</h4><p>我们生成的ipa包，里面就包含MachO文件，这个文件里包含程序的数据和指令，比如你定义的类，方法，全局变量，方法实现等等。</p><ul><li>自定义函数和系统函数的区别</li></ul><ol><li>自定义函数在MachO文件中，在运行时刻进入内存，自定义函数在本镜像文件中。</li><li>系统函数在系统框架中，在运行时刻进入内存，系统函数在系统的动态库中，比如NSLog在Fundtaion这个镜像文件中。</li></ol><p>自定义的函数，在编译时刻，编译器就可以确定函数的实现地址（在MachO文件中的偏移地址），但是系统函数是没办法知道的，那么在CPU执行系统函数的时候，如何知道系统函数的地址呢？</p><h4 id="PIC（position-Independ-code）技术"><a href="#PIC（position-Independ-code）技术" class="headerlink" title="PIC（position Independ code）技术"></a>PIC（position Independ code）技术</h4><p>翻译过来就是位置独立代码。</p><blockquote><p>当你的程序要调用一个MachO外部函数的时候，编译器是没办法知道该函数的地址的，所以它在MachO文件里面生成一个列表，这个列表里放指针，让当前的系统函数调用指向这个列表里面对应的指针，等到我们的MachO文件加载进内存时，再将系统函数的真实地址，一个一个的赋值给列表中的指针。</p></blockquote><ul><li>这个列表就是符号表</li><li>列表里的指针，成为符号</li><li>给里面的指针赋值的过程，称为符号绑定</li></ul><p>所以fishhook之所以Hook不了自定义的函数，就是因为自定义的函数，没有通过符号寻找地址这个过程，而系统函数是通过符号去绑定实现地址的。fishhook就是修改了系统函数的符号达到Hook的目的。</p><p><code>fishhook应用，可以hook 函数objc_msgSend 二进制重排减少page fault 来达到启动优化</code></p><h2 id="一次逆向"><a href="#一次逆向" class="headerlink" title="一次逆向"></a>一次逆向</h2><p>在技术群里，偶然看到一个直播APP链接，好奇驱动下，下载安装，然后打开了新世界的大门，无法自拔….看着这些诱人又年轻活泼的小姐姐，当然要发挥一下我的聊骚本领，可是发现聊天，加好友，刷礼物都需要金币，这些都是要充值RMB的，我是穷人呀…然后想试试是否可以破解给自己充值。</p><h3 id="获取脱壳ipa包"><a href="#获取脱壳ipa包" class="headerlink" title="获取脱壳ipa包"></a>获取脱壳ipa包</h3><p>因为是通过企业证书安装的方式，所以并不需要脱壳，所以这一步只需要获取ipa安装包即可，这个App的安装方式是通过一个plist文件（里面包含ipa的真实url），然后会自动安装，所以要想获取ipa的url路径，需要先获取到这个plist文件，这里借助charles来查看app安装链接跳转后的plist文件路径，和返回的ipa的url。</p><h3 id="重签名调试"><a href="#重签名调试" class="headerlink" title="重签名调试"></a>重签名调试</h3><p>这里就跟之前博客里介绍过的流程一样。</p><h3 id="HooK业务"><a href="#HooK业务" class="headerlink" title="HooK业务"></a>HooK业务</h3><p>这里Hook了UserModel的一些相关属性，比如金币，level…的getter方法，但是发现并没有什么作用，只是改变了App界面上的数据显示，实际发送礼物等需要消耗金币的操作，后台会去做校验，充值模块又是直接用的H5页面…看来App的破解顶多也只是做个路由转发，并没太大实际作用，再者就是破解优质App，分析别人的技术实现方案了.</p><p>想起来之前github上有看到过一个某度网盘的下载限制破解的仓库，于是我去看了下破解方法，下载完代码之后一看，居然也是粗暴的将Uer Model的vip属性getter方法Hook返回为true，然后你就看到可以一直使用vip的下载试用了….想不到大厂的代码也不过如此，再想到我每次面试大厂时的卑微姿态，真的是…</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.jianshu.com/p/c0331869b6af">fishHook原理探究</a></li><li><a href="https://www.infoq.cn/article/P9gE3zuDHLRrRfW4hvRP">一行代码解决！iOS 二进制重排启动优化</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 逆向安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS内存管理</title>
      <link href="/2020/05/16/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2020/05/16/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>苹果公司在2011年的全球开发者大会上指出，90%的应用崩溃与内存管理有关，其中最主要的原因是错误的内存访问和保留环所引起的内存泄漏。</p></blockquote><span id="more"></span><h2 id="虚拟内存和物理内存"><a href="#虚拟内存和物理内存" class="headerlink" title="虚拟内存和物理内存"></a>虚拟内存和物理内存</h2><p>计算机组成原理里可知，32位CPU对应32位OS，它的寻址空间是2的32次方，约为4GB，意味着在32位的计算机系统中，理论支持的物理最大寻址空间是4GB。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32位CPU只有32根地址总线，所以最大的寻址能力是2的32次方</span><br></pre></td></tr></table></figure><h3 id="虚拟内存到物理内存的映射"><a href="#虚拟内存到物理内存的映射" class="headerlink" title="虚拟内存到物理内存的映射"></a>虚拟内存到物理内存的映射</h3><img src="/2020/05/16/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/mmu.png" class=""><p>主要是两个寄存器起作用，界限寄存器用来判断是否越界，如果没有越界就会加上基址寄存器的值，转换为物理内存地址。</p><p>虚拟内存是OS提供给进程使用的概念，而物理内存是CPU提供给OS的概念，从逻辑地址到物理地址最终由CPU中的内存管理单元MMU（Memory Management Unit）进行映射，这样每个进程都能有0x00000000～0xffffffff的寻址空间，物理RAM有限，所有进程分配的内存总量会超过物理RAM数量，有了虚拟内存，OS可以使用硬盘来缓存RAM中无法保存的数据</p><blockquote><p>iOS中没有内存置换的技术，这里讨论的是一般的OS，OSX或者Windows</p></blockquote><p><code>虚拟内存的意义如下：保护了每个进程的地址空间、简化了内存管理，利用硬盘空间扩展了内存空间</code></p><h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>为了方便映射和管理，虚拟内存和物理内存都被分割成相同大小的单位，物理内存最小单位被称为帧（Frame），虚拟内存最小单位被称为页（Page）。</p><p>物理内存是按照4kb为一帧被划分开，虚拟内存同样按照4kb为一页来划分，每页的字节数与每帧的字节数始终相同，这样便可以将进程中的每页无缝映射到物理RAM中的每帧。</p><img src="/2020/05/16/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/virtual_mem.png" class=""><p>虚拟内存这么划分的好处是，可以将进程中连续的地址空间映射到物理RAM中不连续的地址空间中（支持了物理内存的离散使用），这可以最大限度节省内存碎片的产生。当一个进程启动时，OS会创建一张表，来保存虚拟内存到物理RAM的映射关系，这个表被称为“分页表”，类似windwos中的HANDLE</p><h3 id="进程中RAM被写满后怎么办？"><a href="#进程中RAM被写满后怎么办？" class="headerlink" title="进程中RAM被写满后怎么办？"></a>进程中RAM被写满后怎么办？</h3><p>在OS X中，会将某些不活跃的帧存到磁盘，但是在iOS中，由于没有内存置换技术，系统会直接将某些不活跃的帧清空！也就是进程在后台被系统杀死了，这主要是由于RAM和磁盘进行数据交换会极大的影响性能。</p><h3 id="进程访问的地址找不到怎么办？"><a href="#进程访问的地址找不到怎么办？" class="headerlink" title="进程访问的地址找不到怎么办？"></a>进程访问的地址找不到怎么办？</h3><p>如果OS确定进程访问的地址是错误的，则报错，终止进程；如果进程访问的地址被保存到了磁盘上，OS首先分配一帧内存用来保存请求页，如果当前没有可用帧，将现有帧缓存到磁盘，腾出空间，然后将请求读到内存中，更新进程的页表，最后将控制权返回给进程。</p><p>Resident Memory是进程的virtual memory中常驻物理RAM中的部分。</p><h2 id="脏内存和干净内存"><a href="#脏内存和干净内存" class="headerlink" title="脏内存和干净内存"></a>脏内存和干净内存</h2><h3 id="Clean-Memory"><a href="#Clean-Memory" class="headerlink" title="Clean Memory"></a>Clean Memory</h3><p><code>Clean memory is file-backed memory in which the contents are in sync with disk.</code></p><p>对于一般的桌面系统，clean memory可以认为是能够进行Page Out（将优先级低的内存数据交换到磁盘上的操作）的部分。</p><p>在iOS中Clean Memory由于在磁盘中有备份，能够再次读取，所以是可以被重新创建的内存，包括以下几种：</p><ol><li>system framework</li><li>binary executable of your app</li><li>memory mapped files</li></ol><p><code>一般来说，Clean Momory是只读的，clean在memory warning的时候可以被discard掉，然后recreate出来，例如JPEG图片被加载到内存中时，用的是mmap，是clean Memory</code></p><h3 id="Dirty-Memory"><a href="#Dirty-Memory" class="headerlink" title="Dirty Memory"></a>Dirty Memory</h3><p><code>Dirty memory is file-backed memory in which the contents have been modified but not yet written back to disk. The in-memory version of data is out of sync with the on-disk version and is said to be dirty. A mechanism called writeback will eventually update the on-disk version, bringing the two in sync.</code></p><p>脏内存是磁盘上已经被修改但尚未回写到磁盘的内存：通常包括以下几种：</p><ol><li>Memory containing buffered writes that have not been flushed to disk yet</li><li>Regions of memory mapped files that have been updated but not written out to disk yet.</li><li>Pages that are in the process of being written to swap space but have changed since the system started writing them to swap space.</li></ol><p>在iOS中所有不是Clean Memory的内存都是脏内存，系统无法回收。主要包括以下几种：</p><ol><li>Heap allocation</li><li>caches</li><li>decompressed images</li></ol><p>当存在内存压力时，系统将卸载一些干净内存，当再次需要改内存时，系统将重新创建它们。但是对于脏内存，系统无法卸载他们，并且iOS没有交换机制，因此脏内存将始终保留在物理内存中，直到达到一定限制为止，然后你的应用被终止，并且所有内存将被回收给系统。</p><p>eg：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span>* str=[<span class="built_in">NSString</span> stringWIthUTF8String:<span class="string">@&quot;Helllo World&quot;</span>];</span><br><span class="line"><span class="built_in">NSString</span>* strConst=<span class="string">@&quot;Hello world Const&quot;</span>;</span><br><span class="line"><span class="built_in">UIImage</span>* wwdcLogo=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;wwdclogo&quot;</span>];</span><br></pre></td></tr></table></figure><ol><li>动态分配在heap上的对象，为dirty momory，无法被回收</li><li>字符串在编译的时候会被存放在代码段中的read-only常量区，是clean的</li><li>UIImage是decommpress出来的data，是dirty memory</li></ol><p><code>既然iOS的脏内存无法被回收，那么我们释放对象的意义是什么？是为了方便脏内存压缩算法么？heap上释放之后的内存是什么内存，会不会被回收？</code></p><h3 id="Private和Shared-Memory"><a href="#Private和Shared-Memory" class="headerlink" title="Private和Shared Memory"></a>Private和Shared Memory</h3><p>RAM中可以被多个进程共享的部分称为Shared Memory，比如系统的Framework，它只映射一份代码到内存，这部分内存会被不同的进程公用，而每个进程单独alloc的内存，则是Pricate Memory</p><h2 id="内存之间的关系"><a href="#内存之间的关系" class="headerlink" title="内存之间的关系"></a>内存之间的关系</h2><p>虚拟内存就是你的应用程序所需的全部内存<br><code>virtual memory = clean memory + dirty memory.</code></p><p>常驻内存是实际加载到物理内存中的内存（物理内存层面），它表示所有脏内存和部分干净内存<br><code>resident memory = dirty memory + clean memory that loaded in physical memory</code></p><p>你的程序有时候会因为系统内存不足而被杀死，这个时候应该更多关注物理内存层面</p><h2 id="iOS内存管理机制"><a href="#iOS内存管理机制" class="headerlink" title="iOS内存管理机制"></a>iOS内存管理机制</h2><p>iOS系统中，App的基本内存管理原则是保证前台App的运行，可能回收后台App（传说中的假后台机制）</p><p>iOS中的内存回收管理技术有以下几种：</p><ol><li>脏内存压缩技术–Compressed Memory</li><li>内存警告机制–Responding to Memory Warnings</li><li>低内存回收机制–Jstsam</li></ol><h3 id="Compressed-Memory"><a href="#Compressed-Memory" class="headerlink" title="Compressed Memory"></a>Compressed Memory</h3><blockquote><p>由于内存容量和读写寿命的限制，iOS没有Disk swap机制，取而代之使用Compressed memory。Disk swap是指mac OS以及一些其他桌面系统中，当内存可用资源紧张时，系统将内存中的内容写入磁盘中backing store（swaping out）并且在需要访问时从磁盘中再读入RAM（swaping in）。与大多数UNIX系统不同的是，macOS没有预先分配磁盘中的一部分作为backing store，而是利用引导分区所有可用的磁盘空间。</p></blockquote><blockquote><p>苹果最初只是公开了从OS X Mavericks开始使用Compressed memory技术，但iOS系统也从iOS7开始悄悄地使用，从OS X Mavericks Core Technology Overview文档中可以了解到该技术在内存紧张时能够将最近使用过的内存占用压缩至原有大小的一半以下，并且能够在需要时解压复用，它在节省内存的同时提高了系统的响应速度，特点如下：</p></blockquote><ol><li>Shrinks memory usage减少了不活跃内存占用</li><li>Improves power efficiency改善电源效率，通过压缩减少磁盘IO带来的损耗</li><li>Minimizes CPU usage压缩&#x2F;解压十分迅速，能够尽可能减少CPU的时间开销</li><li>Is multicore aware支持多核操作</li></ol><h3 id="内存警报"><a href="#内存警报" class="headerlink" title="内存警报"></a>内存警报</h3><p>在当压缩脏内存依然不解决问题，导致内存压力过大则会触发内存警报，可以通过以下四种途径获取警报：</p><ol><li>applicationDidReceviewMemoryWaring协议方法</li><li>[UIViewController didReceiveMemoryWaring]实例方法</li><li>UIApplicaitonDidReceiveMemoryWaringNotification内存警告通知</li><li>DISPATCH_SOURCE_TYPE_MEMORYPRESSURE Dispatch触发源</li></ol><p>开发者收到内存警报后可以主动回收程序的内存空间，以达到缓解内存空间使用压力。假如App的占用内存还是控制不住的时候，最终将导致OOM（Out of Memory）崩溃，这个崩溃依赖于OS提供的低内存回收机制–Jetsam</p><h3 id="Jetsam"><a href="#Jetsam" class="headerlink" title="Jetsam"></a><a href="https://satanwoo.github.io/2017/10/18/abort/">Jetsam</a></h3><p>iOS系统中存在一种系统级的内存回收服务（Jetsam）。它是一个常驻系统中的进程，在内核中的线程执行优先级比其他进程的执行优先级都要高，这也是它能够强制回收内存空间的缘故。</p><p>低内存处理机制Jetsam，这是一个基于优先级队列的机制，</p><img src="/2020/05/16/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/killMem.png" class=""><p>优先级由低到高是：IDLE（空闲）－&gt;BACKGROUND－&gt;FOREGROUND,依次类推。当内存过低的时候，就会在队列中进行广播，希望大家尽量释放内存，如果一段时间后，仍然内存不够，就会开始Kill进程，直到内存够用</p><h2 id="程序级内存管理"><a href="#程序级内存管理" class="headerlink" title="程序级内存管理"></a>程序级内存管理</h2><p>iOS系统中使用引用计数来管理内存对象，当一个对象的计数器不为0的时候，表示这个对象需要被使用，故而是存活的，当计数器为0的时候则表示这个对象不需要被使用。</p><h3 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h3><ol><li>自己创建自己持有</li><li>非自己生成的对象，自己也可以持有</li><li>不需要的自己持有的对象时释放</li><li>非自己持有的对象无法释放</li></ol><img src="/2020/05/16/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/mrc.jpg" class=""><h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3><blockquote><p>自动引用计数（ARC）是一种编译器功能，可提供OC对象的自动内存管理。</p></blockquote><p>ARC环境的作用范围是OC对象，而CoreFoundation或者其它C类型的指针对象&#x2F;结构体需要转换成OC对象才能够使用ARC，通过以下三种桥接方式来利用ARC：</p><ol><li>__bridge 可以桥接OC对象和Core Foundation，而不改变被转换对象的持有对象，当ARC控制的OC对象释放时，对应的Core Foundation对象指针也会被释放。</li><li>__bridge_retained和CFBridgingRetain也能够桥接两者，不同的是它会变更被转换对象的持有状态，即会进行一步retain让它的计数器+1，编译器不会自动管理Core Foundation对象的内存，需要调用CFRelease（）手动释放。</li><li>__bridge_transfer和CFBridgeRelease也能够桥接两者，不同的是它会变更被转换对象的持有状态，即会进行一步release。被转换的对象在赋值给目标对象后随之释放</li></ol><p>在ARC环境下的OC对象的状态，可以用四种修饰符来说明：</p><ol><li>_ _strong这是默认的动作，表明着这个对象是存活状态，持有强引用的变量在超出其作用域时被废弃，随着强引用失效，引用的对象会随之释放。</li><li>_ _weak弱引用一个对象，即不改变被引用对象的持有状态（计数器不变），同时当这个对象被释放后这个使用__weak修饰的变量会自动置为nil。</li><li>_ _unsafe_unretained与weak类似不会修改被引用对象的持有状态（计数器不变），但这个对象释放后这个使用它修饰的变量的指针会悬空不会自动置为nil。</li><li>_ _autoreleasing相当于MRC下[object autorelease]或者ARC下使用@autorelease{}管理的变量，将这个变量标记为自动释放。</li></ol><h3 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h3><h4 id="Block循环引用"><a href="#Block循环引用" class="headerlink" title="Block循环引用"></a>Block循环引用</h4><p>先将强引用的对象转为弱引用指针，防止了Block和对象之间的循环引用，再在Block中将weakSelf的弱引用转换成strongSelf的强引用指针，防止多线程和ARC环境下弱引用随时被释放的问题。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> MyViewController *wself = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.completionHandler = ^(<span class="built_in">NSInteger</span> result) &#123;</span><br><span class="line">    __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(wself) sself = wself; <span class="comment">// 强引用一次</span></span><br><span class="line">    [sself.property removeObserver: sself forKeyPath:<span class="string">@&quot;pathName&quot;</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="降低内存峰值"><a href="#降低内存峰值" class="headerlink" title="降低内存峰值"></a>降低内存峰值</h4><p>Lazy Allocation，懒加载</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> goodsImageView: <span class="type">UIImageView</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> goodsImageView <span class="operator">=</span> <span class="type">UIImageView</span>()</span><br><span class="line">        <span class="keyword">return</span> goodsImageView</span><br><span class="line">    &#125;()</span><br></pre></td></tr></table></figure><h4 id="图片的读取"><a href="#图片的读取" class="headerlink" title="图片的读取"></a>图片的读取</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imageView<span class="operator">?</span>.image <span class="operator">=</span> <span class="type">UIImage</span>(named: name)</span><br><span class="line">imageView<span class="operator">?</span>.image <span class="operator">=</span> <span class="type">UIImage</span>(contentsOfFile: path)</span><br></pre></td></tr></table></figure><ol><li>带缓存，如果频繁读取小文件，用它只需要读取一次就好，但是缺点就是如果使用大图片会常驻内存，对于降低内存峰值不利</li><li>不带缓存，适合使用大图片，使用完就释放</li></ol><h4 id="NSData-amp-内存映射文件"><a href="#NSData-amp-内存映射文件" class="headerlink" title="NSData &amp; 内存映射文件"></a>NSData &amp; 内存映射文件</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init?</span>(<span class="params">contentsOfFile</span> <span class="params">path</span>: <span class="type">String</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">contentsOfFile</span> <span class="params">path</span>: <span class="type">String</span>, <span class="params">options</span> <span class="params">readOptionsMask</span>: <span class="type">NSDataReadingOptions</span>) <span class="keyword">throws</span></span><br></pre></td></tr></table></figure><p>第二种比第一个多一个Options，第二种方式是创建了一个内存映射文件（NSDataReadingMapped），提高读取的速度，也方便了clean diry回收。</p><h4 id="NSAutoReleasePool"><a href="#NSAutoReleasePool" class="headerlink" title="NSAutoReleasePool"></a>NSAutoReleasePool</h4><p>为什么在ARC时代还需要使用自动释放池？原因就是为了避免内存峰值，常见的是一个很大的For循环，里面不段生成autorelease对象，（datawithContentofFile返回的是autorelease对象），其实每迭代一次，资源都已经用完了，不需要再使用，这个时候就可以释放，但是程序需要等到Runloop结束的时候才可以释放，这就增大了内存的峰值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">loadBigData</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10000</span> &#123;</span><br><span class="line">        autoreleasepool &#123;</span><br><span class="line">            <span class="keyword">let</span> data <span class="operator">=</span> <span class="type">NSData</span>.dataWithContentsOfFile(</span><br><span class="line">                path, options: <span class="literal">nil</span>, error: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存警告处理"><a href="#内存警告处理" class="headerlink" title="内存警告处理"></a>内存警告处理</h4><p>收到内存警告时，所要做的：</p><ol><li>尽可能释放资源，尤其是图片等占用内存多的资源，等需要的时候再进行重建</li><li>单例模式的滥用，会导致单例对象一直持有资源，在内存紧张的时候要进行释放。</li><li>进行缓存更推荐使用NSCache而不是NSDictionary，就是因为NSCache不仅线程安全，而且对存在compressed memory情况下的内存警告也做了优化，可以由系统自动释放内存。</li></ol><h3 id="NSString内存管理"><a href="#NSString内存管理" class="headerlink" title="NSString内存管理"></a>NSString内存管理</h3><p>NSString在OC的内存管理策略中是一个特殊的存在，因为其在编译和运行中做了一些优化处理。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XWLog(_var) (&#123; NSString *name = @#_var; NSLog(@<span class="string">&quot;变量名=%@，类型=%@， 地址=%p，值=%@，引用计数=%d&quot;</span>, name, [_var class], _var, _var, (int)[_var retainCount]); &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试代码</span></span><br><span class="line">    <span class="built_in">NSString</span> *a = <span class="string">@&quot;string&quot;</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *b = [[<span class="built_in">NSString</span> alloc]init];</span><br><span class="line">    <span class="built_in">NSString</span> *c = [[<span class="built_in">NSString</span> alloc]initWithString:<span class="string">@&quot;string&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *d = [[<span class="built_in">NSString</span> alloc]initWithFormat:<span class="string">@&quot;string&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *e = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;string&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *f = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;123456789&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *g = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;1234567890&quot;</span>];</span><br><span class="line">    XWLog(a); XWLog(b); XWLog(c); XWLog(d); XWLog(e); XWLog(f); XWLog(g);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">变量名=a，类型=__NSCFConstantString， 地址=<span class="number">0x1015f3120</span>，值=string，引用计数=<span class="number">-1</span></span><br><span class="line">变量名=b，类型=__NSCFConstantString， 地址=<span class="number">0x1019808d0</span>，值=，引用计数=<span class="number">-1</span></span><br><span class="line">变量名=c，类型=__NSCFConstantString， 地址=<span class="number">0x1015f3120</span>，值=string，引用计数=<span class="number">-1</span></span><br><span class="line">变量名=d，类型=<span class="built_in">NSTaggedPointerString</span>， 地址=<span class="number">0xa00676e697274736</span>，值=string，引用计数=<span class="number">-1</span></span><br><span class="line">变量名=e，类型=<span class="built_in">NSTaggedPointerString</span>， 地址=<span class="number">0xa00676e697274736</span>，值=string，引用计数=<span class="number">-1</span></span><br><span class="line">变量名=f，类型=<span class="built_in">NSTaggedPointerString</span>， 地址=<span class="number">0xa1ea1f72bb30ab19</span>，值=<span class="number">123456789</span>，引用计数=<span class="number">-1</span></span><br><span class="line">变量名=g，类型=__NSCFString， 地址=<span class="number">0x60800002b580</span>，值=<span class="number">1234567890</span>，引用计数=<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="NSCFString"><a href="#NSCFString" class="headerlink" title="__NSCFString"></a>__NSCFString</h4><p>对象类型的字符串，在运行时创建，存储在堆区，服从OC的对象内存管理策略，长度不能太小（内容若包含中文字符，不论长度大小，都是NSCFString），否则创建的是NSTaggedPointerString类型，例如上面f与g</p><h4 id="NSTaggedPointerString"><a href="#NSTaggedPointerString" class="headerlink" title="NSTaggedPointerString"></a>NSTaggedPointerString</h4><p>对于64位程序，为了节省内存和提高运行速度，苹果引入了Tagged Point技术，在运行时创建时对字符串的内容和长度作出判断，若字符串内容是由ASCII构成且长度较小（大概10个字符以内），这是创建的字符串就是NSTaggedPointerString类型，字符串直接存储在指针里，引用计数同样为-1，不适用对象的内存管理策略。</p><blockquote><p>Tagged Pointer指针的值不再是地址，而是真正的值，所以它不再是一个对象，只是一个披着对象皮的普通变量而已。它的内存并不存储在堆中，OC对象的内存管理对其无效。</p></blockquote><h4 id="NSCFConstantString"><a href="#NSCFConstantString" class="headerlink" title="__NSCFConstantString"></a>__NSCFConstantString</h4><p>常量字符串，该类型的字符串是以字面量创建的，是在编译期创建的，保存在常量区</p><blockquote><p>文字常量区存放常量字符串，程序结束后由系统释放，也就是说指向常量表的指针不受引用计数管理，OC的内存管理策略对其无效。</p></blockquote><h3 id="OC内存管理方式"><a href="#OC内存管理方式" class="headerlink" title="OC内存管理方式"></a>OC内存管理方式</h3><ol><li><p>TaggedPointer<br>iPhone 5s开始采用64bit cpu架构，也就是指针占用4个字节，32bit的寻址范围是4G，显然64bit的指针存在空间浪费，对于小对象，比如NSNumer，NSDate，NSString，TaggeddPointer不再是地址，而是真正的值。这种方式可以节省内存，提高执行效率</p></li><li><p>isa指针（NONPOINTER_ISA）<br>非指针型isa：值的部分代表class地址<br>指针型isa：值代表class地址<br>同理64位存储一个内存地址是种浪费，isa是一个公用体结构union，NONPOINTER_ISA是给对象分配了内存空间，但是不使用sideTable管理引用计数，而是把引用计数存在了isa当中。</p></li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">struct</span> &#123;</span><br><span class="line">        uintptr_t indexed           : <span class="number">1</span>;<span class="comment">//0表示普通的isa,1表示使用优化的存储引用计数</span></span><br><span class="line">        uintptr_t has_assoc         : <span class="number">1</span>;<span class="comment">//对象是否包含associated object</span></span><br><span class="line">        uintptr_t has_cxx_dtor      : <span class="number">1</span>;<span class="comment">//该对象是否有 C++ 或 ARC 的析构函数</span></span><br><span class="line">        uintptr_t shiftcls          : <span class="number">44</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x7fffffe00000   类的指针</span></span><br><span class="line">        uintptr_t magic             : <span class="number">6</span>;<span class="comment">//固定值为 0xd2，用于在调试时分辨对象是否未完成初始化</span></span><br><span class="line">        uintptr_t weakly_referenced : <span class="number">1</span>;<span class="comment">//该对象是否有过 weak 对象</span></span><br><span class="line">        uintptr_t deallocating      : <span class="number">1</span>;<span class="comment">//该对象是否正在析构</span></span><br><span class="line">        uintptr_t has_sidetable_rc  : <span class="number">1</span>;<span class="comment">//是否使用了引用计数表sideTable</span></span><br><span class="line">        uintptr_t extra_rc          : <span class="number">8</span>;<span class="comment">//存储引用计数值减一后的结</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>散列表<br>SideTable包含了引用计数表，弱引用计数表，以及一个自旋锁。结构如下</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SideTable &#123;</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>引用计数表<br>是用hash表实现的，引用计数会存在多张sideTable中，修改引用计数，需要经过两次hash算法，第一次是从sideTables中找到具体的sideTable，第二次是从sideTable中找到对应的引用计数。之所以设计成多张sideTable而不是一张sideTables，是因为每次操作都需要加锁，减锁操作，多张可以分离锁，加快操作速度。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SideTable &amp;table = SideTables()[<span class="variable language_">this</span>];</span><br><span class="line">size_t &amp;refcntStorage = table.refcnts[<span class="variable language_">this</span>];</span><br><span class="line"><span class="comment">//refcntStorage  就是引用计数 两次hash查找</span></span><br></pre></td></tr></table></figure><ul><li>弱引用表<br>苹果使用sideTables保存所有的weak引用，key就是对象地址，weak_entry_t作为值，weak_entry_t中保存了所有指向该对象的弱引用。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> weak_table_t &#123;</span><br><span class="line">    weak_entry_t *weak_entries;</span><br><span class="line">    size_t    num_entries;</span><br><span class="line">    uintptr_t mask;</span><br><span class="line">    uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://hello-david.github.io/archives/e94ffa1c.html">iOS中的内存布局与管理</a></li><li><a href="https://www.jianshu.com/p/f95b9bfda4a0">iOS 内存管理与优化</a></li><li><a href="https://xta0.me/2012/07/10/iOS-Memory-1.html">理解iOS中的内存结构</a></li><li><a href="https://www.jianshu.com/p/462adf281fde">NSString 的内存问题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 内存管理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS防逆向代码混淆</title>
      <link href="/2020/05/14/iOS%E9%98%B2%E9%80%86%E5%90%91%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
      <url>/2020/05/14/iOS%E9%98%B2%E9%80%86%E5%90%91%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章里可以看到，砸壳（Dumpdecrypted破壳）之后的ipa包使用class-dump分析之后，App跟裸奔一样，所以需要做代码混淆来添加逆向的难度。</p><span id="more"></span><h2 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h2><p>砸壳就是对安装包进行逆向操作，对已加密的软件进行解密，从而获得真实的软件代码。App Store下载的包全部都是经过苹果加密过的包（苹果不允许开发者自己加密ipa包），加密后的ipa包，无法对其进行反编译，也无法class-dump，需要对其进行解密才能反编译。</p><h3 id="砸壳方式"><a href="#砸壳方式" class="headerlink" title="砸壳方式"></a>砸壳方式</h3><ol><li>静态砸壳<br>使用已知的解密方法对软件进行解密叫静态砸壳，难度大，需要知道其软件的加密算法。</li><li>动态砸壳<br>从进程的内存空间中获取软件镜像（image）进行转存处理叫动态砸壳。<img src="/2020/05/14/iOS%E9%98%B2%E9%80%86%E5%90%91%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/safe00.png" class=""></li></ol><h4 id="动态砸壳工具"><a href="#动态砸壳工具" class="headerlink" title="动态砸壳工具"></a>动态砸壳工具</h4><ol><li><a href="https://github.com/KJCracks/Clutch">clutch</a></li></ol><p>2.<a href="https://github.com/stefanesser/dumpdecrypted">dumpdecrypted</a><br>通过建立一个名为dumpdecrypted.dylib的动态库，插入目标应用实现脱壳</p><h3 id="otool（object-file-displaying-tool）工具"><a href="#otool（object-file-displaying-tool）工具" class="headerlink" title="otool（object file displaying tool）工具"></a>otool（object file displaying tool）工具</h3><p>Mac OS X下二进制可执行文件的动态连结库是dylib文件（也就是bsd风格的动态库），等价于windows的dll和linux的so。Mac基于bsd，所以也使用的dylib</p><p>它是Xcode自带的常用工具</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>依赖库查询 otool -L</li></ol><ul><li>eg:查看微信的是否加密等信息 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -l WeChart | grep -B 2 crypt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> cryptoff 16384</span><br><span class="line">    cryptsize 6651904</span><br><span class="line">      cryptid 0</span><br><span class="line">     cryptoff 16384</span><br><span class="line">    cryptsize 6553600</span><br><span class="line">      cryptid 0123456</span><br><span class="line">//其中cryptid代表是否加壳，1代表加壳，0代表已脱壳。我们发现打印了两遍，其实代表着该可执行文件支持两种架构armv7和arm64.</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>查看 Mach-O头结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ otool -h /Applications/Sublime\ Text.app/Contents/MacOS/Sublime\ Text </span><br><span class="line"></span><br><span class="line">Mach header</span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line"> 0xfeedfacf 16777223          3  0x80           2    27       4336 0x00218085</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查看汇编码 otool -tV</p></li></ol><h2 id="class-dump"><a href="#class-dump" class="headerlink" title="class-dump"></a><a href="http://stevenygard.com/projects/class-dump/">class-dump</a></h2><p>用来分析ipa文件的class信息的工具，它利用Objective-C语言的runtime的特性，将存储在mach-O文件中的@interface和@protocol信息提取出来，并生成对应的.h文件</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>class-dump -H [.app文件的路径] -o [输出文件夹路径]<br>就可以得到所有的.h文件</li></ol><h3 id="导出文件特点"><a href="#导出文件特点" class="headerlink" title="导出文件特点"></a>导出文件特点</h3><p>使用 class-dump 命令导出头文件有以下特点：</p><ol><li>不管 .h 还是 .m 文件中的属性和方法都会被导出；</li><li>某个类的类别中的方法也会被导出，导出到源文件中，比如 ViewController (Navigation) 中的方法被导出到 ViewController 中；</li><li>实现的协议也会被导出，比如 ViewControllerDelegate 的方法被导出到 ViewController 中，如果 ViewController 不实现 ViewControllerDelegate 协议讲不会被导出；</li><li>协议中定义的方法不会被导出，只会导出到实现协议的类中；</li></ol><h2 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h2><p>我们希望在开发时一直保留清晰可读的程序代码，方便自己。<br>同时，希望编译出来的二进制包含乱七八糟的混淆后的程序代码，恶心他人</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>方法名混淆其实就是字符串替换，有2个方法可以，一个是#define，一个是利用tops。<br>利用#define的方法有一个好处，就是可以把混淆结果合并在一个.h中，在工程Prefix.pch的最前面#import这个.h。不导入也可以编译、导入则实现混淆。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单段的selector，如func: ，可以通过#define func 来实现字符串替换。</span><br><span class="line">多段的selector，如a:b:c: ，可以通过分别#define a 、b、c 来实现字符串替换。</span><br></pre></td></tr></table></figure><h3 id="混淆脚本"><a href="#混淆脚本" class="headerlink" title="混淆脚本"></a>混淆脚本</h3><p>主要思路是把敏感方法名集中写在一个名叫func.list的文件中，逐一#define成随机字符，追加写入.h</p><ul><li>confuse.sh</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env bash</span></span><br><span class="line">TABLENAME=symbols</span><br><span class="line">SYMBOL_DB_FILE=<span class="string">&quot;symbols&quot;</span></span><br><span class="line">STRING_SYMBOL_FILE=<span class="string">&quot;<span class="variable">$PROJECT_DIR</span>/<span class="variable">$PROJECT_NAME</span>/Source/CodeConfuse/func.list&quot;</span></span><br><span class="line">HEAD_FILE=<span class="string">&quot;<span class="variable">$PROJECT_DIR</span>/<span class="variable">$PROJECT_NAME</span>/Source/CodeConfuse/codeObfuscation.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LC_CTYPE=C</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">createTable</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;create table <span class="variable">$TABLENAME</span>(src text, des text);&quot;</span> | sqlite3 <span class="variable">$SYMBOL_DB_FILE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">insertValue</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;insert into <span class="variable">$TABLENAME</span> values(&#x27;<span class="variable">$1</span>&#x27; ,&#x27;<span class="variable">$2</span>&#x27;);&quot;</span> | sqlite3 <span class="variable">$SYMBOL_DB_FILE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">query</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;select * from <span class="variable">$TABLENAME</span> where src=&#x27;<span class="variable">$1</span>&#x27;;&quot;</span> | sqlite3 <span class="variable">$SYMBOL_DB_FILE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">ramdomString</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    openssl rand -<span class="built_in">base64</span> 64 | <span class="built_in">tr</span> -<span class="built_in">cd</span> <span class="string">&#x27;a-zA-Z&#x27;</span> |<span class="built_in">head</span> -c 16</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -f <span class="variable">$SYMBOL_DB_FILE</span></span><br><span class="line"><span class="built_in">rm</span> -f <span class="variable">$HEAD_FILE</span></span><br><span class="line">createTable</span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$HEAD_FILE</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;#ifndef Demo_codeObfuscation_h&#x27;</span> &gt;&gt; <span class="variable">$HEAD_FILE</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;#define Demo_codeObfuscation_h&#x27;</span> &gt;&gt; <span class="variable">$HEAD_FILE</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;//confuse string at `date`&quot;</span> &gt;&gt; <span class="variable">$HEAD_FILE</span></span><br><span class="line"><span class="built_in">cat</span> <span class="string">&quot;<span class="variable">$STRING_SYMBOL_FILE</span>&quot;</span> | <span class="keyword">while</span> <span class="built_in">read</span> -ra line; <span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [[ ! -z <span class="string">&quot;<span class="variable">$line</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">ramdom=`ramdomString`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$line</span> <span class="variable">$ramdom</span></span><br><span class="line">insertValue <span class="variable">$line</span> <span class="variable">$ramdom</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#define <span class="variable">$line</span> <span class="variable">$ramdom</span>&quot;</span> &gt;&gt; <span class="variable">$HEAD_FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#endif&quot;</span> &gt;&gt; <span class="variable">$HEAD_FILE</span></span><br><span class="line"></span><br><span class="line">sqlite3 <span class="variable">$SYMBOL_DB_FILE</span> .dump</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>func.list</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loginPass</span><br><span class="line">newPwd</span><br><span class="line">smsCode</span><br><span class="line">secret</span><br><span class="line">tradePwd</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>codeObfuscation.h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#ifndef Demo_codeObfuscation_h</span><br><span class="line">#define Demo_codeObfuscation_h</span><br><span class="line">//confuse string at Wed Jan 16 17:30:22 CST 2019</span><br><span class="line">#define loginPass ITqIAxhareFWDEst</span><br><span class="line">#define newPwd SRgVmxvZsIWUEAWQ</span><br><span class="line">#define smsCode MyiekqqKlJxLiNAx</span><br><span class="line">#define secret hMcpMgCDFGgXwLPL</span><br><span class="line">#define tradePwd ARIKWIPQnJOBNgfS</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ol><li>将混淆脚本confuse.sh放到工程目录下 </li><li>修改Prefix.pch<br>打开Xcode，修改XXX-Prefix.ch ，添加混淆头文件:<br><code># import “codeObfuscation.h”</code></li><li>配置build pharse 加载confuse.sh脚本</li><li>创建函数名列表func.list，写入待混淆的函数名，如:</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)sample;</span><br><span class="line">-(<span class="type">void</span>)seg1:(<span class="built_in">NSString</span> *)string seg2:(<span class="built_in">NSUInteger</span>)num;</span><br><span class="line"><span class="comment">//就这样写：</span></span><br><span class="line">sample</span><br><span class="line">seg1</span><br><span class="line">seg2</span><br></pre></td></tr></table></figure><ol start="5"><li>编译查看结果<br>直接build，混淆脚本会在编译前运行，进行字符随机替换，并且每次build的随机字符不同，<img src="/2020/05/14/iOS%E9%98%B2%E9%80%86%E5%90%91%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/Build00.png" class=""></li></ol><h4 id="class-dump测试"><a href="#class-dump测试" class="headerlink" title="class-dump测试"></a>class-dump测试</h4><img src="/2020/05/14/iOS%E9%98%B2%E9%80%86%E5%90%91%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/Build01.png" class=""><img src="/2020/05/14/iOS%E9%98%B2%E9%80%86%E5%90%91%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/Build02.png" class=""><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.jianshu.com/p/1e3fe0a8c048">class-dump的安装和使用</a></li><li><a href="https://blog.csdn.net/yiyaaixuexi/article/details/29201699">Objective-C代码混淆</a></li><li><a href="https://www.jianshu.com/p/1991854c65af">iOS逆向之《越狱砸壳&#x2F;ipa脱壳》</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 逆向安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS逆向代码注入</title>
      <link href="/2020/05/13/iOS%E9%80%86%E5%90%91%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/05/13/iOS%E9%80%86%E5%90%91%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>前段时间把&lt;&lt;硅谷&gt;&gt;追完了，剧中撒旦教崇拜者Gilfoyle，当时破解了智能冰箱的固件，仔细想想，似忽不存在无法破解的软件，就好像不存在不透风的墙一样，开发人员开发，编译，链接生成一个可执行文件，Mach-O或者ELF，PE，其实本质上都是二进制文件，这当然就可以编辑，不过是在运行的时候添加了非对称加密的认证，对原始文件的一致性会进行认证。可是又有谁能保证非对称加密（RSA）的无法破解性呢？最后一季，他们的去中心化系统通过深度学习，充分发挥分布式计算的算力成功破解了最先进的加密算法!</p><span id="more"></span><blockquote><p>代码注入有两种方案：通过Framework和dylib</p></blockquote><h2 id="App重签名"><a href="#App重签名" class="headerlink" title="App重签名"></a>App重签名</h2><ol><li>通过Xcode新建任意工程，然后运行在手机上，此时当前App的描述文件，证书已经正常安装在了手机上。</li><li>添加shell运行脚本AppSign.sh</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $&#123;SRCROOT&#125; 它是工程文件所在的目录</span></span><br><span class="line">TEMP_PATH=<span class="string">&quot;<span class="variable">$&#123;SRCROOT&#125;</span>/Temp&quot;</span></span><br><span class="line"><span class="comment">#资源文件夹，我们提前在工程目录下新建一个APP文件夹，里面放ipa包</span></span><br><span class="line">ASSETS_PATH=<span class="string">&quot;<span class="variable">$&#123;SRCROOT&#125;</span>/APP&quot;</span></span><br><span class="line"><span class="comment">#目标ipa包路径</span></span><br><span class="line">TARGET_IPA_PATH=<span class="string">&quot;<span class="variable">$&#123;ASSETS_PATH&#125;</span>/*.ipa&quot;</span></span><br><span class="line"><span class="comment">#清空Temp文件夹</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$&#123;SRCROOT&#125;</span>/Temp&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;SRCROOT&#125;</span>/Temp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line"><span class="comment"># 1. 解压IPA到Temp下</span></span><br><span class="line">unzip -oqq <span class="string">&quot;<span class="variable">$TARGET_IPA_PATH</span>&quot;</span> -d <span class="string">&quot;<span class="variable">$TEMP_PATH</span>&quot;</span></span><br><span class="line"><span class="comment"># 拿到解压的临时的APP的路径</span></span><br><span class="line">TEMP_APP_PATH=$(<span class="built_in">set</span> -- <span class="string">&quot;<span class="variable">$TEMP_PATH</span>/Payload/&quot;</span>*.app;<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span>)</span><br><span class="line"><span class="comment"># echo &quot;路径是:$TEMP_APP_PATH&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line"><span class="comment"># 2. 将解压出来的.app拷贝进入工程下</span></span><br><span class="line"><span class="comment"># BUILT_PRODUCTS_DIR 工程生成的APP包的路径</span></span><br><span class="line"><span class="comment"># TARGET_NAME target名称</span></span><br><span class="line">TARGET_APP_PATH=<span class="string">&quot;<span class="variable">$BUILT_PRODUCTS_DIR</span>/<span class="variable">$TARGET_NAME</span>.app&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;app路径:<span class="variable">$TARGET_APP_PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$TARGET_APP_PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$TARGET_APP_PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">cp</span> -rf <span class="string">&quot;<span class="variable">$TEMP_APP_PATH</span>/&quot;</span> <span class="string">&quot;<span class="variable">$TARGET_APP_PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line"><span class="comment"># 3. 删除extension和WatchAPP.个人证书没法签名Extention</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$TARGET_APP_PATH</span>/PlugIns&quot;</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$TARGET_APP_PATH</span>/Watch&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line"><span class="comment"># 4. 更新info.plist文件 CFBundleIdentifier</span></span><br><span class="line"><span class="comment">#  设置:&quot;Set : KEY Value&quot; &quot;目标文件路径&quot;</span></span><br><span class="line">/usr/libexec/PlistBuddy -c <span class="string">&quot;Set :CFBundleIdentifier <span class="variable">$PRODUCT_BUNDLE_IDENTIFIER</span>&quot;</span> <span class="string">&quot;<span class="variable">$TARGET_APP_PATH</span>/Info.plist&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line"><span class="comment"># 5. 给MachO文件上执行权限</span></span><br><span class="line"><span class="comment"># 拿到MachO文件的路径</span></span><br><span class="line">APP_BINARY=`plutil -convert xml1 -o - <span class="variable">$TARGET_APP_PATH</span>/Info.plist|grep -A1 Exec|<span class="built_in">tail</span> -n1|<span class="built_in">cut</span> -f2 -d\&gt;|<span class="built_in">cut</span> -f1 -d\&lt;`</span><br><span class="line"><span class="comment">#上可执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x <span class="string">&quot;<span class="variable">$TARGET_APP_PATH</span>/<span class="variable">$APP_BINARY</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line"><span class="comment"># 6. 重签名第三方 FrameWorks</span></span><br><span class="line">TARGET_APP_FRAMEWORKS_PATH=<span class="string">&quot;<span class="variable">$TARGET_APP_PATH</span>/Frameworks&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$TARGET_APP_FRAMEWORKS_PATH</span>&quot;</span> ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="keyword">for</span> FRAMEWORK <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$TARGET_APP_FRAMEWORKS_PATH</span>/&quot;</span>*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#签名</span></span><br><span class="line">/usr/bin/codesign --force --sign <span class="string">&quot;<span class="variable">$EXPANDED_CODE_SIGN_IDENTITY</span>&quot;</span> <span class="string">&quot;<span class="variable">$FRAMEWORK</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在项目目录下新建APP文件夹，放入砸壳之后的ipa包</li><li>运行就可以调试砸壳之后的ipa包</li></ol><h2 id="Framework注入"><a href="#Framework注入" class="headerlink" title="Framework注入"></a>Framework注入</h2><ol><li>在当前工程中点击Xcode中File-&gt;Target新增一个Framework，HookFrame</li><li>在Framework中添加你想添加的类HookDemo添加load方法<br><code>现在framework有了，但是不会被dyld加载</code></li><li>动态库注入yololib<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.将yololib复制粘贴到/usr/local/bin目录下</span><br><span class="line">2.在签名脚本AppSign.sh末尾添加注入命令</span><br><span class="line">#注入</span><br><span class="line">#yololib &quot;$TARGET_APP_PATH/$APP_BINARY&quot; &quot;Frameworks/HookFrame.framework/HookFrame&quot;</span><br></pre></td></tr></table></figure></li><li>运行，现在可以执行HookDemo类中的load方法了</li></ol><ul><li>注意</li></ul><ol><li>Mach-0文件浏览工具<a href="https://sourceforge.net/projects/machoview/">machoview</a>，是<a href="https://github.com/gdbinit/MachOView">开源</a>的<br><code>安装时如果提示：程序已损坏，打不开。您应该将它移到废纸篓</code>这是macOS Sierra 10 取消了安全性与隐私中的“允许任何来源”选项，导致的问题，可以打开终端，输入一下命令解决。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure></li></ol><h2 id="dylib注入-iOS逆向-代码注入-Hook"><a href="#dylib注入-iOS逆向-代码注入-Hook" class="headerlink" title="[dylib注入](iOS逆向 代码注入+Hook)"></a>[dylib注入](iOS逆向 代码注入+Hook)</h2><h2 id="HOOK某个按钮触发事件"><a href="#HOOK某个按钮触发事件" class="headerlink" title="HOOK某个按钮触发事件"></a>HOOK某个按钮触发事件</h2><p>1.通过Xcode ViewDebug调试，可以找到某个页面的Controller，和UIButton的Action，Target<br><code>可以通过lldb po命令打印内存地址获取类名，然后通过类型转换和KVC获取成员对象</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po 0x133800600</span><br><span class="line">&lt;XXXViewController: 0x133800600&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po [(XXXViewController *)0x133800600 valueForKey:@<span class="string">&quot;_textFieldPwd&quot;</span>]</span><br><span class="line">&lt;XXXextFieldItem: 0x28231f180&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po [(XXXextFieldItem *)0x28231f180 valueForKey:@<span class="string">&quot;m_textField&quot;</span>]</span><br><span class="line">&lt;XXXUITextField: 0x13090d600; baseClass = UITextField; frame = (20 0; 345 44); text = <span class="string">&#x27;Felix&#x27;</span>; opaque = NO; autoresize = W+H; tintColor = UIExtendedSRGBColorSpace 0.00784314 0.733333 0 1; gestureRecognizers = &lt;NSArray: 0x280891650&gt;; layer = &lt;CALayer: 0x280612560&gt;&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用class-dump工具导出Mach-o文件的所有头文件<br><code>文本查找你要找的Controller，如果开发者没做代码混淆的话，这里就很直观的找到你想要找的成员对象，比如pwd之类</code></li><li>Hook</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、给哪个类添加方法</span></span><br><span class="line"><span class="comment">     * 2、方法编号</span></span><br><span class="line"><span class="comment">     * 3、方法实现（地址）</span></span><br><span class="line"><span class="comment">     * 4、v代表Void @代表id类型 ：代表@selecter类型（可以在帮助文档查看这个方法）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">BOOL</span> didAddMethod = class_addMethod(objc_getClass(<span class="string">&quot;XXXViewController&quot;</span>), <span class="keyword">@selector</span>(FX_onNext), FX_onNext, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;添加方法成功&quot;</span>);</span><br><span class="line">        Method oldMethod = class_getInstanceMethod(objc_getClass(<span class="string">&quot;XXXViewController&quot;</span>), <span class="keyword">@selector</span>(onNext));</span><br><span class="line">        Method newMethod = class_getInstanceMethod(objc_getClass(<span class="string">&quot;XXXViewController&quot;</span>), <span class="keyword">@selector</span>(FX_onNext));</span><br><span class="line">        method_exchangeImplementations(oldMethod, newMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法实现IMP</span></span><br><span class="line"><span class="type">void</span> FX_onNext(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">UITextField</span> *accountTF = [[<span class="keyword">self</span> valueForKey:<span class="string">@&quot;_textFieldUserNameItem&quot;</span>] valueForKey:<span class="string">@&quot;m_textField&quot;</span>];</span><br><span class="line">    <span class="built_in">UITextField</span> *passwordTF = [[<span class="keyword">self</span> valueForKey:<span class="string">@&quot;_textFieldPwdItem&quot;</span>] valueForKey:<span class="string">@&quot;m_textField&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;账号：“%@” 密码：“%@”&quot;</span>, accountTF.text, passwordTF.text);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用原来逻辑</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(FX_onNext)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里突然有点明白为什么Apple要退出swift了，因为OC的runtime过于强大，有威胁。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://juejin.im/post/5dc42055e51d4573042fb627">iOS逆向 代码注入</a></li><li><a href="https://hello-david.github.io/archives/82a2b295.html">iOS逆向工程三板斧:砸壳-注入-重签</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 逆向安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS录音生成Wav格式问题</title>
      <link href="/2020/04/16/iOS%E5%BD%95%E9%9F%B3%E7%94%9F%E6%88%90Wav%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2020/04/16/iOS%E5%BD%95%E9%9F%B3%E7%94%9F%E6%88%90Wav%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>iPhone的音质一般，音量偏小，作为听个响系列，表现也是不置可否，这篇文章总结一下，iOS本地录音生成Wav文件格式遇到的一个问题。</p><span id="more"></span><h2 id="Wav文件格式错误"><a href="#Wav文件格式错误" class="headerlink" title="Wav文件格式错误"></a>Wav文件格式错误</h2><p>之前开发一个项目，里面需要通过录音生成wav文件，提交给后台实现声纹注册，当我调用系统的API生成Wav文件上传后，后台报文件格式错误，然而android生成的wav文件却没有报这个错….</p><h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><ol><li>是否iOS本地生成的Wav文件格式有问题<br>使用itunes文件共享功能，将生成的Wav文件导出，进行本地端（Mac OS）播放正常，在windwos端播放正常。</li></ol><p>初略的认定生成的Wav格式没有问题。</p><ol start="2"><li><p>是否wav文件上传功能出现问题<br>借用android端生成的wav文件重新发送，提示声纹注册成功。排除本地端文件上传功能有问题</p></li><li><p>后台解析Wav文件是不是有什么问题？<br>后台说不是他这边报的文件格式错误，他只是做了中间转发，错误是微软后台那边报的（项目是跟微软内部合作）</p></li><li><p>是不是对录音的参数有什么要求，采样率，位深….?<br>各种找人，各种甩锅之后，找到了内部跟微软对接需求的人（DNS迭代查询即视感），没有详细文档，没有参数限制，让我自己试….</p></li><li><p>分析两边Wav文件格式的差异<br>对比之后，发现苹果生成wav文件格式不是标准的wav协议头的文件。。。</p></li></ol><h3 id="WAV简介"><a href="#WAV简介" class="headerlink" title="WAV简介"></a>WAV简介</h3><p>WAVE(Waveform Audio File Format), 采用RIFF（Resource Interchange File Format）文件格式结构</p><p>WAV格式的音频文件通常用来保存PCM格式的原始音频数据，通常被称之为无损音频。</p><p>WAV音频文件，粗略来说是WAV数据头+PCM数据组成的，裸数据PCM外面包了一层文件头，WAV实质是一个RIFF文件</p><h3 id="WAV数据头"><a href="#WAV数据头" class="headerlink" title="WAV数据头"></a>WAV数据头</h3><p>关于 WAV 音频文件的数据头定义如下图所示:</p><img src="/2020/04/16/iOS%E5%BD%95%E9%9F%B3%E7%94%9F%E6%88%90Wav%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/1.jpg" class=""><p><code>一般的 WAV 文件的数据头为 44 个字节, 其后面跟的是 PCM 数据</code></p><h3 id="分析wav数据头"><a href="#分析wav数据头" class="headerlink" title="分析wav数据头"></a>分析wav数据头</h3><p>使用<code>hexdump</code>或者<a href="https://github.com/but0n/xd">xd</a>来看一下 WAV 文件的数据头</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -n 44 m.wav      //查看前 44 个字节</span><br></pre></td></tr></table></figure><img src="/2020/04/16/iOS%E5%BD%95%E9%9F%B3%E7%94%9F%E6%88%90Wav%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/2.jpg" class=""><p>这是标准的44字节的wav文件头，来看下iOS录音生成wav文件的wav格式</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span>* settingDic=@&#123;&#125;.mutableCopy;</span><br><span class="line">[settingDic setObject:@(kAudioFormatLinearPCM) forKey:<span class="built_in">AVFormatIDKey</span>];</span><br><span class="line">[settingDic setValue:@(<span class="number">44100</span>) forKey:<span class="built_in">AVSampleRateKey</span>];</span><br><span class="line">[settingDic setValue:@(<span class="number">2</span>) forKey:<span class="built_in">AVNumberOfChannelsKey</span>];</span><br><span class="line">[settingDic setValue:@(<span class="number">16</span>) forKey:<span class="built_in">AVLinearPCMBitDepthKey</span>];</span><br><span class="line">[settingDic setValue:@(<span class="built_in">AVAudioQualityHigh</span>) forKey:<span class="built_in">AVEncoderAudioQualityKey</span>];</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Jack-Mac-mini:~ Jack$ afinfo /Users/Jack/Desktop/Audio/test.wav</span><br><span class="line">File:           /Users/Jack/Desktop/Audio/test.wav</span><br><span class="line">File <span class="built_in">type</span> ID:   WAVE</span><br><span class="line">Num Tracks:     1</span><br><span class="line">----</span><br><span class="line">Data format:     2 ch,  44100 Hz, <span class="string">&#x27;lpcm&#x27;</span> (0x0000000C) 16-bit little-endian signed <span class="built_in">integer</span></span><br><span class="line">                no channel layout.</span><br><span class="line">estimated duration: 17.507846 sec</span><br><span class="line">audio bytes: 3088384</span><br><span class="line">audio packets: 772096</span><br><span class="line">bit rate: 1411200 bits per second</span><br><span class="line">packet size upper bound: 4</span><br><span class="line">maximum packet size: 4</span><br><span class="line">audio data file offset: 4096</span><br><span class="line">optimized</span><br><span class="line"><span class="built_in">source</span> bit depth: I16</span><br><span class="line">----</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Jack-Mac-mini:~ Jack$ xd -cl  4096  /Users/Jack/Desktop/Audio/test.wav</span><br><span class="line">File name: /Users/Jack/Desktop/Audio/test.wav</span><br><span class="line"></span><br><span class="line">00000000: 52 49 46 46 f8 2f 2f 00  57 41 56 45 4a 55 4e 4b     RIFF.//.WAVEJUNK</span><br><span class="line">00000010: 1c 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00     ................</span><br><span class="line">00000020: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00     ................</span><br><span class="line">00000030: 66 6d 74 20 10 00 00 00  01 00 02 00 44 ac 00 00     fmt.........D...</span><br><span class="line">00000040: 10 b1 02 00 04 00 10 00  46 4c 4c 52 a8 0f 00 00     ........FLLR....</span><br><span class="line">00000050: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00     ................</span><br><span class="line">00000060: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00     ................</span><br><span class="line">****</span><br><span class="line">00000fd0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00     ................</span><br><span class="line">00000fe0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00     ................</span><br><span class="line">00000ff0: 00 00 00 00 00 00 00 00  64 61 74 61 00 20 2f 00     ........data../.</span><br><span class="line">Total 4096 Byte</span><br></pre></td></tr></table></figure><p> 生成的WAV 文件的数据头为 4096 个字节</p><h3 id="转换思路"><a href="#转换思路" class="headerlink" title="转换思路"></a>转换思路</h3><p>AVAudioRecorder录音采样生成PCM文件格式，PCM转成标准44字节的Wav文件格式</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> PCM 转 Wav</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param originPath PCM Path</span></span><br><span class="line"><span class="comment"> @return Wav Path</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="built_in">NSString</span>*)transformPCM2Wav:(<span class="built_in">NSString</span>*)originPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span>* outPath=[[originPath stringByDeletingPathExtension] stringByAppendingString:<span class="string">@&quot;.wav&quot;</span>];</span><br><span class="line">    <span class="built_in">NSData</span>* data=[<span class="built_in">NSData</span> dataWithContentsOfFile:originPath];</span><br><span class="line">    <span class="type">BOOL</span> isSuccess=[[<span class="keyword">self</span> writeWavHead:data] writeToFile:outPath atomically:<span class="literal">YES</span>];</span><br><span class="line">    <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">        <span class="keyword">return</span> outPath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为pcm文件写入wav头</span></span><br><span class="line">-(<span class="built_in">NSData</span>*)writeWavHead:(<span class="built_in">NSData</span> *)audioData &#123;</span><br><span class="line">    <span class="type">long</span> sampleRate = SampleRateKey;</span><br><span class="line">    <span class="type">long</span> numOfChannelsKey = NumberOfChannels;</span><br><span class="line">    Byte waveHead[<span class="number">44</span>];</span><br><span class="line">    waveHead[<span class="number">0</span>] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">    waveHead[<span class="number">1</span>] = <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">    waveHead[<span class="number">2</span>] = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">    waveHead[<span class="number">3</span>] = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> totalDatalength = [audioData length] + <span class="number">44</span>;</span><br><span class="line">    waveHead[<span class="number">4</span>] = (Byte)(totalDatalength &amp; <span class="number">0xff</span>);</span><br><span class="line">    waveHead[<span class="number">5</span>] = (Byte)((totalDatalength &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    waveHead[<span class="number">6</span>] = (Byte)((totalDatalength &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    waveHead[<span class="number">7</span>] = (Byte)((totalDatalength &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    </span><br><span class="line">    waveHead[<span class="number">8</span>] = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">    waveHead[<span class="number">9</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    waveHead[<span class="number">10</span>] = <span class="string">&#x27;V&#x27;</span>;</span><br><span class="line">    waveHead[<span class="number">11</span>] = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    waveHead[<span class="number">12</span>] = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">    waveHead[<span class="number">13</span>] = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">    waveHead[<span class="number">14</span>] = <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line">    waveHead[<span class="number">15</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    waveHead[<span class="number">16</span>] = <span class="number">16</span>;  <span class="comment">//size of &#x27;fmt &#x27;</span></span><br><span class="line">    waveHead[<span class="number">17</span>] = <span class="number">0</span>;</span><br><span class="line">    waveHead[<span class="number">18</span>] = <span class="number">0</span>;</span><br><span class="line">    waveHead[<span class="number">19</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    waveHead[<span class="number">20</span>] = <span class="number">1</span>;   <span class="comment">//format</span></span><br><span class="line">    waveHead[<span class="number">21</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    waveHead[<span class="number">22</span>] = numOfChannelsKey;   <span class="comment">//chanel</span></span><br><span class="line">    waveHead[<span class="number">23</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    waveHead[<span class="number">24</span>] = (Byte)(sampleRate &amp; <span class="number">0xff</span>);</span><br><span class="line">    waveHead[<span class="number">25</span>] = (Byte)((sampleRate &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    waveHead[<span class="number">26</span>] = (Byte)((sampleRate &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    waveHead[<span class="number">27</span>] = (Byte)((sampleRate &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> byteRate = sampleRate*numOfChannelsKey*LinearPCMBitDepth/<span class="number">8</span>;<span class="comment">//每秒字节数 = 采样频率*采样块大小</span></span><br><span class="line">    waveHead[<span class="number">28</span>] = (Byte)(byteRate &amp; <span class="number">0xff</span>);</span><br><span class="line">    waveHead[<span class="number">29</span>] = (Byte)((byteRate &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    waveHead[<span class="number">30</span>] = (Byte)((byteRate &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    waveHead[<span class="number">31</span>] = (Byte)((byteRate &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    </span><br><span class="line">    waveHead[<span class="number">32</span>] =numOfChannelsKey*LinearPCMBitDepth/<span class="number">8</span>;<span class="comment">//采样块大小=声道数量*采样点大小/8</span></span><br><span class="line">    waveHead[<span class="number">33</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    waveHead[<span class="number">34</span>] = LinearPCMBitDepth;<span class="comment">//采样点大小</span></span><br><span class="line">    waveHead[<span class="number">35</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    waveHead[<span class="number">36</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">    waveHead[<span class="number">37</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    waveHead[<span class="number">38</span>] = <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line">    waveHead[<span class="number">39</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> totalAudiolength = [audioData length];</span><br><span class="line">    </span><br><span class="line">    waveHead[<span class="number">40</span>] = (Byte)(totalAudiolength &amp; <span class="number">0xff</span>);</span><br><span class="line">    waveHead[<span class="number">41</span>] = (Byte)((totalAudiolength &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    waveHead[<span class="number">42</span>] = (Byte)((totalAudiolength &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    waveHead[<span class="number">43</span>] = (Byte)((totalAudiolength &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableData</span> *pcmData = [[<span class="built_in">NSMutableData</span> alloc]initWithBytes:&amp;waveHead length:<span class="keyword">sizeof</span>(waveHead)];</span><br><span class="line">    [pcmData appendData:audioData];</span><br><span class="line">    <span class="keyword">return</span> pcmData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.veryitman.com/2018/02/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BC%96%E7%A8%8B-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90-WAV-%E6%96%87%E4%BB%B6/">简单分析 WAV 文件</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 音视频 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS App签名原理</title>
      <link href="/2020/03/01/App%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/"/>
      <url>/2020/03/01/App%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>知道为什么iOS系统可以使用3年，还能保证系统的流畅度么？除了苹果定制的CPU领先业界两年的水平，软件层面，苹果通过签名机制控制了安装在iOS上的APP都是经过苹果官方允许的，这样可以规范控制App在iOS的行为。</p><span id="more"></span><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名的作用是我对某一份数据打个标记，表示我认可了这份数据（签了个名），然后我发送给其他人，其他人可以知道这份数据经过我认证的，数据没有被篡改过。</p><img src="/2020/03/01/App%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/sign0.png" class=""><ol><li>首先使用摘要算法，算出原始数据的摘要</li><li>生成一份非对称加密的公钥和私钥，私钥我自己拿着，公钥发布出去</li><li>私钥加密摘要，得到一份加密后的数据，称为原始数据的签名，把它跟原始数据一起发送给用户</li><li>用户收到数据和签名后，用公钥解密签名得到摘要，同时用户使用同样的算法计算原始数据的摘要，对比这里计算出来的摘要是否相等，从而确保这份数据的一致性。</li></ol><h2 id="苹果的APP签名"><a href="#苹果的APP签名" class="headerlink" title="苹果的APP签名"></a>苹果的APP签名</h2><p>苹果官方生成一对公私钥，在iOS里内置一个公钥，私钥由苹果后台保存，上传App上AppStore时，苹果后台用私钥对APP数据进行签名，iOS系统下载这个APP后，用公钥验证这个签名，弱正确，这个APP肯定是由苹果后台认证的，并没有被修改过，从而保证安装的每一个APP都是经过苹果官方允许的。</p><img src="/2020/03/01/App%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/sign1.png" class=""><p>但是除了从AppStore下载，我们还可以有三种方式安装一个App：</p><ol><li>开发App时可以直接把开发中的应用安装进手机进行调试</li><li>In-House 企业内部分发，可以直接安装企业证书签名后的APP。</li><li>AD-Hoc相当于企业分发的限制版，限制安装设备数量，较少用。</li></ol><h3 id="双重签名"><a href="#双重签名" class="headerlink" title="双重签名"></a>双重签名</h3><p>开发时安装APP，有两个需求：</p><ol><li>安装包不需要传到苹果服务器，可以直接安装到手机上</li><li>苹果必须对这里的安装有控制权，包括经过苹果允许才可以安装，不能被滥用导致非开发的app也能被安装。</li></ol><img src="/2020/03/01/App%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/sign2.png" class=""><ol><li>在Mac开发机器生成一对公私钥，公钥L（用来获取证书），私钥L</li><li>苹果自己的一对固定公私钥，公钥A（在每个iOS设备上），私钥A（在苹果后台）</li><li>把公钥L传到苹果后台，用苹果后台里的私钥A去签名公钥L，得到一份数据包含了公钥L以及其签名，这份数据称为证书</li><li>开发时，编译完一个APP后，用本地的私钥对这个APP进行签名，同时把第三步得到的证书一起打包进APP里，安装到手机上。</li><li>在安装时，iOS系统取得证书，通过内置的公钥A，去验证证书的数字签名是否正确。</li><li>验证证书后确保公钥L是经过苹果认证的，再用公钥L去验证APP的签名，这里就间接验证了这个APP的安装行为是否经过苹果官方允许。（这里只验证安装行为，不验证APP是否被改动，因为开发阶段APP内容总是不断变化）</li></ol><h3 id="避免被滥用"><a href="#避免被滥用" class="headerlink" title="避免被滥用"></a>避免被滥用</h3><p>1.限制在苹果后台注册过的设备才可以安装<br>2.限制签名只能针对某一个具体的APP<br>3.APP里iCloud，push，后台运行权限如何控制，苹果把这些开关统一称为Entitlements，也需要通过签名去授权。</p><p>分析：<br>双重签名中，可以看到步骤3中，证书中只有公钥L，这里可以通过添加允许安装的设备 ID 列表 和 App对应的 AppID 等数据，一起组成证书，再用苹果私钥A对这个证书进行签名，在第5步，验证时可以拿到设备ID列表，判断当前设备是否符合要求，根据数字签名的原理，只要数字签名通过验证，第 5 步这里的设备 IDs &#x2F; AppID &#x2F; 公钥 L 就都是经过苹果认证的，无法被修改，苹果就可以限制可安装的设备和 APP，避免滥用。</p><img src="/2020/03/01/App%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/sign3.png" class=""><p>实际上一个“证书”本来就有规定的格式规范，于是苹果发明了Provisioning Profile，里面包含证书，以及上述提到的所有额外信息，以及所有信息的签名。</p><img src="/2020/03/01/App%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/sign4.png" class=""><p>完整流程如下：</p><ol><li>在Mac开发机器生成一对公私钥，公钥L（用来获取证书），私钥L</li><li>苹果自己的一对固定公私钥，公钥A（在每个iOS设备上），私钥A（在苹果后台）</li><li>把公钥L传到苹果后台，用苹果后台里的私钥A去签名公钥L，得到一份数据包含了公钥L以及其签名，这份数据称为证书</li><li>在苹果后台申请AppID，配置好设备ID列表，和APP可使用的权限，再加上第3步的证书，组成的数据用私钥A签名，把数据和签名一起组成一个Provisioning Profile文件，下载到本地Mac开发机。</li><li>开发时，编译完一个APP后，用本地的私钥L对这个APP签名，同时把第4步得到的Provisoning Profile文件打包进APP里，文件名为embeded.mobileprovison<br>6.在安装时，iOS取得证书，通过系统内置的公钥A，去验证embedded.mobileprovison的数字签名是否正确，里面的证书签名也会再验一遍。<br>7.确保了 embedded.mobileprovision 里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 APP 里的 Entitlements 对应等。</li></ol><h3 id="概念和常见操作"><a href="#概念和常见操作" class="headerlink" title="概念和常见操作"></a>概念和常见操作</h3><ol><li>第 1 步对应的是 keychain 里的 “从证书颁发机构请求证书”，这里就本地生成了一对公私钥，保存的 CertificateSigningRequest 就是公钥，私钥保存在本地电脑里。</li><li>第 3 步对应把 CertificateSigningRequest 传到苹果后台生成证书，并下载到本地。这时本地有两个证书，一个是第 1 步生成的，一个是这里下载回来的，keychain 会把这两个证书关联起来，因为他们公私钥是对应的，在XCode选择下载回来的证书时，实际上会找到 keychain 里对应的私钥去签名。这里私钥只有生成它的这台 Mac 有，如果别的 Mac 也要编译签名这个 App 怎么办？答案是把私钥导出给其他 Mac 用，在 keychain 里导出私钥，就会存成 .p12 文件，其他 Mac 打开后就导入了这个私钥</li><li>第 5 步 XCode 会通过第 3 步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 _CodeSignature 目录下。</li></ol><p>一些概念：<br>证书：内容是公钥或私钥，由其他机构对其签名组成的数据包。<br>Entitlements：包含了 App 权限开关列表。<br>CertificateSigningRequest：本地公钥。<br>p12：本地私钥，可以导入到其他电脑。<br>Provisioning Profile：包含了 证书 &#x2F; Entitlements 等数据，并由苹果后台私钥签名的数据包。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://blog.cnbang.net/tech/3386/">iOS App 签名的原理</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 逆向安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS语音合成</title>
      <link href="/2019/12/10/iOS%E9%9F%B3%E9%A2%91/"/>
      <url>/2019/12/10/iOS%E9%9F%B3%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<p>在iOS中音频按照播放形式可以分为音效播放和音乐播放。音效主要指的是一些短音频，通常作为点缀音频，如提示音，对于这类音频不需要进行进度，循环等控制。音乐主要指的是一些较长的音频，通常是主音频，对于这类音频播放通常需要精确的控制。在iOS中播放音效一般使用AudioToolbox.framework这个框架，播放音乐一般使用AVFoundation.framework</p><span id="more"></span><h2 id="语音合成"><a href="#语音合成" class="headerlink" title="语音合成"></a>语音合成</h2><p>苹果的语音合成比较简单，直接上代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RBAppleSpeechSynthesizeDelegate</span>&lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="type">void</span>)appleSynthesizerWithResult:(<span class="built_in">NSString</span> *)status info:(<span class="built_in">NSString</span> *)info;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RBAppleSpeechSynthesize</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span>&lt;RBAppleSpeechSynthesizeDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">+ (RBAppleSpeechSynthesize *)sharedInstance;</span><br><span class="line">- (<span class="type">void</span>)appleStartSpeak:(<span class="built_in">NSString</span> *)string;</span><br><span class="line">- (<span class="type">void</span>)appleStopSpeak;</span><br><span class="line">- (<span class="type">void</span>)appleCancel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RBAppleSpeechSynthesize</span> ()&lt;<span class="title">AVSpeechSynthesizerDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> AVSpeechSynthesizer: 语音合成器, 可以假想成一个可以说话的人, 是最主要的接口</span></span><br><span class="line"><span class="comment"> AVSpeechSynthesisVoice: 可以假想成人的声音</span></span><br><span class="line"><span class="comment"> AVSpeechUtterance: 可以假想成要说的一段话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVSpeechSynthesizer</span> *synthesizer;  <span class="comment">//合成器</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVSpeechSynthesisVoice</span> *synthesizeVoice;  <span class="comment">//声音</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVSpeechUtterance</span> *speechUtterance;       <span class="comment">//文字</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RBAppleSpeechSynthesize</span></span></span><br><span class="line"></span><br><span class="line">+ (RBAppleSpeechSynthesize *)sharedInstance &#123;</span><br><span class="line">  <span class="keyword">static</span> RBAppleSpeechSynthesize *singleSynthesize = <span class="literal">nil</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    singleSynthesize = [[RBAppleSpeechSynthesize alloc] init];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> singleSynthesize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    [<span class="keyword">self</span> initAppleSysthesize];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)initAppleSysthesize &#123;</span><br><span class="line">  <span class="keyword">self</span>.synthesizer = [[<span class="built_in">AVSpeechSynthesizer</span> alloc] init];</span><br><span class="line">  <span class="keyword">self</span>.synthesizer.delegate = <span class="keyword">self</span>;</span><br><span class="line">  <span class="keyword">self</span>.synthesizeVoice = [<span class="built_in">AVSpeechSynthesisVoice</span> voiceWithLanguage:<span class="string">@&quot;zh-CN&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)appleStartSpeak:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">  <span class="comment">//开始语音合成</span></span><br><span class="line">  <span class="keyword">if</span> (string != <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *tempStr =[string stringByReplacingOccurrencesOfString:<span class="string">@&quot; &quot;</span> withString:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (tempStr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span>.synthesizer.isSpeaking) &#123;</span><br><span class="line">        <span class="comment">//暂停说话</span></span><br><span class="line">        <span class="type">BOOL</span> stoped =[<span class="keyword">self</span>.synthesizer stopSpeakingAtBoundary:<span class="built_in">AVSpeechBoundaryImmediate</span>];</span><br><span class="line">        <span class="keyword">if</span> (stoped) &#123;</span><br><span class="line">          [<span class="keyword">self</span> speechWithString:tempStr];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> speechWithString:tempStr];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)speechWithString:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">  <span class="built_in">AVAudioSession</span> *avSession = [<span class="built_in">AVAudioSession</span> sharedInstance];</span><br><span class="line">  <span class="built_in">NSError</span> *avError = <span class="literal">nil</span>;</span><br><span class="line">  [avSession setCategory:<span class="built_in">AVAudioSessionCategoryPlayback</span> error:&amp;avError];</span><br><span class="line">  <span class="keyword">if</span> (avError) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;AVAudioSession category error:[%@]&quot;</span>, avError.localizedDescription);</span><br><span class="line">  &#125;</span><br><span class="line">  [avSession setActive:<span class="literal">YES</span> withOptions:<span class="built_in">AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation</span> error:<span class="literal">nil</span>];<span class="comment">//AVAudioSession会影响其他App的表现，当自己App的Session被激活，其他App的就会被解除激活</span></span><br><span class="line">  <span class="keyword">self</span>.speechUtterance = [<span class="built_in">AVSpeechUtterance</span> speechUtteranceWithString:string];</span><br><span class="line">  <span class="keyword">self</span>.speechUtterance.voice = <span class="keyword">self</span>.synthesizeVoice;</span><br><span class="line">  <span class="keyword">self</span>.speechUtterance.rate = <span class="number">0.52</span>;   <span class="comment">//设置语速</span></span><br><span class="line">  <span class="keyword">self</span>.speechUtterance.volume = <span class="number">1.0</span>;  <span class="comment">//设置音量</span></span><br><span class="line">  <span class="keyword">self</span>.speechUtterance.pitchMultiplier =<span class="number">1</span>;  <span class="comment">// 在播放特定语句时改变声音的声调,// 一般取值介于0.5(底音调)~2.0(高音调)之间</span></span><br><span class="line">  [<span class="keyword">self</span>.synthesizer speakUtterance:<span class="keyword">self</span>.speechUtterance];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)appleStopSpeak &#123;</span><br><span class="line">  [<span class="keyword">self</span>.synthesizer stopSpeakingAtBoundary:<span class="built_in">AVSpeechBoundaryImmediate</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)appleCancel &#123;</span><br><span class="line">  [<span class="keyword">self</span>.synthesizer stopSpeakingAtBoundary:<span class="built_in">AVSpeechBoundaryImmediate</span>];</span><br><span class="line">  <span class="keyword">self</span>.synthesizer.delegate = <span class="literal">nil</span>;</span><br><span class="line">  <span class="keyword">self</span>.synthesizer = <span class="literal">nil</span>;</span><br><span class="line">  <span class="keyword">self</span>.synthesizeVoice = <span class="literal">nil</span>;</span><br><span class="line">  <span class="keyword">self</span>.speechUtterance = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - AVSpeechSynthesizerDelegate</span></span><br><span class="line">- (<span class="type">void</span>)speechSynthesizer:(<span class="built_in">AVSpeechSynthesizer</span> *)synthesizer</span><br><span class="line">    didStartSpeechUtterance:(<span class="built_in">AVSpeechUtterance</span> *)utterance &#123;</span><br><span class="line">  <span class="comment">// NSLog(@&quot;语音合成开始!&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)speechSynthesizer:(<span class="built_in">AVSpeechSynthesizer</span> *)synthesizer</span><br><span class="line">    didFinishSpeechUtterance:(<span class="built_in">AVSpeechUtterance</span> *)utterance &#123;</span><br><span class="line">  <span class="comment">// NSLog(@&quot;语音合成结束!&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)speechSynthesizer:(<span class="built_in">AVSpeechSynthesizer</span> *)synthesizer didCancelSpeechUtterance:(<span class="built_in">AVSpeechUtterance</span> *)utterance &#123;</span><br><span class="line">    <span class="comment">//NSLog(@&quot;语音合成取消!&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用语音合成可以避免倒入音频资源，从而增大安装包的大小。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.hedy.ltd/2018/07/12/2018-07-12/">iOS语音识别和语音合成</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 音视频 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Charles抓包</title>
      <link href="/2019/12/03/Charles%E6%8A%93%E5%8C%85/"/>
      <url>/2019/12/03/Charles%E6%8A%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="抓包软件-Charles-的原理是什么？"><a href="#抓包软件-Charles-的原理是什么？" class="headerlink" title="抓包软件 Charles 的原理是什么？"></a>抓包软件 Charles 的原理是什么？</h2><p>Charles 的原理实际就是网络的 <code>中间人攻击</code>。</p><p>所谓中间人攻击，指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。</p><p>客户端发给服务端的请求，被中间人劫持篡改之后，再发送给服务端。</p><p>服务端返回给客户端的数据，被中间人劫持篡改之后，再返回给客户端。</p><span id="more"></span><h2 id="Mac-Charles安装教程"><a href="#Mac-Charles安装教程" class="headerlink" title="Mac Charles安装教程"></a>Mac Charles安装教程</h2><p>参考</p><ol><li><p><a href="https://juejin.im/post/5c0a430f51882516207d205d">macOS Charles 4.x版本的安装及使用（含破解激活）</a></p></li><li><p><a href="https://www.xiebruce.top/617.html">Mac使用Charles抓取macOS&#x2F;iOS&#x2F;Android请求</a></p></li></ol><p><strong>注意：</strong></p><ol><li><p>手动设置手机代理为PC。</p></li><li><p>PC添加证书</p></li><li><p>iOS添加证书 并信任</p></li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>使用 Charles 下载过去任意版本的 App</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RunLoop</title>
      <link href="/2019/12/02/runLoop%E6%80%BB%E7%BB%93/"/>
      <url>/2019/12/02/runLoop%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Run loops are part of the fundamental infrastructure associated with threads. A runloop is an event processing loop that you use to schedule work and coordinate the receipt of incoming events. The purpose of a run loop is to keep your thread busy when there is work to do and put your thread to sleep when there is none.</p></blockquote><p>Runloop是与线程相关联的基础架构的一部分，它用来接受循环事件和安排线程的工作，在有工作时让线程处于繁忙状态，没有事件需要处理时让线程休眠；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RunLoop管理事件，让线程在没有消息时休眠以避免占用资源，由用户态切换到内核态；在消息到来时被唤醒，由内核态切换到用户态，这种机制，叫做“事件循环”机制。</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><h3 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h3><p>内核是一种特殊的软件程序，控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序进行。</p><h3 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h3><p>用户态就是提供应用程序运行的空间</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>为了使应用程序访问到内核管理的资源如CPU，内存，I&#x2F;O。内核提供一组通用的访问接口，这些接口就叫系统调用。系统调用是操作系统的最小功能单位。</p><h3 id="为什么要区分用户态与内核态"><a href="#为什么要区分用户态与内核态" class="headerlink" title="为什么要区分用户态与内核态"></a>为什么要区分用户态与内核态</h3><p>在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。CPU指令分为特权指令，和非特权指令，Intel的CPU将特权指令分为4个等级，RING0（内核态），RING1，RING2，RING3（用户态）.</p><p>CPU总处于以下状态中的一种</p><ol><li>内核态，运行于进程上下文，内核代表进程运行于内核空间</li><li>内核态，运行于中断上下文，内核代表硬件运行于内核空间</li><li>用户态，运行于用户空间</li></ol><h3 id="用户态到内核态怎样切换"><a href="#用户态到内核态怎样切换" class="headerlink" title="用户态到内核态怎样切换"></a>用户态到内核态怎样切换</h3><ol><li>系统调用，比如fork()</li><li>异常，比如缺页异常</li><li>外设中断，比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作</li></ol><h2 id="Runloop和线程的关系"><a href="#Runloop和线程的关系" class="headerlink" title="Runloop和线程的关系"></a>Runloop和线程的关系</h2><ol><li>一个线程对应一个Runloop</li><li>主线程的默认就有Runloop</li><li>子线程的Runloop以懒加载的形式创建</li><li>Runloop存储在一个全局的可变字典里吃，线程是key，Runloop是value。</li></ol><p>子线程RunLoop获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopGetCurrent() 或 [NSRunLoop currentRunLoop];</span><br></pre></td></tr></table></figure><h3 id="RunLoop的作用"><a href="#RunLoop的作用" class="headerlink" title="RunLoop的作用"></a>RunLoop的作用</h3><ol><li>让线程一直活着</li><li>处理线程活着遇到的各种事件</li><li>节省CPU时间（有事件处理事件，无事件休息）</li></ol><h2 id="RunLoop内部结构"><a href="#RunLoop内部结构" class="headerlink" title="RunLoop内部结构"></a>RunLoop内部结构</h2><p>RunLoop内部结构</p><img src="/2019/12/02/runLoop%E6%80%BB%E7%BB%93/run10.jpg" class=""><h3 id="CFRunLoopModelRef"><a href="#CFRunLoopModelRef" class="headerlink" title="CFRunLoopModelRef"></a>CFRunLoopModelRef</h3><blockquote><p>A run loop mode is a collection of input sources and timers to be monitored and a collection of run loop observers to be notified</p></blockquote><p>一个run loop mode是一个集合（input sources 和 timers被监测，observers接受通知）<br>每次开启runloop都要指定一个mode来运行，在运行期间，只有该mode下对应的事件源才会被监测以及允许传递事件（同样的，该mode对应的observers才能接受runloop进程的通知）,其他mode下的事件源的事件将会等待直到切换到对应的mode.更改mode只能重新开启runloop</p><p>在设置Run Loop Mode后，你的Run Loop会自动过滤和其他Mode相关的事件源，而只监视和当前设置Mode相关的源(通知相关的观察者)。大多数时候，Run Loop都是运行在系统定义的默认模式上。</p><p>Run Loop运行时只能以一种固定的Mode运行，只会监控这个Mode下添加的Timer source和Input source。如果这个Mode下没有添加事件源，Run Loop会立刻返回</p><p>一个RunLoop包含若干个Mode，每个Mode又包含若干个Soure&#x2F;Timer&#x2F;Oberver，每次调用RunLoop时，只能指定其中一个Mode（每次运行CFRunLoopRun（）函数时必须指定Mode，CFRunLoopRun（）就是runloop的入口函数），这个mode被称作CurrentMode，如果要切换Mode，只能退出当前的循环，再重新指定一个Mode进入。</p><p>上面的Source&#x2F;Timer&#x2F;Observer被统称为mode item，一个item可以被同时加入多个mode，但一个item被重复加入同一个mode时是不会有效果的，如果一个mode中一个item都没有，则RunLoop会直接退出，不进入循环。</p><p>CGRunLoopMode结构：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;            <span class="comment">// Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// Array</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;    <span class="comment">// Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;           <span class="comment">// Set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>系统默认提供五个Model：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> kCFRunLoopDefaultMode <span class="comment">//App的默认Mode，通常主线程是在这个Mode下运行 </span></span><br><span class="line"> <span class="built_in">UITrackingRunLoopMode</span> <span class="comment">//界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 </span></span><br><span class="line"> <span class="built_in">UIInitializationRunLoopMode</span> <span class="comment">// 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</span></span><br><span class="line">  GSEventReceiveRunLoopMode <span class="comment">// 接受系统事件的内部 Mode，通常用不到 </span></span><br><span class="line"> kCFRunLoopCommonModes <span class="comment">//这是一个占位用的Mode，不是一种真正的Mode，而是一种模式组合，一个操作 Common 标记的字符串</span></span><br><span class="line">       你可以用这个字符串来操作 Common Items</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CFRunLoop提供的管理Mode接口</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopAddCommonMode</span>(<span class="built_in">CFRunLoopRef</span> runloop, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, ...);</span><br></pre></td></tr></table></figure><p>Mode管理mode item的接口</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopAddTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</span><br></pre></td></tr></table></figure><p>只能通过mode name来操作内部的mode，当你传入一个新的mode name但RunLoop内部没有对应mode时，RunLoop会自动帮你创建对应的CFRunLoopModeRef。对于一个RunLoop来说，其内部的mode只能增加不能删除。</p><h3 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h3><blockquote><p>A run loop receives events from two different types of sources. Input sources deliver asynchronous events, usually messages from another thread or from a different application. Timer sources deliver synchronous events, occurring at a scheduled time or repeating interval. Both types of source use an application-specific handler routine to process the event when it arrives.</p></blockquote><p>RunLoop 接受的事件源有两种大类: <strong>Input sources</strong>, <strong>Timer sources</strong>:</p><ol><li><p>InputSources : 传递递异步事件,通常消息来自另外的线程或者程序;</p></li><li><p>Timer sources：传递同步事件，发生在预定时间或者是重复间隔；</p></li></ol><img src="/2019/12/02/runLoop%E6%80%BB%E7%BB%93/runloop_00.jpg" class=""><p>从上图可以看到，Input sources 传递异步事件给相应的方法处理，并且通过runUntilDate:（由线程对应的NSRunLoop 对象执行）来退出；</p><p>Timer sources 传递同步事件给它们对应的例行程序来执行但是不会导致run loop退出。</p><h4 id="Input-Sources"><a href="#Input-Sources" class="headerlink" title="Input Sources"></a>Input Sources</h4><p>Input sources 异步地传递事件到线程，而事件的源来至于其中一种：Port-based input sources、Custom input sources 这两种souces的实现处理方式都一样</p><ul><li>Port-based input sources :监听程序的Mach ports，kernel自动发信号<br>Source1：基于mach_Port，来自系统内核活着其他进程或线程的事件，可以主动唤醒休眠中的RunLoop（mach_port可以理解成进程间通信的一种机制）</li><li>Custom input sources ：监听自定义的活动，在其他线程手动的发信号</li><li>Cocoa Perform Selector Sources : Cocoa 框架定义的Custom input sources</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Source0 :只包含一个函数指针（回调方法），不能自动触发，只能手动触发，触发方式是先通过CFRunLoopSourceSignal(source)将这个Source标记为待处理，然后再调用CFRunLoopWakeUp(runloop) 来唤醒RunLoop处理这个事件。</span><br><span class="line"></span><br><span class="line">Source1 :基于port的Source源，包含一个port和一个函数指针（回调方法）。该Source源可通过内核和其他线程相互发送消息，而且可以主动唤醒RunLoop。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="配置Input-Sources"><a href="#配置Input-Sources" class="headerlink" title="配置Input Sources"></a>配置Input Sources</h4><ul><li><p>Port-Based Sources通过内置的端口相关的对象和函数，配置基于端口的Input source。 (比如在主线程创建子线程时传入一个NSPort对象,主线程和子线程就可以进行通讯。NSPort对象会负责自己创建和配置Input source。)</p></li><li><p>Custom Input Sources我们可以使用Core Foundation里面的CFRunLoopSourceRef类型相关的函数来创建custom input source,系统也有提供一些方法。</p></li><li><p>Cocoa框架为我们定义了一些Custom Input Sources，允许我们在线程中执行一系列selector方法，这些在NSThread类里面。和Port-Based Sources一样，这些selector的请求会在目标线程中序列化，以减缓线程中多个方法执行带来的同步问题。和Port-Based Sources不一样的是，一个selector方法执行完之后会自动从当前Run Loop中移除。</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">performSelectorOnMainThread:withObject:waitUntilDone:</span><br><span class="line">performSelectorOnMainThread:withObject:waitUntilDone:modes:</span><br><span class="line"></span><br><span class="line">performSelector:onThread:withObject:waitUntilDone:</span><br><span class="line">performSelector:onThread:withObject:waitUntilDone:modes:</span><br><span class="line"></span><br><span class="line">performSelector:withObject:afterDelay:</span><br><span class="line">performSelector:withObject:afterDelay:inModes:</span><br><span class="line"></span><br><span class="line">cancelPreviousPerformRequestsWithTarget:</span><br><span class="line">cancelPreviousPerformRequestsWithTarget:selector:object:</span><br></pre></td></tr></table></figure><h4 id="Timer-Sources"><a href="#Timer-Sources" class="headerlink" title="Timer Sources"></a>Timer Sources</h4><p>Timer sources 在未来的特定时间同步地传递事件给线程，Timer是一种提醒线程做事的方式。</p><p>尽管Timer是一种基于时间的通知，但是并不是实时机制，如果不是对应的Mode,timer并不会被fire除非切换到对应的Mode.</p><p>如果timer的fire时间，runloop正在处理其他事件，等待超过tolerance，那么这一次fire就会错过，等待下一次来执行，如果runloop退出，那么timer就再也不会fire了。<br>间隔时间是跟上一次之后的间隔，是timer自己调度的，所以可能并不是跟实际时间完全吻合(因为存在等待，这些需要叠加)。</p><h4 id="Timer应用"><a href="#Timer应用" class="headerlink" title="Timer应用"></a>Timer应用</h4><ul><li><p>除了scheduledTimerWithTimeInterval开头的方法创建的Timer都需要手动添加到当前Run Loop中。（scheduledTimerWithTimeInterval 创建的timer会自动以Default Mode加载到当前Run Loop中。）<br>Timer在选择使用一次后，在执行完成时，会从Run Loop中移除。选择循环时，会一直保存在当前Run Loop中，直到调用invalidated方法。</p></li><li><p>一个 Timer 一次只能加入到一个 RunLoop 中。我们日常使用的时候，通常就是加入到当前的 runLoop 的 default mode 中，而 ScrollView 在用户滑动时，主线程 RunLoop 会转到 UITrackingRunLoopMode 。而这个时候， Timer 就不会运行。</p></li></ul><p>有如下两种解决方案：</p><ol><li>设置 RunLoop Mode，例如 NSTimer,我们指定它运行于 NSRunLoopCommonModes ，这是一个 Mode 的集合。注册到这个 Mode 下后，无论当前 runLoop 运行哪个 mode ，事件都能得到执行。</li><li>另一种解决 Timer 的方法是，我们在另外一个线程执行和处理 Timer 事件，然后在主线程更新 UI。</li></ol><h3 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h3><p>在处理事件源时，runloop会产生关于这些行为的通知，可以往Run Loop中加入自己的观察者以便监控Run Loop的运行过程。</p><p>Run Loop Observer会与以下事件相关联：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) </span><br><span class="line">&#123;</span><br><span class="line">kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>),<span class="comment">//即将进入Loop</span></span><br><span class="line">kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),<span class="comment">//即将处理 Timer</span></span><br><span class="line">kCFRunLoopBeforeSources= (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">//runloop即将处理input sources的事件</span></span><br><span class="line">kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">//runloop即将休眠</span></span><br><span class="line">kCFRunLoopAfterWaiting= (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>), <span class="comment">//runloop已经唤醒，但是唤醒runloop的事件还没有处理。</span></span><br><span class="line">kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>), <span class="comment">//即将退出runloop</span></span><br></pre></td></tr></table></figure><p>和Timer一样，Run Loop Observers也可以使用一次或者选择repeat。如果只使用一次，Observer会在它被执行后自己从Run Loop中移除。而循环的Observer会一直保存在Run Loop中.</p><p>一旦runloop跑起来，线程的runloop就会处理等待的事件并且给observer发送通知</p><h2 id="RunLoop生命周期"><a href="#RunLoop生命周期" class="headerlink" title="RunLoop生命周期"></a>RunLoop生命周期</h2><img src="/2019/12/02/runLoop%E6%80%BB%E7%BB%93/runloop.png" class=""><img src="/2019/12/02/runLoop%E6%80%BB%E7%BB%93/runloop_04.png" class=""><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">int32_t __CFRunLoopRun()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通知即将进入runloop</span></span><br><span class="line">  <span class="comment">//创建AutoreleasePool: _objc_autoreleasePoolPush();</span></span><br><span class="line">    __CFRunLoopDoObservers(KCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通知将要处理timer和source</span></span><br><span class="line">        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);</span><br><span class="line">        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理非延迟的主线程调用</span></span><br><span class="line">        __CFRunLoopDoBlocks();</span><br><span class="line">        <span class="comment">// 处理UIEvent事件</span></span><br><span class="line">        __CFRunLoopDoSource0();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// GCD dispatch main queue</span></span><br><span class="line">        CheckIfExistMessagesInMainDispatchQueue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 即将进入休眠</span></span><br><span class="line">      <span class="comment">//释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span></span><br><span class="line">        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待内核mach_msg事件</span></span><br><span class="line">        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Zzz...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从等待中醒来</span></span><br><span class="line">        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> (wakeUpPort == timerPort)&#123;<span class="comment">// 处理因timer的唤醒</span></span><br><span class="line">          __CFRunLoopDoTimers();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (wakeUpPort == mainDispatchQueuePort)&#123;<span class="comment">// 处理异步方法唤醒,如dispatch_async</span></span><br><span class="line">          __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;<span class="comment">// UI刷新,动画显示</span></span><br><span class="line">          __CFRunLoopDoSource1();</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 再次确保是否有同步的方法需要调用</span></span><br><span class="line">        __CFRunLoopDoBlocks();</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">while</span> (!stop &amp;&amp; !timeout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知即将退出runloop</span></span><br><span class="line">  <span class="comment">//释放AutoreleasePool: _objc_autoreleasePoolPop();</span></span><br><span class="line">    __CFRunLoopDoObservers(<span class="built_in">CFRunLoopExit</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到RunLoop事件源执行的顺序是Timer-&gt;source0-&gt;source1</p><h2 id="什么时候才需要使用runloop"><a href="#什么时候才需要使用runloop" class="headerlink" title="什么时候才需要使用runloop"></a>什么时候才需要使用runloop</h2><p>只有在你开启了子线程的情况下才需要运行runloop</p><p>对于子线程，是否需要运行runloop取决于实际需要，并不是所有的子线程都需要运行runloop。如果子线程要跑一个确定的而且长的任务，就没必要开启runloop。runloop更适合当你需要与线程更多交互的情景。以下情景需要开启runloop:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用ports或者自定义input sources与其他线程联通在线程上使用Timer</span><br><span class="line">使用performSelector这类方法保持线程执行定期周期任务</span><br></pre></td></tr></table></figure><p>如果你在子线程运行了runloop，你要准备好在合适的时候退出该子线程，因为相比于强制让runloop终止，通过让线程终止来让runloop退出更好。</p><p>子线程的runloop是要手动开启的，一个runloop必须有至少一个input source或者timer去监听，否则会立即退出。</p><h2 id="RunLoop在休息的时候是一个什么状态"><a href="#RunLoop在休息的时候是一个什么状态" class="headerlink" title="RunLoop在休息的时候是一个什么状态"></a>RunLoop在休息的时候是一个什么状态</h2><p>RunLoop是一个死循环，有执行任务，退出，和休息三种状态，解释休息这个问题前，需要先理解mach_port</p><p>mach是一个内核，提供CPU调度，进程间通信等一些基础服务，在Mach中，进程，线程，和虚拟内存都被称为“对象”，和其他架构不同，Mach的对象间不能直接调用，只能通过消息传递实现对象间的通信，“消息”是Mach中最基础的概念，一条消息包含当前端口local_port和目标端口remote_port，消息在两个端口（port）之间传递，这就是Mach的IPC（进程间通信）的核心。消息的发送和接收使用&lt;mach&#x2F;message.h&gt;中的mach_msg()函数，而mach_msg()的本质是一个调用mach_msg_trap(),这相当于一个系统调用，会触发内核状态切换，让程序处于休眠状态，这个状态就是：</p><p>APP依然在内存中，但不主动申请CPU资源，然后一直监听某个端口（port），等待内核向该端口发送消息，监听到消息后，从睡眠状态中恢复（重新启动RunLoop循环，处理完事件后继续休眠）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.helloted.com/ios/2017/04/10/Runloop_1/">Runloop</a></li><li><a href="https://zhuanlan.zhihu.com/p/62605958">关于RunLoop你想知道的事</a></li><li><a href="https://juejin.im/post/5e5226de6fb9a07c8678f84f">用户态和内核态</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> RunLoop </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UITableView优化</title>
      <link href="/2019/11/29/UITableview%E4%BC%98%E5%8C%96/"/>
      <url>/2019/11/29/UITableview%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>UITableView是iOS开发中的常用控件，用来加载列表数据，当数据量大或者布局过于复杂的时候有可能出现卡顿，影响用户体验。</p><span id="more"></span><h2 id="缓存高度"><a href="#缓存高度" class="headerlink" title="缓存高度"></a>缓存高度</h2><p>UITableView 的 UITableViewDelegate 里面有个方法 <code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;</code> 专门用于获取 Cell 的高度 。由于UITableView在绘制 Cell 的时候每次会主动获取 Cell 的高度，所以这里的优化点是减少该方法的执行时间。保存第一次计算出来的 Cell 高度,并保存到 Cell 对应的 Model 上 ,而不是每次重复计算 Cell 的高度，可以达到减少该方法的执行时间的目的。</p><h2 id="异步渲染UITableViewCell"><a href="#异步渲染UITableViewCell" class="headerlink" title="异步渲染UITableViewCell"></a>异步渲染UITableViewCell</h2><p>如果一个UITableViewCell使用系统自带的View进行布局的层级很多时，可以考虑对TableViewCell进行优化，减少View的层级，也就是对TableViewCell异步渲染。</p><h2 id="按需加载UITableViewCell"><a href="#按需加载UITableViewCell" class="headerlink" title="按需加载UITableViewCell"></a>按需加载UITableViewCell</h2><p>判断按需加载的 indexPaths , 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。这样可以减少 UITableView 的绘制工作量。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset&#123;</span><br><span class="line"> <span class="built_in">NSIndexPath</span> *ip = [<span class="keyword">self</span> indexPathForRowAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y)];</span><br><span class="line">    <span class="built_in">NSIndexPath</span> *cip = [[<span class="keyword">self</span> indexPathsForVisibleRows] firstObject];</span><br><span class="line">     <span class="built_in">NSInteger</span> skipCount = <span class="number">8</span>;</span><br><span class="line">     <span class="comment">// 目标行与当前行相差超过指定行数</span></span><br><span class="line">    <span class="keyword">if</span> (labs(cip.row-ip.row)&gt;skipCount) &#123;</span><br><span class="line">        <span class="comment">// 目标位置的行</span></span><br><span class="line">        <span class="built_in">NSArray</span> *temp = [<span class="keyword">self</span> indexPathsForRowsInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y, <span class="keyword">self</span>.width, <span class="keyword">self</span>.height)];</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *arr = [<span class="built_in">NSMutableArray</span> arrayWithArray:temp];</span><br><span class="line">        <span class="comment">//  velocity.y&lt;0 下拉， velocity.y&gt;0 上拉</span></span><br><span class="line">        <span class="keyword">if</span> (velocity.y&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp lastObject];</span><br><span class="line">            <span class="keyword">if</span> (indexPath.row+<span class="number">3</span>&lt;datas.count) &#123;</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">1</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">2</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">3</span> inSection:<span class="number">0</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp firstObject];</span><br><span class="line">            <span class="keyword">if</span> (indexPath.row&gt;<span class="number">3</span>) &#123;</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-3</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-2</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-1</span> inSection:<span class="number">0</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [needLoadArr addObjectsFromArray:arr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 UITableView 开始绘制 Cell 的时候，若是 indexpath 包含在按需绘制的 needLoadArr 数组里面，那么就异步绘制该 Cell ，如果没有则跳过该 Cell </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line">    VVeboTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@&quot;cell&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (cell==<span class="literal">nil</span>) &#123;</span><br><span class="line">        cell = [[VVeboTableViewCell alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span></span><br><span class="line">                                         reuseIdentifier:<span class="string">@&quot;cell&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绘制 Cell</span></span><br><span class="line">    [<span class="keyword">self</span> drawCell:cell withIndexPath:indexPath];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按需绘制 Cell</span></span><br><span class="line">- (<span class="type">void</span>)drawCell:(VVeboTableViewCell *)cell withIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *data = [datas objectAtIndex:indexPath.row];</span><br><span class="line">    cell.selectionStyle = <span class="built_in">UITableViewCellSelectionStyleNone</span>;</span><br><span class="line">    [cell clear];</span><br><span class="line">    cell.data = data;</span><br><span class="line">    <span class="comment">// 按需绘制，只要在 needLoadArr 里面的 indexPath 才需要绘制 Cell</span></span><br><span class="line">    <span class="keyword">if</span> (needLoadArr.count&gt;<span class="number">0</span>&amp;&amp;[needLoadArr indexOfObject:indexPath]==<span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        [cell clear];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (scrollToToping) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [cell draw];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/2d077da3af94">1.UITableView 的优化技巧</a></p><p><a href="https://github.com/johnil/VVeboTableViewDemo">2. Code</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> UI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS协议</title>
      <link href="/2019/11/25/HTTPS%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/11/25/HTTPS%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>HTTP 主要有这些不足，例举如下</p><ol><li>通信使用明文(不加密)，内容可能会被窃听 </li><li>不验证通信方的身份，因此有可能遭遇伪装   </li><li>无法证明报文的完整性，所以有可能已遭篡改</li></ol> <span id="more"></span><h2 id="通讯加密"><a href="#通讯加密" class="headerlink" title="通讯加密"></a>通讯加密</h2><p>HTTP 协议中没有加密机制，但可以通过和 SSL(Secure Socket Layer，安全套接层)或 TLS(Transport Layer Security，安全层传输协议)的组合使用， 加密 HTTP 的通信内容。用 SSL 建立安全通信线路之后，就可以在这条线路上进行HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS(HTTP Secure，超文本传输安全协议)或 HTTP over SSL</p><h2 id="验证通信方身份"><a href="#验证通信方身份" class="headerlink" title="验证通信方身份"></a>验证通信方身份</h2><p>使用证书，以证明通信方就是意料中的服务器。另外，客户端持有证书即可完成个人身份的确认，也可用于对 Web 网站的认证环节</p><h2 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密：指的就是加、解密使用的同是一串密钥，所以被称做对称加密。对称加密只有一个密钥作为私钥。<br>常见的对称加密算法：DES，AES等。</p><img src="/2019/11/25/HTTPS%E5%8D%8F%E8%AE%AE/duicheng.png" class=""><p>优缺点：加解密的效率要高得多、加密速度快。但是缺陷在于对于密钥的管理和分发上比较困难，不是非常安全，密钥管理负担很重。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密：指的是加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。反之，私钥加密的信息，只有公钥才能解密。 </p><p>见的非对称加密算法：RSA</p><img src="/2019/11/25/HTTPS%E5%8D%8F%E8%AE%AE/noduicheng.png" class=""><p>优缺点：</p><p>安全性更高，公钥是公开的，密钥是自己保存的，不需要将私钥给别人。缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p><p>举例：假设A要发送一封Email给B，他不想让任何其他人在传输中看到Email的内容，做法就是使用B的公钥对Email加密，只有B的私钥能够解密（B的私钥唯一性保证信件不会泄露）。<br>某天出意外了，有黑客冒充A给B发送Email，并且也用B的公钥加密，导致B无法区分这封邮件是否来自A。怎么办？此时A可以用自己的私钥加密，那么B收到邮件后如果用A的公钥可以解密邮件，那么证明这封信肯定来自于A</p><p>公钥的作用：对内容本身加密，保证不被其他人看到。<br>私钥的作用：证明内容的来源</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>上面发邮件的例子，A用自己的私钥对Email加密发送，这存在下面问题<br><strong>对文件本身加密可能是个耗时过程，比如这封Email足够大，那么私钥加密整个文件以及拿到文件后的解密无疑是巨大的开销。</strong></p><p>数字签名可以解决这个问题：<br>1.A先对这封Email执行哈希运算得到hash值简称“摘要”，取名h1<br>2.然后用自己私钥对摘要加密，生成的东西叫“数字签名”<br>3.把数字签名加在Email正文后面，一起发送给B<br>4.B收到邮件后用A的公钥对数字签名解密，成功则代表Email确实来自A，失败说明有人冒充<br>5.B对邮件正文执行哈希运算得到hash值，取名h2<br>6.B 会对比第4步数字签名的hash值h1和自己运算得到的h2，一致则说明邮件未被篡改。</p><img src="/2019/11/25/HTTPS%E5%8D%8F%E8%AE%AE/digitalsign.png" class=""><p><strong>数字签名的作用就是验证数据来源以及数据完整性！解密过程则称为数字签名验证</strong></p><p>数字签名流程有两个问题：</p><ol><li><p>如果中间人同时篡改了Email正文和数字签名，那B收到邮件无法察觉啊。<br>答案：数字签名的生成需要对方私钥，所以数字签名很难被伪造。万一私钥泄漏了呢，不好意思，你私钥都能弄丢了那这篇文章当我白写。（私钥绝对保密不参与传输）</p></li><li><p>公钥是公开的并且可以自行导入到电脑，如果有人比如C偷偷在B的电脑用自己公钥替换了A的公钥，然后用自己的私钥给B发送Email，这时B收到邮件其实是被C冒充的但是他无法察觉。<br>答案：确实存在这种情况！解决办法就是数字证书，一环套一环请接着看。</p></li></ol><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>数字证书如何生成？</p><ol><li>首先A去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对A的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）</li></ol><img src="/2019/11/25/HTTPS%E5%8D%8F%E8%AE%AE/digitalcer.png" class=""><ol start="2"><li>A在邮件正文下方除了数字签名，另外加上这张数字证书</li></ol><img src="/2019/11/25/HTTPS%E5%8D%8F%E8%AE%AE/digtitalFinal.png" class=""><ol start="3"><li>B收到Email后用CA的公钥解密这份数字证书，拿到A的公钥，然后验证数字签名，后面流程就和图1的流程一样了，不再赘述。</li></ol><p>问题：</p><ol><li><p>假设数字证书被伪造了呢？<br>传输中数字证书有可能被篡改。因此数字证书也是经过数字签名的，上文说道数字签名的作用就是验证数据来源以及数据完整性！B收到邮件后可以先验证这份数字证书的可靠性，通过后再验证数字签名。</p></li><li><p>要是有1万个人要给B发邮件，难道B要保存1万份不同的CA公钥吗？<br>不需要，CA认证中心给可以给B一份“根证书”，里面存储CA公钥来验证所有CA分中心颁发的数字证书。</p></li><li><p>证书验证的过程依赖于证书信任链。</p></li></ol><p>所谓证书信任链，即一个证书要依靠上一级证书来证明自己是可信的，最顶层的证书被称为根证书，拥有根证书的机构被称为根 CA。</p><p>以 Github 为例，在浏览器中我们可以看到它的证书信任链如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DigiCert High Assurance EV Root CA -&gt; DigiCert SHA2 </span><br><span class="line">Extended Validation Server CA -&gt; Github.com</span><br></pre></td></tr></table></figure><p>从上到下即 Root CA -&gt; 二级 CA -&gt; 网站。</p><ol start="4"><li>如何验证根证书可靠性？<br>无法验证。根证书是自验证证书，CA机构是获得社会绝对认可和有绝对权威的第三方机构，这一点保证了根证书的绝对可靠。</li></ol><h2 id="HTTP-加密-认证-完整性保护-x3D-HTTPS"><a href="#HTTP-加密-认证-完整性保护-x3D-HTTPS" class="headerlink" title="HTTP+ 加密 + 认证 + 完整性保护 &#x3D; HTTPS"></a>HTTP+ 加密 + 认证 + 完整性保护 &#x3D; HTTPS</h2><p>HTTPS 并非是应用层的一种新协议。只是HTTP通信接口部分用 SSL(Secure Socket Layer)和 TLS(Transport Layer Security)协议代 替而已。</p><p>HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通 信，再由 SSL 和 TCP通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP</p><p><strong>SSL 是独立于 HTTP 的协议,是 当今世界上应用最为广泛的网络安全技术</strong></p><img src="/2019/11/25/HTTPS%E5%8D%8F%E8%AE%AE/https05.png" class=""><h2 id="HTTPS连接过程"><a href="#HTTPS连接过程" class="headerlink" title="HTTPS连接过程"></a>HTTPS连接过程</h2><h3 id="HTTPS-连接的建立流程是怎样的"><a href="#HTTPS-连接的建立流程是怎样的" class="headerlink" title="HTTPS 连接的建立流程是怎样的?"></a>HTTPS 连接的建立流程是怎样的?</h3><img src="/2019/11/25/HTTPS%E5%8D%8F%E8%AE%AE/https_conn.png" class=""><p>会话秘钥 &#x3D; random S + random C + 预主秘钥</p><ul><li>TLS 四次握手</li></ul><ol><li>第一步，客户端向服务器发起请求，请求种包括使用的协议版本号，生成的一个随机数C、以及客户端支持的加密方法。</li><li>第二部，服务端收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数S</li><li>第三部，客户端确认服务器证书有效后，生成一个新的随机数（预主密钥），并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的hash的值，用来供服务器检验。</li><li>服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的hash值来供客户端检验。这个时候双方都有了三个随机数，按照之前约定的加密方法，使用这三个随机数生成对话密钥，以后的对话过程都使用这个密钥来加密信息。</li></ol><ul><li><p>为什么一定要用三个随机数，来生成“会话密钥”？<br>客户端和服务端都需要生成随机数，以此来保证每次生成的密钥都不相同，使用三个随机数，是因为SSL的协议默认不信任每个主机都能产生完全随机的数。三个伪随机数就很接近于随机了，因此可以使用这种方法来保持生成密钥的随机性和安全性。</p></li><li><p>SSL连接断开后如何恢复？<br>一共有两种方法来恢复断开的SSL连接，一种是session ID，一种是session ticket。</p></li></ul><ol><li>使用session ID<br>每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号，那么双方就可以继续使用以前的密钥，而不用重新生成一把。<br>缺点：session ID只能够存在一台服务器上，如果我们的请求通过负载均衡被转移到其他的服务器上，那么就无法恢复对话。</li><li>使用session ticket<br>session ticket是服务器在上一次对话中发送给客户的，这个ticket是加密的，只有服务器能解密，里面包含了本次会话的信息，比如对话密钥和加密算法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将ticket解密以后，就能够获取上次对话的信息，就不用生成新的对话密钥。</li></ol><h3 id="HTTPS都使用了哪些加密手段"><a href="#HTTPS都使用了哪些加密手段" class="headerlink" title="HTTPS都使用了哪些加密手段?"></a>HTTPS都使用了哪些加密手段?</h3><p>在交换密钥环节（连接建立过程中）使用公开密钥加密方式（非对称加密），之后的建立通信交换报文阶段（通信过程中）则使用共享密钥加密方式（对称加密）。</p><h3 id="如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥？"><a href="#如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥？" class="headerlink" title="如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥？"></a>如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥？</h3><p>使用由数字证书认证机构(CA，Certificate Authority)和其相关机关颁发的公开密钥证书。</p><p>数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书 后绑定在一起。</p><p>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。</p><p>接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事: 一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二， 服务器的公开密钥是值得信赖的。</p><p>认证机关的公开密钥必须安全地转交给客户端。使用通信方式 时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布 版本时，会事先在内部植入常用认证机关的公开密钥</p><p>证书的一个作用是用来证明作为通信一方的服务器是否规范，另 外一个作用是可确认对方服务器背后运营的企业是否真实存在</p><h2 id="SSL剥离"><a href="#SSL剥离" class="headerlink" title="SSL剥离"></a>SSL剥离</h2><p>SSL 剥离即阻止用户使用 HTTPS 访问网站。由于并不是所有网站都只支持 HTTPS，大部分网站会同时支持 HTTP 和 HTTPS 两种协议。用户在访问网站时，也可能会在地址栏中输入 http:&#x2F;&#x2F; 的地址，第一次的访问完全是明文的，这就给了攻击者可乘之机。通过攻击 DNS 响应，攻击者可以将自己变成中间人。</p><blockquote><p>DNS 作为基于 UDP 的协议是相当不安全的，为了保证 DNS 的安全可以使用 DNS over TCP 等机制</p></blockquote><p><strong>解决：HSTS（HTTP Strict Transport Security）用于强制浏览器使用 HTTPS 访问网站的一种机制</strong></p><h2 id="伪造证书攻击"><a href="#伪造证书攻击" class="headerlink" title="伪造证书攻击"></a>伪造证书攻击</h2><p>即使在全程使用 HTTPS 的情况下，我们仍然有可能被监听</p><p>假设我们想访问 <code>www.google.com</code>，但我们的 DNS 服务器被攻击了，指向的 IP 地址并非 Google 的服务器，而是攻击者的 IP。当攻击者的服务器也有合法的证书的时候，我们的浏览器就会认为对方是 Google 服务器，从而信任对方。这样，攻击者便可以监听我们和谷歌之前的所有通信了</p><p>击者有两步需要操作，第一步是需要攻击 DNS 服务器。第二步是攻击者自己的证书需要被用户信任，这一步对于用户来说是很难控制的，需要证书颁发机构能够控制自己不滥发证书</p><p><strong>解决：HPKP（Public Key Pinning Extension for HTTP）在 HSTS 上更进一步，HPKP 直接在返回头中存储服务器的公钥指纹信息，一旦发现指纹和实际接受到的公钥有差异，浏览器就可以认为正在被攻击</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/4932cb1499bf">1.通俗理解数字签名，数字证书和https</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>长连接及心跳保活</title>
      <link href="/2019/11/25/%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%8F%8A%E5%BF%83%E8%B7%B3%E4%BF%9D%E6%B4%BB/"/>
      <url>/2019/11/25/%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%8F%8A%E5%BF%83%E8%B7%B3%E4%BF%9D%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<p>短连接的使用有很大的瓶颈，所以才会有长连接的使用空间，但是长连接也会因为某些原因断开。</p><span id="more"></span><h2 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h2><p>早期HTTP1.0的协议都是建立在TCP协议基础上，其特点就是传输完数据后，立马就释放掉该TCP链接，所以就有了形象的短连接这个称号。</p><p>下图形象的展示出了在一个事务的处理过程中，各个阶段的处理时长：</p><img src="/2019/11/25/%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%8F%8A%E5%BF%83%E8%B7%B3%E4%BF%9D%E6%B4%BB/shorttime.png" class=""><p>可以看到，与建立TCP连接，以及传输请求和响应报文的时间相比，事务处理时间可能是很短的。</p><ul><li>短连接的性能瓶颈主要集中在如下几个方面：</li></ul><ol><li>TCP连接的握手时延 <img src="/2019/11/25/%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%8F%8A%E5%BF%83%E8%B7%B3%E4%BF%9D%E6%B4%BB/tcphand.png" class=""></li></ol><p> 在发送数据之前，TCP要传送两个分组来建立连接(现代的TCP栈都允许客户端在确认分组中发送数据)，此时，SYN&#x2F;SYN+ACK握手会产生一个可测量的时延</p><ol start="2"><li>延迟确认</li></ol><p>每个TCP段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段时，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就认为分组已被破坏或损毁，并重发数据。</p><p>由于确认报文很小，所以TCP允许在发往相同方向的输出数据分组中对其进行“捎带”。TCP将返回的确认信息与输出的数据分组结合在一起，可以更有效地利用网络。为了增加确认报文找到同向传输数据分组的可能性，很多TCP栈都实现了一种“延迟确认”算法。延迟确认算法会在一个特定的窗口时间（通常是100～200毫秒）内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。</p><ol start="3"><li>TCP慢启动<br>TCP连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度，这种调谐被称为TCP慢启动，用于防止因特网的突然过载和拥塞。</li></ol><h2 id="长连接保活，Keep-Alive与心跳保活技术"><a href="#长连接保活，Keep-Alive与心跳保活技术" class="headerlink" title="长连接保活，Keep-Alive与心跳保活技术"></a>长连接保活，Keep-Alive与心跳保活技术</h2><h3 id="心跳保活"><a href="#心跳保活" class="headerlink" title="心跳保活"></a>心跳保活</h3><p>App实现长连接保活的方式通常是采用应用层心跳，通过心跳包的超时和其他条件(网络切换)来执行重连操作。心跳一般是指某端(绝大多数情况下是客户端)每隔一定时间向对端发送自定义指令，以判断双方是否存活，因其按照一定间隔发送，类似于心跳，故被称为心跳指令。</p><h3 id="Keep-Alive能否实现保活"><a href="#Keep-Alive能否实现保活" class="headerlink" title="Keep-Alive能否实现保活"></a>Keep-Alive能否实现保活</h3><ol><li><p>HTTP中的Keep-Alive<br>实现HTTP&#x2F;1.0 keep-alive连接的客户端可以通过包含Connection:Keep-Alive首部请求将一条连接保持在打开状态，如果服务器愿意为下一条请求将连接保持在打开状态，就在响应中包含相同的首部。如果响应中没有Connection: Keep-Alive首部，客户端就认为服务器不支持keep-alive，会在发回响应报文之后关闭连接。<code>HTTP/1.1以后Keep-Alive是默认打开的。</code></p></li><li><p>TCP中的Keep-Alive<br>TCP协议的实现中，提供了KeepAlive报文，用来探测连接的对端是否存活。在应用交互的过程中，可能存在以下几种情况：</p></li><li><p>客户端或服务器意外断电，死机，崩溃，重启；</p></li><li><p>中间网络已经中断，而客户端与服务器并不知道；</p></li></ol><ul><li>TCP保活报文交互过程如下：</li></ul> <img src="/2019/11/25/%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%8F%8A%E5%BF%83%E8%B7%B3%E4%BF%9D%E6%B4%BB/tcpAlive.png" class=""><p> 虽然TCP提供了KeepAlive机制，但是并不能替代应用层心跳保活</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.HTTP协议的Keep-Alive意图在于TCP连接复用，同一个连接上串行方式传递请求-响应数据；</span><br><span class="line"> 2. TCP的Keepalive机制意图在于探测连接的对端是否存活。</span><br></pre></td></tr></table></figure><h3 id="影响心跳频率的关键因素"><a href="#影响心跳频率的关键因素" class="headerlink" title="影响心跳频率的关键因素"></a>影响心跳频率的关键因素</h3><p>心跳过于频繁会带来耗电和耗流量的弊病，心跳频率过低则会影响连接检测的实时性。业内关于心跳时间的设置和优化，主要基于如下几个因素：</p><ol><li>NAT超时–大部分移动无线网络运营商在链路一段时间没有数据通讯时，会淘汰 NAT表中的对应项，造成链路中断；</li><li>DHCP租期–DHCP租期到了需要主动续约，否则会继续使用过期IP导致长连接偶然的断连；</li><li>网络状态变化–手机网络和WIFI网络切换、网络断开和连上等情况有网络状态的变化，也会使长连接变为无效连接；</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://caofengbin.github.io/2018/03/16/dhcp-and-nat/">长连接及心跳保活原理简介</a></p></li><li><p><a href="https://blog.csdn.net/weixin_41783335/article/details/95739900">tcp长连接保活与心跳机制</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在浏览器中输入URL到页面展现发生什么？</title>
      <link href="/2019/11/19/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/"/>
      <url>/2019/11/19/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>从开发角度来看，总体来说分以下几个过程</p><ul><li>URL解析</li><li>DNS解析：将域名解析成IP地址</li><li>TCP连接：三次握手</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>TCP断开连接：四次挥手<span id="more"></span></li></ul><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h3><p>分析所需要使用的传输协议和请求资源的路径，如果输入的URL中的协议或者主机名不合法，<br>将会把地址栏中输入的内容传递给搜索引擎，如果没有问题，浏览器会检查URL中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</p><h3 id="缓存检查"><a href="#缓存检查" class="headerlink" title="缓存检查"></a>缓存检查</h3><p>浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失败，那么就直接使用，否则向服务器发起新的请求。</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>首先会判断本地是否有该域名的IP地址的缓存，如果没有则向本地DNS服务器发起请求，本地DNS服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户向本地DNS服务器发起请求属于递归请求</span><br><span class="line">本地DNS服务器向各级域名服务器发起请求属于迭代请求。</span><br></pre></td></tr></table></figure><h3 id="套接字生成"><a href="#套接字生成" class="headerlink" title="套接字生成"></a>套接字生成</h3><p>当浏览器得到IP地址后，数据传输还需要知道目的主机的MAC地址，因为应用层发送数据给传输层，TCP协议会指定元端口号和目的端口号，然后下发给网络层，网络层会将本机地址作为源地址，获取的IP地址作为目的地址，然后下发给数据链路层，数据链路层的发送需要加入通信双方的MAC地址，我们本机的MAC地址作为源MAC地址，目的MAC地址需要按分情况处理。通过将IP地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果在同一个子网里，可以使用ARP协议获取到目的主机的MAC地址，如果不在一个子网里，那么我们的请求应该转发给我们的网关，由它代为转发，此时通过ARP协议来获取网关的MAC地址。此时目的主机的MAC地址应该为该网关的地址。</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>…</p><h3 id="HTTPS协议的话，还会有TLS的一个四次握手的过程"><a href="#HTTPS协议的话，还会有TLS的一个四次握手的过程" class="headerlink" title="HTTPS协议的话，还会有TLS的一个四次握手的过程"></a>HTTPS协议的话，还会有TLS的一个四次握手的过程</h3><p>…</p><h3 id="服务器处理请求并返回HTTP报文"><a href="#服务器处理请求并返回HTTP报文" class="headerlink" title="服务器处理请求并返回HTTP报文"></a>服务器处理请求并返回HTTP报文</h3><p>当页面请求发送到服务端后，服务端会返回一个html文件作为响应，浏览器接收到响应后，开始对html文件进行解析，开始页面的渲染过程。</p><h3 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h3><p>浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端<br>是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建<br>立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页<br>面进行绘制。这个时候整个页面就显示出来了。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>…</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>CDN是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域，不同运营商的服务器，向用户提供资源就近访问的功能，也就是说用户的请求并不是直接发送给源网站，而是发送给CDN服务器，由CDN服务器将请求定位到最近的含有该资源的服务器上去请求，这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。</p><h3 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h3><p>常说的代理就是指正向代理，正向代理的过程隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。</p><img src="/2019/11/19/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/01.png" class=""><p>反向代理隐藏了真实的服务端，当我们请求一个网站的时候，背后可能有成千上万台服务器为我们服务，但具体是哪一台，也不需要知道，我们只需要知道反向代理是谁就好了，反向代理服务器会帮我们把请求转发到真实的服务器那里去。 反向代理一般用来实现负载均衡。</p><img src="/2019/11/19/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/02.png" class=""><h3 id="负载均衡的两种实现方式"><a href="#负载均衡的两种实现方式" class="headerlink" title="负载均衡的两种实现方式"></a>负载均衡的两种实现方式</h3><ol><li>反向代理<br>用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载均衡。</li><li>DNS方式<br>DNS可以用于在冗余的服务器上实现负载均衡，因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址,当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在<br>每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。这种方式有一个<code>缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题</code>。</li></ol><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。</p><p><strong>scheme: &#x2F;&#x2F; host.domain:port &#x2F; path &#x2F; filename ? abc &#x3D; 123 # 456789</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scheme       - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，</span><br><span class="line">               其中最常见的类型是 http，而 https 则是进行加密的网络传输。</span><br><span class="line">host         - 定义域主机（http 的默认主机是 www）</span><br><span class="line">domain       - 定义因特网域名，比如 baidu.com</span><br><span class="line">port         - 定义主机上的端口号（http 的默认端口号是 80）</span><br><span class="line">path         - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</span><br><span class="line">filename     - 定义文档/资源的名称</span><br><span class="line">query        - 即查询参数</span><br><span class="line">fragment     - 即 <span class="comment"># 后的hash值，一般用来定位到某个位置</span></span><br></pre></td></tr></table></figure><h3 id="即时通讯的实现，短轮询、长轮询、SSE-和-WebSocket-间的区别"><a href="#即时通讯的实现，短轮询、长轮询、SSE-和-WebSocket-间的区别" class="headerlink" title="即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别"></a>即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别</h3><p>短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。</p><h4 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h4><p>短轮询的基本思路就是浏览器每隔一段时间向服务器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</p><h4 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h4><p>长轮询的基本思路是，首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。<br>客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</p><h4 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h4><p>SSE 的基本思想是，服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，<code>视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息</code>。它基于 http 协议，目前除了 IE&#x2F;Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。</p><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://juejin.im/post/5c7646f26fb9a049fd108380">从URL输入到页面展现到底发生什么？</a></li><li><a href="https://segmentfault.com/a/1190000022350860">关于计算机网络，助你查漏补缺</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> URL </tag>
            
            <tag> DNS </tag>
            
            <tag> CDN </tag>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactiveCocoa学习</title>
      <link href="/2019/10/15/ReactiveCocoa%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/10/15/ReactiveCocoa%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>RAC 被描述为函数响应式编程。</p><h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><blockquote><p>函数式编程 ：使用高阶函数，例如函数用其他函数作为参数。<br>响应式编程：关注于数据流和变化传播。<br>链式编程 : 是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。a(1).b(2).c(3),注意点:要想达到链式编程方法的返回值必须是一个( (返回值是本身对象的)block)</p></blockquote><span id="more"></span><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="入门第一部分"><a href="#入门第一部分" class="headerlink" title="入门第一部分"></a>入门第一部分</h3><h4 id="Signal-传递的-data"><a href="#Signal-传递的-data" class="headerlink" title="Signal 传递的 data"></a>Signal 传递的 data</h4><p>Signal 传递的 data 是 event，它所传递的 event 包括 3 种：值事件、完成事件和错误事件。其中在传递值事件时，可以携带数据.<strong>传递值事件&#x2F;完成事件&#x2F;错误事件的本质就是向 subscriber 发送sendNext:、sendComplete以及sendError:消息</strong></p><p>Signal 在其生命周期内，可以传递任意多个值事件，但最多只能传递一个完成事件或错误事件；换句话说，一旦 Signal 的事件流中出现了错误事件或者完成事件，之后产生的任何事件都是无效的.</p><h4 id="Signal的简单使用"><a href="#Signal的简单使用" class="headerlink" title="Signal的简单使用"></a>Signal的简单使用</h4><p>创建信号、订阅信号、订阅过程</p><h5 id="创建获取信号"><a href="#创建获取信号" class="headerlink" title="创建获取信号"></a>创建获取信号</h5><ol><li>创建单元信号</li><li>创建动态信号</li><li>通过 Cocoa 桥接</li><li>从别的信号变换而来</li><li>由序列变换而来</li></ol><p>Cocoa桥接</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal6 = [objectrac_signalForSelector:<span class="keyword">@selector</span>(setFrame:)];</span><br><span class="line">RACSignal *signal7 = [control rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">RACSignal *signal8 = [object rac_willDeallocSignal];</span><br><span class="line">RACSignal *signal9 = RACObserve(object, keyPath);</span><br></pre></td></tr></table></figure><p>信号变换</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal10 = [signal1 map:^<span class="type">id</span>(<span class="type">id</span> value) &#123;</span><br><span class="line">    <span class="keyword">return</span> someObject;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>序列变换</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal11 = sequence.signal;</span><br></pre></td></tr></table></figure><h5 id="订阅信号"><a href="#订阅信号" class="headerlink" title="订阅信号"></a>订阅信号</h5><p>订阅信号的方式有 3 种：</p><ol><li>通过subscribeNext:error:completed:方法订阅</li><li>RAC 宏绑定</li><li>Cocoa 桥接</li></ol><p>通过subscribeNext:error:completed:方法订阅</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(<span class="type">void</span> (^)(<span class="type">id</span> x))nextBlock</span><br><span class="line">                           error:(<span class="type">void</span> (^)(<span class="built_in">NSError</span> *error))errorBlock</span><br><span class="line">                       completed:(<span class="type">void</span> (^)(<span class="type">void</span>));</span><br></pre></td></tr></table></figure><p>RAC 宏绑定</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAC(view, backgroundColor) = signal10;</span><br><span class="line"><span class="comment">// 每当signal10产生一个值事件，就将view.backgroundColor设为相应的值</span></span><br></pre></td></tr></table></figure><p>Cocoa 桥接</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[object rac_liftSelector:<span class="keyword">@selector</span>(someSelector:) withSignals:signal1, signal2, <span class="literal">nil</span>];</span><br><span class="line">[object rac_liftSelector:<span class="keyword">@selector</span>(someSelector:) withSignalsFromArray:@[signal1, signal2]];</span><br><span class="line">[object rac_liftSelector:<span class="keyword">@selector</span>(someSelector:) withSignalOfArguments:signal1];</span><br></pre></td></tr></table></figure><h5 id="订阅过程"><a href="#订阅过程" class="headerlink" title="订阅过程"></a>订阅过程</h5><p>订阅过程指的是信号被订阅的处理逻辑</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;1&quot;</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;2&quot;</span>];</span><br><span class="line">    [subscriber sendCompleted];     </span><br><span class="line">    [subscriber sendNext:<span class="string">@&quot;3&quot;</span>];  <span class="comment">// 无效</span></span><br><span class="line">    <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;dispose&quot;</span>);       <span class="comment">// 当错误事件或者完成事件产生时，该block被调用</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;next value is :  %@&quot;</span>, x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;error : %@&quot;</span>, error);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;completed&quot;</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* prints:</span></span><br><span class="line"><span class="comment">next value is :  1</span></span><br><span class="line"><span class="comment">next value is :  2</span></span><br><span class="line"><span class="comment">completed</span></span><br><span class="line"><span class="comment">dispose</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>RACSignal的每一个操作都会返回一个RACSignal。</p></li><li><p>RACSequence是RAC中的集合类,可以实现OC对象与信号中传递值之间的转换,RAC类库中提供了NSArray,NSDictionary等集合类的分类供其转换</p></li><li><p>RAC中信号处理的常用方法</p></li></ul><ol><li>Map实现类型转换 </li><li>信号中的信号  flattenMap </li><li>添加附加的操作 doNext</li><li>Reduce 聚合: 将多个信号发出的值进行聚合</li></ol><ul><li>ReactiveCocoa操作方法之秩序(控制流操作)。</li></ul><ol><li>doNext:执行Next之前，会先执行这个Block</li><li>doCompleted:<br>执行sendCompleted之前，会先执行这个Block</li></ol><h4 id="RACObserve接收不到信号问题"><a href="#RACObserve接收不到信号问题" class="headerlink" title="RACObserve接收不到信号问题"></a><a href="http://www.bubblefoundry.com/blog/2014/04/subscribing-to-collection-changes-using-reactivecocoa/">RACObserve接收不到信号问题</a></h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[RACObserve(<span class="keyword">self</span>, selectedRows) subscribeNext:^(<span class="built_in">NSSet</span> *currentlySelected) &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;Currently selected: %@&quot;</span>, currentlySelected);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.selectedRows = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">- (<span class="type">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">  [<span class="keyword">self</span>.selectedRows addObject:indexPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面RACObserve回调只会调用一次，初始化的时候，为什么addObject的时候没有出发信号？<br>因为addObject没有触发KVO事件。解决通过协议触发KVO</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">  [[<span class="keyword">self</span> mutableSetValueForKey:<span class="string">@&quot;selectedRows&quot;</span>] addObject:indexPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入门第二部分"><a href="#入门第二部分" class="headerlink" title="入门第二部分"></a>入门第二部分</h3><ul><li><p>取消订阅<br>在一个completed或者error事件之后，订阅会自动移除，还可以通过RACDisposable手动移除订阅。</p></li><li><p>链接signal<br>Then方法会等待completed事件的发送，然后再订阅由then block返回的signal。这样就高效地把控制权从一个signal传递给下一个。</p></li><li><p>线程<br>deliverOn</p></li><li><p>节流<br>throttle</p></li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="RACSignal的subscription过程"><a href="#RACSignal的subscription过程" class="headerlink" title="RACSignal的subscription过程"></a>RACSignal的subscription过程</h3><p>RACSignal的常见用法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-(RACSignal *)signInSignal &#123;</span><br><span class="line"><span class="comment">// part 1:[RACSignal createSignal]来获得signal</span></span><br><span class="line">  <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [<span class="keyword">self</span>.signInService</span><br><span class="line">     signInWithUsername:<span class="keyword">self</span>.usernameTextField.text</span><br><span class="line">     password:<span class="keyword">self</span>.passwordTextField.text</span><br><span class="line">     complete:^(<span class="type">BOOL</span> success) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// part 3: 进入didSubscribe，通过[subscriber sendNext:]来执行next block</span></span><br><span class="line">       [subscriber sendNext:@(success)];</span><br><span class="line">       [subscriber sendCompleted];</span><br><span class="line">     &#125;];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;];<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// part 2 : [signal subscribeNext:]来获得subscriber，然后进行subscription</span></span><br><span class="line">[[<span class="keyword">self</span> signInSignal] subscribeNext:^(<span class="type">id</span> x) &#123; </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Sign in result: %@&quot;</span>, x); </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><strong>Subscription过程概括</strong><br>RACSignal的Subscription过程概括起来可以分为三个步骤：</p><ol><li><p>[RACSignal createSignal]来获得signal</p></li><li><p>[signal subscribeNext:]来获得subscriber，然后进行subscription</p></li><li><p>进入didSubscribe，通过[subscriber sendNext:]来执行next block</p></li><li><p>步骤一：[RACSignal createSignal]来获得signal</p></li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RACSignal.m中：</span><br><span class="line">+ ( RACSignal *)createSignal:( RACDisposable * (^)( <span class="type">id</span> &lt; RACSubscriber &gt; subscriber))didSubscribe &#123;</span><br><span class="line">  <span class="keyword">return</span> [ RACDynamicSignal   createSignal :didSubscribe];</span><br><span class="line">&#125;</span><br><span class="line">RACDynamicSignal.m中</span><br><span class="line">+ ( RACSignal *)createSignal:( RACDisposable * (^)( <span class="type">id</span> &lt; RACSubscriber &gt; subscriber))didSubscribe &#123;</span><br><span class="line">  RACDynamicSignal *signal = [[ <span class="keyword">self</span>   alloc ] init ];</span><br><span class="line"> signal-&gt; _didSubscribe = [didSubscribe <span class="keyword">copy</span> ];</span><br><span class="line">  <span class="keyword">return</span> [signal setNameWithFormat : <span class="string">@&quot;+createSignal:&quot;</span> ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[RACSignal createSignal]会调用子类RACDynamicSignal的createSignal来返回一个signal，并在signal中保存后面的 didSubscribe这个block</p><ol start="2"><li>步骤二：[signal subscribeNext:]来获得subscriber，然后进行subscription</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">RACSignal.m中：</span><br><span class="line">- ( RACDisposable *)subscribeNext:( <span class="type">void</span> (^)( <span class="type">id</span> x))nextBlock &#123;</span><br><span class="line">  RACSubscriber *o = [ RACSubscriber   subscriberWithNext :nextBlock error : <span class="literal">NULL</span>   completed : <span class="literal">NULL</span> ];</span><br><span class="line">  <span class="keyword">return</span> [ <span class="keyword">self</span>  subscribe :o];</span><br><span class="line">&#125;</span><br><span class="line">RACSubscriber.m中：</span><br><span class="line"> </span><br><span class="line">+ ( <span class="keyword">instancetype</span> )subscriberWithNext:( <span class="type">void</span> (^)( <span class="type">id</span> x))next error:( <span class="type">void</span> (^)( <span class="built_in">NSError</span> *error))error completed:( <span class="type">void</span> (^)( <span class="type">void</span> ))completed &#123;</span><br><span class="line">  RACSubscriber *subscriber = [[ <span class="keyword">self</span>   alloc ] init ];</span><br><span class="line"> subscriber-&gt; _next = [next <span class="keyword">copy</span> ];</span><br><span class="line"> subscriber-&gt; _error = [error <span class="keyword">copy</span> ];</span><br><span class="line"> subscriber-&gt; _completed = [completed <span class="keyword">copy</span> ];</span><br><span class="line">  <span class="keyword">return</span> subscriber;</span><br><span class="line">&#125;</span><br><span class="line">RACDynamicSignal.m中：</span><br><span class="line">- (RACDisposable *)subscribe:(<span class="type">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">    RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">    subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class="keyword">self</span> disposable:disposable];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.didSubscribe != <span class="literal">NULL</span>) &#123;</span><br><span class="line">RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">RACDisposable *innerDisposable = <span class="keyword">self</span>.didSubscribe(subscriber);</span><br><span class="line">[disposable addDisposable:innerDisposable];</span><br><span class="line">&#125;];</span><br><span class="line">[disposable addDisposable:schedulingDisposable];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>[signal subscribeNext]先会获得一个subscriber，这个subscriber中保存了nextBlock、errorBlock、completedBlock</p></li><li><p>由于这个signal其实是RACDynamicSignal类型的，这个[self subscribe]方法会调用步骤一中保存的didSubscribe，参数就是1中的subscriber</p></li><li><p>步骤三：进入didSubscribe，通过[subscriber sendNext:]来执行next block</p></li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSubscriber.m中：</span><br><span class="line">- (<span class="type">void</span>)sendNext:(<span class="type">id</span>)value &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="type">void</span> (^nextBlock)(<span class="type">id</span>) = [<span class="keyword">self</span>.next <span class="keyword">copy</span>];</span><br><span class="line"><span class="keyword">if</span> (nextBlock == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line">nextBlock(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何时候这个[subscriber sendNext:],就直接调用nextBlock</p><h3 id="multicast和replay"><a href="#multicast和replay" class="headerlink" title="multicast和replay"></a>multicast和replay</h3><h4 id="有关的RACSignal的操作"><a href="#有关的RACSignal的操作" class="headerlink" title="有关的RACSignal的操作"></a>有关的RACSignal的操作</h4><p>在RACSignal+Operation.h中，定义了5个跟我们这个主题有关的RACSignal的操作</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RACSignal+Operation.h中</span><br><span class="line">- (RACMulticastConnection *)publish;</span><br><span class="line"></span><br><span class="line">- (RACMulticastConnection *)multicast:(RACSubject *)subject;</span><br><span class="line"></span><br><span class="line">- (RACSignal *)replay;</span><br><span class="line"></span><br><span class="line">- (RACSignal *)replayLast;</span><br><span class="line"></span><br><span class="line">- (RACSignal *)replayLazily;</span><br></pre></td></tr></table></figure><p>这几个操作的区别很细微，但用错的话很容易出问题。只有理解了原理之后，才明白它们之间的细微区别,很多时候我们意识不到需要用这些操作，这就可能因为side effects执行多次而导致程序bug</p><h4 id="multicast-amp-amp-replay的应用场景"><a href="#multicast-amp-amp-replay的应用场景" class="headerlink" title="multicast &amp;&amp; replay的应用场景"></a>multicast &amp;&amp; replay的应用场景</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用ReactiveCocoa源码的Documentation目录下的一个例子</span></span><br><span class="line"><span class="comment">// This signal starts a new request on each subscription.</span></span><br><span class="line">RACSignal *networkRequest = [RACSignal createSignal:^(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    AFHTTPRequestOperation *operation = [client</span><br><span class="line">        HTTPRequestOperationWithRequest:request</span><br><span class="line">        success:^(AFHTTPRequestOperation *operation, <span class="type">id</span> response) &#123;</span><br><span class="line">            [subscriber sendNext:response];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;</span><br><span class="line">        failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">            [subscriber sendError:error];</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">    [client enqueueHTTPRequestOperation:operation];</span><br><span class="line">    <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        [operation cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Starts a single request, no matter how many subscriptions `connection.signal`</span></span><br><span class="line"><span class="comment">// gets. This is equivalent to the -replay operator, or similar to</span></span><br><span class="line"><span class="comment">// +startEagerlyWithScheduler:block:.</span></span><br><span class="line">RACMulticastConnection *connection = [networkRequest multicast:[RACReplaySubject subject]];</span><br><span class="line">[connection connect];</span><br><span class="line"></span><br><span class="line">[connection.signal subscribeNext:^(<span class="type">id</span> response) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;subscriber one: %@&quot;</span>, response);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[connection.signal subscribeNext:^(<span class="type">id</span> response) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;subscriber two: %@&quot;</span>, response);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ol><li>在上面的例子中，如果我们不用RACMulticastConnection的话，那就会因为执行了两次subscription而导致发了两次网络请求。</li><li>从上面的例子中，我们可以看到对一个Signal进行multicast之后，我们是对connection.signal进行subscription而不是原来的networkRequest。这点是”side effects should only occur once”的关键，我们将在后面解释</li></ol><h3 id="冷信号和热信号"><a href="#冷信号和热信号" class="headerlink" title="冷信号和热信号"></a>冷信号和热信号</h3><p>冷热信号的概念源于.NET框架Reactive Extensions(RX)中的Hot Observable和Cold Observable，两者的区别是：</p><blockquote><ol><li>Hot Observable是主动的，尽管你并没有订阅事件，但是它会时刻推送，就像鼠标移动；而Cold Observable是被动的，只有当你订阅的时候，它才会发布消息。 </li><li>Hot Observable可以有多个订阅者，是一对多，集合可以与订阅者共享信息；而Cold Observable只能一对一，当有不同的订阅者，消息是重新完整发送。</li></ol></blockquote><h4 id="冷信号"><a href="#冷信号" class="headerlink" title="冷信号"></a>冷信号</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)racColdSingle</span><br><span class="line">&#123;</span><br><span class="line">    RACSignal* coldSingle=[RACSignal createSignal:^RACDisposable * _Nullable(<span class="type">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Signal was created.&quot;</span>);</span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">0.1</span> schedule:^&#123;</span><br><span class="line">        [coldSingle subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Subscriber 1 recveive: %@&quot;</span>, x);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">1</span> schedule:^&#123;</span><br><span class="line">        [coldSingle subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Subscriber 2 recveive: %@&quot;</span>, x);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2019-09-23 14:14:26.853285+0800 RACDemo[16585:117906] Signal was created.</span><br><span class="line">2019-09-23 14:14:26.956126+0800 RACDemo[16585:117906] Subscriber 1 recveive: 1</span><br><span class="line">2019-09-23 14:14:26.956339+0800 RACDemo[16585:117906] Subscriber 1 recveive: 2</span><br><span class="line">2019-09-23 14:14:26.956559+0800 RACDemo[16585:117906] Subscriber 1 recveive: 3</span><br><span class="line">2019-09-23 14:14:27.888112+0800 RACDemo[16585:117906] Subscriber 2 recveive: 1</span><br><span class="line">2019-09-23 14:14:27.888267+0800 RACDemo[16585:117906] Subscriber 2 recveive: 2</span><br><span class="line">2019-09-23 14:14:27.888363+0800 RACDemo[16585:117906] Subscriber 2 recveive: 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>信号在14:14:26.853时被创建，14:14:26.956依次接到1、2、3三个值，而在14:14:27.888再依次接到1、2、3三个值。说明了变量名为coldSingle的这个信号，在两个不同时间段的订阅过程中，分别完整地发送了所有的消息。</p><h4 id="热信号"><a href="#热信号" class="headerlink" title="热信号"></a>热信号</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)racHoltSingal</span><br><span class="line">&#123;</span><br><span class="line">    RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable *(<span class="type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">1</span> schedule:^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">2</span> schedule:^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">3</span> schedule:^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">4</span> schedule:^&#123;</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;] publish];</span><br><span class="line">    </span><br><span class="line">    [connection connect];</span><br><span class="line">    RACSignal *signal = connection.signal;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Signal was created.&quot;</span>);</span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">1.1</span> schedule:^&#123;</span><br><span class="line">        [signal subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Subscriber 1 recveive: %@&quot;</span>, x);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">2.1</span> schedule:^&#123;</span><br><span class="line">        [signal subscribeNext:^(<span class="type">id</span> x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Subscriber 2 recveive: %@&quot;</span>, x);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来一一分析：</p><ol><li>创建了一个信号，在1秒、2秒、3秒分别发送1、2、3这三个值，4秒发送结束信号。</li><li>对这个信号调用publish方法得到一个RACMulticastConnection。</li><li>让connection进行连接操作。</li><li>获得connection的信号。</li><li>分别在1.1秒和2.1秒订阅获得的信号。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-09-23 14:20:26.214718+0800 RACDemo[16872:122429] Signal was created.</span><br><span class="line">2019-09-23 14:20:28.325190+0800 RACDemo[16872:122429] Subscriber 1 recveive: 2</span><br><span class="line">2019-09-23 14:20:29.274356+0800 RACDemo[16872:122429] Subscriber 1 recveive: 3</span><br><span class="line">2019-09-23 14:20:29.274537+0800 RACDemo[16872:122429] Subscriber 2 recveive: 3</span><br></pre></td></tr></table></figure><ul><li>[RACSignal publish]、- [RACMulticastConnection connect]、- [RACMulticastConnection signal]这几个操作生成了一个热信号</li></ul><p>信号在14:20:26.214被创建14:20:28.325时订阅者1才收到2这个值，说明1这个值没有接收到，时间间隔是2秒多14:20:29.274时订阅者1和订阅者2同时收到3这个值，时间间隔是3秒多</p><p>热信号的如下特点：</p><ol><li>热信号是主动的，即使你没有订阅事件，它仍然会时刻推送。如第二个例子，信号在50秒被创建，51秒的时候1这个值就推送出来了，但是当时还没有订阅者。而冷信号是被动的，只有当你订阅的时候，它才会发送消息。如第一个例子。</li><li>热信号可以有多个订阅者，是一对多，信号可以与订阅者共享信息。如第二个例子，订阅者1和订阅者2是共享的，他们都能在同一时间接收到3这个值。而冷信号只能一对一，当有不同的订阅者，消息会从新完整发送。如第一个例子，我们可以观察到两个订阅者没有联系，都是基于各自的订阅时间开始接收消息的。</li></ol><h5 id="RAC中的热信号"><a href="#RAC中的热信号" class="headerlink" title="RAC中的热信号"></a>RAC中的热信号</h5><p>在RAC中，所有的热信号都属于一个类<code>RACSubject</code></p><blockquote><p>A subject, represented by the RACSubject class, is a signal that can be manually controlled.</p></blockquote><blockquote><p>Subjects can be thought of as the “mutable” variant of a signal, much like NSMutableArray is for NSArray. They are extremely useful for bridging non-RAC code into the world of signals.</p></blockquote><blockquote><p>For example, instead of handling application logic in block callbacks, the blocks can simply send events to a shared subject instead. The subject can then be returned as a RACSignal, hiding the implementation detail of the callbacks.</p></blockquote><blockquote><p>Some subjects offer additional behaviors as well. In particular, RACReplaySubject can be used to buffer events for future subscribers, like when a network request finishes before anything is ready to handle the result.</p></blockquote><p>Subject具备如下三个特点：</p><ol><li>Subject是可变的</li><li>Subject是非RAC到RAC的一个桥梁</li><li>Subject可以附加行为，例如RACReplySubject具备为未来订阅者缓冲事件的能力。</li></ol><blockquote><ol><li>RACSubject几其子类是热信号</li><li>RACSingle排除RACSubject类以外的是冷信号</li></ol></blockquote><h5 id="冷信号转化成热信号—广播"><a href="#冷信号转化成热信号—广播" class="headerlink" title="冷信号转化成热信号—广播"></a>冷信号转化成热信号—广播</h5><p>冷信号与热信号的本质区别在于是否保持状态，冷信号的多次订阅是不保持状态的，而热信号的多次订阅可以保持状态，所以一种将冷信号转换为热信号的方法就是，将冷信号订阅，订阅到的每一个时间通过<code>RACSubject</code>发送出去，其它订阅者只订阅这个<code>RACSubject</code></p><h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h2><ol><li><a href="https://www.jianshu.com/p/81a1f470a679">ReactiveCocoa学习之路</a></li><li><a href="https://juejin.im/post/57caf01b5bbb500074ebddf6">Reactivecocoa（RAC）知其所以然</a></li><li><a href="https://tech.meituan.com/tags/reactivecocoa.html">美团ReactiveCocoa</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> RAC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS音频边加载边播放</title>
      <link href="/2019/09/16/iOS%E9%9F%B3%E9%A2%91%E8%BE%B9%E5%8A%A0%E8%BD%BD%E8%BE%B9%E6%92%AD%E6%94%BE/"/>
      <url>/2019/09/16/iOS%E9%9F%B3%E9%A2%91%E8%BE%B9%E5%8A%A0%E8%BD%BD%E8%BE%B9%E6%92%AD%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<p>如果你要做一个类似网易云音乐，豆瓣电台的在线音乐类APP，你会这么做？</p><span id="more"></span><h2 id="音频播放的需求"><a href="#音频播放的需求" class="headerlink" title="音频播放的需求"></a>音频播放的需求</h2><ol><li>离线播放：播放本地音频文件，包括先下载完成音频文件再进行播放，这种使用AVFoundation里的AVAudioPlayer就可以满足</li><li>在线播放：使用AVFoundation的AVPlayer可以满足</li><li>在线播放同时存储文件：使用AudioFileStreamer+AudioQueue可以满足</li><li>在线播放且带有音效处理：使用AudioFileStreamer+AudioQueue+音效处理（系统自带或者自行开发）来满足</li></ol><h3 id="AVPlayer"><a href="#AVPlayer" class="headerlink" title="AVPlayer"></a>AVPlayer</h3><p>AVPlayer存在于AVFoundation中，其实它是一个视频播放器，但是用它来播放音乐是没问题的。</p><p>AVAsset是抽象类，不能直接使用，其子类AVURLAsset可以根据URL生成包含媒体信息的Asset对象。</p><p>AVPlayerItem：和媒体资源存在对应关系，管理媒体资源的信息和状态。</p><h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><ol><li>网络链接播放音乐</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURl</span>* url  = [<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span>.currentSong.url];</span><br><span class="line"><span class="built_in">AVPleryItem</span>* songItem=[[<span class="built_in">AVPlayerItem</span> alloc]initWithURL:url];</span><br><span class="line"><span class="built_in">AVPlayer</span>* player=[[<span class="built_in">AVPlayer</span> alloc]initWithPlayerItem:songItem];</span><br></pre></td></tr></table></figure><ol start="2"><li>上一首，下一首<br>两种实现，一种是自行控制下一首歌曲的item，将其替换到当前播放的item<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[player replaceCurrentItemWithPlayerItem:songItem];</span><br></pre></td></tr></table></figure>一种是使用AVPlayer的子类AVQueuePlayer来播放多个item，调用advanceToNextItem来播放下一首</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> * items = @[item1, item2, item3 ....];</span><br><span class="line"><span class="built_in">AVQueuePlayer</span> * queuePlayer = [[<span class="built_in">AVQueuePlayer</span> alloc]initWithItems:items];</span><br></pre></td></tr></table></figure><h3 id="AVPlayer缓存实现"><a href="#AVPlayer缓存实现" class="headerlink" title="AVPlayer缓存实现"></a>AVPlayer缓存实现</h3><p>AVPlayer使用过程中，有很多局限性，比如播放音乐时，不能控制其内部播放逻辑，比如播放时seek会失败，数据加载完毕后不能获取到数据文件进行其他操作，因此需要其他方法弥补其不足，<code>AVAssetResourceLoader</code>.</p><p><code>AVAssetResourceLoader</code>：可以自行掌握AVPlayer数据的加载，包括获取AVPlaer需要的数据信息，以及传递多少数据给AVPlayer</p><img src="/2019/09/16/iOS%E9%9F%B3%E9%A2%91%E8%BE%B9%E5%8A%A0%E8%BD%BD%E8%BE%B9%E6%92%AD%E6%94%BE/avplayer01.png" class=""><h4 id="AVAssetResourceLoaderDelegate"><a href="#AVAssetResourceLoaderDelegate" class="headerlink" title="AVAssetResourceLoaderDelegate"></a>AVAssetResourceLoaderDelegate</h4><p>使用AVAssetResourceLoader需要实现AVAssetResourceLoaderDelegate方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVURLAsset</span> *urlAsset = ...</span><br><span class="line">[urlAsset.resourceLoader setDelegate:&lt;<span class="built_in">AVAssetResourceLoaderDelegate</span>&gt; queue:dispatch_get_main_queue()];</span><br></pre></td></tr></table></figure><p>找一个对象实现AVAssetResourceLoaderDelegate这个协议的方法，丢给asset，再把asset丢给AVPlayer，AVPlayer在执行播放的时候就会去访问delegate，能否播放这个url，然后会触发下面方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader </span><br><span class="line">shouldWaitForLoadingOfRequestedResource:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest; <span class="comment">//要求加载资源的代理方法</span></span><br></pre></td></tr></table></figure><p>此时可以保存loadingRequest并对其所指定的数据进行读取或下载操作，当数据读取或下载完成，我们可以对loadingRequest进行完成操作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)resourceLoader:(<span class="built_in">AVAssetResourceLoader</span> *)resourceLoader </span><br><span class="line">didCancelLoadingRequest:(<span class="built_in">AVAssetResourceLoadingRequest</span> *)loadingRequest; <span class="comment">//取消加载资源的代理方法</span></span><br></pre></td></tr></table></figure><p>这是我们需要取消loadingRequest所指定的数据的读取或下载操作</p><ul><li>如何请求数据<br><code>shouldWaitForLoadingOfRequestedResource</code>代理方法会得到一个<code>AVAssetResourceLoadingRequest</code>对象</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetResourceLoadingRequest</span> : <span class="title">NSObject</span> </span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURLRequest</span> *request;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">AVAssetResourceLoadingContentInformationRequest</span> *contentInformationRequest <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_9, <span class="number">7</span>_0);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">AVAssetResourceLoadingDataRequest</span> *dataRequest <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_9, <span class="number">7</span>_0);</span><br><span class="line"> </span><br><span class="line"> - (<span class="type">void</span>)finishLoading <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_9, <span class="number">7</span>_0);</span><br><span class="line"> </span><br><span class="line"> - (<span class="type">void</span>)finishLoadingWithError:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">@end</span> </span><br></pre></td></tr></table></figure><p>request代表原始的请求，AVPlayer是会触发分片下载的策略，dataRequest中可以得到请求范围的信息，有了请求地址和请求范围，可以重新创建一个设置了请求Range头的NSURLRequest对象，让下载器去下载这个文件的Range范围内的数据。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="https://mp.weixin.qq.com/s/v1sw_Sb8oKeZ8sWyjBUXGA#%23"> AVPlayer 音视频缓存方案</a><br>2.<a href="https://www.jianshu.com/p/93ce1748ea57">VPlayer的缓存实现</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 音视频 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java常用技巧</title>
      <link href="/2019/09/15/Java%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/09/15/Java%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>这篇主要总结一下Java语法方面的技巧</p><span id="more"></span><h2 id="Pubilic-Class和Class"><a href="#Pubilic-Class和Class" class="headerlink" title="Pubilic Class和Class"></a>Pubilic Class和Class</h2><p>使用Pubilic class类名称声明一个类时，类名称必须和文件名称一致，否则程序将无法编译</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>每当使用Java命令执行一个类时，实际上都会启动一个JVM，每一个JVM实际上就是在操作系统中启动了一个进程，Java本身具备了垃圾收集机制，所以在Java运行时至少会启动两个线程，一个是main线程，另外一个是垃圾收集线程。</p><h2 id="Java有参构造方法和无参构造方法"><a href="#Java有参构造方法和无参构造方法" class="headerlink" title="Java有参构造方法和无参构造方法"></a>Java有参构造方法和无参构造方法</h2><ol><li>编写一个类时没有添加无参构造方法，那么编译器会自动添加无参构造方法；(如果自己添加构造函数，无论有参数或是没参数，默认构造函数都将无效)</li><li>编写时添加了有参构造方法而未添加无参构造方法，那么编译器只认有参构造方法而不会默认添加无参构造方法！<br>如果需要使用无参构造方法，一定要在类里面添加</li></ol><h2 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h2><img src="/2019/09/15/Java%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/objectlife.png" class=""><h2 id="String-StringBuffer-StringBuilder"><a href="#String-StringBuffer-StringBuilder" class="headerlink" title="String,StringBuffer,StringBuilder"></a>String,StringBuffer,StringBuilder</h2><ol><li>String是不可变的，String类是final修饰的，所以值是不变的（StirngBufer，StringBuilder可变）</li><li>String，StringBuffer是线程安全的，StringBuilder是线程不安全的（StringBuffer的append操作用了synchronized）</li><li>String对象串联的效率最慢，单线程下字符串的串联用StringBuilder，多线程下用StringBuffer</li></ol><h2 id="equals和hashCode"><a href="#equals和hashCode" class="headerlink" title="equals和hashCode"></a>equals和hashCode</h2><ol><li>如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；</li><li>如果两个对象的hashCode相同，它们并不一定相同。</li><li>当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</li></ol><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>volatile关键字的两层语义</p><ol><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序。</li></ol><p><strong>内存模型</strong><br>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p><p>如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p><p>为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p><ol><li>通过在总线加LOCK#锁的方式（在锁住总线期间，其他CPU无法访问内存，导致效率低下）</li><li>通过缓存一致性协议（Intel 的MESI协议）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该</span><br><span class="line">变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要</span><br><span class="line">读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读</span><br><span class="line">取。</span><br></pre></td></tr></table></figure><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）</p><ol><li>修饰类<br>　当用final修饰一个类时，表明这个类不能被继承。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</li><li>修饰方法<br>“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。“<br>　　因此，如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。<br>　　<code>注：类的private方法会隐式地被指定为final方法</code>。</li><li>修饰变量<br>　　修饰变量是final用得最多的地方<br>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li></ol><h2 id="Static关键字"><a href="#Static关键字" class="headerlink" title="Static关键字"></a>Static关键字</h2><ol><li>static方法<br>“static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。”</li></ol><p>一句话来描述就是：<strong>方便在没有创建对象的情况下来进行调用（方法&#x2F;变量）</strong>。</p><ol start="2"><li>static变量</li></ol><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。<br>　　static成员变量的初始化顺序按照定义的顺序进行初始化。</p><ol start="3"><li>static代码块</li></ol><p>在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p><h2 id="Extends-implements"><a href="#Extends-implements" class="headerlink" title="Extends implements"></a>Extends implements</h2><p>Extends可以理解为全盘继承了父类的功能。implements可以理解为为这个类附加一些额外的功能；interface定义一些方法,并没有实现,需要implements来实现才可用。extend可以继承一个接口,但仍是一个接口,也需要implements之后才可用。</p><p>对于class而言，Extends用于(单)继承一个类（class），而implements用于实现一个接口(interface)</p><p>Implements 接口实现<br>Implements是一个类实现一个接口用的关键字，它是用来实现接口中定义的抽象方法</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 语法基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java注解</title>
      <link href="/2019/09/13/Java%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/09/13/Java%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot框架里面用到了很多注解，发现不明所以，所以学习一下。</p><span id="more"></span><h2 id="注解简介"><a href="#注解简介" class="headerlink" title="注解简介"></a>注解简介</h2><p>出现注解之前，XML大行其道，以松耦合的方式完成了框架中几乎所有的配置，但是随着项目越来越大，xml的内容也越来越复杂，维护成本变高。</p><p>于是一种标记式高耦合的配置方式产生了，注解，可以作用于类，方法，属性，几乎需要配置的地方都可以进行注解。</p><p>xml和注解两种不同配置方式，各有优劣，<strong>追求低耦合就要抛弃高效率，追求效率必然会遇到耦合</strong></p><h2 id="注解的本质"><a href="#注解的本质" class="headerlink" title="注解的本质"></a>注解的本质</h2><blockquote><p>The common interface extended by all annotation types<br>所有的注解类型都继承自这个普通的接口（Annotation）</p></blockquote><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实本质上就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解的本质就是一个继承了 Annotation 接口的接口</strong>。</p><h2 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h2><p>一个注解准确意义上来说，只不过是一种特殊的注释而已，如果没有解析它的代码，它可能连注释都不如</p><p>解析一个类或者方法的注解往往有两种形式，一种是编译器直接的扫描，一种是运行期反射</p><h3 id="编译器注解"><a href="#编译器注解" class="headerlink" title="编译器注解"></a>编译器注解</h3><p>编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理，典型的就是注解 @Override。这一种情况只适用于那些编译器已经熟知的注解类，比如 JDK 内置的几个注解。</p><ol><li>@Override</li><li>@Deprecated</li><li>@SuppressWarnings</li></ol><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解是用于修饰注解的注解，通常用在注解的定义上,一般用于指定某个注解生命周期以及作用目标等信息</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JAVA 中有以下几个元注解：</p><ol><li>@Target：注解的作用目标</li><li>@Retention：注解的生命周期</li><li>@Documented：注解是否应当被包含在 JavaDoc 文档中</li><li>@Inherited：是否允许子类继承该注解</li></ol><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>@Target 的定义如下：</p><img src="/2019/09/13/Java%E6%B3%A8%E8%A7%A3/target.png" class=""><p>可以通过以下的方式来为这个 value 传值：<br><code>@Target(value = &#123;ElementType.FIELD&#125;)</code></p><p>ElementType 是一个枚举类型，有以下一些值：</p><ol><li>ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上</li><li>ElementType.FIELD：允许作用在属性字段上</li><li>ElementType.METHOD：允许作用在方法上</li><li>ElementType.PARAMETER：允许作用在方法参数上</li><li>ElementType.CONSTRUCTOR：允许作用在构造器上</li><li>ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上</li><li>ElementType.ANNOTATION_TYPE：允许作用在注解上</li><li>ElementType.PACKAGE：允许作用在包上</li></ol><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>用于指明当前注解的生命周期，它的基本定义如下：</p><img src="/2019/09/13/Java%E6%B3%A8%E8%A7%A3/retention.png" class=""><p>也有一个 value 属性：<br><code>@Retention(value = RetentionPolicy.RUNTIME</code><br> RetentionPolicy 依然是一个枚举类型，它有以下几个枚举值可取：</p><ol><li>RetentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件</li><li>RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件</li><li>RetentionPolicy.RUNTIME：永久保存，可以反射获取</li></ol><p>@Retention 注解指定了被修饰的注解的生命周期，一种是只能在编译期可见，编译后会被丢弃，一种会被编译器编译进 class 文件中，无论是类或是方法，乃至字段，他们都是有属性表的，而 JAVA 虚拟机也定义了几种注解属性表用于存储注解信息，但是这种可见性不能带到方法区，类加载时会予以丢弃，最后一种则是永久存在的可见性。</p><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>@Documented 注解修饰的注解，当我们执行 JavaDoc 文档打包时会被保存进 doc 文档，反之将在打包时丢弃。@Inherited 注解修饰的注解是具有可继承性的，也就说我们的注解修饰了一个类，而该类的子类将自动继承父类的该注解。</p><h3 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h3><p>从虚拟机的层面看看，注解的本质</p><p>自定义一个注解类型：</p><img src="/2019/09/13/Java%E6%B3%A8%E8%A7%A3/jvm.png" class=""><p>指定了 Hello 这个注解只能修饰字段和方法，并且该注解永久存活，以便我们反射获取。</p><p>虚拟机规范定义了一系列和注解相关的属性表，也就是说，无论是字段、方法或是类本身，如果被注解修饰了，就可以被写进字节码文件。</p><p>属性表有以下几种：</p><ol><li>RuntimeVisibleAnnotations：运行时可见的注解</li><li>RuntimeInVisibleAnnotations：运行时不可见的注解</li><li>RuntimeVisibleParameterAnnotations：运行时可见的方法参数注解</li><li>RuntimeInVisibleParameterAnnotations：运行时不可见的方法参数注解</li><li>AnnotationDefault：注解类元素的默认值</li></ol><p>对于一个类或者接口来说，Class 类中提供了以下一些方法用于反射注解</p><ol><li>getAnnotation：返回指定的注解</li><li>isAnnotationPresent：判定当前元素是否被指定注解修饰</li><li>getAnnotations：返回所有的注解</li><li>getDeclaredAnnotation：返回本元素的指定注解</li><li>getDeclaredAnnotations：返回本元素的所有注解，不包含父类继承而来的</li></ol><p>设置一个虚拟机启动参数，用于捕获 JDK 动态代理类。</p><blockquote><p>-Dsun.misc.ProxyGenerator.saveGeneratedFiles&#x3D;true</p></blockquote><p>然后 main 函数</p><img src="/2019/09/13/Java%E6%B3%A8%E8%A7%A3/main.png" class=""><p>注解本质上是继承了 Annotation 接口的接口，而当你通过反射，也就是我们这里的 getAnnotation 方法去获取一个注解类实例的时候，其实 JDK 是通过动态代理机制生成一个实现我们注解（接口）的代理类。<br>运行程序后，会看到输出目录里有这么一个代理类，反编译之后是这样的：</p><img src="/2019/09/13/Java%E6%B3%A8%E8%A7%A3/proxy.png" class=""><p>代理类实现接口 Hello 并重写其所有方法，包括 value 方法以及接口 Hello 从 Annotation 接口继承而来的方法。而这个关键的 InvocationHandler 实例是谁？<br>AnnotationInvocationHandler 是 JAVA 中专门用于处理注解的 Handler</p><img src="/2019/09/13/Java%E6%B3%A8%E8%A7%A3/handle01.png" class=""><p>这里有一个 memberValues，它是一个 Map 键值对，键是我们注解属性名称，值就是该属性当初被赋上的值。</p><img src="/2019/09/13/Java%E6%B3%A8%E8%A7%A3/handle02.png" class=""><img src="/2019/09/13/Java%E6%B3%A8%E8%A7%A3/handle03.png" class=""><p>而这个 invoke 方法就很有意思了，大家注意看，我们的代理类代理了 Hello 接口中所有的方法，所以对于代理类中任何方法的调用都会被转到这里来。</p><p>var2 指向被调用的方法实例，而这里首先用变量 var4 获取该方法的简明名称，接着 switch 结构判断当前的调用方法是谁，如果是 Annotation 中的四大方法，将 var7 赋上特定的值。<br>如果当前调用的方法是 toString，equals，hashCode，annotationType 的话，AnnotationInvocationHandler 实例中已经预定义好了这些方法的实现，直接调用即可。<br>那么假如 var7 没有匹配上这四种方法，说明当前的方法调用的是自定义注解字节声明的方法，例如我们 Hello 注解的 value 方法。这种情况下，将从我们的注解 map 中获取这个注解属性对应的值。</p><p>反射注解的工作原理:</p><ol><li>通过键值对的形式为注解属性赋值，像这样：@Hello（value &#x3D; “hello”）。</li><li>用注解修饰某个元素，编译器将在编译期扫描每个类或者方法上的注解，会做一个基本的检查，你的这个注解是否允许作用在当前位置，最后会将注解信息写入元素的属性表。</li><li>当进行反射的时候，虚拟机将所有生命周期在 RUNTIME 的注解取出来放到一个 map 中，并创建一个 AnnotationInvocationHandler 实例，把这个 map 传递给它。</li><li>最后，虚拟机将采用 JDK 动态代理机制生成一个目标注解的代理类，并初始化好处理器。这样，一个注解的实例就创建出来了，它本质上就是一个代理类，你应当去理解好 AnnotationInvocationHandler 中 invoke 方法的实现逻辑，这是核心。一句话概括就是，<strong>通过方法名返回注解属性值</strong>。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://juejin.im/post/5b45bd715188251b3a1db54f">JAVA 注解的基本原理</a></li><li><a href="https://www.jianshu.com/p/a08e7e9ed765">Java自定义注解</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 语法基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS图标版本化</title>
      <link href="/2019/09/04/iOS%E5%9B%BE%E6%A0%87%E7%89%88%E6%9C%AC%E5%8C%96/"/>
      <url>/2019/09/04/iOS%E5%9B%BE%E6%A0%87%E7%89%88%E6%9C%AC%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>通常一个App会有多个版本，企业版，调试版等，不同版本下也会有debug，release之分，有时候需要知道测试所测的版本是否是最新的，虽然可以在App内部添加版本信息进去，但是试想一下如果直接在ICON上添加这些信息是不是更显而易见。</p><span id="more"></span><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 1. 判断执行 Build 的机器是否安装了 ImageMagic</span><br><span class="line">//    |- 如果没有安装：提示安装，退出脚本</span><br><span class="line">//    |- 如果安装：继续执行</span><br><span class="line">// 2. 获取 commit 号 <span class="built_in">hash</span> 值、分支名、build 号，并将其拼接成一个字符串</span><br><span class="line">// 3. 判断编译环境</span><br><span class="line">//    |- 如果是 Release 环境：提示当前是 Release 环境，退出脚本</span><br><span class="line">//    |- 如果是非 Release 环境：继续执行</span><br><span class="line">// 4. 获取 Plist 中 CFBundleIconFiles 的数量</span><br><span class="line">// 5. 根据数量循环，执行调用『生成记号图方法』</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 『生成记号图方法』 </span><br><span class="line">// <span class="keyword">function</span> <span class="function"><span class="title">generateIcon</span></span>() &#123;</span><br><span class="line">// 1. 模糊图片</span><br><span class="line">// 2. 截取图片下半部分</span><br><span class="line">// 3. 添加 commit+brach+build 组成的字符串在截取图片上</span><br><span class="line">// 4. 合成截取图片和原图</span><br><span class="line">// 5. 清除多余图片</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><h4 id="ImageMagick"><a href="#ImageMagick" class="headerlink" title="ImageMagick"></a>ImageMagick</h4><blockquote><p>ImageMagick 可以创建、编辑、合成或转换图片。它可以读和写各种格式的图像（超过 200 种格式）包括 PNG、JPEG、JPEG - 2000、GIF、TIFF、DPX、EXR、WebP、Postscript、PDF、SVG。ImageMagick 可以调整、翻转、镜像、旋转、扭曲、剪切和转换图像、图像色彩调整，适用于各种特殊效果,或绘制文本、线、多边形、椭圆和贝塞尔曲线。</p></blockquote><h4 id="安装-建议翻墙"><a href="#安装-建议翻墙" class="headerlink" title="安装(建议翻墙)"></a>安装(建议翻墙)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br><span class="line"></span><br><span class="line">brew install ImageMagick</span><br><span class="line"></span><br><span class="line">brew install ghostscript</span><br></pre></td></tr></table></figure><h4 id="常用用法："><a href="#常用用法：" class="headerlink" title="常用用法："></a>常用用法：</h4><ol><li>查看图片信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">identify original.png </span><br><span class="line">original.png PNG 120x120 120x120+0+0 8-bit sRGB 46c 2.58KB 0.010u 0:00.000</span><br></pre></td></tr></table></figure><ol start="2"><li>合并图像<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给图片添加水印</span></span><br><span class="line">convert original.png -compose over watermark.png -composite new-image.png</span><br></pre></td></tr></table></figure></li><li>高斯模糊<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">convert -blur 80x5 original.jpg blur.png</span><br><span class="line">-blur radiusxsigma，两个分别是高斯模糊需要的两个参数</span><br></pre></td></tr></table></figure></li></ol><h3 id="存在的问题-unhandled-critical-chunk"><a href="#存在的问题-unhandled-critical-chunk" class="headerlink" title="存在的问题  unhandled critical chunk"></a>存在的问题  unhandled critical chunk</h3><p>error: CgBI: unhandled critical chunk <a href="mailto:&#x41;&#x70;&#112;&#x49;&#x63;&#x6f;&#110;&#50;&#48;&#120;&#x32;&#x30;&#x40;&#x32;&#120;&#x2e;&#112;&#110;&#x67;">&#x41;&#x70;&#112;&#x49;&#x63;&#x6f;&#110;&#50;&#48;&#120;&#x32;&#x30;&#x40;&#x32;&#120;&#x2e;&#112;&#110;&#x67;</a></p><h4 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h4><p>在 Xcode 7.3以后,在 Xcode build 项目时,默认会把 png 压缩 和 修改.然后得到新的png图片,ImageMagick 在修改是会遇到上述的问题.<a href="https://stackoverflow.com/questions/36595799/libpng-error-cgbi-unhandled-critical-chunk-xcode-7-3">stackoverflow</a></p><h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>build settting里面设置Compress PNG FIles debug模式下为NO（注意只有项目路径下存在png图片资源时build setting才会有该选项）</p><h3 id="存在的问题-ICON未发生更改"><a href="#存在的问题-ICON未发生更改" class="headerlink" title="存在的问题 ICON未发生更改"></a>存在的问题 ICON未发生更改</h3><p>项目路径下的ICON已经更改，但是没有显示</p><h4 id="分析原因-1"><a href="#分析原因-1" class="headerlink" title="分析原因"></a>分析原因</h4><p>使用 Xcode9 构建 iOS11 系统的 App 图标，默认读取资源文件，而非App包的Icon图标，导致不显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Xcode管理app的icon，通过asset资源目录。</span><br><span class="line">Xcode还包含app的icon文件和Info.plist，是为了向后兼容。</span><br><span class="line">该脚本替换了app根目录中的文件，而不是asset资源目录，在iOS11中使用asset资源目录，而不是app根目录中的文件。</span><br></pre></td></tr></table></figure><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>通过生成独立的 AppIcon_Debug资源文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.对AppIcon.appiconset文件的每一图标。</span><br><span class="line">2.添加模糊效果，版本信息，提交信息。</span><br><span class="line">3.将处理好的图标，复制到AppIcon_Debug.appiconset文件。</span><br><span class="line">4.Xcode中配置使用AppIcon_Debug图标资源文件。</span><br><span class="line">5.删除无用的构建生成的图标。</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="http://zhoulingyu.com/2017/04/04/iOS%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%9A%84%E8%84%9A%E6%9C%AC/#more">iOS—写一个快速定位问题的脚本</a></li><li><a href="https://www.jianshu.com/p/93b6a3087f04">iOS App图标版本化</a></li><li><a href="https://www.jianshu.com/p/a37e114b7e66">iOS APP图标版本化</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> UI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS离屏渲染</title>
      <link href="/2019/07/31/iOS%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"/>
      <url>/2019/07/31/iOS%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<p>离屏渲染是在哪一步进行的？为什么？<br>设置cornerRadius一定会触发离屏渲染吗？</p><span id="more"></span><p>iOS渲染在Application这一层中主要是CPU在操作，而到了<code>Render Server</code>这一层，CoreAnimation会将具体操作转换成发送给GPU的draw calls（以前是call OpenGL ES，现在慢慢转到了Metal），<br>显然CPU和GPU双方同处于一个流水线中，协作完成整个渲染工作</p><h2 id="离屏渲染的定义"><a href="#离屏渲染的定义" class="headerlink" title="离屏渲染的定义"></a>离屏渲染的定义</h2><p>如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的<code>frame buffer</code>，作为像素数据存储区域，而这也是GPU存储渲染结果的地方。</p><p>如果有时因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。</p><img src="/2019/07/31/iOS%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/v2-c448aaebe3cf19e37101ce16a799cdd2_1440w.png" class=""><p>渲染结果先经过了离屏buffer，再到frame buffer</p><h3 id="CPU”离屏渲染“"><a href="#CPU”离屏渲染“" class="headerlink" title="CPU”离屏渲染“"></a>CPU”离屏渲染“</h3><p>如果我们在UIView中实现了<code>drawRect</code>方法，就算它的函数体内部实际没有代码，系统也会为这个view申请一块内存区域，等待CoreGraphics可能的绘画操作。</p><p>根据苹果工程师的说法，CPU渲染并非真正意义上的离屏渲染。另一个证据是，如果你的<code>view</code>实现了<code>drawRect</code>，此时打开Xcode调试的“Color offscreen rendered yellow”开关，你会发现这片区域不会被标记为黄色，说明Xcode并不认为这属于离屏渲染。</p><p>通过CPU渲染就是俗称的“<code>软件渲染</code>”，而真正的离屏渲染发生在GPU</p><h3 id="GPU离屏渲染"><a href="#GPU离屏渲染" class="headerlink" title="GPU离屏渲染"></a>GPU离屏渲染</h3><p>主要的渲染操作都是由CoreAnimation的<code>Render Server</code>模块，通过调用显卡驱动所提供的<code>OpenGL/Metal</code>接口来执行的。<br>通常对于每一层layer，Render Server会遵循“<code>画家算法</code>”，按次序输出到<code>frame buffer</code>，后一层覆盖前一层，就能得到最终的显示结果（值得一提的是，与一般桌面架构不同，<code>在iOS中，设备主存和GPU的显存共享物理内存</code>，这样可以省去一些数据传输开销）</p><img src="/2019/07/31/iOS%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/v2-24394bcd0b84005553320df018e06999_1440w.png" class=""><p>”画家算法“，把每一层依次输出到画布</p><p>然而有些场景并没有那么简单。作为“画家”的GPU虽然可以一层一层往画布上进行输出，但是无法在某一层渲染完成之后，再回过头来擦除&#x2F;改变其中的某个部分——因为在这一层之前的若干层layer像素数据，已经在渲染中被永久覆盖了。这就意味着，对于每一层layer，要么能<code>找到一种通过单次遍历就能完成渲染的算法</code>，要么就不得不<code>另开一块内存，借助这个临时中转区域来完成一些更复杂的、多次的修改/剪裁操作</code>。</p><ul><li>绘制一个带有圆角并剪切圆角以外内容的容器</li></ul><ol><li><p>将一个layer的内容裁剪成圆角，可能不存在一次遍历就能完成的方法</p></li><li><p>容器的子layer因为父容器有圆角，那么也会需要被裁剪，而这时它们还在渲染队列中排队，尚未被组合到一块画布上，自然也无法统一裁剪</p></li></ol><p>此时我们就不得不开辟一块独立于<code>frame buffer</code>的空白内存，先把容器以及其所有子layer依次画好，然后把四个角“剪”成圆形，再把结果画到frame buffer中。这就是GPU的离屏渲染。</p><h4 id="常见触发离屏渲染的操作"><a href="#常见触发离屏渲染的操作" class="headerlink" title="常见触发离屏渲染的操作"></a>常见触发离屏渲染的操作</h4><ul><li><p>cornerRadius+clipsToBounds</p></li><li><p>shadow</p></li></ul><p>阴影默认是作用在其中”非透明区域“的，而且需要显示在所有layer内容的下方，因此根据画家算法必须被渲染在先。但矛盾在于此时阴影的本体（layer和其子layer）都还没有被组合到一起，怎么可能在第一步就画出只有完成最后一步之后才能知道的形状呢？这样一来又只能另外申请一块内存，把本体内容都先画好，再根据渲染结果的形状，添加阴影到frame buffer，最后把内容画上去（这只是我的猜测，实际情况可能更复杂）。不过如果我们能够预先告诉CoreAnimation（通过shadowPath属性）阴影的几何形状，那么阴影当然可以先被独立渲染出来，不需要依赖layer本体，也就不再需要离屏渲染了。</p><ul><li>group opacity</li></ul><p>alpha并不是分别应用在每一层之上，而是只有到整个layer树画完之后，再统一加上alpha，最后和底下其他layer的像素进行组合。显然也无法通过一次遍历就得到最终结果。</p><ul><li>mask</li></ul><p>mask是应用在layer和其所有子layer的组合之上的，而且可能带有透明度，那么其实和group opacity的原理类似，不得不在离屏渲染中完成。</p><ul><li>UIBlurEffect</li></ul><p>总结：</p><blockquote><p>原理也都是类似：如果你无法仅仅使用frame buffer来画出最终结果，那就只能另开一块内存空间来储存中间结果。</p></blockquote><h2 id="离屏渲染的性能影响"><a href="#离屏渲染的性能影响" class="headerlink" title="离屏渲染的性能影响"></a>离屏渲染的性能影响</h2><p>GPU的操作是<code>高度流水线化</code>的。本来所有计算工作都在有条不紊地正在向frame buffer输出，此时突然收到指令，需要输出到另一块内存，那么流水线中正在进行的一切都不得不被丢弃，切换到只能服务于我们当前的“切圆角”操作。等到完成以后再次清空，再回到向frame buffer输出的正常流程。</p><p>在tableView或者collectionView中，滚动的每一帧变化都会触发每个cell的重新绘制，因此一旦存在离屏渲染，上面提到的上下文切换就会每秒发生60次，并且很可能每一帧有几十张的图片要求这么做，对于GPU的性能冲击可想而知（GPU非常擅长大规模并行计算，但是我想频繁的上下文切换显然不在其设计考量之中）</p><h3 id="什么时候使用离屏渲染？"><a href="#什么时候使用离屏渲染？" class="headerlink" title="什么时候使用离屏渲染？"></a>什么时候使用离屏渲染？</h3><p>把结果缓存下来，那么下一帧渲染就可以复用这个成果，不需要再重新画一遍了</p><p>CALayer为这个方案提供了对应的解法：<code>shouldRasterize</code>。一旦被设置为true，Render Server就会强制把layer的渲染结果（包括其子layer，以及圆角、阴影、group opacity等等）保存在一块内存中，这样一来在下一帧仍然可以被复用，而不会再次触发离屏渲染。</p><ul><li>注意：</li></ul><ol><li><code>shouldRasterize</code>的主旨在于降低性能损失，但总是<code>至少会触发一次离屏渲染</code>。如果你的layer本来并不复杂，也没有圆角阴影等等，打开这个开关反而会增加一次不必要的离屏渲染</li><li><code>离屏渲染缓存有空间上限，最多不超过屏幕总像素的2.5倍大小</code></li><li>一旦缓存超过100ms没有被使用，会自动被丢弃</li><li>layer的内容（包括子layer）必须是静态的，因为一旦发生变化（如resize，动画），之前辛苦处理得到的缓存就失效了。如果这件事频繁发生，我们就又回到了“每一帧都需要离屏渲染”的情景，而这正是开发者需要极力避免的。针对这种情况，Xcode提供了“Color Hits Green and Misses Red”的选项，帮助我们查看缓存的使用是否符合预期</li><li>其实除了解决多次离屏渲染的开销，<code>shouldRasterize</code>在另一个场景中也可以使用：如果layer的子结构非常复杂，渲染一次所需时间较长，同样可以打开这个开关，把layer绘制到一块缓存，然后在接下来复用这个结果，这样就不需要每次都重新绘制整个layer树了</li></ol><h3 id="什么时候需要CPU渲染"><a href="#什么时候需要CPU渲染" class="headerlink" title="什么时候需要CPU渲染"></a>什么时候需要CPU渲染</h3><p>渲染性能的调优，其实始终是在做一件事：<code>平衡CPU和GPU的负载，让他们尽量做各自最擅长的工作</code>。</p><p>绝大多数情况下，得益于GPU针对图形处理的优化，我们都会倾向于<code>让GPU来完成渲染任务</code>，而<code>给CPU留出足够时间处理各种各样复杂的App逻辑</code>。为此Core Animation做了大量的工作，尽量把渲染工作转换成适合GPU处理的形式（也就是所谓的硬件加速，如layer composition，设置backgroundColor等等）。</p><p>但是对于一些情况，如<code>文字（CoreText使用CoreGraphics渲染）</code>和<code>图片（ImageIO）渲染</code>，由于<code>GPU并不擅长做这些工作，不得不先由CPU来处理好以后，再把结果作为texture传给GPU</code>。除此以外，有时候也会遇到GPU实在忙不过来的情况，而CPU相对空闲（GPU瓶颈），这时可以让CPU分担一部分工作，提高整体效率。</p><img src="/2019/07/31/iOS%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/v2-2f45a2d49c0a4bb97ed975054f0534b5_1440w.jpg" class=""><p>Core Text基于Core Graphics</p><p>eg：<br>使用CoreGraphics给图片加上圆角（将图片中圆角以外的部分渲染成透明）。整个过程全部是由CPU完成的。这样一来既然我们已经得到了想要的效果，就不需要再另外给图片容器设置cornerRadius。另一个好处是，我们可以灵活地控制裁剪和缓存的时机，巧妙避开CPU和GPU最繁忙的时段，达到平滑性能波动的目的</p><ul><li>注意</li></ul><ol><li>渲染不是CPU的强项，调用<code>CoreGraphics</code>会消耗其相当一部分计算时间，并且我们也不愿意因此阻塞用户操作，因此一般来说CPU渲染都在后台线程完成（这也是<code>AsyncDisplayKit</code>的主要思想），然后再回到主线程上，把渲染结果传回CoreAnimation。这样一来，多线程间数据同步会增加一定的复杂度</li><li>同样因为CPU渲染速度不够快，因此<code>只适合渲染静态的元素，如文字、图片</code>（想象一下没有硬件加速的视频解码，性能惨不忍睹）</li><li>作为渲染结果的bitmap数据量较大（形式上一般为解码后的UIImage），消耗内存较多，所以应该在使用完及时释放，并在需要的时候重新生成，否则很容易导致OOM</li><li>如果你选择使用CPU来做渲染，那么就没有理由再触发GPU的离屏渲染了，否则会同时存在两块内容相同的内存，而且CPU和GPU都会比较辛苦</li><li>一定要使用Instruments的不同工具来测试性能，而不是仅凭猜测来做决定</li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li>大量应用<code>AsyncDisplayKit</code>(Texture)作为主要渲染框架，对于文字和图片的异步渲染操作交由框架来处理。关于这方面可以看我之前的一些介绍</li><li>对于图片的圆角，统一采用“precomposite”的策略，也就是不经由容器来做剪切，而是预先使用CoreGraphics为图片裁剪圆角</li><li>对于视频的圆角，由于实时剪切非常消耗性能，我们会创建四个白色弧形的layer盖住四个角，从视觉上制造圆角的效果</li><li>对于view的圆形边框，如果没有backgroundColor，可以放心使用cornerRadius来做</li><li>对于所有的阴影，使用shadowPath来规避离屏渲染</li><li>对于特殊形状的view，使用layer mask并打开<code>shouldRasterize</code>来对渲染结果进行缓存</li><li>对于模糊效果，不采用系统提供的UIVisualEffect，而是另外实现模糊效果（CIGaussianBlur），并手动管理渲染结果</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/72653360">关于iOS离屏渲染的深入研究</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> UI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RunLoop应用</title>
      <link href="/2019/07/29/RunLoop%E5%BA%94%E7%94%A8/"/>
      <url>/2019/07/29/RunLoop%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>线程创建需要的内存和时间消耗都比较大，建立一个Run Loops允许进行经常性的工作，<br>Run Loops可以让你使用最小的资源来创建长时间运行线程。因为run loop在没有任何事件处理的时候会把它的线程置于休眠状态，它消除了消耗CPU周期轮询，并防止处理器本身进入休眠状态并节省电源。</p><span id="more"></span><h2 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h2><p>App启动后，苹果在主线程RunLoop里注册了两个Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p><p>第一个Observer监视的事件是Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池（向当前AutoreleasePoolPage增加一个边界对象标志，每一次push都会加入一个边界对象，从边界对象往后加入对象a，b，c；）其 order是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p><p>第二个Observer监视了两个事件：<br> BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池（根据情况从最新加入的对象一直往前清理直到遇到边界对象）并创建新池；<br> Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><h2 id="图片延迟显示-PerformSelector"><a href="#图片延迟显示-PerformSelector" class="headerlink" title="图片延迟显示 PerformSelector"></a>图片延迟显示 PerformSelector</h2><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p><p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PerformSelector:afterDelay:这个方法在子线程中是否起作用？为什么？怎么解决？</span><br><span class="line">不起作用，子线程默认没有 Runloop，也就没有 Timer。</span><br><span class="line"></span><br><span class="line">解决的办法是可以使用 GCD 来实现：Dispatch_after</span><br></pre></td></tr></table></figure><p>一般在滑动UITableView时，cell中的图片显示方法会这样写</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.imgView performSelector:<span class="keyword">@selector</span>(setImage:) withObject:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;123&quot;</span>] afterDelay:<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>为什么要这样写？其实答案很简单，换个写法大家就明白了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.imgView performSelector:<span class="keyword">@selector</span>(setImage:) withObject:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;123&quot;</span>] afterDelay:<span class="number">0</span> inModes:@[<span class="built_in">NSDefaultRunLoopMode</span>]];</span><br></pre></td></tr></table></figure><p>显示图片的方法指定了NSDefaultRunLoopMode，滑动界面的时候处于UITrackingRunLoopMode，滑动的时候，无论图片多大，都不会显示，这样可以保证tableview的流畅，直到滑动结束，mode变回NSDefaultRunLoopMode，再执行显示图片的方法</p><h2 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h2><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p><p>当一个硬件事件(触摸&#x2F;锁屏&#x2F;摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏&#x2F;静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p><p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture&#x2F;处理屏幕旋转&#x2F;发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin&#x2F;Move&#x2F;End&#x2F;Cancel 事件都是在这个回调中完成的。</p><h2 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h2><p>当上面的 _UIApplicationHandleEventQueue()识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin&#x2F;Move&#x2F;End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p><p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer 的回调。</p><p>当有 UIGestureRecognizer 的变化(创建&#x2F;销毁&#x2F;状态改变)时，这个回调都会进行相应处理。</p><h2 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h2><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView&#x2F;CALayer 的层次时，或者手动调用了 UIView&#x2F;CALayer 的 setNeedsLayout&#x2F;setNeedsDisplay方法后，这个 UIView&#x2F;CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：</p><p>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView&#x2F;CAlayer 以执行实际的绘制和调整，并更新 UI 界面</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [<span class="built_in">CALayer</span> layoutSublayers];</span><br><span class="line">                            [<span class="built_in">UIView</span> layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [<span class="built_in">CALayer</span> display];</span><br><span class="line">                            [<span class="built_in">UIView</span> drawRect];</span><br></pre></td></tr></table></figure><h2 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h2><p>在RunLoop的源代码中可以看到用到了GCD的相关内容，但是RunLoop本身和GCD并没有直接的关系，当调用 <code>dispatch_async(dispatch_get_main_queue(), &lt;#^(void)block#&gt;)</code> 时，libDispatch 会向主线程的 RunLoop 发送消息唤醒RunLoop，RunLoop从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p><h2 id="AFNetworking中运用Runloop"><a href="#AFNetworking中运用Runloop" class="headerlink" title="AFNetworking中运用Runloop"></a>AFNetworking中运用Runloop</h2><p>AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)networkRequestThreadEntryPoint:(<span class="type">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@&quot;AFNetworking&quot;</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RunLoop 启动前内部必须要有至少一个 Timer&#x2F;Observer&#x2F;Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)start &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p><h2 id="FDTemplateLayoutCell利用RunLoop空闲时间执行预缓存任务"><a href="#FDTemplateLayoutCell利用RunLoop空闲时间执行预缓存任务" class="headerlink" title="FDTemplateLayoutCell利用RunLoop空闲时间执行预缓存任务"></a>FDTemplateLayoutCell利用RunLoop空闲时间执行预缓存任务</h2><p>FDTemplateLayoutCell 的高度预缓存是一个优化功能，它要求页面处于空闲状态时才执行计算，当用户正在滑动列表时显然不应该执行计算任务影响滑动体验。</p><h3 id="空闲mode"><a href="#空闲mode" class="headerlink" title="空闲mode"></a>空闲mode</h3><p>当 UI 没在滑动时，默认的 Mode 是 NSDefaultRunLoopMode（同 CF 中的 kCFRunLoopDefaultMode），同时也是 CF 中定义的 “空闲状态 Mode”。当用户啥也不点，此时也没有什么网络 IO 时，就是在这个 Mode 下。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line"><span class="built_in">CFStringRef</span> runLoopMode = kCFRunLoopDefaultMode;</span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span></span><br><span class="line">(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, <span class="literal">true</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> _) &#123;</span><br><span class="line">    <span class="comment">// TODO here</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(runLoop, observer, runLoopMode);</span><br></pre></td></tr></table></figure><h3 id="分解多个RunLoop-Source任务"><a href="#分解多个RunLoop-Source任务" class="headerlink" title="分解多个RunLoop Source任务"></a>分解多个RunLoop Source任务</h3><p>假设列表有 20 个 cell，加载后展示了前 5 个，那么开启估算后 table view 只计算了这 5 个的高度，此时剩下 15 个就是“预缓存”的任务，而我们并不希望这 15 个计算任务在同一个 RunLoop 迭代中同步执行，这样会卡顿 UI，所以应该把它们分别分解到 15 个 RunLoop 迭代中执行，这时就需要手动向 RunLoop 中添加 Source 任务</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *mutableIndexPathsToBePrecached = <span class="keyword">self</span>.fd_allIndexPathsToBePrecached.mutableCopy;</span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, <span class="literal">true</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> _) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mutableIndexPathsToBePrecached.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopRemoveObserver</span>(runLoop, observer, runLoopMode);</span><br><span class="line">        <span class="built_in">CFRelease</span>(observer); <span class="comment">// 注意释放，否则会造成内存泄露</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSIndexPath</span> *indexPath = mutableIndexPathsToBePrecached.firstObject;</span><br><span class="line">    [mutableIndexPathsToBePrecached removeObject:indexPath];</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(fd_precacheIndexPathIfNeeded:)</span><br><span class="line">                 onThread:[<span class="built_in">NSThread</span> mainThread]</span><br><span class="line">               withObject:indexPath</span><br><span class="line">            waitUntilDone:<span class="literal">NO</span></span><br><span class="line">                    modes:@[<span class="built_in">NSDefaultRunLoopMode</span>]];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/">优化UITableViewCell高度计算的那些事</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> RunLoop </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS本地数据存储</title>
      <link href="/2019/07/29/iOS%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
      <url>/2019/07/29/iOS%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>据存储本质就是运行时的对象保存在文件、数据库中。数据存储可以分为两步：首先是将对象转换成二进制数据，这一步也叫序列化；相反，将二进制数据转换成对象则称为反序列化；然后是考虑二进制数据如何保存和读取。</p><span id="more"></span><h2 id="沙盒目录"><a href="#沙盒目录" class="headerlink" title="沙盒目录"></a>沙盒目录</h2><p>iOS系统为每个App分配了独立的数据目录，App只能对自己的目录进行操作，这个目录所在被称为沙盒目录。<br>一个应用的沙盒包括下面三个部分：应用目录、沙盒目录、iCloud目录。</p><img src="/2019/07/29/iOS%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/image01.png" class=""><p>Documents目录用于保存App的数据，包括App运行时需要的各类文件以及用户的数据等。Documents文件夹可以在连接iTunes时选择备份，通常Documents目录用来存放可以对外的文件。</p><p>Library目录用来保存不对外的数据，但同样可以被iTunes备份（Library&#x2F;Caches目录除外，原因就和目录名一样，里面应该只放Caches）。Library&#x2F;Caches目录用来放置运行时产生的临时文件以及缓存文件，空间不足时可能会被iOS系统删除。Library&#x2F;Preferences目录通常用于保存用户的设置等信息，比如我们常用的<strong>NSUserDefaults类就会以plist的方式保存在该目录中</strong>。</p><p>tmp目录用来保存不重要的临时文件，在系统重启后会被清空，容易知道这个也不会被iTunes备份。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取沙盒根目录路径</span></span><br><span class="line"><span class="built_in">NSString</span> *homeDir = <span class="built_in">NSHomeDirectory</span>();</span><br><span class="line"><span class="comment">// 获取Documents目录路径</span></span><br><span class="line"><span class="built_in">NSString</span> *docDir = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>,<span class="built_in">NSUserDomainMask</span>,<span class="literal">YES</span>) firstObject];</span><br><span class="line"><span class="comment">//获取Library的目录路径</span></span><br><span class="line"><span class="built_in">NSString</span> *libDir = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSLibraryDirectory</span>,<span class="built_in">NSUserDomainMask</span>,<span class="literal">YES</span>) lastObject];</span><br><span class="line"><span class="comment">// 获取cache目录路径</span></span><br><span class="line"><span class="built_in">NSString</span> *cachesDir = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>,<span class="built_in">NSUserDomainMask</span>,<span class="literal">YES</span>) firstObject];</span><br><span class="line"><span class="comment">// 获取tmp目录路径</span></span><br><span class="line"><span class="built_in">NSString</span> *tmpDir =<span class="built_in">NSTemporaryDirectory</span>();</span><br></pre></td></tr></table></figure><p><strong>我们工程中的图片资源是不是放在沙盒目录中呢？</strong><br>工程中的资源文件在NSBundle，而NSBundle会被打包到.ipa文件上传到App Store，而用户安装App时候，会把App放置在应用目录（非沙盒目录）。</p><h2 id="NSBundle"><a href="#NSBundle" class="headerlink" title="NSBundle"></a>NSBundle</h2><p>在用NSFileManager去读取文件的时候需要提供文件路径，但是有时候我们并不知道资源被放置在哪个<strong>目录</strong>，此时可以用到NSBundle。</p><p><strong>在Xcode编译运行的时候，会把Xcode内的图片、xib、音频等都拷贝到.app文件中。<br>NSBundle就是系统提供，用来读取这些资源的类</strong></p><p><code>NSBundle * mainBundle = [NSBundle mainBundle];</code><br>这样我们就拿到我们的mainBundle，通过mainBundle我们可以查找对应的资源：<br>NSString *path &#x3D;[mainBundle pathForImageResource:@”some_pic_name”]; &#x2F;&#x2F; 查找图片地<br>也可以通过mainBundle直接加载xib：<br><code>[[NSBundle mainBundle] loadNibNamed:@&quot;SSProgressView&quot; owner:self options:nil];</code></p><p><strong>通过CocoaPods安装的Pod库，要如何读取其资源？</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@&quot;SSTestPod&quot;</span> ofType:<span class="string">@&quot;bundle&quot;</span>];</span><br><span class="line"><span class="built_in">NSBundle</span> *podBundle = [<span class="built_in">NSBundle</span> bundleWithPath:path];</span><br></pre></td></tr></table></figure><h2 id="Keychain"><a href="#Keychain" class="headerlink" title="Keychain"></a>Keychain</h2><p>保存在沙盒目录的数据是不安全的，用户可能会导出沙盒数据进行分析。<br>有没有什么保存方式是更安全的呢？<br>iOS给出的答案是keychain。</p><p><strong>keychain是iOS提供给App存储敏感和安全相关数据用的工具。</strong>keychain同样会被iTunes备份，即使App重装仍能读取到上次保存的结果。为了保证数据安全，keychain内的数据都是经过加密。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &lt;Security/Security.h&gt;</span><br><span class="line"><span class="comment">// SELECT</span></span><br><span class="line">OSStatus SecItemCopyMatching(<span class="built_in">CFDictionaryRef</span> query, <span class="built_in">CFTypeRef</span> *result);</span><br><span class="line"><span class="comment">// ADD</span></span><br><span class="line">OSStatus SecItemAdd(<span class="built_in">CFDictionaryRef</span> attributes, <span class="built_in">CFTypeRef</span> *result);</span><br><span class="line"><span class="comment">// UPDATE</span></span><br><span class="line">OSStatus SecItemUpdate(<span class="built_in">CFDictionaryRef</span> query, <span class="built_in">CFDictionaryRef</span> attributesToUpdate);</span><br><span class="line"><span class="comment">// DELETE</span></span><br><span class="line">OSStatus SecItemDelete(<span class="built_in">CFDictionaryRef</span> query);</span><br></pre></td></tr></table></figure><p>以<a href="https://github.com/jizhidexia/KeychainWrapper">KeychainWrapper</a>为例，来看看封装后更简单的接口。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)savePassword:(<span class="built_in">NSString</span> *)password;</span><br><span class="line">- (<span class="type">BOOL</span>)deleteItem;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)readPassword;</span><br><span class="line"><span class="comment">//返回当前accessGroup下的service的所有Keychain Item</span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)passwordItemsForService:(<span class="built_in">NSString</span> *)service accessGroup:(<span class="built_in">NSString</span> *)accessGroup;</span><br></pre></td></tr></table></figure><p>具体的使用样例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KeychainWrapper *wrapper = [[KeychainWrapper alloc] initWithSevice:kKeychainService account:<span class="keyword">self</span>.account accessGroup:kKeychainAccessGroup];</span><br><span class="line"><span class="built_in">NSString</span> *saveStr = [wrapper readPassword];</span><br><span class="line"><span class="keyword">if</span> (!saveStr) &#123;</span><br><span class="line">    [wrapper savePassword:<span class="string">@&quot;test_password&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;saveStr:%@&quot;</span>, saveStr);</span><br></pre></td></tr></table></figure><p>要保存在keychain，即使应用卸载重装，仍旧能读取到该值。</p><h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><p><strong>NSCoding</strong>是系统提供的序列化协议，在对象转换为二进制的时候，会通过NSCoding的方法回调开发者。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSCoding</span></span></span><br><span class="line">- (<span class="type">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder; <span class="comment">// NS_DESIGNATED_INITIALIZER</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SSUser</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> gender;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *userName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">self</span>.gender = [[aDecoder decodeObjectForKey:<span class="string">@&quot;gender&quot;</span>] integerValue];</span><br><span class="line">    <span class="keyword">self</span>.userName = [aDecoder decodeObjectForKey:<span class="string">@&quot;userName&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder &#123;</span><br><span class="line">    [aCoder encodeObject:@(<span class="keyword">self</span>.gender) forKey:<span class="string">@&quot;gender&quot;</span>];</span><br><span class="line">    [aCoder encodeObject:<span class="keyword">self</span>.userName forKey:<span class="string">@&quot;userName&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><strong>YYModel</strong>具有几大特点：<br>1、利用iOS的Runtime特点，无需继承；<br>2、安全转换数据类型，常见Crash都进行了保护；<br>3、扩展性强，提供多种容器扩展；</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Objective-C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS渲染流程</title>
      <link href="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>app中一个视图从点击屏幕（硬件）到完全渲染，中间发生了什么？</li><li>在一个表内有很多cell,每个cell上有很多个视图,如何解决卡顿问题？</li><li>UIView与CALayer的区别？</li></ol><span id="more"></span><h2 id="CPU-GPU"><a href="#CPU-GPU" class="headerlink" title="CPU GPU"></a>CPU GPU</h2><blockquote><p>CPU（Central Processing Unit）：作为整个系统的运算和控制单元。CPU 内部的流水线结构使其拥有一定程度的并行计算能力。</p></blockquote><p>GPU（Graphics Processing Unit）：一种可进行绘图运算工作的专用微处理器。GPU 能够生成 2D&#x2F;3D 的图形图像和视频，从而能够支持基于窗口的操作系统、图形用户界面、视频游戏、可视化图像应用和视频播放。GPU 具有非常强的并行计算能力。</p><p><em>使用 GPU 渲染图形的根本原因就是：速度。GPU 的并行计算能力使其能够快速将图形结果计算出来并在屏幕的所有像素中进行显示</em>。</p><h2 id="像素是如何绘制在屏幕上的？"><a href="#像素是如何绘制在屏幕上的？" class="headerlink" title="像素是如何绘制在屏幕上的？"></a>像素是如何绘制在屏幕上的？</h2><p>计算机将存储在内存中的形状转换成实际绘制在屏幕上的对应的过程称为<code>渲染</code>。</p><p>渲染过程中最常用的技术就是 <code>光栅化</code></p><p><em>光栅化就是将数据转化成可见像素的过程</em></p><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/gpu-rasterization-basic-concept.png" class=""><p>GPU 则是执行转换过程的硬件部件。由于这个过程涉及到屏幕上的每一个像素，所以 GPU 被设计成了一个高度并行化的硬件部件</p><h2 id="GPU历史"><a href="#GPU历史" class="headerlink" title="GPU历史"></a>GPU历史</h2><p>GPU 还未出现前，PC 上的图形操作是由<code>视频图形阵列</code>（VGA，Video Graphics Array） 控制器完成。VGA 控制器由连接到一定容量的DRAM上的存储控制器和显示产生器构成。</p><p>1997 年，VGA 控制器开始具备一些 3D 加速功能，包括用于 <code>三角形生成</code>、<code>光栅化</code>、<code>纹理贴图</code> 和 <code>阴影</code></p><p>如今，GPU 及其相关驱动实现了图形处理中的 OpenGL 和 DirectX 模型，从而允许开发者能够轻易地操作硬件。</p><ul><li>GPU 图形渲染流水线的主要工作可以被划分为两个部分：</li></ul><ol><li>把 3D 坐标转换为 2D 坐标</li><li>把 2D 坐标转变为实际的有颜色的像素</li></ol><ul><li><p>GPU 图形渲染流水线的具体实现可分为六个阶段，如下图所示。</p></li><li><p>顶点着色器（Vertex Shader）</p></li><li><p>形状装配（Shape Assembly），又称 图元装配</p></li><li><p>几何着色器（Geometry Shader）</p></li><li><p>光栅化（Rasterization）</p></li><li><p>片段着色器（Fragment Shader）</p></li><li><p>测试与混合（Tests and Blending）</p></li></ul><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/opengl-graphics-pipeline.png" class=""><h2 id="CPU-GPU-异构系统"><a href="#CPU-GPU-异构系统" class="headerlink" title="CPU-GPU 异构系统"></a>CPU-GPU 异构系统</h2><p>两种常见的 CPU-GPU 异构架构</p><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/cpu-gpu-architecture.png" class=""><p>左图是分离式的结构，CPU 和 GPU 拥有各自的存储系统，两者通过 PCI-e 总线进行连接。这种结构的缺点在于 PCI-e 相对于两者具有低带宽和高延迟，数据的传输成了其中的性能瓶颈。目前使用非常广泛，如PC、智能手机等。</p><p>右图是耦合式的结构，CPU 和 GPU 共享内存和缓存。AMD 的 APU 采用的就是这种结构，目前主要使用在游戏主机中，如 PS4</p><h3 id="CPU-GPU-工作流"><a href="#CPU-GPU-工作流" class="headerlink" title="CPU-GPU 工作流"></a>CPU-GPU 工作流</h3><p>下图所示为 CPU-GPU 异构系统的工作流，当 CPU 遇到图像处理的需求时，会调用 GPU 进行处理，主要流程可以分为以下四步：</p><ol><li>将主存的处理数据复制到显存中</li><li>CPU 指令驱动 GPU</li><li>GPU 中的每个运算单元并行处理</li><li>GPU 将显存结果传回主存</li></ol><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/cuda_processing_flow.png" class=""><h2 id="屏幕图像显示原理"><a href="#屏幕图像显示原理" class="headerlink" title="屏幕图像显示原理"></a>屏幕图像显示原理</h2><h3 id="CRT-显示器原理"><a href="#CRT-显示器原理" class="headerlink" title="CRT 显示器原理"></a>CRT 显示器原理</h3><p>CRT 的电子枪从上到下逐行扫描，扫描完成后显示器就呈现一帧画面。然后电子枪回到初始位置进行下一次扫描。为了同步显示器的显示过程和系统的视频控制器，显示器会用硬件时钟产生一系列的定时信号。当电子枪换行进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率</p><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/ios-screen-scan.png" class=""><ul><li>CPU、GPU、显示器工作方式<br>CPU 计算好显示内容提交至 GPU，GPU 渲染完成后将渲染结果存入帧缓冲区，视频控制器会按照 VSync 信号逐帧读取帧缓冲区的数据，经过数据转换后最终由显示器进行显示。</li></ul><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/ios-renderIng-gpu-internal-structure.png" class=""><p>最简单的情况下，帧缓冲区只有一个。此时，帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，GPU 通常会引入两个缓冲区，即 双缓冲机制。在这种情况下，GPU 会预先渲染一帧放入一个缓冲区中，用于视频控制器的读取。当下一帧渲染完毕后，GPU 会直接把视频控制器的指针指向第二个缓冲器。</p><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/gpu-double-buffer.png" class=""><p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象.</p><p>为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p><h2 id="iOS图形渲染技术栈"><a href="#iOS图形渲染技术栈" class="headerlink" title="iOS图形渲染技术栈"></a>iOS图形渲染技术栈</h2><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/image03.png" class=""><p>简单来说，OpenGL ES是对图层进行取色，采样，生成纹理，绑定数据，生成前后帧缓存。</p><h2 id="iOS-渲染框架"><a href="#iOS-渲染框架" class="headerlink" title="iOS 渲染框架"></a>iOS 渲染框架</h2><h3 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h3><p><code>UIkit </code>自身不具备在屏幕成像的能力，其主要负责对用户操作事件的响应（UIView 继承自 UIResponder），事件响应的传递大体是经过逐层的<code>视图树</code>遍历实现。</p><h3 id="Core-Animation"><a href="#Core-Animation" class="headerlink" title="Core Animation"></a>Core Animation</h3><p><code>Core Animation</code>源自于 Layer Kit, <code>Core Animation </code>是一个复合引擎，其职责是 尽可能快地组合屏幕上不同的可视内容，这些可视内容可被分解成独立的图层（即 CALayer），这些图层会被存储在一个叫做<code>图层树</code>的体系之中。从本质上而言，<code>CALayer</code> 是用户所能在屏幕上看见的一切的基础。</p><h3 id="Core-Graphics"><a href="#Core-Graphics" class="headerlink" title="Core Graphics"></a>Core Graphics</h3><p><code>Core Graphics</code> 基于 Quartz 高级绘图引擎，主要用于<code>运行时绘制图像</code>。开发者可以使用此框架来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影，图像数据管理，图像创建和图像遮罩以及 PDF 文档创建，显示和分析。</p><h3 id="Core-Image"><a href="#Core-Image" class="headerlink" title="Core Image"></a>Core Image</h3><p>Core Image 是用来处理 <code>运行前创建的图像</code> ,Core Image 框架拥有一系列现成的图像过滤器，能对已存在的图像进行高效的处理。</p><h3 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h3><p><code>OpenGL ES</code>（OpenGL for Embedded Systems，简称 GLES），是 OpenGL 的子集。在前面的 图形渲染原理综述 一文中提到过 OpenGL 是一套第三方标准，函数的内部实现由对应的 GPU 厂商开发实现。</p><h3 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a>Metal</h3><p>Metal 类似于 OpenGL ES，也是一套第三方标准，具体实现由苹果实现。大多数开发者都没有直接使用过 Metal，但其实所有开发者都在间接地使用 Metal。Core Animation、Core Image、SceneKit、SpriteKit 等等渲染框架都是构建于 Metal 之上的。</p><p>当在真机上调试 OpenGL 程序时，控制台会打印出启用 Metal 的日志。根据这一点可以猜测，Apple 已经实现了一套机制将 OpenGL 命令无缝桥接到 Metal 上，由 Metal 担任真正于硬件交互的工作。</p><h2 id="UIView-与-CALayer-的关系"><a href="#UIView-与-CALayer-的关系" class="headerlink" title="UIView 与 CALayer 的关系"></a>UIView 与 CALayer 的关系</h2><h3 id="为什么-UIKit-中的视图能够呈现可视化内容？"><a href="#为什么-UIKit-中的视图能够呈现可视化内容？" class="headerlink" title="为什么 UIKit 中的视图能够呈现可视化内容？"></a>为什么 UIKit 中的视图能够呈现可视化内容？</h3><p>因为 UIKit 中的每一个 UI 视图控件其实内部都有一个关联的 CALayer，即 <code>backing layer</code></p><p>由于这种一一对应的关系，视图层级拥有 视图树 的树形结构，对应 <code>CALayer</code> 层级也拥有 图层树 的树形结构</p><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/ios-viewtree-layertree.png" class=""><p>视图的职责是 创建并管理 图层，以确保当子视图在层级关系中 添加或被移除 时，其关联的图层在图层树中也有相同的操作，即保证视图树和图层树在结构上的一致性。</p><h3 id="为什么-iOS-要基于-UIView-和-CALayer-提供两个平行的层级关系呢？"><a href="#为什么-iOS-要基于-UIView-和-CALayer-提供两个平行的层级关系呢？" class="headerlink" title="为什么 iOS 要基于 UIView 和 CALayer 提供两个平行的层级关系呢？"></a>为什么 iOS 要基于 UIView 和 CALayer 提供两个平行的层级关系呢？</h3><p>原因在于要做 <code>职责分离</code>，这样也能避免很多重复代码。在 iOS 和 Mac OS X 两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘的交互有着本质的区别，这就是为什么 iOS 有 UIKit 和 UIView，对应 Mac OS X 有 AppKit 和 NSView 的原因。它们在功能上很相似，但是在实现上有着显著的区别。</p><blockquote><p>实际上，这里并不是两个层级关系，而是四个。每一个都扮演着不同的角色。除了 视图树 和 图层树，还有 呈现树 和 渲染树</p></blockquote><h2 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h2><h3 id="为什么-CALayer-可以呈现可视化内容呢？"><a href="#为什么-CALayer-可以呈现可视化内容呢？" class="headerlink" title="为什么 CALayer 可以呈现可视化内容呢？"></a>为什么 CALayer 可以呈现可视化内容呢？</h3><p>因为 CALayer 基本等同于一个 <code>纹理</code>。纹理是 GPU 进行图像渲染的重要依据。</p><p><code>纹理本质上就是一张图片</code>，因此 <code>CALayer</code> 也包含一个 <code>contents</code> 属性指向一块缓存区，称为 <code>backing store</code>，可以存放位图（Bitmap）。iOS 中将该缓存区保存的图片称为 <code>寄宿图</code>。</p><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/ios-layer-contents.png" class=""><p>图形渲染流水线支持从顶点开始进行绘制（在流水线中，顶点会被处理生成纹理），也支持直接使用纹理（图片）进行渲染。相应地，在实际开发中，绘制界面也有两种方式：一种是 手动绘制；另一种是 使用图片。</p><p>对此，iOS 中也有两种相应的实现方式：</p><ol><li>使用图片：contents image</li><li>手动绘制：custom drawing</li></ol><h3 id="Contents-Image"><a href="#Contents-Image" class="headerlink" title="Contents Image"></a>Contents Image</h3><p>Contents Image 是指通过 CALayer 的 contents 属性来配置图片。然而，contents 属性的类型为 id。在这种情况下，可以给 contents 属性赋予任何值，app 仍可以编译通过。但是在实践中，如果 content 的值不是 CGImage ，得到的图层将是空白的。</p><h3 id="Custom-Drawing"><a href="#Custom-Drawing" class="headerlink" title="Custom Drawing"></a>Custom Drawing</h3><p><code>Custom Drawing</code> 是指使用 <code>Core Graphics</code> 直接绘制寄宿图。实际开发中，一般通过继承 <code>UIView</code> 并实现 <code>-drawRect: </code>方法来自定义绘制。</p><p>虽然 <code>-drawRect: </code>是一个 <code>UIView</code> 方法，但事实上都是底层的 <code>CALayer</code> 完成了重绘工作并保存了产生的图片。下图所示为 <code>-drawRect:</code> 绘制定义寄宿图的基本原理。</p><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/ios-layer-bitmap-custom-drawing.png" class=""><ol><li>UIView 有一个关联图层，即 CALayer。</li><li>CALayer 有一个可选的 delegate 属性，实现了 CALayerDelegate 协议。UIView 作为 CALayer 的代理实现了 CALayerDelegae 协议。</li><li>当需要重绘时，即调用 -drawRect:，CALayer 请求其代理给予一个寄宿图来显示。</li><li>CALayer 首先会尝试调用 -displayLayer: 方法，此时代理可以直接设置 contents 属性。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)displayLayer:(<span class="built_in">CALayer</span> *)layer;</span><br></pre></td></tr></table></figure><ol start="5"><li>如果代理没有实现 <code>-displayLayer: </code>方法，CALayer 则会尝试调用 <code>-drawLayer:inContext: </code>方法。在调用该方法前，CALayer 会创建一个空的寄宿图（尺寸由 bounds 和 contentScale 决定）和一个 Core Graphics 的绘制上下文，为绘制寄宿图做准备，作为 ctx 参数传入。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx;</span><br></pre></td></tr></table></figure><ol start="6"><li>最后，由 Core Graphics 绘制生成的寄宿图会存入 <code>backing store</code></li></ol><h2 id="Core-Animation-流水线"><a href="#Core-Animation-流水线" class="headerlink" title="Core Animation 流水线"></a>Core Animation 流水线</h2><p> CALayer是如何调用 GPU 并显示可视化内容的呢？</p><h3 id="Core-Animation-流水线的工作原理"><a href="#Core-Animation-流水线的工作原理" class="headerlink" title="Core Animation 流水线的工作原理"></a>Core Animation 流水线的工作原理</h3><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/ios-core-animation-pipeline-steps.png" class=""><p>事实上，app 本身并不负责渲染，渲染则是由一个独立的进程负责，即 <code>Render Server</code> 进程</p><p>App 通过 IPC 将渲染任务及相关数据提交给 Render Server。Render Server 处理完数据后，再传递至 GPU。最后由 GPU 调用 iOS 的图像设备进行显示。</p><ul><li>Core Animation 流水线的详细过程如下：</li></ul><ol><li>首先，由 app 处理事件（Handle Events），如：用户的点击操作，在此过程中 app 可能需要更新 视图树，相应地，图层树 也会被更新。</li><li>其次，app 通过 CPU 完成对显示内容的计算，如：视图的创建、布局计算、图片解码、文本绘制等。在完成对显示内容的计算之后，app 对图层进行打包，并在下一次 RunLoop 时将其发送至 Render Server，即完成了一次 Commit Transaction 操作。</li><li>Render Server 主要执行 Open GL、Core Graphics 相关程序，并调用 GPU</li><li>GPU 则在物理层上完成了对图像的渲染。</li><li>最终，GPU 通过 Frame Buffer、视频控制器等相关部件，将图像显示在屏幕上。</li></ol><p>对上述步骤进行串联，它们执行所消耗的时间远远超过 16.67 ms，因此为了满足对屏幕的 60 FPS 刷新率的支持，需要将这些步骤进行分解，通过流水线的方式进行并行执行，如下图所示。</p><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/ios-core-animation-pipeline-workflow.png" class=""><h4 id="Commit-Transaction"><a href="#Commit-Transaction" class="headerlink" title="Commit Transaction"></a>Commit Transaction</h4><p>在 Core Animation 流水线中，app 调用 Render Server 前的最后一步 Commit Transaction 其实可以细分为 4 个步骤：</p><ol><li>Layout</li><li>Display</li><li>Prepare</li><li>Commit</li></ol><ul><li>Layout</li></ul><p>Layout 阶段主要进行视图构建，包括：LayoutSubviews 方法的重载，addSubview: 方法填充子视图等。</p><ul><li>Display</li></ul><p>Display 阶段主要进行视图绘制，这里仅仅是设置最要成像的图元数据。重载视图的 drawRect: 方法可以自定义 UIView 的显示，其原理是在 drawRect: 方法内部绘制寄宿图，该过程使用 CPU 和内存。</p><ul><li>Prepare</li></ul><p>Prepare 阶段属于附加步骤，一般处理图像的解码和转换等操作。</p><ul><li>Commit</li></ul><p>Commit 阶段主要将图层进行打包，并将它们发送至 Render Server。该过程会递归执行，因为图层和视图都是以树形结构存在。</p><h3 id="动画渲染原理"><a href="#动画渲染原理" class="headerlink" title="动画渲染原理"></a>动画渲染原理</h3><p>iOS 动画的渲染也是基于上述 Core Animation 流水线完成的。</p><p>如果不是特别复杂的动画，一般使用 UIView Animation 实现，iOS 将其处理过程分为如下三部阶段：</p><p>Step 1：调用 animationWithDuration:animations: 方法</p><p>Step 2：在 Animation Block 中进行 Layout，Display，Prepare，Commit 等步骤。</p><p>Step 3：Render Server 根据 Animation 逐帧进行渲染。</p><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/ios-animation-three-stage-process.png" class=""><h2 id="UIView渲染"><a href="#UIView渲染" class="headerlink" title="UIView渲染"></a>UIView渲染</h2><p>iOS渲染视图的核心是Core Animation<br>其渲染层次依次为：<code>图层树-&gt;呈现树-&gt;渲染树</code></p><h3 id="CPU阶段"><a href="#CPU阶段" class="headerlink" title="CPU阶段"></a>CPU阶段</h3><ol><li>布局（Frame）</li><li>显示（Core Graphics）</li><li>准备（QuartzCore&#x2F;Core Animation）</li><li>通过IPC提交(打包好的图层树以及动画属性)</li></ol><h3 id="OpenGL-ES阶段"><a href="#OpenGL-ES阶段" class="headerlink" title="OpenGL ES阶段"></a>OpenGL ES阶段</h3><ol><li>生成(Generate)</li><li>绑定(Bind)</li><li>缓存数据(Buffer Data)</li><li>启用(Enable)</li><li>设置指针(Set Pointers)</li><li>绘图(Draw)</li><li>清除(Delete)</li></ol><h3 id="GPU阶段"><a href="#GPU阶段" class="headerlink" title="GPU阶段"></a>GPU阶段</h3><ol><li>接收提交的纹理（Texture）和顶点描述（三角形）</li><li>应用变换（transform）</li><li>合并渲染（离屏渲染等）</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>首先一个视图由CPU进行Frame布局，准备视图和图层的层级关系，查询是否有重写drawRect:或drawLayer:inContext:方法，注意：<code>如果有重写的话，这里的渲染是会占用CPU进行处理的</code>。</li><li>CPU会将处理视图和图层的层级关系打包，通过IPC（内部处理通信）通道提交给渲染服务，渲染服务由OpenGL ES和GPU组成。</li><li>渲染服务首先将图层数据交给<code>OpenGL ES进行纹理生成和着色。生成前后帧缓存</code>，再根据显示硬件的刷新频率，一般以设备的VSync信号和CADisplayLink为标准，进行前后帧缓存的切换。</li><li>最后，将最终要显示在画面上的后帧缓存交给GPU，进行采集图片和形状，运行变换，应用纹理和混合。最终显示在屏幕上。</li></ol><p>iOS平台渲染核心原理的重点主要围绕<strong>前后帧缓存、Vsync信号、CADisplayLink</strong></p><h3 id="Core-Animation-1"><a href="#Core-Animation-1" class="headerlink" title="Core Animation"></a>Core Animation</h3><p>core Animation不仅仅是字面意思的核心动画，而是整个显示核心QuartzCore框架中的Core Animation</p><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/image01.png" class=""><p>Core Animation是依赖于OpenGL ES做GPU渲染，CoreGraphics做CPU渲染</p><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/image02.png" class=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件。这个Observer的</span><br><span class="line">优先级是2000000，低于常见的其他 Observer。当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操</span><br><span class="line">作，比如创建和调整视图层级、设置UIView的frame、修改CALayer的透明度、为视图添加一个动画；这些操作最终都会被</span><br><span class="line">CALayer 捕获，并通过CATransaction提交到一个中间状态去（CATransaction 的文档略有提到这些内容，但并不完</span><br><span class="line">整）。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 CA</span><br><span class="line">注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到GPU去显示；如果此处有动画，CA会通过DisplayLink</span><br><span class="line">等机制多次触发相关流程。</span><br></pre></td></tr></table></figure><h3 id="CPU渲染职能"><a href="#CPU渲染职能" class="headerlink" title="CPU渲染职能"></a>CPU渲染职能</h3><p>CPU渲染职能主要体现在以下5个方面：</p><ol><li><p>布局计算</p></li><li><p>视图懒加载</p></li><li><p>Core Graphics绘制<br>如果对视图实现了drawRect:或drawLayer:inContext:方法，或者 CALayerDelegate 的 方法，那么在绘制任何东 西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后， 必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢，所以在一个对性能十分挑剔的场景下这样做十分不好。</p></li><li><p>解压图片</p></li><li><p>图层打包</p></li></ol><h3 id="GPU渲染职能"><a href="#GPU渲染职能" class="headerlink" title="GPU渲染职能"></a>GPU渲染职能</h3><p>GPU会根据生成的前后帧缓存数据，根据实际情况进行合成，其中造成GPU渲染负担的一般是：离屏渲染，图层混合，延迟加载。</p><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/image04.png" class=""><h3 id="前后帧缓存-amp-Vsync信号"><a href="#前后帧缓存-amp-Vsync信号" class="headerlink" title="前后帧缓存 &amp; Vsync信号"></a>前后帧缓存 &amp; Vsync信号</h3><p>iOS 的显示系统是由 VSync 信号驱动的，VSync 信号由硬件时钟生成，每秒钟发出 60 次（这个值取决设备硬件，比如 iPhone 真机上通常是 59.97）。iOS 图形服务接收到 VSync 信号后，会通过 IPC 通知到 App 内。App 的 Runloop 在启动后会注册对应的 CFRunLoopSource 通过 mach_port 接收传过来的时钟信号通知，随后 Source 的回调会驱动整个 App 的动画与显示。</p><img src="/2019/07/29/iOS%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/image05.png" class=""><p>帧缓存：接收渲染结果的缓冲区，为GPU指定存储渲染结果的区域</p><p>帧缓存可以同时存在多个，但是屏幕显示像素受到保存在前帧缓存（front frame buffer）的特定帧缓存中的像素颜色元素的控制。程序的渲染结果通常保存在后帧缓存（back frame buffer）在内的其他帧缓存，当渲染后的后帧缓存完成后，前后帧缓存会互换。（OS完成）</p><p>前帧缓存决定了屏幕上显示的像素颜色，会在适当的时候与后帧缓存切换。</p><p>Core Animation的合成器会联合OpenGL ES层和UIView层、StatusBar层等，在后帧缓存混合产生最终的颜色，并切换前后帧缓存；<br>OpenGL ES坐标是以浮点数来存储，即使是其他数据类型的顶点数据也会被转化成浮点型。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/">图形图像渲染原理</a></li><li><a href="http://chuquan.me/2018/09/25/ios-graphics-render-principle/">iOS 图像渲染原理</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> UI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS图片加载和处理</title>
      <link href="/2019/07/26/iOS%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%A4%84%E7%90%86/"/>
      <url>/2019/07/26/iOS%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图片的显示分为三步：加载，解码，渲染。我们一般操作的只有加载，解码和渲染是由UIKit进行。</p><span id="more"></span><h2 id="Image-x2F-IO"><a href="#Image-x2F-IO" class="headerlink" title="Image&#x2F;IO"></a>Image&#x2F;IO</h2><p><a href="https://developer.apple.com/documentation/imageio?language=objc">Image&#x2F;IO</a>是Apple提供的一套用于图片编码解码的系统库，对外是一层非常直观易用的C的接口。上层的UIKit，Core Image，还有Core Graphics中的CGImage处理，都是依赖Image&#x2F;IO库的。</p><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>以UIImageView为例。当其显示在屏幕上时，需要UIImage作为数据源。<br>UIImage持有的数据是未解码的压缩数据，能节省较多的内存和加快存储。<br>当UIImage被赋值给UIImage时（例如imageView.image &#x3D; image;），图像数据会被解码，变成RGB的颜色数据。<br>解码是一个计算量较大的任务，且需要CPU来执行；并且解码出来的图片体积与图片的宽高有关系，而与图片原来的体积无关。<br>其体积大小可简单描述为：宽 * 高 * 每个像素点的大小 &#x3D; width * height * 4bytes。</p><img src="/2019/07/26/iOS%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%A4%84%E7%90%86/image01.png" class=""><p><strong>图像解码操作会造成什么问题？</strong><br>以我们常见的UITableView和UICollectionView为例，假如我们在使用一个多图片显示的功能</p><p>在上下滑动显示图片的过程中，我们会在cellFor的方法加载UIImage图片、赋值给UIImageView，相当于在主线程同时进行IO操作、解码操作等，会造成内存迅速增长和CPU负载瞬间提升。<br>并且内存的迅速增加会触发系统的内存回收机制，尝试回收其他后台进程的内存，增加CPU的工作量。如果系统无法提供足够的内存，则会先结束其他后台进程，最终无法满足的话会结束当前进程。</p><p><strong>那么如何对这种情况进行优化</strong></p><ol><li>优化1：降采样<br>在滑动显示的过程中，图片显示的宽高远比真实图片要小，我们可以采用加载缩略图的方式减少图片的占用内存。如下图所示：</li></ol><img src="/2019/07/26/iOS%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%A4%84%E7%90%86/image02.png" class=""><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">downsample</span>(<span class="params">imageAt</span> <span class="params">imageURL</span>: <span class="type">URL</span>, <span class="params">to</span> <span class="params">pointSize</span>: <span class="type">CGSize</span>, <span class="params">scale</span>: <span class="type">CGFloat</span>) -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line"><span class="keyword">let</span> imageSourceOptions <span class="operator">=</span> [kCGImageSourceShouldCache: <span class="literal">false</span>] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line"><span class="keyword">let</span> imageSource <span class="operator">=</span> <span class="type">CGImageSourceCreateWithURL</span>(imageURL <span class="keyword">as</span> <span class="type">CFURL</span>, imageSourceOptions)<span class="operator">!</span></span><br><span class="line"><span class="keyword">let</span> maxDimensionInPixels <span class="operator">=</span> <span class="built_in">max</span>(pointSize.width, pointSize.height) <span class="operator">*</span> scale</span><br><span class="line"><span class="keyword">let</span> downsampleOptions <span class="operator">=</span> [kCGImageSourceCreateThumbnailFromImageAlways: <span class="literal">true</span>,</span><br><span class="line">kCGImageSourceShouldCacheImmediately: <span class="literal">true</span>,</span><br><span class="line">kCGImageSourceCreateThumbnailWithTransform: <span class="literal">true</span>,</span><br><span class="line">kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels] <span class="keyword">as</span> <span class="type">CFDictionary</span></span><br><span class="line"><span class="keyword">let</span> downsampledImage <span class="operator">=</span> <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, downsampleOptions)<span class="operator">!</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">UIImage</span>(cgImage: downsampledImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们加载jpeg的图片，然后进行相关设置，解码后根据设置生成CGImage缩略图，最后包装成UIImage，最终传递给UIImageView渲染。</p><p><strong>这里的解码步骤为何不是上文提到的imageView.image&#x3D;image时机？</strong><br>我的理解：正常的UIImage加载是从APP本地读取，或者从网络下载图片，此时不涉及图片内容相关的操作，并不需要解码；当图片被赋值给UIImageView时，CALayer读取图片内容进行渲染，所以需要对图片进行解码；<br>而上文的缩略图生成过程中，已经对图片进行解码操作，此时的UIImage只是一个CGImage的封装，所以当UIImage赋值给UIImageView时，CALayer可以直接使用CGImage所持有的图像数据。</p><ol start="2"><li>优化2：异步处理</li></ol><img src="/2019/07/26/iOS%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%A4%84%E7%90%86/image03.png" class=""><p>从用户的体验来分析，滑动的操作往往是间断性触发，在滑动的瞬间有较大的工作量，而且由于都是在主线程进行操作无法进行任务分配，CPU 2处于闲置。由此引申出两种优化手段：Prefetching（预处理）和<br>Background decoding&#x2F;downsampling（子线程解码和降采样）。综合起来，可以在Prefetching的时候把降采样放到子线程进行处理，因为降采样过程就包括解码操作。</p><img src="/2019/07/26/iOS%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%A4%84%E7%90%86/image04.png" class=""><p>Prefetching回调中，把降采样的操作放到同步队列serialQueue中，处理完毕之后抛给主线程进行update操作。<br>需要特别注意，此处不能是并发队列，否则会造成线程爆炸</p><img src="/2019/07/26/iOS%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%A4%84%E7%90%86/image05.png" class=""><ol start="3"><li>优化3：使用Image Asset Catalogs</li></ol><p>Apple推荐的图片资源管理工具，压缩效率更高，在iOS 12的机器上有10~20%的空间节约，并且每个版本Apple都会持续对其进行优化。</p><p>对于解码操作，我们可以分为静态图（比如JPEG，PNG）和动态图（比如GIF，APNG）的两种。</p><h4 id="静态图"><a href="#静态图" class="headerlink" title="静态图"></a>静态图</h4><p>静态图的解码，基本可以分为以下步骤：</p><ol><li>创建CGImageSource</li><li>读取图像格式元数据（可选）</li><li>解码得到CGImage</li><li>生成上层的UIImage，清理</li></ol><h4 id="动态图"><a href="#动态图" class="headerlink" title="动态图"></a>动态图</h4><p>步骤：</p><ol><li>静态图的步骤1</li><li>遍历所有图像帧，重复静态图的步骤2-4</li><li>生成动图UIImage</li></ol><h3 id="渐进式解码"><a href="#渐进式解码" class="headerlink" title="渐进式解码"></a>渐进式解码</h3><p>渐进式解码（Progressive Decoding），即不需要完整的图像流数据，允许解码部分帧（大部分情况下，会是图像的部分区域），对部分使用了渐进式编码的格式，则更可以解码出相对模糊但完整的图像。</p><p>JPEG支持三种方式的渐进式编码，包括Baseline，interlaced，以及progressive</p><h4 id="怎样像浏览器那样边下载边显示图片？（渐进式解码）"><a href="#怎样像浏览器那样边下载边显示图片？（渐进式解码）" class="headerlink" title="怎样像浏览器那样边下载边显示图片？（渐进式解码）"></a>怎样像浏览器那样边下载边显示图片？（渐进式解码）</h4><p>图片本身有 3 种常见的编码方式：<br>第一种是 baseline，即逐行扫描。默认情况下，JPEG、PNG、GIF 都是这种保存方式。<br>第二种是 interlaced，即隔行扫描。PNG 和 GIF 在保存时可以选择这种格式。<br>第三种是 progressive，即渐进式。JPEG 在保存时可以选择这种方式。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>编码过程，这里指的就是将一个UIImage表示的图像，编码为对应图像格式的数据，输出一个NSData的过程。Image&#x2F;IO提供的对应概念，叫做CGImageDestination，表示一个输出。之后的编码相关的操作，和这个Destination一一对应。</p><h4 id="静态图-1"><a href="#静态图-1" class="headerlink" title="静态图"></a>静态图</h4><p>静态图的编码，基本可以分为以下步骤：</p><ol><li>创建CGImageDestination</li><li>添加图像格式元数据（可选）和CGImage</li><li>编码得到NSData，清理</li></ol><h4 id="动态图-1"><a href="#动态图-1" class="headerlink" title="动态图"></a>动态图</h4><p>动态图的编码，其实不像解码那样困难。只需要准备好所有的动态图的帧，按照帧的顺序进行一一添加即可。基本步骤可以概括为：</p><ol><li>静态图的步骤1，提供帧数</li><li>遍历所有图像帧，重复静态图的步骤2</li><li>静态图的步骤3</li></ol><h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><h3 id="UIImage-缓存问题"><a href="#UIImage-缓存问题" class="headerlink" title="UIImage 缓存问题"></a>UIImage 缓存问题</h3><p>通过 imageNamed 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。据我观察，在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。</p><h3 id="用-imageWithData-能不能避免缓存呢？"><a href="#用-imageWithData-能不能避免缓存呢？" class="headerlink" title="用 imageWithData 能不能避免缓存呢？"></a>用 imageWithData 能不能避免缓存呢？</h3><p>不能。通过数据创建 UIImage 时，UIImage 底层是调用 ImageIO 的 CGImageSourceCreateWithData() 方法。该方法有个参数叫 ShouldCache，在 64 位的设备上，这个参数是默认开启的。这个图片也是同样在第一次显示到屏幕时才会被解码，随后解码数据被缓存到 CGImage 内部。与 imageNamed 创建的图片不同，如果这个图片被释放掉，其内部的解码数据也会被立刻释放。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">UIImage</span> *)imageNamed:(<span class="built_in">NSString</span> *)name cache:(<span class="type">BOOL</span>)cache &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache)</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageNamed:name];</span><br><span class="line">    name = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:[name stringByDeletingPathExtension] ofType:[name pathExtension]]; </span><br><span class="line">    <span class="built_in">UIImage</span> *retVal = [[<span class="built_in">UIImage</span>  alloc] initWithContentsOfFile:name];</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>如果图片在Images.xcassets中，是不能使用imageWithContentsOfFile:<br>这个方法的。所以说想要自己进行图片的内存管理（不希望有缓存图片），那么要将图片资源直接拖入工程，而不是放在Images.xcassets中。</p><p><strong>Images.xcassets</strong></p><p>如果图片存放在assets资源管理器,最终里面所以的图片会被打包成Assets.car(用ThemeEngine可以把图片弄出来),其作用在于<br>1、 自动识别@2x，@3x图片，<br>2、 根据不同的设备，不同的分辨率设置相应的图片。<br>3、 可以对图片进行剪裁和拉伸处理<br>在.car中的图片是不能通过imageWithContentsOfFile:来加载 imageName:加载的图片要么是Assets.car中的图片,要么是资源包(mainBundle)中直接存放的图片。如果用imageNamed:从Images.xcassets以外的地方加载图片，必须在文件名后加扩展名</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://dreampiggy.com/2017/10/30/iOS%E5%B9%B3%E5%8F%B0%E5%9B%BE%E7%89%87%E7%BC%96%E8%A7%A3%E7%A0%81%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88Image:IO%E7%AF%87%EF%BC%89/">iOS平台图片编解码入门教程（Image&#x2F;IO篇）</a></li><li><a href="https://blog.ibireme.com/2015/11/02/ios_image_tips/">iOS 处理图片的一些小 Tip</a></li><li><a href="https://www.jianshu.com/p/7d8a82115060">iOS性能优化——图片加载和处理</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> UI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机的引导启动过程</title>
      <link href="/2019/07/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/07/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<ul><li><p>当你按下计算机的电源键后，机器就开始运转了。一旦主板上电，它就会初始化自身的固件(firmware)——芯片组和其他零零碎碎的东西 ——并尝试启动CPU</p></li><li><p>如果一切正常，CPU就开始运行了。在一个多处理器或多核处理器的系统中，会有一个CPU被动态的指派为引导处理器（bootstrap processor简写BSP），用于执行全部的BIOS和内核初始化代码。其余的处理器，此时被称为应用处理器（application processor简写AP），一直保持停机状态直到内核明确激活他们为止。（虽然Intel CPU经历了很多年的发展，但他们一直保持着完全的向后兼容性，所以现代的CPU可以表现得跟原先1978年的Intel 8086完全一样）</p><span id="more"></span></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.toutiao.com/i6713898803977519624/?tt_from=copy_link&utm_campaign=client_share&timestamp=1564044693&app=news_article&utm_source=copy_link&utm_medium=toutiao_ios&req_id=20190725165132010027041153866F481&group_id=6713898803977519624">计算机的引导启动过程</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机系统结构 </category>
          
          <category> IO </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Intel主板上的内存映射</title>
      <link href="/2019/07/10/Intel%E4%B8%BB%E6%9D%BF%E4%B8%8A%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"/>
      <url>/2019/07/10/Intel%E4%B8%BB%E6%9D%BF%E4%B8%8A%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前通过MMKV提到过文件内存映射，现在了解下硬件角度的内存映射。</p><span id="more"></span><h3 id="如今Intel计算机组成"><a href="#如今Intel计算机组成" class="headerlink" title="如今Intel计算机组成"></a>如今Intel计算机组成</h3><img src="/2019/07/10/Intel%E4%B8%BB%E6%9D%BF%E4%B8%8A%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/intel.jpeg" class=""><p>CPU一点也不知道它连接了什么东西（这很符合设计六大原则的开闭原则），CPU仅仅通过一组针脚与外界交互，它并不关心外界到底有什么。可能是电脑主板，导弹，网络路由器，植入脑内的设备，或CPU测试工作台。</p><h4 id="CPU主要通过3种方式与外界交互"><a href="#CPU主要通过3种方式与外界交互" class="headerlink" title="CPU主要通过3种方式与外界交互"></a>CPU主要通过3种方式与外界交互</h4><ol><li>内存地址空间</li><li>I&#x2F;O地址空间</li><li>中断</li></ol><h4 id="CPU与外界的通信"><a href="#CPU与外界的通信" class="headerlink" title="CPU与外界的通信"></a>CPU与外界的通信</h4><p>安装在主板上的CPU与外界沟通的门户是<strong>前端总线</strong>（front-side bus），前端总线把CPU与北桥连接起来。每当CPU需要读写内存时，都会使用这条总线。CPU通过一部分管脚来传输想要读写的物理内存地址，同时另一些管脚用于发送将被写入或接收被读出的数据。一个Intel Core 2 QX6600有33个针脚用于传输物理内存地址（可以表示233个地址位置），64个针脚用于接收&#x2F;发送数据（所以数据在64位通道中传输，也就是8字节的数据块）。这使得CPU可以控制64GB的物理内存（233个地址乘以8字节）。</p><h3 id="内存映射I-x2F-O"><a href="#内存映射I-x2F-O" class="headerlink" title="内存映射I&#x2F;O"></a>内存映射I&#x2F;O</h3><ul><li><p>我们可能曾经认为内存指的就是RAM，被各式各样的程序读写着。的确，大部分CPU发出的内存请求都被北桥转送给了RAM管理器，但并非全部如此。物理内存地址还可能被用于主板上各种设备间的通信，这种通信方式叫做<strong>内存映射I&#x2F;O</strong>。这类设备包括显卡，大多数的PCI卡（比如扫描仪或SCSI卡），以及BIOS中的flash存储器等。</p></li><li><p>当北桥接收到一个物理内存访问请求时，它需要决定把这个请求转发到哪里：是发给RAM？抑或是显卡？具体发给谁是由内存地址映射表来决定的。映射表知道每一个物理内存地址区域所对应的设备。绝大部分的地址被映射到了RAM，其余地址由映射表来通知芯片组该由哪个设备来响应此地址的访问请求。这些被映射为设备的内存地址形成了一个经典的空洞，位于PC内存的640KB到1MB之间。当内存地址被保留用于显卡和PCI设备时，就会形成更大的空洞。这就是为什么32位的操作系统无法使用全部的4GB RAM。Linux中，&#x2F;proc&#x2F;iomem这个文件简明的列举了这些空洞的地址范围。下图展示了Intel PC低端4GB物理内存地址形成的一个典型的内存映射：</p></li></ul><img src="/2019/07/10/Intel%E4%B8%BB%E6%9D%BF%E4%B8%8A%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/intel_4Mem.jpeg" class=""><ul><li><p>实际的地址和范围依赖于特定的主板和电脑中接入的设备，但是对于大多数Core 2系统，情形都跟上图非常接近。所有棕色的区域都被设备地址映射走了。记住，这些在主板总线上使用的都是物理地址。在CPU内部（比如我们正在编写和运行的程序），使用的是逻辑地址，必须先由CPU翻译成物理地址以后，才能发布到总线上去访问内存.</p></li><li><p>这个把逻辑地址翻译成物理地址的规则比较复杂，而且还依赖于当时CPU的运行模式（实模式，32位保护模式，64位保护模式）。不管采用哪种翻译机制，CPU的运行模式决定了有多少物理内存可以被访问。比如，当CPU工作于32位保护模式时，它只可以寻址4GB物理地址空间（当然，也有个例外叫做物理地址扩展，但暂且忽略这个技术吧）。由于顶部的大约1GB物理地址被映射到了主板上的设备，CPU实际能够使用的也就只有大约3GB的RAM（有时甚至更少，我曾用过一台安装了Vista的电脑，它只有2.4GB可用）。如果CPU工作于实模式，那么它将只能寻址1MB的物理地址空间（这是早期的Intel处理器所支持的唯一模式）。如果CPU工作于64位保护模式，则可以寻址64GB的地址空间（虽然很少有芯片组支持这么大的RAM）。处于64位保护模式时，CPU就有可能访问到RAM空间中被主板上的设备映射走了的区域了（即访问空洞下的RAM）。要达到这种效果，就需要使用比系统中所装载的RAM地址区域更高的地址。这种技术叫做回收(reclaiming)，而且还需要芯片组的配合。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">微信公众号：技术原理君</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机系统结构 </category>
          
          <category> IO </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS面试题汇总</title>
      <link href="/2019/07/04/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2019/07/04/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>把最近面试中遇到的问题总结下</p><span id="more"></span><h3 id="1-使用atomic一定是线程安全的吗"><a href="#1-使用atomic一定是线程安全的吗" class="headerlink" title="1.使用atomic一定是线程安全的吗?"></a>1.使用atomic一定是线程安全的吗?</h3><p>不是,atomic 的本意是指属性的存取方法是线程安全的,并不保证整个对象是线程安全的。</p><p>声明一个 NSMutableArray 的原子属性 stuff,此时 self.stuff 和 self.stuff &#x3D;othersulf 都是线程安全的。但是,使用[self.stuff objectAtIndex:index]就不是线程安全的,需要用互斥锁来保证线程安全性。</p><h3 id="2-synthesize-和-dynamic-分别有什么作用"><a href="#2-synthesize-和-dynamic-分别有什么作用" class="headerlink" title="2.@synthesize 和 @dynamic 分别有什么作用?"></a>2.@synthesize 和 @dynamic 分别有什么作用?</h3><p>@property 有两个对应的词,一个是@synthesize,一个是@dynamic。<br>如果@synthesize 和@dynamic 都没写,那么默认的就是</p><p>@syntheszie var &#x3D; _var;</p><p>@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法,那么编译器会自动为你加上这两个方法。</p><p>@dynamic 告诉编译器:属性的 setter 与 getter 方法由用户自己实现,不自动生成。(当然对于 readonly 的属性只需提供 getter 即可)</p><p>假如一个属性被声明为<br>@dynamic var；然后你没有提供@setter 方法和@getter 方法,编译的时候没问题,但是当程序运行到 instance.var &#x3D; someVar,由于缺 setter方法会导致程序崩溃;<br>或者当运行到 someVar &#x3D; instance.var 时,由于缺 getter 方法同样会导致崩溃。</p><p>编译时没问题,运行时才执行相应的方法,这就是所谓的动态绑定</p><h3 id="3-浅拷贝和深拷贝在不同对象下的表现"><a href="#3-浅拷贝和深拷贝在不同对象下的表现" class="headerlink" title="3.浅拷贝和深拷贝在不同对象下的表现"></a>3.<a href="https://juejin.im/post/5d9de2d3f265da5bb414bf4e">浅拷贝和深拷贝</a>在不同对象下的表现</h3><img src="/2019/07/04/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/copy.png" class=""><p>总结：copy后的都是不可变对象，mutablecopy后的都是可变对象，NSString使用copy和strong都是浅拷贝，但是使用strong关键字后可能变成可变对象，因此要用copy关键字，同理NSMutableString使用copy关键字会变成不可变对象，所以建议使用strong</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深复制</span></span><br><span class="line">Person *xiaoMing = [[Person alloc] init];</span><br><span class="line"><span class="built_in">NSMutableString</span> * name = [[<span class="built_in">NSMutableString</span> alloc] initWithString:<span class="string">@&quot;xiaoming&quot;</span>];</span><br><span class="line"><span class="comment">//name.string = @&quot;xiaoming&quot;;</span></span><br><span class="line">xiaoMing.name = name;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, xiaoMing.name);</span><br><span class="line">[name appendString:<span class="string">@&quot;hah&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时名字这个属性被修改了</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, xiaoMing.name);</span><br></pre></td></tr></table></figure><ol><li>容器中的元素实现深拷贝，也就是多层容器对象，可以使用归接档实现</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *trueDeepCopyArray = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:[<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:array]];</span><br></pre></td></tr></table></figure><ol start="2"><li>自定义对象使用copy和mutableCopy需要遵守NSCopying和NSMutableCopying协议，实现<br><code>- (id)copyWithZone:(nullable NSZone *)zone</code>和<code>- (id)mutableCopyWithZone:(nullable NSZone *)zone</code>方法。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    </span><br><span class="line">    Person *person = [[Person allocWithZone:zone] init];</span><br><span class="line">    </span><br><span class="line">    person.name = <span class="keyword">self</span>.name;</span><br><span class="line">    person.age = <span class="keyword">self</span>.age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-这个写法会出什么问题：-property-copy-NSMutableArray-array"><a href="#4-这个写法会出什么问题：-property-copy-NSMutableArray-array" class="headerlink" title="4.这个写法会出什么问题： @property (copy) NSMutableArray *array;"></a>4.这个写法会出什么问题： @property (copy) NSMutableArray *array;</h3><p>两个问题：</p><p>1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；</p><p>2、使用了 atomic 属性会严重影响性能 ；</p><h3 id="5-如何给-Category-添加属性？关联对象以什么形式进行存储？"><a href="#5-如何给-Category-添加属性？关联对象以什么形式进行存储？" class="headerlink" title="5.如何给 Category 添加属性？关联对象以什么形式进行存储？"></a>5.如何给 Category 添加属性？关联对象以什么形式进行存储？</h3><p>查看的是 关联对象 的知识点。</p><p>详细的说一下 关联对象。</p><p>关联对象 以哈希表的格式，存储在一个全局的单例中。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Extension</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>  ) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Extension</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    </span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>,<span class="keyword">@selector</span>(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="6-说一下-Runtime-消息解析和转发"><a href="#6-说一下-Runtime-消息解析和转发" class="headerlink" title="6.说一下 Runtime 消息解析和转发"></a>6.说一下 Runtime 消息解析和转发</h3><img src="/2019/07/04/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/method_forward.png" class=""><h3 id="7-说一下-Runtime-的方法缓存？存储的形式、数据结构以及查找的过程？"><a href="#7-说一下-Runtime-的方法缓存？存储的形式、数据结构以及查找的过程？" class="headerlink" title="7.说一下 Runtime 的方法缓存？存储的形式、数据结构以及查找的过程？"></a>7.说一下 Runtime 的方法缓存？存储的形式、数据结构以及查找的过程？</h3><p>cache_t增量扩展的哈希表结构。哈希表内部存储的 bucket_t。</p><p>bucket_t 中存储的是 SEL 和 IMP的键值对。</p><p>如果是有序方法列表，采用二分查找</p><p>如果是无序方法列表，直接遍历查找</p><h3 id="7-Category-可不可以添加实例对象？为什么？"><a href="#7-Category-可不可以添加实例对象？为什么？" class="headerlink" title="7.Category 可不可以添加实例对象？为什么？"></a>7.Category 可不可以添加实例对象？为什么？</h3><p>每个类的内存布局在编译时期就已经确定了，运行时才加载的category无法添加属性和实例变量</p><h3 id="8-Bounds-和Frame的区别"><a href="#8-Bounds-和Frame的区别" class="headerlink" title="8.Bounds 和Frame的区别"></a>8.Bounds 和Frame的区别</h3><p>Bounds：一般是相对于自身来说的，是控件的内部尺寸。如果你修改了 Bounds，那么子控件的相对位置也会发生改变。</p><p>Frame ：是相对于父控件来说的，是控件的外部尺寸。</p><h3 id="9-UIViewController-的生命周期"><a href="#9-UIViewController-的生命周期" class="headerlink" title="9.UIViewController 的生命周期"></a>9.UIViewController 的生命周期</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-[ViewController initWithCoder:]</span><br><span class="line">-[ViewController awakeFromNib]</span><br><span class="line">-[ViewController loadView]</span><br><span class="line">-[ViewController viewDidLoad]</span><br><span class="line">-[ViewController viewWillAppear:]</span><br><span class="line">-[ViewController viewWillLayoutSubviews]</span><br><span class="line">-[ViewController viewDidLayoutSubviews]</span><br><span class="line">-[ViewController viewDidAppear:]</span><br><span class="line">-[ViewController viewWillDisappear:]</span><br><span class="line">-[ViewController viewDidDisappear:]</span><br><span class="line">-[ViewController dealloc]</span><br><span class="line">-[ViewController didReceiveMemoryWarning]</span><br></pre></td></tr></table></figure><h3 id="10-iOS程序的启动流程"><a href="#10-iOS程序的启动流程" class="headerlink" title="10.iOS程序的启动流程"></a>10.iOS程序的启动流程</h3><p>程序完成加载</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[AppDelegate application:didFinishLaunchingWithOptions:]</span><br></pre></td></tr></table></figure><p>点击Home键</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[AppDelegate applicationWillResignActive:]; <span class="comment">//程序取消激活状态</span></span><br><span class="line"></span><br><span class="line">[AppDelegate applicationDidEnterBackground:];<span class="comment">// 程序进入后台</span></span><br></pre></td></tr></table></figure><p>点击APP</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[AppDelegate applicationWillEnterForeground:]<span class="comment">// 程序进入前台</span></span><br><span class="line"></span><br><span class="line">[AppDelegate applicationDidBecomeActive:];<span class="comment">// 程序被激活</span></span><br></pre></td></tr></table></figure><p>注意</p><h4 id="applicationWillResignActive-非活动-与applicationDidEnterBackground-后台-的区别。"><a href="#applicationWillResignActive-非活动-与applicationDidEnterBackground-后台-的区别。" class="headerlink" title="applicationWillResignActive(非活动)与applicationDidEnterBackground(后台)的区别。"></a>applicationWillResignActive(非活动)与applicationDidEnterBackground(后台)的区别。</h4><p>applicationWillResignActive:<br>比如当有电话进来或短信进来或锁屏等情况下，这时应用程序挂起进入非活动状态，也就是手机界面还是显示着你当前的应用程序的窗口，只不过被别的任务强制占用了，也可能是即将进入后台状态(因为要先进入非活动状态然后进入后台状态)</p><p>applicationDidEnterBackground:<br>指当前窗口不是你的App,大多数程序进入这个后台会在这个状态上停留一会，时间到之后会进入挂起状态(Suspended)。如果你程序特殊处理后可以长期处于后台状态也可以运行。</p><p>Suspended : 程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</p><p><a href="https://www.jianshu.com/p/4a62c10a36f1">点我</a></p><h3 id="11-id-和instanceType有什么区别？"><a href="#11-id-和instanceType有什么区别？" class="headerlink" title="11.id 和instanceType有什么区别？"></a>11.id 和instanceType有什么区别？</h3><p>相同点</p><p>instancetype 和 id 都是万能指针，指向对象。</p><p>不同点：</p><p>1.id 在编译的适合不能判断对象的真实类型，instancetype 在编译的时候可以判断对象的真实类型<br>2.id 可以用来定义变量，可以作为返回值类型，可以作为形参类型；instancetype 只能作为返回值类型</p><h3 id="12-block-vs-weak"><a href="#12-block-vs-weak" class="headerlink" title="12.__block vs __weak"></a>12.__block vs __weak</h3><ol><li>__block：使用__block修饰的变量在block代码快中会被retain（ARC下，MRC下不会retain） </li><li>__weak：使用__weak修饰的变量不会在block代码块中被retain<br>同时，在ARC下，要避免block出现循环引用 __weak typedof(self)weakSelf &#x3D; self;</li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Objective-C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSInvocation</title>
      <link href="/2019/07/03/NSInvocation/"/>
      <url>/2019/07/03/NSInvocation/</url>
      
        <content type="html"><![CDATA[<h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><p>在iOS中不通过类可以直接调用某个对象的消息方式有两种：</p><ol><li><code>performSelector:withObject</code>;</li><li><code>NSInvocation</code><span id="more"></span></li></ol><h3 id="performSelector使用"><a href="#performSelector使用" class="headerlink" title="performSelector使用"></a>performSelector使用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HTOtherModule</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)doSomethingWithParameter:(<span class="built_in">NSString</span> *)para&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;done some with:%@&quot;</span>,para);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;HTOtherModule&quot;</span>);</span><br><span class="line"><span class="type">id</span> obj = [[cls alloc]init];</span><br><span class="line">[obj performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;doSomethingWithParameter:&quot;</span>) withObject:<span class="string">@&quot;this is the value&quot;</span>];</span><br></pre></td></tr></table></figure><p>performSelector虽然能达到调用方法的目的，但是传递的参数最多只能有两个，也许可以通过封装进字典来传递，但是这样就徒增了工作。我们可以用NSInvocation的特性来达到这个目的。</p><h3 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h3><p>NSInvocation与其他NSObject类不一样，不会通过alloc&#x2F;init来生成，它需要通过一个方法签名NSMethodSignature来生成</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInvocation</span> *invocatin = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:sig];</span><br></pre></td></tr></table></figure><p>而NSMethodSignature由类的selector来形成的</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMethodSignature</span> *sig  = [cls instanceMethodSignatureForSelector:aSelecotor];</span><br></pre></td></tr></table></figure><p>依次填补参数，</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[invocatin setTarget:obj];</span><br><span class="line">[invocatin setSelector:aSelecotor];</span><br><span class="line"><span class="built_in">NSString</span> *para = <span class="string">@&quot;this is the value&quot;</span>;</span><br><span class="line">[invocatin setArgument:&amp;para atIndex:<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>触发，就可以发送一条消息</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[invocatin invoke];</span><br></pre></td></tr></table></figure><p>下面是调用HTOtherModule类的方法的完整代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SEL aSelecotor = <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;doSomethingWithParameter:&quot;</span>);</span><br><span class="line">   Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;HTOtherModule&quot;</span>);</span><br><span class="line">   <span class="type">id</span> obj = [[cls alloc]init];</span><br><span class="line">   <span class="built_in">NSMethodSignature</span> * sig  = [cls instanceMethodSignatureForSelector:aSelecotor];</span><br><span class="line">   <span class="built_in">NSInvocation</span> * invocatin = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:sig];</span><br><span class="line">   [invocatin setTarget:obj];</span><br><span class="line">   [invocatin setSelector:aSelecotor];</span><br><span class="line">   <span class="built_in">NSString</span> *para = <span class="string">@&quot;this is the value&quot;</span>;</span><br><span class="line">   [invocatin setArgument:&amp;para atIndex:<span class="number">2</span>];</span><br><span class="line">   [invocatin invoke];</span><br></pre></td></tr></table></figure><h3 id="组件化路由跳转（Mediator）"><a href="#组件化路由跳转（Mediator）" class="headerlink" title="组件化路由跳转（Mediator）"></a>组件化路由跳转（Mediator）</h3><img src="/2019/07/03/NSInvocation/mediator.png" class=""><p>Category</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HTMediator</span> (<span class="title">HTOtherModule</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)otherModulePerform:(<span class="built_in">NSString</span> *)targetName action:(<span class="built_in">NSString</span> *)actionName name:(<span class="built_in">NSString</span> *)name hour:(<span class="built_in">NSUInteger</span>)hour place:(<span class="built_in">NSString</span> *)palce doSomething:(<span class="built_in">NSString</span> *)doSomething;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)performTarget:(<span class="built_in">NSString</span> *)targetName action:(<span class="built_in">NSString</span> *)actionName parameters:(<span class="built_in">NSArray</span> *)parameters&#123;</span><br><span class="line">    Class tagetClass = <span class="built_in">NSClassFromString</span>(targetName);</span><br><span class="line">    <span class="built_in">NSObject</span> *tagert= [[tagetClass alloc]init];</span><br><span class="line">    SEL aSelector = <span class="built_in">NSSelectorFromString</span>(actionName);</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *methodSignature = [tagetClass instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span>(methodSignature == <span class="literal">nil</span>) <span class="comment">// 方法签名找不到，异常情况自己处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;找不到这个方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:methodSignature];</span><br><span class="line">        [invocation setTarget:tagert];</span><br><span class="line">        [invocation setSelector:aSelector];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//消息发送的参数，签名两个是class和selector，所以方法参数从第3个开始</span></span><br><span class="line">        [parameters enumerateObjectsUsingBlock:^(<span class="type">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            [invocation setArgument:&amp;obj atIndex:idx+<span class="number">2</span>];</span><br><span class="line">        &#125;];</span><br><span class="line">        [invocation invoke];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回值处理</span></span><br><span class="line">        __autoreleasing <span class="type">id</span> callBackObject = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span>(methodSignature.methodReturnLength)</span><br><span class="line">        &#123;</span><br><span class="line">            [invocation getReturnValue:&amp;callBackObject];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> callBackObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.helloted.com/ios/2018/05/30/runtimeApply_3/">Runtime应用(三)：NSInvocation</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Runtime </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH协议</title>
      <link href="/2019/07/01/SSH%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/07/01/SSH%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>SSH是一种协议标准，它的主要目的是实现远程登录和提供安全网络服务。它的实现有很多种，最常用的就是开源openssh。</p><span id="more"></span><h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><p>加密分为两种加密方式：</p><ol><li>对称加密（秘钥加密）</li><li>非对称加密（公钥加密）</li></ol><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>就是加密和解密都是使用同一套秘钥。</p><img src="/2019/07/01/SSH%E5%8D%8F%E8%AE%AE/duichen01.jpeg" class=""><p>服务端和客户端的交互过程如下图：</p><img src="/2019/07/01/SSH%E5%8D%8F%E8%AE%AE/duichen02.jpeg" class=""><p>对称加密的加密强度很高，但是这有一个很大的问题。就是：如何保证秘钥A的安全？当客户端的数量非常大的时候，如何保证秘钥的安全？一旦秘钥泄漏出去，后果不堪设想。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密有两个秘钥：“私钥”和“公钥”。公钥加密后的密文，只能通过对应的私钥进行解密。而通过公钥推理出私钥的可能性微乎其微。</p><img src="/2019/07/01/SSH%E5%8D%8F%E8%AE%AE/feiduichen01.jpeg" class=""><p>上图在实际的使用中存在一个问题，就是客户端需要知道服务端的公钥，不然没法加密。所以需要服务端告知客户端公钥的一个过程。</p><img src="/2019/07/01/SSH%E5%8D%8F%E8%AE%AE/feiduichen02.jpeg" class=""><ol><li>服务端收到客户端的登录请求，服务端把公钥发送给客户端</li><li>客户端用这个公钥，对密码加密</li><li>客户端将加密后的密码发送给服务端</li><li>服务端用私钥解密，验证OK</li><li>返回验证结果</li></ol><p>私钥是服务端独有，这就保证了客户端的登录信息即使在网络传输过程中被窃据，也没有私钥进行解密，保证了数据的安全性，这充分利用了非对称加密的特性。</p><p>上述图中有一个漏洞：客户端如何保证接受到的公钥就是目标服务端的？如果攻击者截获了客户端的请求，发送自己的公钥，那客户端用这个公钥加密的密码，就能被攻击者用自己的私钥解密。这不是一个很大的漏洞吗？</p><h2 id="SSH如何做的？"><a href="#SSH如何做的？" class="headerlink" title="SSH如何做的？"></a>SSH如何做的？</h2><p>SSH有两种方式：1. 基于口令的认证；2.基于公钥认证</p><h3 id="基于口令的认证"><a href="#基于口令的认证" class="headerlink" title="基于口令的认证"></a>基于口令的认证</h3><p>从上面可以知道，我们的主要要解决的是“如何对服务端的公钥进行验证”，客户端只要对公钥进行确认下就OK了。通常在第一次登录的时候，系统会出现下面提示信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;ssh-server.example.com (12.18.429.21)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? </span><br></pre></td></tr></table></figure><p>上面的信息说的是：无法确认主机ssh-server.example.com（12.18.429.21）的真实性，不过知道它的公钥指纹，是否继续连接？</p><p>之所以用fingerprint代替key，主要是key过于长（RSA算法生成的公钥有1024位），很难直接比较。所以，对公钥进行hash生成一个128位的指纹，这样就方便比较了。</p><p><code>输入yes后，该host已被确认，并被追加到文件known_hosts中，然后就需要输入密码</code>。</p><h3 id="基于公钥认证"><a href="#基于公钥认证" class="headerlink" title="基于公钥认证"></a>基于公钥认证</h3><ol><li>客户端与服务端协商产生会话密钥；</li><li>客户端会向服务端发送一个登录请求（如：<a href="mailto:&#114;&#111;&#111;&#116;&#64;&#49;&#x39;&#50;&#x2e;&#x31;&#54;&#x38;&#x2e;&#49;&#x2e;&#50;">&#114;&#111;&#111;&#116;&#64;&#49;&#x39;&#50;&#x2e;&#x31;&#54;&#x38;&#x2e;&#49;&#x2e;&#50;</a>），发送的信息包括用户名root和root的公钥指纹，且所有信息都是通过会话密钥加密过的。</li><li>服务端通过会话密钥解密客户端发送的数据得到请求登录的用户名root和root的公钥指纹，然后读取root用户家目录下的所有公钥数据（&#x2F;root&#x2F;.ssh&#x2F;autorized_keys文件中），并分别通过单向加密算法获取各公钥的数据指纹与客户端发送过来的数据指纹做对比，从而找到客户端上的root用户的公钥；</li><li>服务端使用找到的客户端的公钥对一个随机数进行加密发送发送给客户端；</li><li>客户端使用私钥对服务端发送的随机数密文进行解密，然后把解密结果发送给服务端;</li><li>服务端验证客户端解密后的数据与自己发送的数据一致，则对客户端身份验证成功；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>程序的生命周期</title>
      <link href="/2019/07/01/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8CUIWindow/"/>
      <url>/2019/07/01/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8CUIWindow/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对App的生命周期和相关的方法触发做个笔记。</p><span id="more"></span><h2 id="程序的生命周期"><a href="#程序的生命周期" class="headerlink" title="程序的生命周期"></a>程序的生命周期</h2><img src="/2019/07/01/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8CUIWindow/applife.png" class=""><h3 id="应用程序的状态："><a href="#应用程序的状态：" class="headerlink" title="应用程序的状态："></a>应用程序的状态：</h3><ul><li>Not running未运行：程序没启动。</li><li>Inactive未激活：程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态。</li><li>Active激活：程序在前台运行而且接收到了事件。这也是前台的一个正常的模式。</li><li>Backgroud后台：程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态(Suspended)。有的程序经过特殊的请求后可以长期处于Backgroud状态。</li><li>Suspended挂起：程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</li></ul><h3 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h3><ul><li>application didFinishLaunchingWithOptions：当应用程序启动时执行，应用程序启动入口，只在应用程序启动时执行一次。若用户直接启动，lauchOptions内无数据,若通过其他方式启动应用，lauchOptions包含对应方式的内容。</li><li>applicationWillResignActive：在应用程序将要由活动状态切换到非活动状态时候，要执行的委托调用，如 按下 home 按钮，返回主屏幕，或全屏之间切换应用程序等。</li><li>applicationDidEnterBackground：在应用程序已进入后台程序时，要执行的委托调用。</li><li>applicationWillEnterForeground：在应用程序将要进入前台时(被激活)，要执行的委托调用，刚好与applicationWillResignActive 方法相对应。</li><li>applicationDidBecomeActive：在应用程序已被激活后，要执行的委托调用，刚好与applicationDidEnterBackground 方法相对应。</li><li>applicationWillTerminate：在应用程序要完全推出的时候，要执行的委托调用，这个需要要设置UIApplicationExitsOnSuspend的键值。</li></ul><h3 id="方法触发"><a href="#方法触发" class="headerlink" title="方法触发"></a>方法触发</h3><ul><li>初次启动：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iOS_didFinishLaunchingWithOptions</span><br><span class="line"></span><br><span class="line">iOS_applicationDidBecomeActive</span><br></pre></td></tr></table></figure><ul><li>按下home键：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iOS_applicationWillResignActive</span><br><span class="line"></span><br><span class="line">iOS_applicationDidEnterBackground</span><br></pre></td></tr></table></figure><ul><li>点击程序图标进入：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iOS_applicationWillEnterForeground</span><br><span class="line"></span><br><span class="line">iOS_applicationDidBecomeActive</span><br></pre></td></tr></table></figure><ul><li>点击通知进入：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applicationWillEnterForeground application:didReceiveRemoteNotification applicationDidBecomeActive</span><br></pre></td></tr></table></figure><ul><li>从其他APP切回来</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applicationWillEnterForeground application:openURL:sourceApplication applicationDidBecomeActive</span><br></pre></td></tr></table></figure><h2 id="图片说明"><a href="#图片说明" class="headerlink" title="图片说明"></a>图片说明</h2><img src="/2019/07/01/%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8CUIWindow/apprun.png" class="">]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> UI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UIApperance协议</title>
      <link href="/2019/06/26/UIApperance%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/06/26/UIApperance%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在iOS开发中有时候需要全局设置某个控件的属性</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UINavigationBar</span> appearance].barTintColor = xxx;</span><br></pre></td></tr></table></figure><p>那么它是如何实现的呢？</p><span id="more"></span><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>UIApperance</code>实际上是一个协议（Protocol），我们可以用它来获取一个类的外观代理（Apperance Proxy）.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)appearance;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)appearanceWhenContainedInInstancesOfClasses:(<span class="built_in">NSArray</span>&lt;Class &lt;<span class="built_in">UIAppearanceContainer</span>&gt;&gt; *)containerTypes <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</span><br><span class="line"><span class="comment">// 详细方法见 UIKit/UIAppearance.h</span></span><br></pre></td></tr></table></figure><p>另外一个与之对应的协议是<code>UIApperanceContainer</code>，该协议并没有任何约定方法。因为它只是一个容器。</p><p>UIView实现了这两种协议，既可以获取外观代理，也可以作为外观容器。<br>UIViewController则是仅实现了<code>UIApperanceContainer</code>协议。<br>对于我们继承与UIView的自定义控件，如果需要支持使用apperance来设置的属性，需要在属性后增加<code>UI_APPERANCE_SELECTOR</code>(并没有干什么事，如文档所说，只是 tag 一下)宏声明即可。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">To participate <span class="keyword">in</span> the appearance proxy API, tag your appearance property selectors <span class="keyword">in</span> your header with <span class="built_in">UI_APPEARANCE_SELECTOR</span>.</span><br><span class="line"></span><br><span class="line">Appearance property selectors must be of the form:</span><br><span class="line">- (<span class="type">void</span>)setProperty:(PropertyType)property forAxis1:(IntegerType)axis1 axis2:(IntegerType)axis2 axisN:(IntegerType)axisN;</span><br><span class="line">- (PropertyType)propertyForAxis1:(IntegerType)axis1 axis2:(IntegerType)axis2 axisN:(IntegerType)axisN;</span><br><span class="line">You may have no axes or as many as you like <span class="keyword">for</span> any property. PropertyType may be any standard iOS type: <span class="type">id</span>, <span class="built_in">NSInteger</span>, <span class="built_in">NSUInteger</span>, <span class="built_in">CGFloat</span>, <span class="built_in">CGPoint</span>, <span class="built_in">CGSize</span>, <span class="built_in">CGRect</span>, <span class="built_in">UIEdgeInsets</span> or <span class="built_in">UIOffset</span>. IntegerType must be either <span class="built_in">NSInteger</span> or <span class="built_in">NSUInteger</span>; we will throw an exception <span class="keyword">if</span> other types are used <span class="keyword">in</span> the axes.</span><br></pre></td></tr></table></figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>写一个简单的小 <a href="https://github.com/JackWchen2015/iOS_Demo/tree/master/TestUIApperance">Demo</a>，自定义 CardView，有两个 subview: headerView 和 footerView，声明 2 个属性：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *headerColor <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *bodyColor <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</span><br></pre></td></tr></table></figure><p>Setter 方法都加断点调试：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setHeaderColor:(<span class="built_in">UIColor</span> *)headerColor</span><br><span class="line">&#123;</span><br><span class="line">    _headerColor = headerColor;</span><br><span class="line">    <span class="keyword">self</span>.headerView.backgroundColor = _headerColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setBodyColor:(<span class="built_in">UIColor</span> *)bodyColor</span><br><span class="line">&#123;</span><br><span class="line">    _bodyColor = bodyColor;</span><br><span class="line">    <span class="keyword">self</span>.bodyView.backgroundColor = _bodyColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ViewController 的 view 中加一个按钮，点击则创建并添加 CardView，每行代码均加断点：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)createButtonTouched:(<span class="type">id</span>)sender</span><br><span class="line">CardView *cardView = [[CardView alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">20</span>, <span class="number">100</span>, <span class="number">80</span>, <span class="number">120</span>)];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:cardView];</span><br><span class="line">cardView.headerColor = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在较早的时候，添加 appearance 设置：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[CardView appearance].headerColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">[CardView appearance].bodyColor = [<span class="built_in">UIColor</span> orangeColor];</span><br></pre></td></tr></table></figure><p>运行发现，在通过 appearance 设置属性的时候，并没有调用 setter 方法，由此可知 appearance 并不会生成实例，立即赋值。当 cardView 被添加到主视图（即视图树）中去的时候，才依次调用两个 setter 方法，调用栈如下</p><img src="/2019/06/26/UIApperance%E5%8D%8F%E8%AE%AE/UIApperance_call_Track.png" class=""><p>从 15 至 11 可以看出确实是加入到视图树中才触发的，从 7 至 2 可以基本猜测出，appearance 设置的属性，都以 <code>Invocation</code> 的形式存储到 <code>UIApperance</code> 类中（事实上  UIApperance 类中就有一个 <code>_appearanceInvocations</code> 数组），等到视图树 performUpdates 的时候，会去检查有没有相关的属性设置，有则 invoke。(这里可以看看 <code>NSInvocation</code>)</p><p>紧接着，它进入了 bodyColor 的 setter</p><img src="/2019/06/26/UIApperance%E5%8D%8F%E8%AE%AE/UIApperance_Setter.png" class=""><p>然后，当手动设置属性的时候，它是直接进入 setter 的。</p><img src="/2019/06/26/UIApperance%E5%8D%8F%E8%AE%AE/UIApperance_handler.png" class=""><p>总结：</p><ol><li>每一个实现 UIAppearance 协议的类，都会有一个 _UIApperance 实例，保存着这个类通过 appearance 设置属性的 invocations，在该类被添加或应用到视图树上的时候，它会检查并调用这些属性设置。这样就实现了让所有该类的实例都自动统一属性。</li></ol><p>当然，如果后面又手动设置了属性，肯定会覆盖了。</p><p>2.去掉 UI_APPEARANCE_SELECTOR 宏声明，然后通过 appearance 设置属性，会发现结果是一样的。也就是说 UI_APPEARANCE_SELECTOR 并没有干什么事，正如文档所说，只是 tag 一下。看 UI_APPEARANCE_SELECTOR 宏定义如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UI_APPEARANCE_SELECTOR __attribute__((annotate(<span class="string">&quot;ui_appearance_selector&quot;</span>)))</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="https://hyancat.com/posts/2016/04/13/UIAppearance/">iOS UIAppearance 探秘</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> UI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS中的锁</title>
      <link href="/2019/06/02/iOS%E4%B8%AD%E7%9A%84%E9%94%81/"/>
      <url>/2019/06/02/iOS%E4%B8%AD%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在计算机科学中，锁是执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足，<br>锁分为建议锁和强制锁<br>建议锁：每个线程在访问对应资源前都需要获取锁的信息，再根据信息决定是否可以访问，若访问对应信息，锁的状态会改变为锁定，因此其它线程此时不会访问该资源，当资源结束后，会恢复锁的状态，允许其他线程的访问。<br>强制锁：若有未授权的线程想要访问锁定的数据，在访问时就会发生异常。</p></blockquote><span id="more"></span><p>iOS中，锁分为互斥锁，递归锁，信号量，条件锁，自旋锁，读写锁，分布式锁</p><h3 id="互斥锁-synchronized-NSLock"><a href="#互斥锁-synchronized-NSLock" class="headerlink" title="互斥锁   (@synchronized,NSLock)"></a>互斥锁   (@synchronized,NSLock)</h3><blockquote><p>在编程中，引入对象互斥锁的的概念，来保证共享数据操作的完整性，每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问对象。</p></blockquote><p>@synchronized要一个参数，这个参数相当于信号量</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用在防止多线程访问属性上比较多</span></span><br><span class="line">- (<span class="type">void</span>)setTestInt:(<span class="built_in">NSInteger</span>)testInt &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _testInt = testInt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><blockquote><p>何谓自旋锁？它是为实现保护共享资源而提出一种锁机制，其实，自旋锁与互斥锁比较类似，他们都是为了解决对某项资源的互斥使用。无论是互斥锁还是自旋锁，在任何时刻，最多只能有一个保持着，也就说，在任何时刻最多只能有一个执行单元获得锁，但是两者在调度机制上略有不同，对于互斥锁，如果资源已经被占用， 资源申请者只能进入睡眠状态，但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，“自旋”一词就是因此而得名。</p></blockquote><h4 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h4><p>使用方式</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">spinLock = OS_SPINKLOCK_INIT;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">OSSpinLockLock(&amp;spinLock);</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">OSSpinLockUnlock(&amp;spinLock);</span><br></pre></td></tr></table></figure><p>这个自旋锁存在优先级反转的问题,已经不再线程安全。</p><h4 id="自旋锁和互斥锁对比"><a href="#自旋锁和互斥锁对比" class="headerlink" title="自旋锁和互斥锁对比"></a>自旋锁和互斥锁对比</h4><p>自旋锁会忙等：所谓忙等，即在访问被锁资源时，调用者线程不会休眠，而是不停循环在那里，直到被锁资源释放锁。</p><p>互斥锁会休眠：所谓休眠，即在访问被锁资源时，调用者线程会休眠，此时CPU可以调度其他线程工作，直到被锁资源释放锁，此时会唤醒休眠线程。</p><p>如果能在短时间内获得锁，自旋锁的效率远高于互斥锁，如果不能在很短的时间获得锁，会使CPU效率降低，自旋锁不能实现递归调用。</p><h3 id="Dispatch-Semaphore（信号量）"><a href="#Dispatch-Semaphore（信号量）" class="headerlink" title="Dispatch Semaphore（信号量）"></a>Dispatch Semaphore（信号量）</h3><p>信号量其实就是用来保证访问资源的线程数，当信号量大于等于1时，资源可以访问，否则无法访问资源，直到其它线程释放资源。</p><p>主要有三个函数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t dispatch_semaphore_create(<span class="type">long</span> value);  <span class="comment">//创建一个dispatch_semaphore_t，value为初始信号量</span></span><br><span class="line"><span class="type">long</span> dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);   <span class="comment">//信号量-1</span></span><br><span class="line"><span class="type">long</span> dispatch_semaphore_signal(dispatch_semaphore_t dsema);   <span class="comment">//信号量+1</span></span><br></pre></td></tr></table></figure><p>注意：<br>同一个信号的dispatch_semaphore_wait与 异步操作不能在同一个线程中，否则异步操作会被卡住，也就不会执行到dispatch_semaphore_signal</p><p>两个线程交替打印Hello，world循环100次，如何实现？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)Action</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span>  queueA=dispatch_queue_create(<span class="string">&quot;com.Jack.SerialA&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span>  queueB=dispatch_queue_create(<span class="string">&quot;com.Jack.SerialB&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_semaphore_t  semaphoreA=dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    dispatch_semaphore_t  semaphoreB=dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queueA, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; ++i) &#123;</span><br><span class="line">             dispatch_semaphore_wait(semaphoreB, DISPATCH_TIME_FOREVER);</span><br><span class="line">             <span class="built_in">NSLog</span>(<span class="string">@&quot;%dHello&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">            dispatch_semaphore_signal(semaphoreA);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queueB, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; ++i) &#123;</span><br><span class="line">            dispatch_semaphore_wait(semaphoreA, DISPATCH_TIME_FOREVER);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%dWorld!&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">            dispatch_semaphore_signal(semaphoreB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><blockquote><p>读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分为读者和写者，读者只对共享资源进行读访问，写者只对共享资源进行写操作。允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数，写者是排他性的，一个读写锁同时只能有一个写者或多个读者，但不能同时既有读者又有写者。</p></blockquote><h4 id="dispatch-barrier-async和dispatch-barrier-sync（栅栏）"><a href="#dispatch-barrier-async和dispatch-barrier-sync（栅栏）" class="headerlink" title="dispatch_barrier_async和dispatch_barrier_sync（栅栏）"></a><code>dispatch_barrier_async</code>和<code>dispatch_barrier_sync</code>（栅栏）</h4><img src="/2019/06/02/iOS%E4%B8%AD%E7%9A%84%E9%94%81/syn01.png" class=""><p>相同：这两个函数的作用差不多，都是把它前面和它后面的函数分隔开，使它前面的任务先执行，再执行它添加的任务，最后执行它后面的任务</p><p>不同：提交任务的方式不同，一个是同步，一个是异步。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://juejin.im/post/5b4c179ee51d4518e3117c9f">iOS中常见的几种锁</a></li><li><a href="https://juejin.im/post/5a0a92996fb9a0451f307479">iOS多线程的锁</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS中的多线程NSOperation</title>
      <link href="/2019/06/01/NSOperation/"/>
      <url>/2019/06/01/NSOperation/</url>
      
        <content type="html"><![CDATA[<blockquote><p>NSOperation 是 OC 语言中基于 GCD 的面向对象的封装</p></blockquote><span id="more"></span><h2 id="NSOperation-与-GCD-的区别"><a href="#NSOperation-与-GCD-的区别" class="headerlink" title="NSOperation 与 GCD 的区别"></a>NSOperation 与 GCD 的区别</h2><img src="/2019/06/01/NSOperation/gcdvsNSOperation.png" class="&#x3D;"><h2 id="NSOperation-与-NSOperationQueue"><a href="#NSOperation-与-NSOperationQueue" class="headerlink" title="NSOperation 与 NSOperationQueue"></a>NSOperation 与 NSOperationQueue</h2><p><code>NSOperation</code> 需要和 <code>NSOperationQueue</code> 配合使用来实现多线程方案。<strong>单独使用 NSOperation 的话, 它是属于同步操作, 并不具备开启新线程的能力</strong>。</p><h3 id="NSOperation：操作"><a href="#NSOperation：操作" class="headerlink" title="NSOperation：操作"></a>NSOperation：操作</h3><ul><li>NSOperation 类是一个抽象类，不能直接使用它来封装任务，而是使用系统定义的子类（ NSInvocationOperation 或 NSBlockOperation）或者自定义子类来封装任务。</li><li>操作对象是一个单发对象，即它只执行一次任务，不能再次执行。通常通过将操作添加到操作队列来执行操作。</li></ul><h3 id="NSOperationQueue：队列"><a href="#NSOperationQueue：队列" class="headerlink" title="NSOperationQueue：队列"></a>NSOperationQueue：队列</h3><p> 获取主队列：<code>[NSOperationQueue mainQueue]</code><br> 获取当前队列：<code>[NSOperationQueue currentQueue] </code></p><h3 id="NSOperation-使用"><a href="#NSOperation-使用" class="headerlink" title="NSOperation 使用"></a>NSOperation 使用</h3><blockquote><p>如果不想使用 NSOperationQueue，可以通过调用 NSOperation 对象的start方法来自己执行操作。默认情况下，调用 NSOperation 的 start 方法并不会开一条新线程去执行操作，而是在当前线程同步执行操作。</p></blockquote><p> <strong>注意点：如果将操作添加到队列后，又调用 start 方法，会导致Crash</strong></p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *operation = [[<span class="built_in">NSInvocationOperation</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test) object:<span class="literal">nil</span>];</span><br><span class="line">    [queue addOperation:operation];</span><br><span class="line">    [operation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2020-02-03 03:49:07.027372+0800 多线程[11489:1903781] &lt;NSThread: 0x600003ee8140&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-02-03 03:49:07.031612+0800 多线程[11489:1903644] *** Terminating app due to uncaught exception &#x27;NSInvalidArgumentException&#x27;, </span></span><br><span class="line"><span class="comment">reason: &#x27;*** -[NSInvocationOperation start]: something is trying to start the receiver simultaneously from more than one thread&#x27;</span></span><br><span class="line"><span class="comment">*** First throw call stack:</span></span><br><span class="line"><span class="comment">(</span></span><br><span class="line"><span class="comment">    0   CoreFoundation                      0x00007fff23b98bde __exceptionPreprocess + 350</span></span><br><span class="line"><span class="comment">    1   libobjc.A.dylib                     0x00007fff503b5b20 objc_exception_throw + 48</span></span><br><span class="line"><span class="comment">    2   Foundation                          0x00007fff25653930 -[NSOperation start] + 1424</span></span><br><span class="line"><span class="comment">    ......</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">libc++abi.dylib: terminating with uncaught exception of type NSException</span></span><br><span class="line"><span class="comment">(lldb) </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>模拟图片下载完成后回到主线程更新 UI：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;下载图片,%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;下载完成更新UI,%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2020-01-20 10:32:55.807874+0800 多线程[28682:6334587] 下载图片,&lt;NSThread: 0x6000037dd480&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 10:32:55.808920+0800 多线程[28682:6334435] 下载完成更新UI,&lt;NSThread: 0x6000037a6680&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="NSOperation进阶"><a href="#NSOperation进阶" class="headerlink" title="NSOperation进阶"></a>NSOperation进阶</h3><h4 id="什么是并发数？"><a href="#什么是并发数？" class="headerlink" title="什么是并发数？"></a>什么是并发数？</h4><p> 并发数就是同时执行的任务数。<br> 比如，同时开3个线程执行3个任务，并发数就是3。<br> 但是，并发数是3，并不代表开启的线程数就是3，也有可能是4个或者5个。因为线程有可能在等待，进入了就绪状态。</p><p> <code>@property NSInteger maxConcurrentOperationCount;</code></p><h4 id="NSOperation-与-GCD-区别："><a href="#NSOperation-与-GCD-区别：" class="headerlink" title="NSOperation 与 GCD 区别："></a>NSOperation 与 GCD 区别：</h4><p> GCD 会自动重用线程，而 NSOperation 不会，会一直开线程。<br> 而开太多线程反而会影响效率，我们需要自己控制，一般开 3-6 个。</p><h4 id="队列的暂停-x2F-继续-x2F-取消操作"><a href="#队列的暂停-x2F-继续-x2F-取消操作" class="headerlink" title="队列的暂停&#x2F;继续&#x2F;取消操作"></a>队列的暂停&#x2F;继续&#x2F;取消操作</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> NSOperationQueue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// YES：暂停 / NO：继续（当前正在执行的操作会执行完毕，暂停后续的所有操作）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">getter</span>=isSuspended) <span class="type">BOOL</span> suspended; </span><br><span class="line"><span class="comment">// 取消队列中的所有操作（当前正在执行的操作会执行完毕，取消后续的所有操作）</span></span><br><span class="line">- (<span class="type">void</span>)cancelAllOperations;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> NSOperation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 也可以调用 NSOperation 的 cancel 方法移除单个操作</span></span><br><span class="line">- (<span class="type">void</span>)cancel；</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)start:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="keyword">self</span>.queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">    <span class="keyword">self</span>.queue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;开始&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.queue addOperationWithBlock:^&#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;操作%d,%@&quot;</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)suspend:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="keyword">self</span>.queue.suspended = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;暂停&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)resume:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    <span class="keyword">self</span>.queue.suspended = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;继续&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)cancel:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span>.queue cancelAllOperations];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;取消&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2020-01-20 19:40:36.128809+0800 多线程[29051:6389455] 开始</span></span><br><span class="line"><span class="comment">2020-01-20 19:40:37.133303+0800 多线程[29051:6389765] 操作0,&lt;NSThread: 0x60000161cb80&gt;&#123;number = 8, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 19:40:38.138239+0800 多线程[29051:6520475] 操作1,&lt;NSThread: 0x600001607440&gt;&#123;number = 9, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 19:40:39.142707+0800 多线程[29051:6389765] 操作2,&lt;NSThread: 0x60000161cb80&gt;&#123;number = 8, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 19:40:39.804264+0800 多线程[29051:6389455] 暂停</span></span><br><span class="line"><span class="comment">2020-01-20 19:40:40.145399+0800 多线程[29051:6520475] 操作3,&lt;NSThread: 0x600001607440&gt;&#123;number = 9, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 19:40:45.175465+0800 多线程[29051:6389455] 继续</span></span><br><span class="line"><span class="comment">2020-01-20 19:40:46.179761+0800 多线程[29051:6520475] 操作4,&lt;NSThread: 0x600001607440&gt;&#123;number = 9, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 19:40:47.184917+0800 多线程[29051:6520585] 操作5,&lt;NSThread: 0x6000016009c0&gt;&#123;number = 10, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 19:40:48.189422+0800 多线程[29051:6520585] 操作6,&lt;NSThread: 0x6000016009c0&gt;&#123;number = 10, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 19:40:49.192921+0800 多线程[29051:6520475] 操作7,&lt;NSThread: 0x600001607440&gt;&#123;number = 9, name = (null)&#125;</span></span><br><span class="line"><span class="comment">2020-01-20 19:40:49.748142+0800 多线程[29051:6389455] 取消</span></span><br><span class="line"><span class="comment">2020-01-20 19:40:50.198083+0800 多线程[29051:6520585] 操作8,&lt;NSThread: 0x6000016009c0&gt;&#123;number = 10, name = (null)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="操作执行状态控制"><a href="#操作执行状态控制" class="headerlink" title="操作执行状态控制"></a>操作执行状态控制</h4><p>操作的执行状态：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isReady) <span class="type">BOOL</span> ready;         <span class="comment">//就绪</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isExecuting) <span class="type">BOOL</span> executing; <span class="comment">//正在执行</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFinished) <span class="type">BOOL</span> finished;   <span class="comment">//完成</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isCancelled) <span class="type">BOOL</span> cancelled; <span class="comment">//取消</span></span><br></pre></td></tr></table></figure><h4 id="怎么控制-NSOperation-的状态？"><a href="#怎么控制-NSOperation-的状态？" class="headerlink" title="怎么控制 NSOperation 的状态？"></a>怎么控制 NSOperation 的状态？</h4><ul><li><p>如果只重写了main方法，底层控制变更操作执行完成状态，以及操作退出；</p></li><li><p>如果重写了start方法，自行控制任务状态。</p></li><li><p>系统是怎样移除一个isFinished &#x3D; YES的 NSOperation 的？</p><blockquote><p>通过KVO。</p></blockquote></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1615614">iOS - 多线程（四）：NSOperation</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS中的多线程</title>
      <link href="/2019/05/31/iOS%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/05/31/iOS%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>使用GCD后，可以不用浪费精力去关注线程，你只需要想清楚任务的执行方法（同步还是异步）和队列的运行方式（串行还是并行）即可。</p><p><code>任务是一个抽象概念，表示用来执行的一段代码，可以是一个block或者一个函数</code></p><span id="more"></span><h3 id="串行-x2F-并行和同步-x2F-异步"><a href="#串行-x2F-并行和同步-x2F-异步" class="headerlink" title="串行&#x2F;并行和同步&#x2F;异步"></a>串行&#x2F;并行和同步&#x2F;异步</h3><h4 id="串行-x2F-并行"><a href="#串行-x2F-并行" class="headerlink" title="串行&#x2F;并行"></a>串行&#x2F;并行</h4><p>在使用GCD的时候，会把需要处理的任务放到Block中，然后将任务追加到相应的队列里，这个队列就叫<em>Dispatch Queue</em>。然而，存在于两种Dispatch Queue，一种是<code>要等待上一个执行完，再执行下一个的Serial Dispatch Queue，这叫做串行队列</code>；另一种，则是<code>不需要上一个执行完，就能执行下一个的Concurrent Dispatch Queue，叫做并行队列</code>.这两种，均遵循FIFO原则。</p><ul><li><p>串行队列<br>串行队列一次只能执行一个任务，对应一个线程</p></li><li><p>并行队列<br>可以同时执行多个任务，系统会维护一个线程池来保证并行队列的执行。线程池会根据当前任务量自行安排线程的数量，以确保任务尽快执行。</p></li></ul><p>队列对应到代码里就是一个dispatch_queue对象：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)<span class="built_in">dispatch_queue_t</span> queue;</span><br></pre></td></tr></table></figure><h4 id="同步-x2F-异步"><a href="#同步-x2F-异步" class="headerlink" title="同步&#x2F;异步"></a>同步&#x2F;异步</h4><p>dispatch_async表示异步，将指定的Block“异步”加入Dispach Queue，不做任何等待</p><img src="/2019/05/31/iOS%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/async.png" class=""><p>dispatch_sync表示同步，将指定的Block“同步”的加入Dispatch Queue，在Block结束之前，dispatch_sync会一直等待</p><img src="/2019/05/31/iOS%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/sync.png" class=""><h3 id="串行队列死锁"><a href="#串行队列死锁" class="headerlink" title="串行队列死锁"></a>串行队列死锁</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>); <span class="comment">// 任务1</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;2&quot;</span>); <span class="comment">// 任务2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;3&quot;</span>); <span class="comment">// 任务3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出：1</span></span><br></pre></td></tr></table></figure><p>分析：</p><ol><li>dispatch_sync表示是一个同步线程；</li><li>dispatch_get_main_queue表示运行在主线程中的主队列；</li><li>任务2是同步线程的任务。</li></ol><p>首先执行任务1，这是肯定没问题的，只是接下来，程序遇到了同步线程，那么它会进入等待，等待任务2执行完，然后执行任务3。但这是队列，有任务来，当然会将任务加到队尾，然后遵循FIFO原则执行任务。那么，现在任务2就会被加到最后，任务3排在了任务2前面，问题来了：<br>任务3要等任务2执行完才能执行，任务2由排在任务3后面，意味着任务2要在任务3执行完才能执行，所以他们进入了互相等待的局面。【既然这样，那干脆就卡在这里吧】这就是死锁。</p><img src="/2019/05/31/iOS%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/GCD_lock.jpg" class=""><p>从这里看发生死锁需要2个条件：</p><ol><li>代码运行的当前队列是串行队列</li><li>使用sync将任务加入到自己队列中</li></ol><h3 id="队列优先级设置"><a href="#队列优先级设置" class="headerlink" title="队列优先级设置"></a>队列优先级设置</h3><ul><li>队列创建<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> dispatch_queue_create(<span class="keyword">const</span> <span class="type">char</span> *label, dispatch_queue_attr_t attr);</span><br><span class="line"><span class="comment">//label: 队列的名称，调试的时候可以区分其他的队列</span></span><br><span class="line"><span class="comment">//attr: 队列的属性，dispatch_queue_attr_t类型。用以标识队列串行，并行，以及优先级等信息</span></span><br></pre></td></tr></table></figure></li></ul><p>attr三种传值方式</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_SERIAL NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并行</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_CONCURRENT \</span></span><br><span class="line"><span class="meta">        DISPATCH_GLOBAL_OBJECT(dispatch_queue_attr_t, \</span></span><br><span class="line"><span class="meta">        _dispatch_queue_attr_concurrent)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义属性值</span></span><br><span class="line">dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, <span class="type">int</span> relative_priority);</span><br></pre></td></tr></table></figure><p>dispatch_queue_attr_make_with_qos_class函数可以创建带有优先级的dispatch_queue_attr_t对象。通过这个对象可以自定义queue的优先级。</p><h2 id="NSOperation-和-NSOperationQueue"><a href="#NSOperation-和-NSOperationQueue" class="headerlink" title="NSOperation 和 NSOperationQueue"></a>NSOperation 和 NSOperationQueue</h2><p>NSOperation是基于GCD开发的，但是比GCD拥有更强的可控性和代码可读性，NSOperation是一个抽象基类，表示一个独立的计算单元，可以为子类提供有用且线程安全的建立状态，优先级，依赖，和取消等操作。使用比较多的就是NSInvocationOperation和NSBlockOperation，更多的是定制</p><h3 id="NSInvocationOperation"><a href="#NSInvocationOperation" class="headerlink" title="NSInvocationOperation"></a>NSInvocationOperation</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSInvocationOperation</span> *invo = [[<span class="built_in">NSInvocationOperation</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test:) object:<span class="literal">nil</span>];</span><br><span class="line">    [invo start];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;111&quot;</span>);</span><br><span class="line">- (<span class="type">void</span>)test:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;test - %@ - %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread], string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2017-09-29 14:19:13.242517+0800 aegewgr[10143:3388734] <span class="built_in">test</span> - &lt;NSThread: 0x600000078180&gt;&#123;number = 1, name = main&#125; - (null)</span><br><span class="line">2017-09-29 14:19:13.242967+0800 aegewgr[10143:3388734] 111</span><br></pre></td></tr></table></figure><p>可以看到<code>NSInvocaionOperation是同步并且串行的</code>，主要还是要和NSOperationQueue结合使用</p><h3 id="NSBlockOperation"><a href="#NSBlockOperation" class="headerlink" title="NSBlockOperation"></a>NSBlockOperation</h3><p>NSBlockOperation支持并发的实行一个或多个block</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *blockOperation = [[<span class="built_in">NSBlockOperation</span> alloc]init];</span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;block 1 in thread:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;block 2 in thread:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;block 3 in thread:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;block 4 in thread:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;block 5 in thread:%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [blockOperation start];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017-09-29 14:32:03.710936+0800 aegewgr[10335:3439694] block 1 <span class="keyword">in</span> thread:&lt;NSThread: 0x60400006d740&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2017-09-29 14:32:03.710939+0800 aegewgr[10335:3439916] block 3 <span class="keyword">in</span> thread:&lt;NSThread: 0x60400027a780&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2017-09-29 14:32:03.710943+0800 aegewgr[10335:3439920] block 4 <span class="keyword">in</span> thread:&lt;NSThread: 0x60400027a840&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2017-09-29 14:32:03.710961+0800 aegewgr[10335:3439919] block 2 <span class="keyword">in</span> thread:&lt;NSThread: 0x600000270c00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-09-29 14:32:04.712532+0800 aegewgr[10335:3439920] block 5 <span class="keyword">in</span> thread:&lt;NSThread: 0x60400027a840&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2017-09-29 14:32:04.712932+0800 aegewgr[10335:3439694] 123</span><br></pre></td></tr></table></figure><p><code>NSBlockOperation也是同步的，而block的执行是并发的</code></p><h3 id="自定义NSOperation"><a href="#自定义NSOperation" class="headerlink" title="自定义NSOperation"></a>自定义NSOperation</h3><p>自定义NSOperaion分两种，一种是自定义非并发的NSOperaion，一种是自定义并发的NSOperaion</p><h3 id="定义非并发的NSOperaion"><a href="#定义非并发的NSOperaion" class="headerlink" title="定义非并发的NSOperaion"></a>定义非并发的NSOperaion</h3><p>只需要重写main方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;SerialNSOperation.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SerialNSOperation</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;main begin&quot;</span>);</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="comment">//在这里我们要创建自己的释放池，因为这里我们拿不到主线程的释放池</span></span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="comment">// 提供一个变量标识，来表示需要执行的操作是否完成了，当然，没开始执行之前，为NO</span></span><br><span class="line">            <span class="type">BOOL</span> taskIsFinished = <span class="literal">NO</span>;</span><br><span class="line">            <span class="comment">// while 保证：只有当没有执行完成和没有被取消，才执行自定义的相应操作</span></span><br><span class="line">            <span class="keyword">while</span> (taskIsFinished == <span class="literal">NO</span> &amp;&amp; [<span class="keyword">self</span> isCancelled] == <span class="literal">NO</span>)&#123;</span><br><span class="line">                <span class="comment">// 自定义的操作</span></span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;currentThread = %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">                sleep(<span class="number">10</span>);  <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                <span class="comment">// 这里相应的操作都已经完成，后面就是要通知KVO我们的操作完成了。</span></span><br><span class="line">                taskIsFinished = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> * e) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Exception %@&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;main end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接使用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SerialNSOperation *op = [[SerialNSOperation alloc]init];</span><br><span class="line">[op start];</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-09-29 15:12:59.151481+0800 aegewgr[10524:3564080] main begin</span><br><span class="line">2017-09-29 15:13:09.152082+0800 aegewgr[10524:3564080] currentThread = &lt;NSThread: 0x60400006e1c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2017-09-29 15:13:09.152299+0800 aegewgr[10524:3564080] main end</span><br></pre></td></tr></table></figure><p>实用性不大</p><h3 id="定义并发的NSOperation"><a href="#定义并发的NSOperation" class="headerlink" title="定义并发的NSOperation"></a>定义并发的NSOperation</h3><ol><li>start方法：该方法必须实现，</li><li>main:该方法可选，如果你在start方法中定义了你的任务，则这个方法就可以不实现，但通常为了代码逻辑清晰，通常会在该方法中定义自己的任务</li><li>isExecuting isFinished 主要作用是在线程状态改变时，产生适当的KVO通知</li><li>isAsynchronous :必须覆盖并返回YES;</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ConcurrentOperation</span> : <span class="title">NSOperation</span></span>&#123;</span><br><span class="line">    <span class="type">BOOL</span> executing;</span><br><span class="line">    <span class="type">BOOL</span> finished;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//.m</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;ConcurrentOperation.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ConcurrentOperation</span></span></span><br><span class="line">- (<span class="type">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span> = [<span class="variable language_">super</span> init])</span><br><span class="line">    &#123;</span><br><span class="line">        executing = <span class="literal">NO</span>;</span><br><span class="line">        finished = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">BOOL</span>)isAsynchronous &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">BOOL</span>)isExecuting &#123;</span><br><span class="line">    <span class="keyword">return</span> executing;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">BOOL</span>)isFinished &#123;</span><br><span class="line">    <span class="keyword">return</span> finished;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)start &#123;</span><br><span class="line">    <span class="comment">//第一步就要检测是否被取消了，如果取消了，要实现相应的KVO</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;isFinished&quot;</span>];</span><br><span class="line">        finished = <span class="literal">YES</span>;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;isFinished&quot;</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没被取消，开始执行任务</span></span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;isExecuting&quot;</span>];</span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(main) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line">    executing = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;isExecuting&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)main &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;main begin&quot;</span>);</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="comment">//在这里定义自己的并发任务</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;自定义并发操作NSOperation&quot;</span>);</span><br><span class="line">            <span class="built_in">NSThread</span> *thread = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;current Thread:%@&quot;</span>,thread);</span><br><span class="line">            <span class="comment">//任务执行完成后要实现相应的KVO</span></span><br><span class="line">            [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;isFinished&quot;</span>];</span><br><span class="line">            [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;isExecuting&quot;</span>];</span><br><span class="line">            executing = <span class="literal">NO</span>;</span><br><span class="line">            finished = <span class="literal">YES</span>;</span><br><span class="line">            [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;isExecuting&quot;</span>];</span><br><span class="line">            [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;isFinished&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> * e) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Exception %@&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;main end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">    ConcurrentOperation *op1 = [[ConcurrentOperation alloc]init];</span><br><span class="line">    ConcurrentOperation *op2 = [[ConcurrentOperation alloc]init];</span><br><span class="line">    ConcurrentOperation *op3 = [[ConcurrentOperation alloc]init];</span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    [queue addOperation:op3];    </span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-29</span> <span class="number">15</span>:<span class="number">34</span>:<span class="number">15.158649</span>+<span class="number">0800</span> aegewgr[<span class="number">10664</span>:<span class="number">3638228</span>] main begin</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-29</span> <span class="number">15</span>:<span class="number">34</span>:<span class="number">15.158653</span>+<span class="number">0800</span> aegewgr[<span class="number">10664</span>:<span class="number">3638226</span>] main begin</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-29</span> <span class="number">15</span>:<span class="number">34</span>:<span class="number">15.158675</span>+<span class="number">0800</span> aegewgr[<span class="number">10664</span>:<span class="number">3638227</span>] main begin</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-29</span> <span class="number">15</span>:<span class="number">34</span>:<span class="number">15.158912</span>+<span class="number">0800</span> aegewgr[<span class="number">10664</span>:<span class="number">3638228</span>] 自定义并发操作<span class="built_in">NSOperation</span></span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-29</span> <span class="number">15</span>:<span class="number">34</span>:<span class="number">15.159321</span>+<span class="number">0800</span> aegewgr[<span class="number">10664</span>:<span class="number">3638226</span>] 自定义并发操作<span class="built_in">NSOperation</span></span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-29</span> <span class="number">15</span>:<span class="number">34</span>:<span class="number">15.159372</span>+<span class="number">0800</span> aegewgr[<span class="number">10664</span>:<span class="number">3638227</span>] 自定义并发操作<span class="built_in">NSOperation</span></span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-29</span> <span class="number">15</span>:<span class="number">34</span>:<span class="number">15.159965</span>+<span class="number">0800</span> aegewgr[<span class="number">10664</span>:<span class="number">3638226</span>] current Thread:&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400046b640</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-29</span> <span class="number">15</span>:<span class="number">34</span>:<span class="number">15.160014</span>+<span class="number">0800</span> aegewgr[<span class="number">10664</span>:<span class="number">3638228</span>] current Thread:&lt;<span class="built_in">NSThread</span>: <span class="number">0x60000026d140</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-29</span> <span class="number">15</span>:<span class="number">34</span>:<span class="number">15.160103</span>+<span class="number">0800</span> aegewgr[<span class="number">10664</span>:<span class="number">3638227</span>] current Thread:&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400046b5c0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-29</span> <span class="number">15</span>:<span class="number">34</span>:<span class="number">15.160799</span>+<span class="number">0800</span> aegewgr[<span class="number">10664</span>:<span class="number">3638226</span>] main end</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-29</span> <span class="number">15</span>:<span class="number">34</span>:<span class="number">15.160973</span>+<span class="number">0800</span> aegewgr[<span class="number">10664</span>:<span class="number">3638227</span>] main end</span><br><span class="line"><span class="number">2017</span><span class="number">-09</span><span class="number">-29</span> <span class="number">15</span>:<span class="number">34</span>:<span class="number">15.161154</span>+<span class="number">0800</span> aegewgr[<span class="number">10664</span>:<span class="number">3638228</span>] main end</span><br></pre></td></tr></table></figure><h3 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h3><p>NSOperationQueue就是执行NSOperation的队列，我们可以将一个或多个NSOperation对象放到队列中去执行。NSOpetaionQueue有两种不同类型的队列：主队列和自定义队列。主队列运行在主线程上，而自定义队列在后台执行。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *mainQueue = [<span class="built_in">NSOperationQueue</span> mainQueue];  <span class="comment">//主队列</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init]; <span class="comment">//自定义队列</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="comment">//任务执行</span></span><br><span class="line">&#125;];</span><br><span class="line">[queue addOperation:operation];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="maxConcurrentOperationCount默认值"><a href="#maxConcurrentOperationCount默认值" class="headerlink" title="maxConcurrentOperationCount默认值"></a>maxConcurrentOperationCount默认值</h4><p>maxConcurrentOperationCount 最大并发操作数。用来控制一个特定队列中可以有多少个操作同时参与并发执行</p><p>maxConcurrentOperationCount 默认情况下为-1，表示不进行限制，可进行并发执行。<br>maxConcurrentOperationCount 为1时，队列为串行队列。只能串行执行<br>maxConcurrentOperationCount大于1时，队列为并发队列。操作并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为 min{自己设定的值，系统设定的默认最大值}。</p><h2 id="GCD与NSOperationQueue有哪些异同？"><a href="#GCD与NSOperationQueue有哪些异同？" class="headerlink" title="GCD与NSOperationQueue有哪些异同？"></a>GCD与NSOperationQueue有哪些异同？</h2><ol><li>GCD 是纯 C 语言的 API 。NSOperationQueue 是基于 GCD 的 OC 的封装。</li><li>GCD 只支持 FIFO 队列，NSOperationQueue 可以方便设置执行顺序，设置最大的并发数量。</li><li>NSOperationQueue 可是方便的设置 operation 之间的依赖关系，GCD 则需要很多代码。</li><li>NSOperationQueue 支持 KVO，可以检测 operation 是否正在执行（isExecuted），是否结束（isFinished），是否取消（isCanceled）</li><li>NSOperationQueue可以很方便的取消一个NSOperation的执行。</li></ol><p>使用场合：</p><ul><li>任务之间不太相互依赖：GCD</li><li>任务之间有依赖或要监听任务的执行情况：NSOperationQueue</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol start="2"><li><a href="https://www.jianshu.com/p/2dd000a8f072">iOS多线程详解</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程安全</title>
      <link href="/2019/05/31/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>/2019/05/31/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="并行-和-并发-有什么区别？"><a href="#并行-和-并发-有什么区别？" class="headerlink" title="并行 和 并发 有什么区别？"></a>并行 和 并发 有什么区别？</h3><p>并行：充分利用计算机的多核，在多个线程上同步进行 (多个操作同时进行)</p><p>并发：在一条线程上通过快速切换，让人感觉在同步进行（多个操作同时存在）</p><blockquote><p>如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。</p><p>在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。</p><p>我相信你已经能够得出结论——“并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。</p><p>摘自：《并发的艺术》 — 〔美〕布雷谢斯</p></blockquote><span id="more"></span><h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><ul><li><p>堆：是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。</p></li><li><p>栈：是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，<strong>栈是thread safe的</strong>。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。</p></li></ul><p>与线程“绑定”的是栈，用于存储自动变量。每一个线程建立的时候，都会新建一个默认栈与之配合。堆则是通常与进程相关，用于存储全局性的变量，进程建立的时候，会建立默认堆。于是，每一个线程都有自己的栈，然后访问共同的堆。当然，你可以通过OS API建立其他堆栈。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>多条线程同时工作的情况下，通过运用线程锁，原子性等方法避免多条线程因为同时访问同一块内存造成的数据错误或冲突。</p><h3 id="多线程数据为什么不安全"><a href="#多线程数据为什么不安全" class="headerlink" title="多线程数据为什么不安全"></a>多线程数据为什么不安全</h3><p>目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。</p><p>在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。</p><p><code>每条线程都有自己独立的栈空间，但是他们公用了堆，所以他们肯能同时访问同一块内存空间，因此造成数据冲突。</code></p><h3 id="多线程之间共享、独享哪些资源呢？"><a href="#多线程之间共享、独享哪些资源呢？" class="headerlink" title="多线程之间共享、独享哪些资源呢？"></a>多线程之间共享、独享哪些资源呢？</h3><ul><li>共享资源:</li></ul><ol><li>堆  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆）</li><li>全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的</li><li>静态变量 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存在于堆中开辟的.bss和.data段，是共享的。</li><li>文件等公用资源 这个是共享的</li></ol><ul><li>独享的资源</li></ul><ol><li>栈</li><li>寄存器 这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC</li></ol><h2 id="解决线程安全的方法"><a href="#解决线程安全的方法" class="headerlink" title="解决线程安全的方法"></a>解决线程安全的方法</h2><p>线程锁，原子性</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程</title>
      <link href="/2019/05/31/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/05/31/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>一开始，CPU 只有在执行完一份完整的任务代码后，才能执行下一份。后来，通过把 CPU 时间分片，可以让多个任务“看似”同时地执行。</p><p>为了更好地区分这些“同时”执行的任务以及整合各自资源，人们就提出了 process 这个概念。</p><span id="more"></span><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><h3 id="为了整合资源"><a href="#为了整合资源" class="headerlink" title="为了整合资源"></a>为了整合资源</h3><p>一开始，CPU 只有在执行完一份完整的任务代码后，才能执行下一份。后来，通过把 CPU 时间分片，可以让多个任务“看似”同时地执行。</p><p>为了更好地区分这些“同时”执行的任务以及整合各自资源，人们就提出了 process 这个概念</p><blockquote><p>A process is basically a program in execution… It is fundamentally a container that holds all the information needed to run a program.</p></blockquote><p>每个 process 都有独立的下列资源：</p><ul><li>address space：a list of memory locations from 0 to some maximum, which the process can read and write.</li><li>resource：commonly including registers (including the program counter and stack pointer), a list of related processes, and all the other information needed to run the program.</li></ul><p>process 之间要的通信要通过 IPC（inter-process communication）来实现。</p><h3 id="为了提高效率"><a href="#为了提高效率" class="headerlink" title="为了提高效率"></a>为了提高效率</h3><p>原始的 process 只有一个“thread of control”来执行任务，后来人们发现如果一个 process 中能够有“multiple threads of control”，让它们共享 process 资源并相互协作，将会大大提高效率。由此，人们提出了 thread 这个概念。</p><p>每个 thread 都拥有自己 stack，用来记录执行历史。</p><p>正如前面所说，为了提高效率，threads 之间共享 process 的 address space 和 resource。由于 address space 共享，thread A 可以几乎毫无障碍地修改 thread B 上的数据。</p><p>为什么不在 thread 之间设置一定的保护（其实在多进程场景设计时，需要考虑进程同步与死锁的问题，这里的保护指的是其他的保护措施）呢？</p><blockquote><p>Unlike different processes, which may be from different users and which may be hostile to one another, a process is always owned by a single user, who has presumably created multiple threads so that they can cooperate, not fight.</p></blockquote><p>为什么不用多进程（multi-processes）而是使用多线程（multi-threads）来协作呢？</p><blockquote><p>…they are lighter weight than processes, they are easier (i.e., faster) to create and destroy than processes. In many systems, creating a thread goes 10-100 times faster than creating a process.</p></blockquote><p>而且，process 之间的资源共享和信息传递（IPC）不如 thread 高效（共享 address space 和 resource）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>process 模型体系由两个独立的概念（resource grouping 和 execution）组成，解释如下：</p><blockquote><p>resource grouping：One way of looking at a process is that it is a way to group related resources together. A process has an address space containing program text and data, as well as other resource. These resources may include open files, child processes, pending alarms, signal handlers, accounting information, and more. By putting them together in the form of a process, they can be managed more easily.</p></blockquote><blockquote><p>execution：The other concept a process has is a thread of control, usually shortened to just thread. The thread has a program counter that keeps track of which instruction to execute next. It has registers, which hold its current working variables. It has a stack, which contains the execution history, with one frame for each procedure called but not yet returned from.</p></blockquote><p>process 和 thread 虽然联系紧密，但从概念上区分的话，可以这么认为：</p><p><strong>processes are used to group resources together; threads are the entities scheduled for execution on the CPU.</strong></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>同一个 process 可以同时存在多个 thread；<br>同一个 process 下的 Thread 共享 process 的资源，如内存、变量等，而不同的 process 则不能如此；<br>在多线程（Multi threading）中，两个线程如果同时存取或改变全局变量（Golbal Variable），则可能发生同步（Synchronization）的问题。如果线程之间互抢资源，则可能产生死锁（Dead Lock）。在编写多线程程序时，需要特别注意这两种情况。</p><h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><p>进程:进程基本上是那些从就绪状态调遣出来的程序，它们被安排在CPU中执行。PCB(进程控制块)包含进程的概念。进程可以创建其他进程，这些进程称为子进程。该进程需要更多的时间来终止，它是孤立的意味着它不与任何其他进程共享内存。 </p><p>进程可以具有以下状态:新建、就绪、运行、等待、终止和挂起。 </p><p>线程:线程是进程的一部分，这意味着一个进程可以有多个线程，这些线程包含在一个进程中。线程有三种状态:运行中、就绪和阻塞。 </p><p>与进程相比，线程终止所需的时间更短，但与进程不同的是，线程不会隔离。</p><blockquote><p>Process: Processes are basically the programs that are dispatched from the ready state and are scheduled in the CPU for execution. PCB(Process Control Block) holds the concept of process. A process can create other processes which are known as Child Processes. The process takes more time to terminate and it is isolated means it does not share the memory with any other process.</p></blockquote><blockquote><p>The process can have the following states new, ready, running, waiting, terminated, and suspended.</p></blockquote><blockquote><p>Thread: Thread is the segment of a process which means a process can have multiple threads and these multiple threads are contained within a process. A thread has three states: Running, Ready, and Blocked.</p></blockquote><blockquote><p>The thread takes less time to terminate as compared to the process but unlike the process, threads do not isolate.</p></blockquote><img src="/2019/05/31/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/progress_thread.png" class="&#x3D;"><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><p>进程：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. </p></li><li><p>线程：线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.</p></li></ul><p>线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.geeksforgeeks.org/difference-between-process-and-thread/">Difference between Process and Thread</a><br><a href="https://liitdar.blog.csdn.net/article/details/80991865">进程（process）和线程（thread）介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MMKV分析mmap</title>
      <link href="/2019/05/20/MMKV%E5%88%86%E6%9E%90mmap/"/>
      <url>/2019/05/20/MMKV%E5%88%86%E6%9E%90mmap/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>为了保证每一个进程都能安全的执行。现代OS中，CPU运行有两种模式：“用户模式”与“内核模式”。</p><blockquote><p>内核模式下，应用具有对硬件的所有控制权，可以执行所有CPU指令，可以访问任意地址内存，在内核模式下的任何异常都是灾难性的，将会导致整台机器停机。</p></blockquote><p>一些容易发生安全问题的操作都被限制在只有内核模式下才可以执行，例如I&#x2F;O操作，修改基址寄存器内容等。</p><blockquote><p>用户模式下，应用没有对硬件的直接控制权，也不能直接访问地址的内存，程序是通过调用系统API来达到访问硬件和内存，这种保护模式下，即使应用发生崩溃也是可以恢复的。</p></blockquote><p>应用程序代码运行在用户模式下，当应用程序需要实现内核模式下的指令时，先向系统发送调用请求，操作系统收到请求后，执行系统调用接口，使处理器进入内核模式，当处理器完成系统调用操作后，OS会让处理器返回用户模式，继续执行用户代码。</p><p><code>连接用户模式和内核模式的接口称之为系统调用</code></p><p>应用程序中十大对文件的操作过程就是典型的系统调用过程。</p> <span id="more"></span><h4 id="虚拟文件系统-VFS"><a href="#虚拟文件系统-VFS" class="headerlink" title="虚拟文件系统  VFS"></a>虚拟文件系统  VFS</h4><p>一个操作系统可以支持多种底层不同的文件系统（比如NTFS, FAT, ext3, ext4），通过使用同一套I&#x2F;O系统调用即可对Linux中的任意文件进行操作而无需考虑其所在的具体文件系统格式，Linux在用户进程和底层文件系统之间加入了一个抽象层，即虚拟文件系统(Virtual File System, VFS)，进程所有的文件操作都通过VFS，由VFS来适配各种底层不同的文件系统，完成实际的文件操作。</p><h4 id="Linux进程的虚拟内存"><a href="#Linux进程的虚拟内存" class="headerlink" title="Linux进程的虚拟内存"></a>Linux进程的虚拟内存</h4> <img src="/2019/05/20/MMKV%E5%88%86%E6%9E%90mmap/Linux_vitrual_Mem.jpeg" class="" title="一个Linux进程的虚拟内存"><p>进程的虚拟地址空间可分为两部分，内核空间和用户空间，内核空间中放的是内核代码和数据，而进程的用户空间中存放的是用户代码和程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.虚拟的意思是进程以为自己有这么一大块内存，实际上物理内存可能还没有分配给它，等到缺页异常是系统才会分配，</span><br><span class="line">通过这种以时间换空间的方式提高了内存利用效率。从虚拟内存到物理内存的映射过程需要一个专门的硬件单元MMU来完</span><br><span class="line">成。</span><br><span class="line">2. 系统调用的代码和数据就在内核虚拟内存中， </span><br><span class="line">3. 因为在保护模式下，用户态进程无法访问到这里，必须要通过系统调用的方式陷入到内核态才行。</span><br></pre></td></tr></table></figure><h3 id="MMKV"><a href="#MMKV" class="headerlink" title="MMKV"></a>MMKV</h3><p> <a href="https://github.com/Tencent/MMKV">MMKV</a>是基于 mmap 内存映射的 key-value 组件，底层序列化&#x2F;反序列化使用 protobuf 实现，性能高，稳定性强。</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><ol><li>内存准备<br>通过 mmap 内存映射文件，提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统负责将内存回写到文件，不必担心 crash 导致数据丢失。</li><li>数据组织<br>数据序列化方面我们选用 protobuf 协议，pb 在性能和空间占用上都有不错的表现。</li><li>写入优化<br>考虑到主要使用场景是频繁地进行写入更新，我们需要有增量更新的能力。我们考虑将增量 kv 对象序列化后，append 到内存末尾。</li><li>空间增长<br>使用 append 实现增量更新带来了一个新的问题，就是不断 append 的话，文件大小会增长得不可控。我们需要在性能和空间上做个折中。</li></ol><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><h4 id="为什么mmap-可以节约IO读写时间"><a href="#为什么mmap-可以节约IO读写时间" class="headerlink" title="为什么mmap()可以节约IO读写时间?"></a>为什么mmap()可以节约IO读写时间?</h4><ul><li>常规文件读写流程</li></ul><ol><li>读文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、进程调用库函数向内核发起读文件请求；</span><br><span class="line"></span><br><span class="line">2、内核通过检查进程的文件描述符定位到虚拟文件系统的已打开文件列表表项；</span><br><span class="line"></span><br><span class="line">3、调用该文件可用的系统调用函数read()</span><br><span class="line"></span><br><span class="line">3、read()函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的inode；</span><br><span class="line"></span><br><span class="line">4、在inode中，通过文件内容偏移量计算出要读取的页；</span><br><span class="line"></span><br><span class="line">5、通过inode找到文件对应的address_space；</span><br><span class="line"></span><br><span class="line">6、在address_space中访问该文件的页缓存树，查找对应的页缓存结点：</span><br><span class="line"></span><br><span class="line">（1）如果页缓存命中，那么直接返回文件内容；</span><br><span class="line"></span><br><span class="line">（2）如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第6步查找页缓存；</span><br><span class="line"></span><br><span class="line">7、文件内容读取成功。</span><br></pre></td></tr></table></figure><img src="/2019/05/20/MMKV%E5%88%86%E6%9E%90mmap/read.jpeg" class="" title="read系统调用原理"><ol start="2"><li>写文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">写文件</span><br><span class="line"></span><br><span class="line">前5步和读文件一致，在address_space中查询对应页的页缓存是否存在：</span><br><span class="line"></span><br><span class="line">6、如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了。这时候文件修改位于页缓存，并没有写回到磁盘文件中去。</span><br><span class="line"></span><br><span class="line">7、如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第6步。</span><br><span class="line"></span><br><span class="line">8、一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘：</span><br><span class="line"></span><br><span class="line">（1）手动调用sync()或者fsync()系统调用把脏页写回</span><br><span class="line"></span><br><span class="line">（2）pdflush进程会定时把脏页写回到磁盘</span><br><span class="line"></span><br><span class="line">同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。</span><br></pre></td></tr></table></figure><ul><li>内存映射读写流程<br>具体操作方式是：open一个文件，然后调用mmap系统调用，将文件的内容的全部或一部分直接映射到进程的地址空间，映射完成后，进程可以像访问普通内存一样做其他的操作，比如memcpy等等。mmap并不分配物理地址空间，它只是占有进程的虚拟地址空间。这跟常规文件读写方式不一样的，常规文件读写方式需要预先分配好物理内存，内核才能将页高速缓冲中的文件数据拷贝到用户进程指定的内存空间中。</li></ul><p>而内存映射读写方式，当多个进程需要同时访问同一个文件时，每个进程都将文件所存储的内核高速缓冲映射到自己的进程地址空间。当第一个进程访问内核中的缓冲区时候，前面讲过并没有实际拷贝数据，这时MMU在地址映射表中是无法找到与ptr相对应的物理地址的，也就是MMU失败，就会触发缺页中断。内核将文件的这一页数据读入到内核高速缓冲区中，并更新进程的页表，使页表指向内核缓冲中的这一页。之后有其他的进程再次访问这一页的时候，该页已经在内存中了，内核只需要将进程的页表登记并且指向内核的页高速缓冲区即可。</p><img src="/2019/05/20/MMKV%E5%88%86%E6%9E%90mmap/mmap_mmu.jpeg" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span> <span class="comment">/* for mmap and munmap */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">/* for open */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> <span class="comment">/* for open */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> <span class="comment">/* for open */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">/* for lseek and write */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="type">char</span> *mapped_mem, * p;</span><br><span class="line"> <span class="type">int</span> flength = <span class="number">1024</span>;</span><br><span class="line"> <span class="type">void</span> * start_addr = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"> fd = open(argv[<span class="number">1</span>], O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);</span><br><span class="line"> flength = lseek(fd, <span class="number">1</span>, SEEK_END);</span><br><span class="line"> write(fd, <span class="string">&quot;&quot;</span>, <span class="number">1</span>); <span class="comment">/* 在文件最后添加一个空字符，以便下面printf正常工作 */</span></span><br><span class="line"> lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"> mapped_mem = mmap(start_addr, flength, PROT_READ, <span class="comment">//允许读</span></span><br><span class="line"> MAP_PRIVATE, <span class="comment">//不允许其它进程访问此内存区域</span></span><br><span class="line"> fd, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 使用映射区域. */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, mapped_mem); <span class="comment">/* 为了保证这里工作正常，参数传递的文件名最好是一个文本文件 */</span></span><br><span class="line"> close(fd);</span><br><span class="line"> munmap(mapped_mem, flength);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mmap和常规文件操作的区别"><a href="#mmap和常规文件操作的区别" class="headerlink" title="mmap和常规文件操作的区别"></a>mmap和常规文件操作的区别</h4><ol><li>常规文件读写</li></ol><ul><li><p>两次拷贝  (磁盘-&gt;内核，内核-&gt;用户态)<br>常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制，这是由OS控制的。这样造成读文件时需要先将<br>文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数<br>据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任<br>务。<br>写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘<br>中（延迟写回），也是需要两次数据拷贝。</p></li><li><p>当存在多个进程同时读取同一个文件时，每一个进程中的地址空间都会保存一份副本，这样肯定不是最优方式的，造成了物理内存的浪费</p></li></ul><img src="/2019/05/20/MMKV%E5%88%86%E6%9E%90mmap/readOpen.jpeg" class=""><ol start="2"><li>mmap文件操作</li></ol><p>内存映射，简而言之就是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空间&lt;—-&gt;用户空间两者之间需要大量数据传输等操作的话效率是非常高的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用mmap操作文件中，由于不需要经过内核空间的数据缓存，只使用一次数据拷贝，就从磁盘中将数据传入内存</span><br><span class="line">的用户空间中，供进程使用。 </span><br><span class="line"> mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。</span><br></pre></td></tr></table></figure><img src="/2019/05/20/MMKV%E5%88%86%E6%9E%90mmap/mmap.jpeg" class="" title="内存映射原理"><h3 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h3><ol><li><a href="https://www.cnblogs.com/huxiao-tee/p/4657851.html">从内核文件系统看文件读写过程</a></li><li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html">认真分析mmap：是什么 为什么 怎么用</a></li><li><a href="https://blog.csdn.net/yusiguyuan/article/details/23388771">linux内存映射mmap原理分析</a></li><li><a href="https://cloud.tencent.com/developer/article/1145377">理解mmap</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Objective-C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS Pod私有库发布</title>
      <link href="/2019/04/20/iOS%20Pod%E7%A7%81%E6%9C%89%E5%BA%93%E5%8F%91%E5%B8%83/"/>
      <url>/2019/04/20/iOS%20Pod%E7%A7%81%E6%9C%89%E5%BA%93%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<p>为了提高项目中代码的复用，通常会把耦合度低的模块解耦出来做成Pod库放在私有仓库上，很多To B的业务，需要制作SDK给第三方使用，这时候需要提供静态framework给第三方。</p><span id="more"></span><h2 id="静态库生成"><a href="#静态库生成" class="headerlink" title="静态库生成"></a>静态库生成</h2><h3 id="模块说明书PodSpec"><a href="#模块说明书PodSpec" class="headerlink" title="模块说明书PodSpec"></a>模块说明书PodSpec</h3><p>我们把podspec文件上传给cocoapod的master上，当别人配置好CocoaPods就会把我们的podspec.json下载到&#x2F;.cocoapods&#x2F;repos&#x2F;master&#x2F;下，用户要使用AFNetworking查找本地&#x2F;.cocoapods&#x2F;repos&#x2F;master&#x2F; 找到这个AFNetworking.podspec.json文件根据内容下载配置。</p><p>podspec文件就是充当了一个我们源代码模块的说明书，告诉开发者我们模块名称，我们用途，可以在哪下载源代码 ，需要如何配置。 </p><h4 id="podspec创建"><a href="#podspec创建" class="headerlink" title="podspec创建"></a>podspec创建</h4><p>pod 还提供了一个一条龙服务的命令：pod lib create 会帮我们创建一个跟项目名称相同podspec文件 测试project 工程 测试框架。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create XXXX</span><br></pre></td></tr></table></figure><h4 id="podspec常用属性说明"><a href="#podspec常用属性说明" class="headerlink" title="podspec常用属性说明"></a>podspec常用属性说明</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title class_">Pod::Spec</span>.new <span class="keyword">do</span>|<span class="params">s</span>|</span><br><span class="line">  /<span class="regexp">/项目名</span></span><br><span class="line"><span class="regexp">  s.name =&#x27;Project&#x27;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/版本号</span></span><br><span class="line"><span class="regexp">  s.version =&#x27;1.0.1&#x27;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/listen文件的类型</span></span><br><span class="line"><span class="regexp">  s.license = &#x27;MIT&#x27;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/简单描述</span></span><br><span class="line"><span class="regexp">  s.summary = &#x27;ATest in iOS.&#x27;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/项目的getub地址，只支持HTTP和HTTPS地址，不支持ssh的地址</span></span><br><span class="line"><span class="regexp">  s.homepage =&#x27;https:/</span><span class="regexp">/github.com/</span><span class="number">3671932</span>/Project<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  //作者和邮箱</span></span><br><span class="line"><span class="string">  s.authors = &#123;&#x27;</span><span class="variable constant_">MMMMM</span><span class="string">&#x27; =&gt; &#x27;</span><span class="variable constant_">XXXXXX</span><span class="variable">@qq</span>.com<span class="string">&#x27; &#125;</span></span><br><span class="line"><span class="string">  //git仓库的https地址</span></span><br><span class="line"><span class="string">  s.source = &#123; :git=&gt; &#x27;</span><span class="symbol">https:</span>/<span class="regexp">/github.com/</span><span class="number">3671932</span>/Project.git<span class="string">&#x27;, :tag =&gt;s.version&#125;</span></span><br><span class="line"><span class="string">  //是否要求arc（有部分非arc文件情况未考证）</span></span><br><span class="line"><span class="string">  s.requires_arc = true</span></span><br><span class="line"><span class="string"> //在这个属性中声明过的.h文件能够使用&lt;&gt;方法联想调用（这个是可选属性）</span></span><br><span class="line"><span class="string">  s.public_header_files = &#x27;</span>UIKit/*.h<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  //表示源文件的路径，这个路径是相对podspec文件而言的。（这属性下面单独讨论）</span></span><br><span class="line"><span class="string">  s.source_files =&#x27;</span>AppInfo/*.*<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  //需要用到的frameworks，不需要加.frameworks后缀。（这个没有用到也可以不填）</span></span><br><span class="line"><span class="string">  s.frameworks =&#x27;</span>Foundation<span class="string">&#x27;, &#x27;</span>CoreGraphics<span class="string">&#x27;, &#x27;</span>UIKit<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  //图片资源可支持xcassets</span></span><br><span class="line"><span class="string">     s.resource_bundles = &#123;</span></span><br><span class="line"><span class="string">     &#x27;</span>WSFBaseService<span class="string">&#x27; =&gt; [&#x27;</span>WSFBaseService/Assets/WSFBaseService.xcassets<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   //建立名称为Info的子仓库（虚拟路径）</span></span><br><span class="line"><span class="string">  s.subspec &#x27;</span>Info<span class="string">&#x27; do |ss| </span></span><br><span class="line"><span class="string">  ....</span></span><br><span class="line"><span class="string">  end</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure><h4 id="模块说明书的验证"><a href="#模块说明书的验证" class="headerlink" title="模块说明书的验证"></a>模块说明书的验证</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint test.podspec </span><br></pre></td></tr></table></figure><p>可以设置 –allow-warnings来忽略警告，通过–verbose查看错误具体信息</p><h4 id="模块说明书注意"><a href="#模块说明书注意" class="headerlink" title="模块说明书注意"></a>模块说明书注意</h4><p>一个tag对应一个版本 都会包含一个podspec 文件</p><h3 id="仓库Repo"><a href="#仓库Repo" class="headerlink" title="仓库Repo"></a>仓库Repo</h3><p>存放说明书的地方就是仓库<br>创建自己cocoapod仓库的命令就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//REPO_NAME 仓库名称</span><br><span class="line">//SOURCE_URL 仓库远程地址</span><br><span class="line">pod repo add REPO_NAME SOURCE_URL</span><br></pre></td></tr></table></figure><p> 推送podspec需要添加仓库名称和 podspec文件地址</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo push RooboSpecs xxxxxx.podspec</span><br></pre></td></tr></table></figure><h3 id="编译SDK静态库"><a href="#编译SDK静态库" class="headerlink" title="编译SDK静态库"></a>编译SDK静态库</h3><p> 如果需要隐藏源代码，可以把pod库编译成静态库的方式。<br> 可以通过安装cocoapod的编译插件配合我们的cocoapod 文件来编译我们静态库文件 安装cocoapods-packager</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods-packager</span><br></pre></td></tr></table></figure><ul><li>编译库文件</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//pod package NAME [SOURCE]</span><br><span class="line">pod package Roobo_Plus.podspec  --force --embedded</span><br></pre></td></tr></table></figure><ul><li>Pod Package命令含义</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> //强制覆盖之前已经生成过的二进制库 </span><br><span class="line">--force</span><br><span class="line"></span><br><span class="line">//生成静态.framework </span><br><span class="line">--embedded</span><br><span class="line"></span><br><span class="line">//生成静态.a </span><br><span class="line">--library</span><br><span class="line"></span><br><span class="line">//生成动态.framework </span><br><span class="line">--dynamic</span><br><span class="line"></span><br><span class="line">//动态.framework是需要签名的，所以只有生成动态库的时候需要这个BundleId </span><br><span class="line">--bundle-identifier</span><br><span class="line"></span><br><span class="line">//不包含依赖的符号表，生成动态库的时候不能包含这个命令，动态库一定需要包含依赖的符号表。 </span><br><span class="line">--exclude-deps</span><br><span class="line"></span><br><span class="line">//表示生成的库是debug还是release，默认是release。--configuration=Debug </span><br><span class="line">--configuration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--no-mangle</span><br><span class="line">//表示不使用name mangling技术，pod package默认是使用这个技术的。我们能在用pod package生成二进制库的时候会看到终端有输出Mangling symbols和Building mangled framework。表示使用了这个技术。</span><br><span class="line">//如果你的pod库没有其他依赖的话，那么不使用这个命令也不会报错。但是如果有其他依赖，不使用--no-mangle这个命令的话，那么你在工程里使用生成的二进制库的时候就会报错：Undefined symbols for architecture x86_64。</span><br><span class="line"></span><br><span class="line">--subspecs</span><br><span class="line"></span><br><span class="line">//如果你的pod库有subspec，那么加上这个命名表示只给某个或几个subspec生成二进制库，--subspecs=subspec1,subspec2。生成的库的名字就是你podspec的名字，如果你想生成的库的名字跟subspec的名字一样，那么就需要修改podspec的名字。 </span><br><span class="line">这个脚本就是批量生成subspec的二进制库，每一个subspec的库名就是podspecName+subspecName。</span><br><span class="line"></span><br><span class="line">--spec-sources</span><br><span class="line"></span><br><span class="line">//一些依赖的source，如果你有依赖是来自于私有库的，那就需要加上那个私有库的source，默认是cocoapods的Specs仓库。--spec-sources=private,https://github.com/CocoaPods/Specs.git。</span><br></pre></td></tr></table></figure><p>注意：<br>使用–library编译出的.a静态库文件，pod package插件有问题的，根部不会生成头文件。所以只能编译framwork的库文件</p><h2 id="静态库制作遇到的坑"><a href="#静态库制作遇到的坑" class="headerlink" title="静态库制作遇到的坑"></a>静态库制作遇到的坑</h2><h3 id="运行时便无法找到对应的selector？"><a href="#运行时便无法找到对应的selector？" class="headerlink" title="运行时便无法找到对应的selector？"></a>运行时便无法找到对应的selector？</h3><h4 id="编译-x2F-链接过程"><a href="#编译-x2F-链接过程" class="headerlink" title="编译&#x2F;链接过程"></a>编译&#x2F;链接过程</h4><ul><li><p>编译器在编译的过程中首先会将 .c&#x2F;.cc&#x2F;.cpp&#x2F;.m&#x2F;.mm 的源文件编译成后缀为 .o 的对象文件 ，源文件与对象文件是一一对应的，对象文件中包含了符号、代码以及数据，对象文件是不能被系统加载并使用的。当在编译生成静态库时，这些所有的对象文件，都会被封装到 .a(archive) 文件，可以理解为一个归档文件，也就是我们平常使用的静态库。</p></li><li><p>当需要生产二进制文件或是动态库时，编译器会对静态库 .a(archive) 文件进行处理；编译器将获取静态库中所有的符号表，并检查哪些符号被引用，只有被引用的对象文件才会被链接器真正的加载并处理。例如在静态库中有 10 个对象文件，但被引用到只有 2 个，则链接器只加载被引用的 2 个对象文件，未被使用到的 8 个对象文件则会被忽略。</p></li><li><p>在 C&#x2F;C++ 语言中，这种机制可以很好的工作，因为 C&#x2F;C++ 语言会尽可能的在编译期去做这些事。在 Objective-C 语言中非常依赖运行时特性，Category 就是基于运行时实现，但它并不会像类或者函数一样被创建链接符号，编译器在检查符号表时便不能检查到 Category 对应的符号表，从而 Category 的对象文件就不能被正常的加载，在运行时便无法找到对应的 selector 。</p></li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>Other Linker Flags 添加</li></ol><ul><li><p>-all_load  告诉编译器 对于所有静态库中的所有对象文件，不管里面的符号有没有被用到，全部都载入，这种方法可以解决问题，但是会产生比较大的二进制文件</p></li><li><p>-force_load 并指定路径，-force_load $(BUILT_PRODUCTS_DIR)&#x2F;&lt;library_name.a&gt; 这种方法和 -all_load 类似，不同的是它只载入指定的静态库</p></li><li><p>-ObjC  如果在静态库的对象文件中发现了 Objective-C 代码，就把它载入，Category 中肯定会存在 Objective-C 代码。</p></li></ul><ol start="2"><li>在 Category 的源文件里添加 Fake symbol，并确保以某种方法在编译时引用了该 Fake symbol，这会使得 Fake symbol 对象文件被加载时它里面 Category 代码也会被载入。该方法可以控制哪些 Category 可以被正常加载，同时也不需要添加编译参数做特殊处理。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.enkichen.com/2017/09/13/ios-static-library-categories/">iOS 静态库中的 Category 运行时错误</a></li><li><a href="https://www.jianshu.com/p/9eea3e7cb3a1">podspec文件解析</a></li><li><a href="https://juejin.im/post/6844903559931117581">Pod 库的资源引用</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocoaPods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pod openssl报错</title>
      <link href="/2019/04/04/Pod%20openssl%E6%8A%A5%E9%94%99/"/>
      <url>/2019/04/04/Pod%20openssl%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>新版本的Mac OS系统在安装openssl的时候会报错<br><strong>Error while installing pod: “cp: file.tgz: No such file or directory”</strong><a href="https://github.com/FredericJacobs/OpenSSL-Pod/issues/49">错误详情</a></p><span id="more"></span><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>是因为临时路径问题导致的。</p><p>看了下podspec文件里的pre command,发现它是将压缩文件放到一个临时目录，再解压，然后编译成库。再回去看cocoaPod的下载库，也是下载到一个它内部使用的临时目录，然后解压到目标目录，发现两者的流程并没有串起来的，而且最近一次更新添加了删除下载下来的压缩包的代码，所以导致pre command里的当前目标目录下并没有这个压缩文件。</p><p>解决办法，就是把解压好的文件再拷回到原本要解压的临时目录去，然后去掉解压命令。。。</p><ol><li>找到openssl的podspec文件路径</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/&lt;username&gt;/.cocoapods/repos/master/Specs/e/e/3/OpenSSL/1.0.210</span><br></pre></td></tr></table></figure><p>2.编辑版本的podspec文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -rf <span class="string">&quot;<span class="variable">$&#123;BASEPATH&#125;</span>/&quot;</span> <span class="string">&quot;<span class="variable">$&#123;CURRENTPATH&#125;</span>/openssl-<span class="variable">$&#123;VERSION&#125;</span>&quot;</span></span><br><span class="line"><span class="comment">#cp &quot;file.tgz&quot; &quot;$&#123;CURRENTPATH&#125;/file.tgz&quot;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$&#123;CURRENTPATH&#125;</span>&quot;</span></span><br><span class="line"><span class="comment">#tar -xzf file.tgz</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;openssl-<span class="variable">$&#123;VERSION&#125;</span>&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者用下面的直接内容替换<br><a href="https://github.com/JackWchen2015/Attachment">编辑过后的podsepc文件</a></p><h3 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h3><p>1.<a href="https://blog.csdn.net/Mamong/article/details/80709449">pod openssl引入失败cp: file.tgz:No such file or directory</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocoaPods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS组件化</title>
      <link href="/2019/04/03/iOS%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
      <url>/2019/04/03/iOS%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>查了下资料，没找到关于组建化合理的定义，可以理解为模块化，对较大粒度的业务模块进行封装，组件间只有很少的依赖，只关注输入与输出。</p><span id="more"></span><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>通常一个APP会有多个模块，模块之间会有通信，互相调用，例如微信读书有 书籍详情 想法列表 阅读器 发现卡片 等等模块，这些模块会互相调用，例如 书籍详情要调起阅读器和想法列表，阅读器要调起想法列表和书籍详情，等等，一般我们是怎样调用呢，以阅读器为例，会这样写：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;WRBookDetailViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;WRReviewViewController.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Mediator</span></span></span><br><span class="line">- (<span class="type">void</span>)gotoDetail &#123;</span><br><span class="line">    WRBookDetailViewController *detailVC = [[WRBookDetailViewController alloc] initWithBookId:<span class="keyword">self</span>.bookId];</span><br><span class="line">    [<span class="keyword">self</span>.navigationController.pushViewController:detailVC animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)gotoReview &#123;</span><br><span class="line">    WRReviewViewController *reviewVC = [[WRReviewViewController alloc] initWithBookId:<span class="keyword">self</span>.bookId reviewType:<span class="number">1</span>];</span><br><span class="line">    [<span class="keyword">self</span>.navigationController.pushViewController:reviewVC animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>看起来挺好，这样做简单明了，没有多余的东西，项目初期推荐这样快速开发，但到了项目越来越庞大，这种方式会有什么问题呢？显而易见，每个模块都离不开其他模块，互相依赖粘在一起成为一坨：</p><img src="/2019/04/03/iOS%E7%BB%84%E4%BB%B6%E5%8C%96/component1.png" class=""><p>这样揉成一坨对测试&#x2F;编译&#x2F;开发效率&#x2F;后续扩展都有一些坏处，那怎么解开这一坨呢。很简单，按软件工程的思路，下意识就会加一个中间层：</p><img src="/2019/04/03/iOS%E7%BB%84%E4%BB%B6%E5%8C%96/component2.png" class=""><p>负责转发信息的中间层，暂且叫他 Mediator(Mediator Manager Router)。</p><p>看起来顺眼多了，但这里有几个问题：</p><p>Mediator 怎么去转发组件间调用？<br>一个模块只跟 Mediator 通信，怎么知道另一个模块提供了什么接口？<br>按上图的画法，模块和 Mediator 间互相依赖，怎样破除这个依赖？</p><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>对于前两个问题，最直接的反应就是在 Mediator 直接提供接口，调用对应模块的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Mediator.m</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;BookDetailComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;ReviewComponent.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Mediator</span></span></span><br><span class="line">+ (<span class="built_in">UIViewController</span> *)BookDetailComponent_viewController:(<span class="built_in">NSString</span> *)bookId &#123;</span><br><span class="line">    <span class="keyword">return</span> [BookDetailComponent detailViewController:bookId];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">UIViewController</span> *)ReviewComponent_viewController:(<span class="built_in">NSString</span> *)bookId reviewType:(<span class="built_in">NSInteger</span>)type &#123;</span><br><span class="line">    <span class="keyword">return</span> [ReviewComponent reviewViewController:bookId type:type];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BookDetailComponent  组件</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Mediator.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;WRBookDetailViewController.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BookDetailComponent</span></span></span><br><span class="line">+ (<span class="built_in">UIViewController</span> *)detailViewController:(<span class="built_in">NSString</span> *)bookId &#123;</span><br><span class="line">    WRBookDetailViewController *detailVC = [[WRBookDetailViewController alloc] initWithBookId:bookId];</span><br><span class="line">    <span class="keyword">return</span> detailVC;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReviewComponent  组件</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Mediator.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;WRReviewViewController.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ReviewComponent</span></span></span><br><span class="line">+ (<span class="built_in">UIViewController</span> *)reviewViewController:(<span class="built_in">NSString</span> *)bookId type:(<span class="built_in">NSInteger</span>)type &#123;</span><br><span class="line">    <span class="built_in">UIViewController</span> *reviewVC = [[WRReviewViewController alloc] initWithBookId:bookId type:type];</span><br><span class="line">    <span class="keyword">return</span> reviewVC;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后在阅读模块里：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WRReadingViewController.m</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Mediator.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WRReadingViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)gotoDetail:(<span class="built_in">NSString</span> *)bookId &#123;</span><br><span class="line">    <span class="built_in">UIViewController</span> *detailVC = [Mediator BookDetailComponent_viewControllerForDetail:bookId];</span><br><span class="line">    [<span class="keyword">self</span>.navigationController pushViewController:detailVC];</span><br><span class="line">    <span class="built_in">UIViewController</span> *reviewVC = [Mediator ReviewComponent_viewController:bookId type:<span class="number">1</span>];</span><br><span class="line">    [<span class="keyword">self</span>.navigationController pushViewController:reviewVC];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>问题来了，<br>依赖关系并没有解除，Mediator 依赖了所有模块，而调用者又依赖 Mediator，最后还是一坨互相依赖，跟原来没有 Mediator 的方案相比除了更麻烦点其他没区别。</p><p>怎样让Mediator解除对各个组件的依赖，同时又能调到各个组件暴露出来的方法？对于OC有一个法宝可以做到，就是runtime反射调用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Mediator.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Mediator</span></span></span><br><span class="line">+ (<span class="built_in">UIViewController</span> *)BookDetailComponent_viewController:(<span class="built_in">NSString</span> *)bookId &#123;</span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;BookDetailComponent&quot;</span>);</span><br><span class="line">    <span class="type">id</span> obj = [[cls alloc] init];</span><br><span class="line">    <span class="keyword">return</span> [obj performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;detailViewController:&quot;</span>) withObject:@&#123;<span class="string">@&quot;bookId&quot;</span>:bookId&#125;];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">UIViewController</span> *)ReviewComponent_viewController:(<span class="built_in">NSString</span> *)bookId type:(<span class="built_in">NSInteger</span>)type &#123;</span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;ReviewComponent&quot;</span>);</span><br><span class="line">    <span class="type">id</span> obj = [[cls alloc] init];</span><br><span class="line">    <span class="keyword">return</span> [obj performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;reviewViewController:&quot;</span>) withObject:@&#123;<span class="string">@&quot;bookId&quot;</span>:bookId, <span class="string">@&quot;type&quot;</span>: @(type)&#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这下 Mediator 没有再对各个组件有依赖了，你看已经不需要 #import 什么东西了，对应的架构图就变成：</p><img src="/2019/04/03/iOS%E7%BB%84%E4%BB%B6%E5%8C%96/component3.png" class=""><p>只有调用其他组件接口时才需要依赖 Mediator，组件开发者不需要知道 Mediator 的存在。</p><p>既然用runtime就可以解耦取消依赖，那还要Mediator做什么？组件间调用时直接用runtime接口调不就行了，这样就可以没有任何依赖就完成调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WRReadingViewController.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WRReadingViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)gotoReview:(<span class="built_in">NSString</span> *)bookId &#123;</span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;BookDetailComponent&quot;</span>);</span><br><span class="line">    <span class="type">id</span> obj = [[cls alloc] init];</span><br><span class="line">    <span class="built_in">UIViewController</span> *reviewVC = [obj performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;reviewViewController:&quot;</span>) withObject:@&#123;<span class="string">@&quot;bookId&quot;</span>:bookId, <span class="string">@&quot;type&quot;</span>: @(<span class="number">1</span>)&#125;];</span><br><span class="line">    [<span class="keyword">self</span>.navigationController pushViewController:reviewVC];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这样就完全解耦了，但这样做的问题是：</p><ol><li>调用者写起来很恶心，代码提示都没有，每次调用写一坨。</li><li>runtime方法的参数个数和类型限制，导致只能每个接口都统一传一个 NSDictionary。这个 NSDictionary里的key value是什么不明确，需要找个地方写文档说明和查看。</li><li>编译器层面不依赖其他组件，实际上还是依赖了，直接在这里调用，没有引入调用的组件时就挂了</li></ol><p>把它移到Mediator后：</p><ol><li>调用者写起来不恶心，代码提示也有了。</li><li>参数类型和个数无限制，由 Mediator 去转就行了，组件提供的还是一个 NSDictionary 参数的接口，但在Mediator 里可以提供任意类型和个数的参数，像上面的例子显式要求参数 NSString *bookId 和 NSInteger type。</li><li>Mediator可以做统一处理，调用某个组件方法时如果某个组件不存在，可以做相应操作，让调用者与组件间没有耦合。</li></ol><p>到这里，基本上能解决我们的问题：各组件互不依赖，组件间调用只依赖中间件Mediator，Mediator不依赖其他组件。接下来就是优化这套写法，有两个优化点：</p><ol><li>Mediator 每一个方法里都要写 runtime 方法，格式是确定的，这是可以抽取出来的。</li><li>每个组件对外方法都要在 Mediator 写一遍，组件一多 Mediator 类的长度是恐怖的。<br>优化后就成了 casa 的方案，target-action 对应第一点，target就是class，action就是selector，通过一些规则简化动态调用。Category 对应第二点，每个组件写一个 Mediator 的 Category，让 Mediator 不至于太长。</li></ol><p>总结起来就是，组件通过中间件通信，中间件通过 runtime 接口解耦，通过 target-action 简化写法，通过 category 感官上分离组件接口代码。这里可以看到这个实现的 <a href="https://github.com/casatwy/CTMediator">Demo</a>。</p><h3 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h3><ol><li><a href="http://wereadteam.github.io/2016/03/19/iOS-Component/">iOS 组件化方案探索</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CocoaPods Setup，更新repo缓慢</title>
      <link href="/2019/04/02/CocoaPods%20Setup%EF%BC%8C%E6%9B%B4%E6%96%B0repo%E7%BC%93%E6%85%A2/"/>
      <url>/2019/04/02/CocoaPods%20Setup%EF%BC%8C%E6%9B%B4%E6%96%B0repo%E7%BC%93%E6%85%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>CocoaPods在首次安装后，不管是search、install还是update，都会强制的升级他的repo。这个repo起到了CocoaPods在本地缓存索引的作用，比如我们进行pod search的时候，实际是在本地进行检索的，这个repo是git上的一个仓库，由CocoaPods官方创建，地址如下：<a href="https://github.com/CocoaPods/Specs">https://github.com/CocoaPods/Specs</a>，存放了CocoaPods支持的各种三方库的信息，每次在执行pod search的时候，首先CocoaPods会主动的pull这个git，确保本地的索引信息是最新的，然后再在本地repo中进行搜索，以保证加载的速度。</p><span id="more"></span><h3 id="关于CocoaPods的repo"><a href="#关于CocoaPods的repo" class="headerlink" title="关于CocoaPods的repo"></a>关于CocoaPods的repo</h3><p>repo，全称是Repository，顾名思义就是仓库的意思，当然就是git托管的仓库了。CocoaPods通过这个repo里的信息来获取各种三方库的信息。</p><img src="/2019/04/02/CocoaPods%20Setup%EF%BC%8C%E6%9B%B4%E6%96%B0repo%E7%BC%93%E6%85%A2/podSetup.png" class=""><p>针对三处红线标识的解释：</p><ol><li>更新CocoaPods的master repo；</li><li>从<a href="https://github.com/CocoaPods/Specs">https://github.com/CocoaPods/Specs</a> 这个地址上克隆repo到本地；</li><li>下载git上的repo，需要下载的文件有1963451个，也就是190万个。</li></ol><h3 id="更新repo缓慢的问题"><a href="#更新repo缓慢的问题" class="headerlink" title="更新repo缓慢的问题"></a>更新repo缓慢的问题</h3><p>既然CocoaPods需要将一个git仓库克隆到本地，我们是否可以自己帮CocoaPods创建本地仓库呢？答案是可以的。我们找到CocoaPods存放repo的地方。终端输入<code>open ~/.cocoapods/repos</code>，就打开了repo存放的路径。</p><p>解决思路：</p><ol><li>将<a href="https://github.com/CocoaPods/Specs">https://github.com/CocoaPods/Specs</a>zip下载到本地，放入repos文件夹。</li></ol><p><code>将所有解压出来的文件放入.cocoapods/repos/master文件夹中. </code></p><ol start="2"><li>将本地的文件，与<a href="https://github.com/CocoaPods/Specs">https://github.com/CocoaPods/Specs</a>关联，让CocoaPods识别本地仓库是从git上pull下载的。</li></ol><ul><li>2-1 初始化git：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.cocoapods/repos/master </span><br><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>2-2 关联仓库：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/CocoaPods/Specs</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocoaPods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式详解</title>
      <link href="/2019/03/02/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/03/02/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p></blockquote><p>正确使用设计模式具有以下优点。</p><ul><li>可以提高程序员的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li></ul><span id="more"></span><h3 id="设计模式定义"><a href="#设计模式定义" class="headerlink" title="设计模式定义"></a>设计模式定义</h3><p>每一个设计模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能重复使用该方案。</p><ul><li>一个模式的四个基本要素</li></ul><ol><li>模式名称（助记词）</li><li>问题（描述了应该在何时使用模式）</li><li>解决方案（描述的设计组成成分）</li><li>效果（描述了模式应用的效果及使用模式应权衡的问题）</li></ol><p><code>设计模式对于面向对象而言，其作用好比数据结构对于面向过程</code></p><p>面向对象系统追求的目标就是尽可能的提高系统模块内部的内聚，尽可能降低模块间的耦合。</p><h3 id="设计模式框架"><a href="#设计模式框架" class="headerlink" title="设计模式框架"></a>设计模式框架</h3><p>设计模式大致可分三种类型以及MVX架构系列</p><img src="/2019/03/02/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/design_Category.png" class=""><!--more--><h3 id="设计模式详解"><a href="#设计模式详解" class="headerlink" title="设计模式详解"></a>设计模式详解</h3><h4 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h4><p>用于描述“怎么创建对象”。它的主要特点是“将对象的创建与使用分离”</p><h5 id="原型模式（Prototype）："><a href="#原型模式（Prototype）：" class="headerlink" title="原型模式（Prototype）："></a>原型模式（Prototype）：</h5><ol><li>定义：原型模式是通过克隆已有的对象来创建新的对象，已有的对象称为原型。通俗来讲，原型模式就是允许你创建现有对象的副本并根据需要进行修改，而不是从头开始创建对象并进行设置。</li><li>使用场景：通过初始化产生一个对象需要非常繁琐的准备步骤，也就是新生成一个对象的代价比较大，则可以考虑使用原型模式。</li><li>具体实现：原型模式实现起来比较简单，iOS实现这个模式用的就是copy方法，如果是类使用copy，那这个类就要实现。NSCopying协议中的copyWithZone方法，告诉程序如何复制该对象。</li><li>注意事项: 涉及到copy，注意下深复制和浅复制就好。</li></ol><h5 id="单例模式（Singleton）："><a href="#单例模式（Singleton）：" class="headerlink" title="单例模式（Singleton）："></a>单例模式（Singleton）：</h5><ol><li>定义: 单例模式能够确保某个类在应用中只存在一个实例，创建之后会向整个系统共用这个实例。</li><li>使用场景： 需要用来保存全局的状态，并且不和任何作用域绑定的时候可以考虑单例。</li><li>注意事项: 单例模式比较常用，也可能是很多初级工程师唯一会使用的设计模式。这里还是要尽量避免滥用单例，大家可以查看这篇文章 另外还要防止一下对单例对象的copy操作。</li></ol><h5 id="工厂方法模式（FactoryMethod）："><a href="#工厂方法模式（FactoryMethod）：" class="headerlink" title="工厂方法模式（FactoryMethod）："></a>工厂方法模式（FactoryMethod）：</h5><ol><li>定义: 定义一个用于创建对象的接口，让子类决定实例化哪一个类。</li><li>使用场景： 当存在多个类共同实现一个协议或者共同继承一个基类的时候，需要创建不同的对象，这个时候就可以考虑是否有必要使用工厂类进行管理。</li><li>具体实现：工厂方法模式还可以缩小成简单工厂模式，形如：</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CarFactory.m</span></span><br><span class="line">+ (Car *)createCarWithType:(<span class="built_in">NSIntger</span>)passengersCount &#123;</span><br><span class="line">    <span class="keyword">if</span> (passengersCount &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[SportCar alloc] init];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (passengersCount &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[NormalCar alloc] init];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [[SUV alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但简单工厂模式的耦合和扩展方面存在一些问题，基本所有使用简单工厂模式的地方都可以用依赖注入来解决掉这个问题</p><ol start="4"><li>优点： 1.在工厂方法中，用户只需要知道所要产品的具体工厂，不需要知道具体的创建过程，甚至不需要具体产品类。2.在系统增加新的产品时，我们只需要添加一个具体产品类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”。</li><li>缺点： 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，代码量会增加，也增加了系统的复杂度。</li></ol><h5 id="抽象工厂模式（AbstractFactory）："><a href="#抽象工厂模式（AbstractFactory）：" class="headerlink" title="抽象工厂模式（AbstractFactory）："></a>抽象工厂模式（AbstractFactory）：</h5><ol><li>定义: 抽象工厂模式是工厂方式模式的升级版本，抽象工厂模式允许调用组件在不了解创建对象所需类的情况下，创建一组相关或者互相依赖的对象。</li><li>使用场景： 一个对象族有相同的约束时可以使用抽象工厂模式。</li><li>具体实现： 这里引用了一个生产门的工厂，木门需要搭配木门安装工，铁门需要搭配铁门安装工</li><li>优点：良好的封装性：抽象工厂模式允许调用组件不必了解创建对象使用的类，也不必知道为什么选择这些类，因为我可以在不修改调用组件的情况下，对使用的类进行修改。</li><li>缺点：扩展产品族困难，需要更改接口及其下所有子类(什么是产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的。例如苹果手机，苹果平板，苹果电脑)。</li></ol><h5 id="建造者模式（Builder）："><a href="#建造者模式（Builder）：" class="headerlink" title="建造者模式（Builder）："></a>建造者模式（Builder）：</h5><ol><li>定义: 将一个复杂的对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。</li><li>使用场景： 当创建多种风格的对象时或者创建对象时涉及很多步骤，可以使用建造者模式。</li><li>具体实现： 这里举了一个手抓饼的例子，5元的不辣手抓饼需要添加（生菜 + 火腿肠 + 鸡蛋，味精 + 番茄酱），10元的变态辣手抓饼需要添加(生菜 + 热狗 + 肉松 + 里脊 + 芝士，辣椒 + 辣酱 + 麻酱 + 干辣椒 + 剁辣椒 + 老干妈 + 辣椒油)，具体实现请看demo</li><li>优点： 1.将产品的创建过程与产品本身分离开来，可以使用相同的创建过程来得到不同的产品。2.每一个具体建造者都相对独立，因此可以很方便地替换具体建造者或增加新的具体建造者。</li><li>缺点： 1.建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。2.如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ol><h4 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h4><p>用于描述“如何将类或对象按某种布局组成更大的结构”</p><ul><li>类的层次结构</li></ul><ol><li>类的功能层次结构：父类具有基本功能，在子类中增加新的功能（继承）</li><li>类的实现层次结构：父类通过声明抽象方法来定义接口，不同子类通过实现具体的方法来实现接口。（多态）</li></ol><h5 id="适配器模式（Adapter）："><a href="#适配器模式（Adapter）：" class="headerlink" title="适配器模式（Adapter）："></a>适配器模式（Adapter）：</h5><ol><li>定义: 适配器模式将一个类的接口变成调用者所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。(举一个现实中的实例：比如转接头)。</li><li>使用场景： 扩展应用或者组件时，而被集成进来的又不符合现在的接口，这个时候可以考虑使用适配器模式。</li><li>注意事项: 适配器模式一般不是为了解决还处在于开发阶段的问题，一般都是解决正在服役项目的扩展问题。</li></ol><h5 id="桥接模式（Bridge）："><a href="#桥接模式（Bridge）：" class="headerlink" title="桥接模式（Bridge）："></a>桥接模式（Bridge）：</h5><ol><li>定义: 编程时为了使得类变得简洁，类功能明确，往往需要将 <code>类的功能层次结构</code>与<code>类的实现层次结构</code>独立出来，将两种层次结构分离开，必然需要一种“媒介”将他们构成联系，就是bridge。</li><li>使用场景： 重用性要求较高的不希望或不适用使用继承的场景。也就是说当继承N层，达到层级有点爆炸的时候可以考虑使用此模式。</li><li>注意事项: 并不是一涉及继承就要考虑使用桥接模式，不然还要继承做什么？桥接模式的目的就是要对变化进行封装，尽可能的把变化的因素封装到最细最小的单元中，避免风险扩散。所以当发现类的继承有N层的时候，才需要去考虑使用该模式。</li></ol><h5 id="装饰器模式（Decorator）："><a href="#装饰器模式（Decorator）：" class="headerlink" title="装饰器模式（Decorator）："></a>装饰器模式（Decorator）：</h5><ol><li>定义: 通过组合的方式动态的给一个对象添加一些额外的职责。就增加功能来说，装饰模式会比通过继承生成子类更为灵活。</li><li>使用场景： 需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li><li>具体实现： Objective-C中的Category 就是装饰器模式的一种应用。</li><li>优点： 装饰器模式中定义的行为，能够在不创建大量子类的情况下，组合起来实现复杂的效果，比继承更加灵活。<br>5.缺点： 装饰器模式会导致设计中出现许多的小对象，会让系统变得更加复杂，比如说出错调试时寻找错误可能需要逐级排查。</li></ol><h5 id="组合模式（Composite）："><a href="#组合模式（Composite）：" class="headerlink" title="组合模式（Composite）："></a>组合模式（Composite）：</h5><ol><li>定义: 组合模式将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</li><li>使用场景： 维护和展示部分-整体关系的场景，在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，可以一致地对待它们的时候。</li><li>缺点： 使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联。</li><li>注意事项: 当使用这个属性结构的调用组件能够通过同一个类或者协议来使用书中包含的所有的对象时，才能证明正确的实现了此模式。</li></ol><h5 id="享元模式（Flyweight）："><a href="#享元模式（Flyweight）：" class="headerlink" title="享元模式（Flyweight）："></a>享元模式（Flyweight）：</h5><ol><li>定义: 享元模式就是运行共享技术有效地支持大量细粒度对象的复用</li><li>使用场景： 系统中存在大量的相似对象，由于这类对象的大量使用可能会造成系统内存资源浪费，而且这些对象的状态大部分可以外部化，这个时候可以考虑享元模式。在iOS中，我们用到的UITableView 重用机制就是享元模式的典型应用。</li><li>优点： 通过共享极大的减少了对象实例的个数，节省了内存开销。</li><li>缺点： 1.提高了系统的复杂度，需要分离出外部状态和内部状态。 2.这些类必须有一个工厂对象加以控制。</li></ol><h5 id="代理模式（Proxy）："><a href="#代理模式（Proxy）：" class="headerlink" title="代理模式（Proxy）："></a>代理模式（Proxy）：</h5><ol><li>定义: 代理模式为其他对象提供一种代理以控制对这个对象的访问。</li><li>使用场景： 想在访问一个类时做一些控制。</li><li>具体实现： 这里举一个实际的例子，就是火车票代售点，具体实现Demo请点击这里查看</li><li>优点： 1、职责清晰。 2、高扩展性。</li><li>缺点： 增加了系统的复杂度</li><li>注意事项: 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li></ol><h4 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h4><p>用于描述“类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责”。</p><h5 id="责任链模式（Chain-of-Responsibility）："><a href="#责任链模式（Chain-of-Responsibility）：" class="headerlink" title="责任链模式（Chain of Responsibility）："></a>责任链模式（Chain of Responsibility）：</h5><ol><li>定义: 责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之前的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，知道有对象处理它为止。</li><li>使用场景： 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时确定。</li><li>优点： 1.低耦合：将请求和处理分开，请求者可以不用知道是谁处理的。2.新增和修改新的处理类比较容易</li><li>缺点： 每个请求都是从链头遍历到链尾，如果链比较长会产生一定的性能问题，调试起来也比较麻烦。</li><li>注意事项: 避免超长链的情况出现</li></ol><h5 id="命令模式（Command）："><a href="#命令模式（Command）：" class="headerlink" title="命令模式（Command）："></a>命令模式（Command）：</h5><ol><li>定义: 命令模式将请求封装成对象，从而可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销和恢复的操作。</li><li>使用场景： 在某些场合，比如要对行为进行”记录、撤销&#x2F;重做、事务”等处理的时候。</li><li>具体实现： YTKNetwork就是用的命令模式，推荐大家学习。这里我举了一个吃饭点菜的例子，具体请点击这里查看</li><li>优点： 1.类间解耦：调用者与接收者之间没有任何依赖关系。2.扩展性良好：新的命令可以很容易添加到系统中去。</li><li>缺点： 使用命令模式可能会导致系统有过多的具体命令类。</li></ol><h5 id="中介者模式（Mediator）："><a href="#中介者模式（Mediator）：" class="headerlink" title="中介者模式（Mediator）："></a>中介者模式（Mediator）：</h5><ol><li>定义: 中介者模式就是用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</li><li>使用场景： 多个类相互依赖，形成了网状结构的时候可以考虑使用中介者模式。</li><li>具体实现： 这里举了一个聊天室的例子，具体请点击这里查看</li><li>优点： 1.解耦：通过中介者模式，我们可以将复杂关系的网状结构变成结构简单的以中介者为核心的星形结构，每个对象不再和它与之关联的对象直接发生相互作用，而是通过中介者对象来另一个对象发生相互作用。2.降低了类的复杂度，将一对多转化成了一对一。</li><li>缺点：中介者模式在某些情况会膨胀得很大，而且逻辑复杂，中介类越多越复杂，越难以维护。</li><li>注意事项: 类之间的依赖关系是必然存在的，所以不一定有多个依赖关系的时候就考虑使用中介者模式。中介者模式适用于多个对象之间的紧密耦合的情况，紧密耦合的定义标准是：在类图中出现了蜘蛛网状结构，这种情况就要考虑使用中介者模式，中介者模式可以把蜘蛛网梳理成星型结构，使原本复杂混乱的关系变得清晰简单。</li></ol><h5 id="观察者模式（Observer）："><a href="#观察者模式（Observer）：" class="headerlink" title="观察者模式（Observer）："></a>观察者模式（Observer）：</h5><ol><li>定义: 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li><li>使用场景： 一个对象的状态发生改变，所有的依赖对象都将得到通知的时候。</li><li>具体实现： Objective-C中的通知以及KVO都是观察者模式的具体实现。这里举了一个找工作订阅的例子，具体请点击这里查看</li><li>优点： 1.观察者和被观察者是抽象耦合的，扩展比较方便。2.建立一套触发机制。</li><li>缺点： 1.如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2.如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3.观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ol><h5 id="备忘录模式（Memento）："><a href="#备忘录模式（Memento）：" class="headerlink" title="备忘录模式（Memento）："></a>备忘录模式（Memento）：</h5><ol><li>定义: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就开奖对象恢复到原先保存的状态了。</li><li>使用场景： 需要存档的时候，比如说游戏中的存档。</li><li>具体实现： 打游戏时的存档，数据库的事务管理，SVN以及Git代码的版本控制系统等等都可以说成是备忘录模式的实例。这里我简单的举了一下例子，具体请点击这里查看</li><li>优点： 1.给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2.实现了信息的封装，使得用户不需要关心状态的保存细节。</li><li>缺点： 在一些场景下比较消耗资源。</li><li>注意事项: 不要在频繁建立备份的场景中使用备忘录模式，比如说在for循环中。</li></ol><h5 id="策略模式（Strategy）："><a href="#策略模式（Strategy）：" class="headerlink" title="策略模式（Strategy）："></a>策略模式（Strategy）：</h5><ol><li>定义: 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。</li><li>使用场景： 1.多个类只有在算法或行为上稍有不同的场景。2.算法需要自由切换的场景。3.需要屏蔽算法规则的场景。</li><li>具体实现： 具体请点击这里查看</li><li>优点： 1.算法可以自由切换。 2.避免使用多重条件判断。 3.扩展性良好。</li><li>缺点：1.策略类会增多。 2.所有策略类都需要对外暴露。</li><li>注意事项: 如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</li></ol><h5 id="访问者模式（Visitor）："><a href="#访问者模式（Visitor）：" class="headerlink" title="访问者模式（Visitor）："></a>访问者模式（Visitor）：</h5><ol><li>定义: 访问者模式封装了一些作用于某种数据结构中的各元素操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</li><li>使用场景： 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</li><li>具体实现： 这里举了一个悲观的人和乐观的人对待不同事物的反应的实例，具体请点击这里查看，如果想增加Action就比较方便，但是如果想增加一个既悲观又乐观的人就有一点麻烦了。</li><li>优点： 1.符合单一职责原则。 2.优秀的扩展性。 3.灵活性高</li><li>缺点：1.具体元素对访问者公布细节，违反了迪米特原则。 2.具体元素变更比较困难。 3.违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</li></ol><h5 id="模板方法模式（TemplateMethod）："><a href="#模板方法模式（TemplateMethod）：" class="headerlink" title="模板方法模式（TemplateMethod）："></a>模板方法模式（TemplateMethod）：</h5><ol><li>定义: 定义一个操作中的算法的框架，而降一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li><li>使用场景： 1.多个子类有公有的方法，并且逻辑基本相同时。2.有重要、复杂的算法的时候，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</li><li>具体实现： 这里简单举了一个Android 和iOS项目的从code到发布的简易过程Demo，具体请点击这里查看</li><li>优点： 1.封装不变部分，扩展可变部分。 2.提取公共代码，便于维护。 3.行为由父类控制，子类实现。</li><li>缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</li></ol><h5 id="状态模式（State）："><a href="#状态模式（State）：" class="headerlink" title="状态模式（State）："></a>状态模式（State）：</h5><ol><li>定义: 当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。</li><li>使用场景： 1.行为随状态改变而改变的场景。2.条件、分支判断语句的替代者。</li><li>具体实现： 这里举了一个不太恰当的例子，假如一支笔有3种状态可以切换，可以写钢笔字，圆珠笔字，毛笔字，具体请点击这里查看。再举一个实际中典型的例子就是酒店管理房间的时候，房间应该会有三种状态：空闲，已预订，已入住，同理。</li><li>优点： 1.结构清晰，避免了过多的选择判断语句。2.封装性比较好。</li><li>缺点： 子类会比较多，增加了复杂度。</li></ol><h5 id="迭代器模式（Iterator）："><a href="#迭代器模式（Iterator）：" class="headerlink" title="迭代器模式（Iterator）："></a>迭代器模式（Iterator）：</h5><ol><li>定义: 迭代器模式提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。</li><li>使用场景： 一个聚合对象有遍历的需求</li><li>具体实现： 在 Cocoa Touch 中的 NSEnumerator类 就实现了迭代器模式。还有基于块的枚举也是迭代器模式的实现等等</li><li>优点： 1.它支持以不同的方式遍历一个聚合对象。2.增加新的collection类和迭代器类都很方便。</li><li>缺点： 迭代器和collection类是对应的，增加新的collection类就会增加新的迭代器，类的个数成对增加，可能会增加系统复杂度。</li></ol><h5 id="解释器模式（Interpreter）："><a href="#解释器模式（Interpreter）：" class="headerlink" title="解释器模式（Interpreter）："></a>解释器模式（Interpreter）：</h5><ol><li>定义: 给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</li><li>使用场景： 解释器模式在实际项目中用到的比较少，正则表达式就是用的解释器模式。</li><li>具体实现： 正则表达式。</li><li>优点： 容易改变和扩展问法。</li><li>缺点： 效率是严重的问题。</li></ol><h3 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h3><ol><li><a href="https://www.jianshu.com/p/55f0e3b30e9c">iOS设计模式四部曲</a></li><li><a href="https://github.com/maligh/DesignPatterns">Sample Code</a> </li><li><a href="http://design-patterns.readthedocs.io/zh_CN/latest/index.html">图说设计模式</a></li><li><a href="https://github.com/huang303513/Design-Pattern-For-iOS">Sample Code 2</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式六大原则</title>
      <link href="/2019/02/28/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2019/02/28/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h3><img src="/2019/02/28/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/desig_principle.png" class=""><span id="more"></span><h4 id="单一职责原则（Single-Responsibility-Principle，简称SRP-）"><a href="#单一职责原则（Single-Responsibility-Principle，简称SRP-）" class="headerlink" title="单一职责原则（Single Responsibility Principle，简称SRP ）"></a>单一职责原则（Single Responsibility Principle，简称SRP ）</h4><ul><li>核心思想：一个类应该有且只有一个变化的原因（There should never be more than one reason for a class to change.）</li><li>职责的定义：”一个变化的原因（a reason for change)”,如果你能想出多于一种动机来更改一个类，则这个类就包含多于一个职责。</li><li>需注意：</li></ul><ol><li><pre><code>单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可以度量的，因项目和环境而异。</code></pre></li><li>一个较好的设计是将两个职责完全地隔离到不同的类当中。<img src="/2019/02/28/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/srp_design.jpg" class=""></li></ol><h4 id="开放封闭原则（Open-Close-Principle-简称OCP）"><a href="#开放封闭原则（Open-Close-Principle-简称OCP）" class="headerlink" title="开放封闭原则（Open Close Principle,简称OCP）"></a>开放封闭原则（Open Close Principle,简称OCP）</h4><ul><li>引用：1988年Bertrand Meyer 就给出了指导建议，他创造了当下非常著名的开放封闭原则。套用他的原话：”软件实体（类、模块、函数等）应对扩展开放，但对修改封闭。”（Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.）</li><li>核心思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化</li><li>通俗来讲： <ol><li><pre><code>一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。</code></pre></li></ol></li></ul><ol start="2"><li>更改符合开放封闭原则的程序是通过增加新的代码，而不是修改已存在的代码.</li><li>这个原则是面向对象设计的核心，是构建可维护性和可重用性代码的基础。抽象（Abstraction）和多态（Polymorphism）是实现这一原则的主要机制，而继承（Inheritance）则是实现抽象和多态的主要方法。</li></ol><ul><li><p>问题：符合开放封闭原则的模块都有两个主要特性：1. 它们 “面向扩展开放（Open For Extension）”，2. 它们 “面向修改封闭（Closed For Modification）”。通常扩展模块行为的常规方式就是修改该模块，如何使这两个相反的特性共存呢？</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">抽象是关键</span><br><span class="line">使用面向对象设计技术时，可以创建固定的抽象和一组无限界的可能行为来表述。这里的抽象指的是抽象基类，而无限界的可能行为则由诸多可能衍生出的子类来表示。为了一个模块而篡改一个抽象类是有可能的，而这样的模块则可以对修改封闭，因为它依赖于一个固定的抽象。然后这个模块的行为可以通过创建抽象的衍生类来扩展.</span><br></pre></td></tr></table></figure></li><li><p>策略：</p></li></ul><ol><li>使用抽象来获取显示地闭合</li><li>使用 “数据驱动（Data Driven）” 的方法来达成闭合。<img src="/2019/02/28/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/OCP_design.jpg" class=""></li></ol><h4 id="里氏替换原则（Liskov-Substitution-Principle-简称LSP）"><a href="#里氏替换原则（Liskov-Substitution-Principle-简称LSP）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle,简称LSP）"></a>里氏替换原则（Liskov Substitution Principle,简称LSP）</h4><ul><li>核心思想：使用基类对象指针或引用的函数必须能够在不了解衍生类的条件下使用衍生类的对象。（Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it）。</li><li>需注意：</li></ul><ol><li>如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系 采用依赖、聚合、组合等关系代替继承。通常来说，继承关系是 is-a 的关系。换句话讲，如果一种新的对象与一种已有对象满足 is-a 的关系，那么新的对象的类应该是从已有对象的类继承来的.</li><li>is-a 关系是与行为有关的。不是内在的私有的行为，而是外在的公共的行为，是使用者依赖的行为。</li></ol><ul><li><p>说明：LSP是实现 OCP 原则的重要方式。只有当衍生类能够完全替代它们的基类时，使用基类的函数才能够被安全的重用，然后衍生类也可以被放心的修改了。</p><img src="/2019/02/28/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/lsp_design.jpg" class=""></li><li><p>契约式设计:使用契约式设计，类中的方法需要声明前置条件和后置条件。前置条件为真，则方法才能被执行。而在方法调用完成之前，方法本身将确保后置条件也成立。</p></li></ul><h4 id="接口分离原则（Interface-Segregation-Principle-简称ISP）"><a href="#接口分离原则（Interface-Segregation-Principle-简称ISP）" class="headerlink" title="接口分离原则（Interface Segregation Principle,简称ISP）"></a>接口分离原则（Interface Segregation Principle,简称ISP）</h4><ul><li><p>说明：ISP 原则承认了对象设计中非内聚接口的存在。但它建议客户类不应该只通过一个单独的类来使用这些接口。取而代之的是，客户类应该通过不同的抽象基类来使用那些内聚的接口。在不同的编程语言中，这里所指的抽象基类可以指 “接口（interface）”、”协议（protocol）”、”签名（signature）” 等。</p></li><li><p>核心思想：类间的依赖关系应该建立在最小的接口上，换句话说客户类不应被强迫依赖那些它们不需要的接口。（Clients should not be forced to depend upon interfaces that they do not use.）</p></li><li><p>使用场景：用于处理胖接口（fat interface）所带来的问题</p></li><li><p>通俗来讲：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p></li><li><p>策略：让对象的客户类不通过对象的接口来访问，而是通过委托（delegation）或者基类对象来访问。</p></li></ul><ol><li>通过委托进行分离(或者使用 Adapter 设计模式)<br>弊端：都需要创建一个新的对象。创建对象显然多了些开销</li><li>通过多继承进行分离</li></ol><p><code>采用委托（delegation）或多继承方式，胖接口可以被分离成多个抽象的基类接口，从而打破客户类之间的不必要的耦合。</code></p><img src="/2019/02/28/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/isp_design.jpg" class=""><h4 id="依赖倒置原则（Dependence-Inversion-Principle-简称DIP）"><a href="#依赖倒置原则（Dependence-Inversion-Principle-简称DIP）" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle,简称DIP）"></a>依赖倒置原则（Dependence Inversion Principle,简称DIP）</h4><ul><li>“Bad Design” 的定义：是什么让设计变得僵化、脆弱和难以复用呢？答案是模块间的相互依赖。</li><li>僵化性：体现在，如果对相互依赖严重的软件做一处改动，将会导致所有依赖的模块发生级联式的修改。</li><li>脆弱性:是指一处变更将破坏程序中多个位置的功能。</li><li>核心思想：</li></ul><ol><li>高层模块不应该依赖低层模块，二者都该依赖于抽象；</li><li>抽象不应该依赖于具体实现细节，而具体实现细节应该依赖于抽象。</li><li>要面向接口编程，不要面向实现编程</li></ol><ul><li>说明：高层模块就是调用端，低层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类。</li><li>通俗来讲：依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。</li></ul><p>eg: socket设计<br><code>别管用户怎么用你的socket（高层不应该依赖底层模块）；也别管socket将来要如何实现（抽象不应该依赖细节）——先问问自己，我，应该把socket做成什么样子？</code></p><ul><li>核心：我们其实想重用的是高层模块。我们已经通过子程序库等方式很好地重用了低层模块了。如果高层模块依赖于低层模块，将导致高层模块在不同的环境中变得极难被复用。而如果高层模块完全独立于与低层模块，高层模块就可以很容易地被复用。这就是这个原则的核心所在。</li><li>分层：所有结构良好的面向对象架构都有着清晰明确的层级定义，每一层都通过一个定义良好和可控的接口来提供一组内聚的服务集合。（All well-structured object-oriented architectures have clearly-defined layers, with each layer providing some coherent set of services though a well-defined and controlled interface.）</li><li>说明：依赖倒置原则（Dependency Inversion Principle）是很多面向对象技术的根基。它特别适合应用于构建可复用的软件框架，其对于构建弹性地易于变化的代码也特别重要。并且，因为抽象和细节已经彼此隔离，代码也变得更易维护。</li></ul><img src="/2019/02/28/iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/dip_design.jpg" class=""><h4 id="迪米特法则（Law-of-Demeter-简称LoD）（Least-Knowledge-Principle）"><a href="#迪米特法则（Law-of-Demeter-简称LoD）（Least-Knowledge-Principle）" class="headerlink" title="迪米特法则（Law of Demeter,简称LoD）（Least Knowledge Principle）"></a>迪米特法则（Law of Demeter,简称LoD）（Least Knowledge Principle）</h4><ul><li>前言：最少知识原则（Least Knowledge Principle），或者称迪米特法则（Law of Demeter），是一种面向对象程序设计的指导原则，它描述了一种保持代码松耦合的策略。</li><li>核心思想：每个单元对其他单元只拥有有限的知识，只了解与当前单元紧密联系的单元；（Each unit should have only limited knowledge about other units: only units “closely” related to the current unit.），</li><li>类应该与其协作类进行交互但无需了解它们的内部结构。（A class should interact directly with its collaborators and be shielded from understanding their internal structure.）</li><li>优点：更好的信息隐藏和更少的信息重载，将降低模块间的耦合，提升了软件的可维护性和可重用性</li><li>缺点：可能会导致不得不在类中设计出很多用于中转的包装方法（Wrapper Method），这会提升类设计的复杂度。</li><li>通俗来讲： 一个类对自己依赖的类知道的越少越好。自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。</li></ul><h3 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h3><ol><li><a href="https://www.jianshu.com/p/55f0e3b30e9c">iOS设计模式四部曲</a></li><li><a href="http://www.cnblogs.com/gaochundong/p/single_responsibility_principle.html">C#设计模式翻译</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP/UDP协议</title>
      <link href="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2><ul><li>TCP, 传输控制协议</li><li>UDP,用户数据报协议 无连接，尽最大努力交付</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li>TCP 提供一种面向连接的、可靠的字节流服务</li><li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li><li>TCP 使用校验和，确认和重传机制来保证可靠传输</li><li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li><li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递</span><br><span class="line">送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，</span><br><span class="line">它所能提供的是数据的可靠递送或故障的可靠通知。</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定</p><p><code>TCP连接 :: = &#123; socket1,socket2&#125; = &#123;(IP1 : port1),(IP2 : port2)&#125;</code></p><p>IP1和IP2是两个端点的IP地址，port1和port2是两个主机应用的端口号，TCP连接的端点是套接字。</p><img src="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/tcpconn.png" class=""><p>数据传输开始之前，需要建立连接(三次握手)。 数据传输结束之后，需要释放连接(四次挥手)</p><h3 id="TCP可靠传输的精髓"><a href="#TCP可靠传输的精髓" class="headerlink" title="TCP可靠传输的精髓"></a>TCP可靠传输的精髓</h3><p>TCP连接的一方A，由操作系统动态随机选取一个32位长的序列号（Initial Sequence Number），假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001，1002，1003…，并把自己的初始序列号ISN告诉B，让B有一个思想准备，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。</p><p>同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003…，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。</p><p><strong>TCP连接握手，握的是啥？通信双方数据原点的序列号！</strong></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYN(synchronous建立联机)</span><br><span class="line">ACK(acknowledgement 确认)</span><br><span class="line">FIN(finish结束)</span><br><span class="line">Sequence number(顺序号码)</span><br><span class="line">Acknowledge number(确认号码)</span><br></pre></td></tr></table></figure><p><strong>建立一个 TCP 连接时，需要客户端和服务器总共发送3个包</strong>.</p><p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。</p><p><code>在 socket 编程中，客户端执行 connect() 时。将触发三次握手。</code></p><ul><li><p>第一次握手(SYN&#x3D;1, seq&#x3D;x)<br>由客户端向服务端发送 SYN 标志位置1的包 ,指明客户端打算连接的服务器的端口，以及初始序号 X。</p></li><li><p>第二次握手(SYN&#x3D;1, ACK&#x3D;1, seq&#x3D;y, ACKnum&#x3D;x+1):<br>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1</p></li><li><p>第三次握手(ACK&#x3D;1，ACKnum&#x3D;y+1)<br>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</p></li></ul><img src="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/netConn3detail.png" class=""><h4 id="为什么是”三次握手”？"><a href="#为什么是”三次握手”？" class="headerlink" title="为什么是”三次握手”？"></a>为什么是”三次握手”？</h4><p>两次握手的过程：<br>2.1 A 发送同步信号SYN + A’s ISN（Initial sequence number）<br>2.2 B发送同步信号SYN+B’s ISN+B‘s ACK sequence number</p><p>这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，A和B就B的初始序列号将无法达成一致</p><ul><li>如果A发给B的确认丢了，该如何？<br>A会超时重传这个ACK吗？不会！TCP不会为没有数据的ACK超时重传。B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止(SYN攻击埋下伏笔)。</li></ul><h4 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h4><p>在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.</p><p>SYN 攻击指的是，<strong>攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪</strong>。</p><p><code>SYN 攻击是一种典型的 DoS/DDoS 攻击。</code></p><ul><li>如何检测 SYN 攻击？</li></ul><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux&#x2F;Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p><ul><li>如何防御 SYN 攻击？</li></ul><p>SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p><p>缩短超时（SYN Timeout）时间<br>增加最大半连接数<br>过滤网关防护<br>SYN cookies技术</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><img src="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/tcpconnfin4.png" class=""><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。</p><h4 id="为什么要”四次挥手”"><a href="#为什么要”四次挥手”" class="headerlink" title="为什么要”四次挥手”"></a>为什么要”四次挥手”</h4><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭</p><p>TCP协议的连接是全双工连接，一个TCP连接存在双向的读写通道。</p><p>简单说来是 “先关读，后关写”，一共需要四个阶段。以客户机发起关闭连接为例：<br>1.服务器读通道关闭<br>2.客户机写通道关闭<br>3.客户机读通道关闭<br>4.服务器写通道关闭</p><ul><li>挥手过程</li></ul><p>第一阶段 客户机发送完数据之后，向服务器发送一个FIN数据段，序列号为i；<br>1.服务器收到FIN(i)后，返回确认段ACK，序列号为i+1，关闭服务器读通道；<br>2.客户机收到ACK(i+1)后，关闭客户机写通道；<br>（此时，客户机仍能通过读通道读取服务器的数据，服务器仍能通过写通道写数据）</p><p>第二阶段 服务器发送完数据之后，向客户机发送一个FIN数据段，序列号为j；<br>3.客户机收到FIN(j)后，返回确认段ACK，序列号为j+1，关闭客户机读通道；<br>4.服务器收到ACK(j+1)后，关闭服务器写通道。<br>这是标准的TCP关闭两个阶段，服务器和客户机都可以发起关闭，完全对称。</p><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p>TCP如何保证可靠传输呢?<br>TCP发送的报文段是交给IP层传送的，IP层只能提供尽最大努力服务，也就是不可靠服务，因此TCP必须采用恰当的措施才能使得两个传输层之间的通信变得可靠。</p><ul><li>TCP保证可靠传输的方式如下：</li></ul><ol><li>数据包校验： TCP会对整个报文段进行检验</li><li>滑动窗口机制： 以字节为单位进行</li><li>超时重传机制： 发送方在规定时间内没有收到确认就要重新发送报文</li><li>选择确认：当报文未按序到达时，若这些在接收窗口范围内，接收方就先收下然后将准确信息告诉发送方，让它不要重复发送。</li><li>流量控制和拥塞控制：通过发送窗口和接收窗口大小来实现。</li></ol><h4 id="停止等待协议-（发送窗口-x3D-1，接收窗口-x3D-1）"><a href="#停止等待协议-（发送窗口-x3D-1，接收窗口-x3D-1）" class="headerlink" title="停止等待协议  （发送窗口&#x3D;1，接收窗口&#x3D;1）"></a>停止等待协议  （发送窗口&#x3D;1，接收窗口&#x3D;1）</h4><p>停止等待就是每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组，停止等待协议分为以下几种情况：</p><ol><li><p>无差错情况<br>A发送分组M1，发完就暂停发送，等待B的确认。B收到M1后就向A确认，A在收到对M1的确认后，就再发送下一个分组M2。同样在收到B对M2的确认后，再发送M3</p><img src="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/TCP01.png" class=""></li><li><p>超时重传<br>可靠传输协议是只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组，这就叫超时重传，要实现超时重传，就要在每发送完一个分组设置一个超时计时器，如果在超时计时器到期之前收到之前对方的确认，就撤销已设置的超时计时器。</p><img src="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/TCP02.png" class=""></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">1.A发送完一个分组后，必须暂时保留发送分组的副本（为发生超时重传时使用），收到确认后清除</span><br><span class="line">2.分组和确认分组必须进行编号，这样才能明确是哪一个发送出去的分组收到了确认</span><br></pre></td></tr></table></figure><ol start="3"><li>确认丢失<br>B发送的对M1的确认丢失，A在设定的超时重传时间内没有收到确认，A在超时计时器到期后就要重传M1，现在应注意B的动作，假设B又收到了重传的分组M1，这时应该采取两个行动：</li></ol><p>1.1  丢弃重复的M1，不向上层交付<br>1.2 重新向A发送确认，不能认为已经发送给确认就不再发送，因为A之所以重传M2就表示A没有收到对M2的确认。</p><ol start="4"><li>确认超时<br>传输过程中没有出现差错，但B对分组M1的确认迟到了，A会收到重复的确认，对重复的确认的处理很简单：收下后丢弃。B仍然会收到重复的M1，并且同样要丢弃重复的M1，并重传确认分组。</li></ol><img src="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/TCP04.png" class=""><h4 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4><p>停止等待协议的接受方的窗口和发送方的窗口大小都是1，1个比特就够表示了，所以也叫1比特滑动窗口协议，发送方这时自然发送每次只能发送一个，并且必须等待这个数据包的ACK，才能发送下一个。<br>停止等待协议每发送一帧就要停止等待知道接收到确认帧，这样每次等待的时候不能传送数据使得传输效率很低，</p><img src="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/TCP10.png" class=""><p>那么我们就不能先连发几个包等他一起确认吗？</p><img src="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/TCP11.png" class=""><p>把两个包一起发送，然后一起确认，所花的时间只是一个来回的时间<br>每次发送多少个包过去是最优解呢？<br>把第一个和第二个包发送过去后，收到第一个确认包就把第三个包发送过去，而不是等到第二个包的确认包才去发第三个包</p><img src="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/TCP12.png" class=""><img src="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/TCP05.png" class=""><p>位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了，连续ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</p><p>接收方采用累积确认的方式，这就是说，接收方不必对收到的分组逐个发送确认，而是可以在收到几个分组后，对按序到达的最后一个分组发送确认，这就表示到这个分组为止的所有分组都已正确收到了。</p><p>滑动窗口协议分为两种，一种是后退N帧协议，一种是选择重传协议。</p><h5 id="后退N帧协议-（发送窗口-gt-1，接收窗口-x3D-1）"><a href="#后退N帧协议-（发送窗口-gt-1，接收窗口-x3D-1）" class="headerlink" title="后退N帧协议  （发送窗口&gt;1，接收窗口&#x3D;1）"></a>后退N帧协议  （发送窗口&gt;1，接收窗口&#x3D;1）</h5><p>如果发送方发送了前9个分组，而中间的第2个分组丢失，这是接收方只能对前两个分组发出确认，发送方无法知道后面7个分组的下落，而只好把后面的7个分组都再重传一次，这就叫做Go-back-N（回退N），表示需要再退回来重传已发送的N个分组</p><img src="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/TCP06.jpeg" class=""><h5 id="选择重传协议-（发送窗口-gt-1，接收窗口-gt-1）"><a href="#选择重传协议-（发送窗口-gt-1，接收窗口-gt-1）" class="headerlink" title="选择重传协议  （发送窗口&gt;1，接收窗口&gt;1）"></a>选择重传协议  （发送窗口&gt;1，接收窗口&gt;1）</h5><p>返回N协议简化了接收方的处理过程，接收方只需要跟踪一个变量，并且不需要对失序到达的分组缓存，而是简单地把失序到达的分组他们丢掉。</p><p>选择重传协议是在后退N帧的基础上进行了改进，选择重传协议原理很简单，<code>接收端总会缓存所有收到的帧，当某个帧出现错误时，只会要求重传这一个帧，只有当某个序号后的所有帧都正确收到后，才会一起提交给高层应用</code></p><p>选择重传协议的接收窗口和发送窗口一样大(2^m-1) 比返回N协议的窗口(2^m)小了一倍</p><img src="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/TCP07.png" class=""><p><code>选择重传的接收窗口与发送窗口一样大</code>.选择重传协议允许与接受窗口一样多的分组失序到达,并保存这些失序到达的分组,直到连续的一组分组被交付给应用层.因为发送窗口与接收窗口是相同的,所以发送出来的所有分组都可以失序到达,而且会被保留直到交付为止.但是必须强调一点,在一个可靠的协议中,接收方永远不会把分组失序地交给应用层.在他们被交付给应用层之前,先要等待那些更早发出来的分组到达.</p><img src="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/TCP08.png" class=""><p>理论上选择重传协议要为每个分组使用一个计时器.当某个计时器超时后,只有相应的分组被重传.换而言之,返回N协议将所有的分组当做一个整体对待,而选择重传协议则分别对待每一个分组.但是大多数SR的运输层仅使用了一个计时器. 注意只使用一个计时器而做到跟踪所有发出去的分组的情况的做法是:标记发出分组,当ACK&#x3D;Sf 时,将窗口滑过所有连续的已确认的分组,如果还有未确认的分组,则则重发所有检测到的未被确认的分组并重启计时器,如果所有分组都被确认了则停止计时器.</p><h4 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h4><img src="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/tcp_byte.png" class=""><p>不管发送方一次性提交给 TCP 的缓冲是多大的数据，对于TCP本身来说它会根据实际的情况来进行划分，比如发送方发送10字节，TCP 并不是一次性传递10字节数据，它可能是拆分成3个字节和7个字节分俩次发送给接收方</p><h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><p>基于滑动窗口协议实现.TCP的滑动窗口主要有两个作用，一是提供TCP的可靠性，二是提供TCP的流控特性。同时滑动窗口机制还体现了TCP面向字节流的设计思路。</p><p>滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。</p><img src="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/tcp_winddow.png" class=""><p>对照上图，现在假如发送窗口是客户端，接收窗口是服务端。当我们现在要继续发送数据的时候，可能由于接收方的接收窗口没有那么大，而发送方的发送窗口非常大，就会以更快的速率往后发，需要由接收窗口通过向TCP的报文首部字段中去更改窗口值去调整发送方的发送窗口大小。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>TCP的四种拥塞控制算法<br>慢开始<br>拥塞避免<br>快恢复<br>快重传</p><img src="/2019/02/01/%E7%BD%91%E7%BB%9CTCP:UDP%E5%8D%8F%E8%AE%AE/tcp_control.png" class=""><p>横轴代表 APP 交互或者轮循次数，纵轴代表窗口值的大小<br>上图中，一开始我们可以先发送一个报文，如果没有发生网络拥塞，就继续发送 2 个报文，依然没有发生网络拥塞，就继续翻倍，直到 16 个报文，这就是慢开始算法<br>当到达 16 报文数的时候，会采用拥塞避免的策略来进行发送报文的一个数量的线性增长。<br>当报文数到 24 的时候，就会发生网络拥塞，采用拥塞避免的乘法减小到值发送 1 一个报文，来减少对网络层面带来的压力，然后再重新开始 慢开始算法增长，同时限定一个新的门限值.</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP 是一个简单的传输层协议。和 TCP 相比，UDP 有下面几个显著特性：</p><ol><li><p>UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次</p></li><li><p>UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。</p></li><li><p>UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。</p></li><li><p>UDP 支持多播和广播。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.zhihu.com/question/24853633">TCP 为什么是三次握手，而不是两次或四次？</a></li><li><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html">TCP 的特性</a></li><li><a href="https://blog.csdn.net/smileiam/article/details/78226816">TCP的三次握手、四次挥手–非常详细讲解</a></li><li><a href="https://blog.csdn.net/u013309870/article/details/77430017">计算机网络–TCP</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议</title>
      <link href="/2019/01/28/%E7%BD%91%E7%BB%9CHttp%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/01/28/%E7%BD%91%E7%BB%9CHttp%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>在HTTP建立之初，主要就是为了将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。</p><blockquote><p>HTTP是超文本传输协议。它是应用层协议的一种，请求&#x2F;响应报文的组成结构</p></blockquote><img src="/2019/01/28/%E7%BD%91%E7%BB%9CHttp%E5%8D%8F%E8%AE%AE/http20.png" class="&#x3D;"><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><h3 id="请求报文的格式"><a href="#请求报文的格式" class="headerlink" title="请求报文的格式"></a>请求报文的格式</h3><img src="/2019/01/28/%E7%BD%91%E7%BB%9CHttp%E5%8D%8F%E8%AE%AE/http_request.png" class=""><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br></pre></td></tr></table></figure><ul><li>三个部分</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请求行</span><br><span class="line">请求头，都是以 key-value形式组成</span><br><span class="line">实体主体 ， GET 请求一般不带有实体主体</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="响应报文的格式"><a href="#响应报文的格式" class="headerlink" title="响应报文的格式"></a>响应报文的格式</h3><img src="/2019/01/28/%E7%BD%91%E7%BB%9CHttp%E5%8D%8F%E8%AE%AE/http_response.png" class=""><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>137582</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache 0.84</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>三个部分<br>响应行<br>请求头，都是以 key-value形式组成<br>实体主体</li></ul><h2 id="HTTP的特点"><a href="#HTTP的特点" class="headerlink" title="HTTP的特点"></a>HTTP的特点</h2><h3 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h3><p>无连接, 每次请求有一个建立连接和释放连接的过程<br>可以通过HTTP的持久连接方案来进行HTTP无连接的一个补偿</p><img src="/2019/01/28/%E7%BD%91%E7%BB%9CHttp%E5%8D%8F%E8%AE%AE/http_chactater.png" class=""><ul><li><p>非持久连接，在 Client 和 Server 的交互中，打开一个 TCP 连接，进行网络数据的传输，然后关闭这条 TCP 连接.   之后发送第二个请求的时候可能需要重新打开一个 TCP 的连接 。 也就是说每次请求接口都需要重新建立一个 TCP 连接，经历 三次握手 四次挥手.</p></li><li><p>持久连接 , 打开一条 TCP 通道，之后可能在一定时间内, 多个 HTTP 请求可能会在同一条链路上进行请求和响应的传递.</p></li><li><p>持久连接涉及到 HTTP 的哪些头部字段呢?</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connection : keep-alive 客户端期许采用持久连接</span><br><span class="line">time : 20 多长时间有效</span><br><span class="line">max : 10 最多可以发生多少个 HTTP 请求和响应对</span><br></pre></td></tr></table></figure><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx 代表临时响应，需要请求者继续执行操作的状态代码。</span><br><span class="line">2xx 代表的多是操作成功。</span><br><span class="line">3xx 代表重定向，表示要完成请求，需要进一步操作</span><br><span class="line">4xx 代表请求错误，表示请求可能出错，妨碍了服务器的处理。</span><br><span class="line">5xx 代表服务器错误，表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错</span><br></pre></td></tr></table></figure><h3 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h3><ol><li>GET 请求参数以 ? 分割拼接到 URL 后面 ，POST请求参数在 Body里面</li><li>GET 参数长度限制 2048 个字符 ， POST一般没有该限制</li><li>GET 请求不安全 ， POST请求比较安全</li></ol><p>从语义的角度来回答</p><ol><li>GET 获取资源 ,安全的 , 幂等的 , 可缓存的</li><li>POST 处理资源 ，非安全的 ,非幂等的 , 非可缓存的</li></ol><ul><li>安全性 : 不应该引起 Server 端的任何状态变化</li><li>幂等行 : 同一个请求方法执行多次和执行一次的效果完全相同</li><li>请求是否可以被缓存</li></ul><h2 id="HTTP连接管理"><a href="#HTTP连接管理" class="headerlink" title="HTTP连接管理"></a>HTTP连接管理</h2><h3 id="连接模式"><a href="#连接模式" class="headerlink" title="连接模式"></a>连接模式</h3><p>HTTP有两种连接模式，持续连接、非持续连接</p><ol><li><p>非持续连接  指的是服务器必须为每一个请求的对象建立和维护一个全新的连接</p></li><li><p>持续连接下，TCP 连接默认不关闭，可以被多个请求复用，采用持续链接的好处是可以避免每次建立TCP连接三次握手时所花费的时间。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP1.0 以前默认使用非持续链接，但是可以在请求时，加上Connection：keep-alive来要求服务器不要关闭TCP连接</span><br><span class="line">HTTP1.1 以后默认采用的是持续的连接。</span><br></pre></td></tr></table></figure><p><em>目前对于同一个域，大多数浏览器支持同时建立6个持久连接</em></p><h3 id="无连接？有连接？"><a href="#无连接？有连接？" class="headerlink" title="无连接？有连接？"></a>无连接？有连接？</h3><p>无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p>无连接的含义可以结合HTTP无状态的含义在应用层面上去理解：每一个请求都拥有自己的请求体，期望接收到唯一的对应的响应体，而每一次的请求都相互独立，与上一次或下一次的请求毫无关系，哪怕是在同一条连接中（后面说的长连接）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP的面向连接是基于网络底层的数据传输。</span><br><span class="line">HTTP的无连接是基于应用层面的沟通交互。</span><br></pre></td></tr></table></figure><h3 id="从短连接到长连接"><a href="#从短连接到长连接" class="headerlink" title="从短连接到长连接"></a>从短连接到长连接</h3><ul><li><p>HTTP&#x2F;0.9：最早发布的1991年0.9版，该时期的HTTP协议十分简单，只支持Get请求，采用短连接的方式，也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。</p></li><li><p>HTTP&#x2F;1.0：1996年发布，默认使用短连接，提出长连接（也叫持久连接）的概念，但当时仅提供初步的支持。</p></li><li><p>HTTP&#x2F;1.1：1999年发布，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：<strong>Connection:keep-alive</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服</span><br><span class="line">务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。</span><br></pre></td></tr></table></figure><p><strong>持久连接的特点是，只要任意一端 没有明确提出断开连接，则保持 TCP 连接状态。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的</span><br><span class="line">TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</span><br><span class="line">Keep-Alive不会永久保持连接，它有一个保持时间（Keep-Alive的默认参数是</span><br><span class="line">[timout=5, max=100]，即一个TCP连接可以服务至多5秒内的100次请求），可以在不同</span><br><span class="line">的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连</span><br><span class="line">接。</span><br></pre></td></tr></table></figure><p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p><p>TCP短连接长连接都由客户端发起，而TCP长连接的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。也因为<strong>短连接、长连接的实现在HTTP之外，与HTTP无关，从HTTP自身来看，HTTP依然是无连接的</strong>。</p><h3 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep Alive"></a>Keep Alive</h3><p>在HTTP&#x2F;1.1之前的协议中，每一次通信就会连接和断开一次TCP链接。</p><img src="/2019/01/28/%E7%BD%91%E7%BB%9CHttp%E5%8D%8F%E8%AE%AE/keepalive.jpeg" class=""><p>在每一次的请求和响应都是一次完整的TCP连接的建立和断开，TCP的握手和挥手的开销对于频繁的通信来说是不可接受的。所以为了解决这个问题，提出了持久连接。也就是keep alive.</p><img src="/2019/01/28/%E7%BD%91%E7%BB%9CHttp%E5%8D%8F%E8%AE%AE/keepalive01.jpeg" class=""><p>这样做的优点：</p><ol><li>减少TCP握手和挥手的开销</li><li>减轻了服务器的负载<br>你以为做就完美了吗？其实不然，每一次通信都需要HTTP响应，才能发送下一个包，这样效率岂不是很慢。所以就引入了管线化技术。</li></ol><h2 id="从HTTP-x2F-1-1到HTTP-x2F-2"><a href="#从HTTP-x2F-1-1到HTTP-x2F-2" class="headerlink" title="从HTTP&#x2F;1.1到HTTP&#x2F;2"></a>从HTTP&#x2F;1.1到HTTP&#x2F;2</h2><h3 id="HTTP-x2F-1-1：pipelining-管线化"><a href="#HTTP-x2F-1-1：pipelining-管线化" class="headerlink" title="HTTP&#x2F;1.1：pipelining 管线化"></a>HTTP&#x2F;1.1：pipelining 管线化</h3><p>持久连接使得多数请求以管线化(pipelining)方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求</p><img src="/2019/01/28/%E7%BD%91%E7%BB%9CHttp%E5%8D%8F%E8%AE%AE/keepalive03.jpeg" class=""><p>HTTP&#x2F;1.1时期，持久连接（长连接）的弊端被提出 —— HOLB（Head of Line Blocking）即持久连接下一个连接中的请求仍然是串行的，如果某个请求出现网络阻塞等问题，会导致同一条连接上的后续请求被阻塞</p><p>因此，HTTP&#x2F;1.1中提出了pipelining概念，即客户端可以在一个请求发送完成后不等待响应便直接发起第二个请求，服务端在返回响应时会按请求到达的顺序依次返回，这样就极大地降低了延迟。然而pipelining并没有解决HOLB的问题，因为响应依然是串行返回的，pipelining也因此没有被广泛接受。</p><p>所以现代浏览器默认是不开启 HTTP Pipelining 的。</p><h3 id="HTTP-x2F-2：multiplexing-（-HTTP2-都是在-HTTPS-上实现的）"><a href="#HTTP-x2F-2：multiplexing-（-HTTP2-都是在-HTTPS-上实现的）" class="headerlink" title="HTTP&#x2F;2：multiplexing   （ HTTP2 都是在 HTTPS 上实现的）"></a>HTTP&#x2F;2：multiplexing   （ HTTP2 都是在 HTTPS 上实现的）</h3><p>multiplexing即多路复用，连接共享，在SPDY中提出，同时也在HTTP&#x2F;2中实现。multiplexing技术能够让多个请求和响应的传输完全混杂在一起进行，通过streamId来互相区别。这彻底解决了HOLB问题，同时还允许给每个请求设置优先级，服务端会先响应优先级高的请求。</p><p>pipelining和multiplexing的对比，如图：</p><img src="/2019/01/28/%E7%BD%91%E7%BB%9CHttp%E5%8D%8F%E8%AE%AE/pipeliningVSmultiplexing.png" class=""><h2 id="HTTP的长连接和WebSocket的长连接"><a href="#HTTP的长连接和WebSocket的长连接" class="headerlink" title="HTTP的长连接和WebSocket的长连接"></a>HTTP的长连接和WebSocket的长连接</h2><ul><li><p>HTTP的长连接：HTTP&#x2F;1.1通过使用Connection:keep-alive进行长连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。这种<strong>长连接是一种“伪链接”，而且只能由客户端发送请求，服务端响应</strong>。</p></li><li><p>WebSocket的长连接，是一个全双工的连接，可由服务端主动发起信息。长连接第一次TCP链路建立之后，后续数据可以双方都进行发送，不需要发送请求头。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1中双方并没有建立正真的连接会话，服务端可以在任何一次请求完成后关闭。</span><br><span class="line">WebSocket 它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="怎样判断一个请求是否结束"><a href="#怎样判断一个请求是否结束" class="headerlink" title="怎样判断一个请求是否结束?"></a>怎样判断一个请求是否结束?</h3><p>在同一条TCP上产生了多次 HTTP 请求，怎样判断前一个请求的结束</p><p>Content-length : 1024 ,  发送一个请求的时候,Server 端会携带响应数据的大小,通过 Content-length 来标识，客户端可以根据所接受数据的字节数是否到达 Content-length 的值，到达了就说明全部接受完毕，既 HTTP 请求结束</p><p>还有一种情况, 当使用 POST 端进行请求的时候 , 往往 Server 端需要多次响应来返回给客户端数据, 我们可以通过 HTTP 响应报文当中的头部字段叫 chunked 来判断请求是否结束，当有多个块通过 HTTP 的 TCP连接传输给客户端的时候，每一个报文都会带有chunked 这个字段， 最后一个块会带有一个空 chunked，这样就可以判断前一个网络请求是否结束了.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://segmentfault.com/a/1190000015821798">如何理解HTTP的无连接、短连接、长连接</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息发送和转发</title>
      <link href="/2019/01/01/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/"/>
      <url>/2019/01/01/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>消息发送（Messaging）是 Runtime 通过 selector 快速查找 IMP 的过程，有了函数指针就可以执行对应的方法实现；</p><p>消息转发（Message Forwarding）是在查找 IMP 失败后执行一系列转发流程的慢速通道，如果不作转发处理，则会打日志和抛出异常</p><span id="more"></span><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数的四要素</p><ol><li>名称   SEL   name</li><li>返回值 const char* types</li><li>参数  const char* types</li><li>函数体 IMP</li></ol><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p>SEL是selector在Objc中的表示类型，selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:</p><p><code>typedef struct objc_selector *SEL;</code></p><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p>IMP在objc.h中的定义是：</p><p><code>typedef void (*IMP)(void /* id, SEL, ... */ );</code></p><p>它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。</p><h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><p>伪代码如下或类似的逻辑，反正就是获取 IMP 并调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> objc_msgSend(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd, ...) &#123;</span><br><span class="line">  Class <span class="keyword">class</span> = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">  IMP imp = class_getMethodImplementation(<span class="keyword">class</span>, _cmd);</span><br><span class="line">  <span class="keyword">return</span> imp ? imp(<span class="keyword">self</span>, _cmd, ...) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="self-和-super"><a href="#self-和-super" class="headerlink" title="self 和 super"></a>self 和 super</h3><p>看一个问题</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Phone</span>:<span class="title">Mobile</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Phone</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="type">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">self</span>=[<span class="variable language_">super</span> init];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,<span class="built_in">NSStringFromClass</span>([<span class="variable language_">super</span> <span class="keyword">class</span>]));</span><br><span class="line">&#125;</span><br><span class="line">retrurn <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>结果是都打印出来 Phone。</p><p>来看一下[self class],[super class]的消息传递</p><img src="/2019/01/01/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/self_send.png" class=""><img src="/2019/01/01/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/super_send.png" class=""><p>这里可以看到 objc_super 结构体当中 receiver 就是当前对象 。 也就是说 无论是 [self class]或者 [super class] ，接收者都是当前对象!</p><p>解析<br>当前的实例是 phone<br>[self class] –&gt;objc_msgSend(self,@selector(class)),   首先通过实例的 isa 指针找到 phone 的类对象，它本身是没有 class 方法的，然后往父类找，也没有。 顺次一直查找到根类也就是 NSObject ,将 class的具体实现返回给调用方，也就是 phone</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance of Subclass --&gt; Subclass(class) --&gt;Superclass(class)--&gt;Root class(class)</span><br></pre></td></tr></table></figure><p>[super class] –&gt;objc_msgSendSuper(self,@selector(class))。 接受者依然是当前的 phone 这个实例，区别不同的是 它会从父类的方法了列表开始查找，也就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance of Subclass --&gt; Superclass(class)--&gt;Root class(class)</span><br></pre></td></tr></table></figure><p>所以依然还是 phone;</p><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><img src="/2019/01/01/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/msg_transfer.png" class=""><h3 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h3><ol><li><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/">Objective-C 消息发送与转发机制原理</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Runtime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息转发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象结构和行为</title>
      <link href="/2018/12/01/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%92%8C%E8%A1%8C%E4%B8%BA/"/>
      <url>/2018/12/01/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%92%8C%E8%A1%8C%E4%B8%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="拓展-VS-分类"><a href="#拓展-VS-分类" class="headerlink" title="拓展 VS 分类"></a>拓展 VS 分类</h3><h4 id="一般用扩展做什么？"><a href="#一般用扩展做什么？" class="headerlink" title="一般用扩展做什么？"></a>一般用扩展做什么？</h4><ul><li>声明私有属性</li><li>声明私有方法</li><li>声明私有成员变量</li></ul><h4 id="扩展的特点-和分类的区别"><a href="#扩展的特点-和分类的区别" class="headerlink" title="扩展的特点 (和分类的区别)"></a>扩展的特点 (和分类的区别)</h4><ul><li>编译时决议</li><li>只以声明的形式存在，多数情况下寄生于宿主类的.m中</li><li>不能为系统类添加扩展</li></ul><span id="more"></span><h3 id="KVO-和-KVC"><a href="#KVO-和-KVC" class="headerlink" title="KVO 和 KVC"></a>KVO 和 KVC</h3><h4 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h4><p>KVO实现：使用 isa-swizzling 来实现KVO</p><p>当调用了 addObserver:forkeypath 方法之后，系统会动态创建 NSKVONorifying_A 类，同时将A的isa指针指向 NSKVONorifying_A</p><p>子类拥有自己的set方法实现，内部会调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-willChangeValueForKey:</span><br><span class="line">原来的setter</span><br><span class="line">-didChangeValueForKey:这个方法内部又会调用监听器(observer)的监听方法</span><br></pre></td></tr></table></figure><h4 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h4><p>主要有这俩个方法<br>通过一副流程图看一下 valueForKey 的实现逻辑</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">-(<span class="type">void</span>)setValue:(<span class="type">id</span>)value forkey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><img src="/2018/12/01/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%92%8C%E8%A1%8C%E4%B8%BA/KVC.png" class=""><p>首先系统会判断访问的key是否有对应的getter方法，存在就直接进行调用，不存在就判断实例变量是否存在，通过 accessInstanceVariablesDirectly 来判断 ，默认是YES。 如果不存在，会调用 UndefinedKey ，抛出异常.</p><h4 id="KVC-VS-KVO"><a href="#KVC-VS-KVO" class="headerlink" title="KVC VS KVO"></a>KVC VS KVO</h4><p>KVC，即是指 NSKeyValueCoding，一个非正式的 Protocol，提供一种机制来间接访问对象的属性。KVO 就是基于 KVC 实现的关键技术之一。<br>一个对象拥有某些属性。比如说，一个 Person 对象有一个 name 和一个 address 属性。以 KVC 说法，Person 对象分别有一个 value 对应他的 name 和 address 的 key。 key 只是一个字符串，它对应的值可以是任意类型的对象。从最基础的层次上看，KVC 有两个方法：一个是设置 key 的值，另一个是获取 key 的值</p><h3 id="Copy属性关键字"><a href="#Copy属性关键字" class="headerlink" title="Copy属性关键字"></a>Copy属性关键字</h3><h4 id="浅拷贝和深拷贝的概念"><a href="#浅拷贝和深拷贝的概念" class="headerlink" title="浅拷贝和深拷贝的概念"></a>浅拷贝和深拷贝的概念</h4><img src="/2018/12/01/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%92%8C%E8%A1%8C%E4%B8%BA/copy_law.png" class=""><img src="/2018/12/01/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%92%8C%E8%A1%8C%E4%B8%BA/copy_deep.png" class=""><h4 id="Copy修饰对象"><a href="#Copy修饰对象" class="headerlink" title="Copy修饰对象"></a>Copy修饰对象</h4><img src="/2018/12/01/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%92%8C%E8%A1%8C%E4%B8%BA/copy_mutable.png" class=""><p>总结下来三点</p><ol><li>可变对象的 copy 和mutableCopy都是深拷贝</li><li>不可变对象的copy是浅拷贝，mutableCopy是深拷贝</li><li><pre><code>copy方法返回的都是不可变对象</code></pre></li></ol><h3 id="成员变量捕获"><a href="#成员变量捕获" class="headerlink" title="成员变量捕获"></a>成员变量捕获</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)catchIvar</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (^blockA)() = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,_ivarA);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)catchIvar</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (^blockA)() = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,<span class="keyword">self</span>-&gt;_ivarA);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两份代码是等价的，系统为什么要转化成self-&gt;_ivarA的形式去捕获self呢？而不是直接捕获_ivarA</p><p>正常的方法中，直接使用成员变量ivar，编译器都会自动转化为self-&gt;ivar，之所以这样做，是因为正常的消息发送中，self是会作为一个参数，传递到objc_send方法中的。所以在任何方法中都可以直接获取到self，而成员变量ivar，并没有作为任何参数传入到方法中，所以为了访问到ivar，正常都会转化为self-&gt;ivar来访问。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVC </tag>
            
            <tag> KVO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Category和load</title>
      <link href="/2018/10/10/Category%E5%92%8Cload/"/>
      <url>/2018/10/10/Category%E5%92%8Cload/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p> 一个类的分类重写了这个类的方法后，那么这个类的这个方法将失效，那么原方法失效，分类方法生效的原因是什么？</p><span id="more"></span><h3 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h3><p>+load 方法是当类或分类被添加到 Objective-C runtime 时被调用的，实现这个方法可以让我们在类加载的时候执行一些类相关的行为。子类的 +load 方法会在它的所有父类的 +load 方法之后执行，而分类的 +load 方法会在它的主类的 +load 方法之后执行。但是不同的类之间的 +load 方法的调用顺序是不确定的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原因就在这里，因为加载顺序是父类先+load，然后子类+load，然后分类+load，那么如果分类重写子类方法：首先子类+load，将方法添加到类的方法列表methodLists，然后分类+load，将重写的方法添加到方法列表中</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这里存在几点疑问：</p><ol><li>方法列表methodLists里是否会有两个SEL相同的方法？</li><li>如果会有，这两个方法在方法列表中的顺序是怎样的？(顺序决定哪个被调用)</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;TestCategory.h&quot;</span></span></span><br><span class="line"><span class="comment">/*主类实现*/</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestCategory</span></span></span><br><span class="line">- (<span class="type">void</span>)newMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;主类&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;TestCategory+add.h&quot;</span></span></span><br><span class="line"><span class="comment">/*分类一实现*/</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestCategory</span> (<span class="title">add</span>)</span></span><br><span class="line">- (<span class="type">void</span>)newMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;分类一&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;TestCategory.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="type">id</span> LenderClass = objc_getClass(<span class="string">&quot;TestCategory&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> outCount, i;</span><br><span class="line">    <span class="comment">//获取实例方法列表</span></span><br><span class="line">    Method *methodList = class_copyMethodList(LenderClass, &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;outCount; i++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;instanceMethod：%@&quot;</span>, <span class="built_in">NSStringFromSelector</span>(method_getName(method)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用一下</span></span><br><span class="line">    TestCategory *tCategory = [[TestCategory alloc]init];</span><br><span class="line">    [tCategory newMethod];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-07-19 21:38:13.593 TestRuntimeProperty[27827:1306334] instanceMethod：newMethod</span><br><span class="line">2017-07-19 21:38:13.593 TestRuntimeProperty[27827:1306334] instanceMethod：newMethod</span><br><span class="line">2017-07-19 21:38:13.594 TestRuntimeProperty[27827:1306334] 分类一</span><br></pre></td></tr></table></figure><p>可见：</p><ol><li>方法列表里会存在两个SEL相同的方法。</li><li>实际调用时，调用的是分类添加的方法，即分类添加的方法在方法列表methodLists的这个数组的顶部</li></ol><p>答案已经很明确了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">后+load的类的方法，后添加到方法列表，而这时的添加方式又是插入顶部添加，即[methodLists insertObject:category_method atIndex:0]; 所以objc_msgSend遍历方法列表查找SEL 对应的IMP时，会先找到分类重写的那个，调用执行。然后添加到缓存列表中，这样主类方法实现永远也不会调到。</span><br></pre></td></tr></table></figure><h3 id="多个category实现同一个方法"><a href="#多个category实现同一个方法" class="headerlink" title="多个category实现同一个方法"></a>多个category实现同一个方法</h3><p>如果多个分类同时重写同一个方法，执行顺序又是怎样的呢？<br>对于多个分类同时重写同一个方法，Xcode在运行时是根据buildPhases-&gt;Compile Sources里面的顺序从上至下编译的，那么很明显就像子类和分类一样，后编译的后load，即后添加到方法列表，所以后编译的分类，方法会放到方法列表顶部，调用的时候先执行。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;TestCategory+addAgain.h&quot;</span></span></span><br><span class="line"><span class="comment">/*分类二实现*/</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestCategory</span> (<span class="title">addAgain</span>)</span></span><br><span class="line">- (<span class="type">void</span>)newMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;分类二&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>看输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017-07-19 22:18:13.593 TestRuntimeProperty[28385:1331972] instanceMethod：newMethod</span><br><span class="line">2017-07-19 22:18:13.593 TestRuntimeProperty[28385:1331972] instanceMethod：newMethod</span><br><span class="line">2017-07-19 21:18:13.593 TestRuntimeProperty[28385:1331972] instanceMethod：newMethod</span><br><span class="line">2017-07-19 22:18:13.594 TestRuntimeProperty[28385:1331972] 分类一</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结:类的加载顺序，决定方法的添加顺序，调用的时候，后添加的方法会先被找到，所以调用的始终是后加载的类的方法实现。</span><br></pre></td></tr></table></figure><h3 id="initialize"><a href="#initialize" class="headerlink" title="+initialize"></a>+initialize</h3><p>+initialize 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说 +initialize 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize 方法是永远不会被调用的。那这样设计有什么好处呢？好处是显而易见的，那就是节省系统资源，避免浪费。</p><h3 id="load-VS-initialize"><a href="#load-VS-initialize" class="headerlink" title="load VS initialize"></a>load VS initialize</h3><img src="/2018/10/10/Category%E5%92%8Cload/laod_initial.png" class=""><h3 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h3><ol><li><a href="https://www.jianshu.com/p/87cfbdda0a68">Category 重写方法的调用</a></li><li><a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/">Objective-C +load vs +initialize</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Runtime </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UIView绘制原理以及异步绘制</title>
      <link href="/2018/09/01/UIView%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/"/>
      <url>/2018/09/01/UIView%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于UIKit框架的线程不安全性，苹果规定UI渲染相关操作要放在主线程来执行，不过CoreGraphic框架是线程安全的。</p><span id="more"></span><h3 id="UIView绘制流程"><a href="#UIView绘制流程" class="headerlink" title="UIView绘制流程"></a>UIView绘制流程</h3><p>UIView调用setNeedsDisplay方法后,实际上并没有发生当前视图的绘制工作,而是在之后的某一时机进行绘制工作,为什么会在之后的某一时机进行绘制工作呢?<br>当UIView调用setNeedDisplay之后,系统会调用view对应layer的 setNeedsDisplay方法,相当于在当前layer上打上了一个脏标记,然后会在当前runloop即将结束的时候调用CALayer的display方法,才会真正的进入当前视图的绘制流程当中,所以视图的绘制时机,是在当前runloop即将结束的时候才会开始。</p><p>CALayer的display方法的内部实现,首先会判断layer的delegete是否响应display方法,如果代理不响应就会进入到系统的绘制流程当中,如果响应,实际上就为我们提供了异步绘制的接口,这样就构成了UIView的绘制原理</p><img src="/2018/09/01/UIView%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/UIView_Display.jpeg" class=""><h3 id="系统的绘制流程"><a href="#系统的绘制流程" class="headerlink" title="系统的绘制流程"></a>系统的绘制流程</h3><p>首先CALayer会在内部创建一个backing store(CGContextRef),我们一般在drawRect中可以通过上下文堆栈当中拿到当前栈顶的context.然后layer判断是否有代理,如果没有代理会调用layer的drawInContext方法,如果实现了代理就会调用delegete的drawLayer:inContext方法,这是在发生在系统内部当中的,然后在合适的时机给予回调方法,也就是View的drawRect方法.可以通过drawRect方法做一些其他的绘制工作.然后无论哪两个分支,都有calayer上传backing store (最终的位图)到CPU.然后结束系统的绘制流程.</p><img src="/2018/09/01/UIView%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/UIView_DisplayBySystem.jpeg" class=""><h3 id="何为渲染"><a href="#何为渲染" class="headerlink" title="何为渲染"></a>何为渲染</h3><p>渲染就是把我们代码里设置的代码的视图和数据结合，最后绘制成一张图呈现在用户的面前。每秒绘制60张图，用户看着就是流畅的界面呈现，如果不到60帧，那么越少用户看着就会越卡。</p><h3 id="利用Runloop解释一下页面的渲染的过程"><a href="#利用Runloop解释一下页面的渲染的过程" class="headerlink" title="利用Runloop解释一下页面的渲染的过程"></a>利用Runloop解释一下页面的渲染的过程</h3><p>当我们调用 [UIView setNeedsDisplay] 时，这时会调用当前 View.layer 的 [view.layer setNeedsDisplay]方法。</p><p>这等于给当前的 layer 打上了一个脏标记，而此时并没有直接进行绘制工作。而是会到当前的 Runloop 即将休眠，也就是 beforeWaiting 时才会进行绘制工作。</p><p>紧接着会调用 [CALayer display]，进入到真正绘制的工作。CALayer 层会判断自己的 delegate 有没有实现异步绘制的代理方法 displayer:，这个代理方法是异步绘制的入口，如果没有实现这个方法，那么会继续进行系统绘制的流程，然后绘制结束。</p><p>过程可以用下面这张图来解释：</p><img src="/2018/09/01/UIView%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/setNeedsDisplay.png" class=""><p>CALayer 内部会创建一个 Backing Store，用来获取图形上下文。接下来会判断这个 layer 是否有 delegate。</p><p>如果有的话，会调用 [layer.delegate drawLayer:inContext:]，并且会返回给我们 [UIView DrawRect:] 的回调，让我们在系统绘制的基础之上再做一些事情。</p><p>如果没有 delegate，那么会调用 [CALayer drawInContext:]。</p><p>以上两个分支，最终 CALayer 都会将位图提交到 Backing Store，最后提交给 GPU。</p><p>至此绘制的过程结束。</p><img src="/2018/09/01/UIView%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/drawLayer.png" class=""><h3 id="什么是异步绘制"><a href="#什么是异步绘制" class="headerlink" title="什么是异步绘制"></a>什么是异步绘制</h3><p>异步绘制，就是可以在子线程把需要绘制的图形，提前在子线程处理好。将准备好的图像数据直接返给主线程使用，这样可以降低主线程的压力。</p><p>异步绘制的过程<br>要通过系统的 [view.delegate displayLayer:] 这个入口来实现异步绘制。</p><p>代理负责生成对应的 Bitmap<br>设置该 Bitmap 为 layer.contents 属性的值。<br>整个过程可以通过一张图来说明</p><img src="/2018/09/01/UIView%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/displayLayer.png" class=""><h3 id="异步绘制"><a href="#异步绘制" class="headerlink" title="异步绘制"></a>异步绘制</h3><p>怎么进行异步绘制呢,其实就是基于系统给我们开的口子layer.delegate,如果遵从或者实现了displayLayer方法,我们就可以进入到异步绘制流程当中,在异步绘制的过程当中</p><p>就由delegete去负责生成bitmap位图<br>设置改bitmap作为layer.content属性的值</p><p>通过一副时序图来了解异步绘制的机制和流程</p><img src="/2018/09/01/UIView%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/UIView_DrawAsync.jpeg" class=""><h3 id="如何实现异步"><a href="#如何实现异步" class="headerlink" title="如何实现异步"></a>如何实现异步</h3><ol><li>开辟子线程</li></ol><p>在子线程使用CoreGraphic生成一张图片然后再在主线程将图片设置到View或者Layer</p><ol start="2"><li>监听MainRunloop的空闲时间，进行渲染（YYAsyncLayer）</li></ol><p>注册一个RunloopObserver，监听MainRunloop在kCFRunLoopCommonModes（包含kCFRunLoopDefaultMode、UITrackingRunLoopMode）下的kCFRunLoopBeforeWaiting（Runloop将要进入休眠）和kCFRunLoopExit（即将退出本次Runloop）的状态，也就是说在一次Runloop空闲时去执行更新显示的操作。</p><h4 id="调用链："><a href="#调用链：" class="headerlink" title="调用链："></a>调用链：</h4><p>对一个包含了<code>YYAsyncLayer</code>的view，比如<code>YYLable</code>重写<code>layoutSubviews</code>方法添加对layer的<code>setNeedsDisplay</code>方法的调用。</p><p>这样一个调用链就形成了：用户操作-&gt;[view layoutSubviews]-&gt;[view.layer setNeedsDisplay]-&gt;[layer display]-&gt;[layer _displayAsync]异步绘制开始（准确的说是<code>_displayAsync</code>方法的参数为<em></em>true**的时候开始异步绘制）。</p><p>但是这并没有用到<em>RunLoop</em>。所以代码会修改为每次调用<code>layoutSubviews</code>的时候给RunLoop提交一个异步绘制的任务：在runloop空闲时回调执行。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://www.jianshu.com/p/a0ef0838e0e0">UIView绘制原理,异步绘制</a></li><li><a href="https://cloud.tencent.com/developer/article/1007314">iOS的异步绘制–YYAsyncLayer源码分析</a></li><li><a href="https://zsisme.gitbooks.io/ios-/content/chapter2/custom-drawing.html">Custom Drawing iOS核心动画高级技巧</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> UI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS特殊技巧</title>
      <link href="/2018/07/03/iOS%E7%89%B9%E6%AE%8A%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/07/03/iOS%E7%89%B9%E6%AE%8A%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>艾德的父亲给所有逍遥法外的罪犯起了一个统一的代称-<em>罗罗·汤马西</em>.——–&lt;洛城机密&gt;</p></blockquote><p>这篇博客总结一些，iOS开发中遇到的，比较特殊的问题，或者暂时想不到解决办法的问题。有些问题是个人能力不足，暂时没找到解决方案，有些可能就是苹果系统本身的问题。</p><span id="more"></span><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><h3 id="需要手动添加-synthesize的情况"><a href="#需要手动添加-synthesize的情况" class="headerlink" title="需要手动添加@synthesize的情况"></a>需要手动添加@synthesize的情况</h3><ul><li>你手动同时重写 setXXX 和 XXX（get） 方法, 就不会为你自动生成 _xxx 实例变量</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Cat</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line">- (<span class="type">void</span>)echo;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>解决</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;Cat.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Cat</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> name = _name;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)echo</span><br><span class="line">&#123;</span><br><span class="line">    _name = <span class="string">@&quot;XiaoHua&quot;</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;name = %@&quot;</span>, _name);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="单例的创建与释放"><a href="#单例的创建与释放" class="headerlink" title="单例的创建与释放"></a>单例的创建与释放</h3><ul><li>线程安全的单例创建</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)shareSingleton &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        singleton = [[<span class="keyword">self</span> alloc]init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>单例的销毁</li></ul><ol><li>必须把static dispatch_once_t onceToken; 这个拿到函数体外,成为全局的.</li><li>onceToken&#x3D;0;</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="type">void</span>)attempDealloc&#123;</span><br><span class="line">    onceToken = <span class="number">0</span>; <span class="comment">// 只有置成0,GCD才会认为它从未执行过.它默认为0.这样</span></span><br><span class="line">    才能保证下次再次调用shareInstance的时候,再次创建对象.</span><br><span class="line">    [_instance release];</span><br><span class="line">    _instance = <span class="literal">nil</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>onceToken说明</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GCD创建：dispatch_once中dispatch_once_t类型为typedef long</span><br><span class="line"> •onceToken= 0，线程执行dispatch_once的block中代码</span><br><span class="line"> •onceToken= -1，线程跳过dispatch_once的block中代码不执行</span><br><span class="line"> •onceToken= 其他值，线程被线程被阻塞，等待onceToken值改变</span><br></pre></td></tr></table></figure><h3 id="iOS定时器时间准么？"><a href="#iOS定时器时间准么？" class="headerlink" title="iOS定时器时间准么？"></a>iOS定时器时间准么？</h3><p>对于NSTimer是否时间准确呢？大家可能都知道是时间不准确的，因为受RunLoop的影响，那么GCD中也有延时，如果用GCD来做延时，那时间准确吗？</p><p>答案是GCD的time是准确的，GCD 的线程管理是通过系统来直接管理的。GCD Timer 是通过 dispatch port 给 RunLoop 发送消息，来使 RunLoop 执行相应的 block，如果所在线程没有 RunLoop，那么 GCD 会临时创建一个线程去执行 block，执行完之后再销毁掉，因此 GCD 的 Timer 是不依赖 RunLoop 的。</p><h3 id="iOS中纯代码创建的UI控件使用weak还是strong？"><a href="#iOS中纯代码创建的UI控件使用weak还是strong？" class="headerlink" title="iOS中纯代码创建的UI控件使用weak还是strong？"></a>iOS中纯代码创建的UI控件使用weak还是strong？</h3><p>当addSubview:时，该UI控件已经被VC的view持有了。如果VC把该控件声明成了strong，就会同时有两个对象持有这个UI控件，一个是VC，一个是VC的view，所以只有这两个持有者都释放了才会释放该UI控件。声明成weak的好处是不会干扰该UI控件的正常的生命周期</p><p>使用weak连接控件，只要我们在创建控件的时候，在当前的作用域 { xxx }中，添加到contentView上，就能为其添加强引用保证它不被销毁。然后当我们removeFromSuperView的时候，可以实现控件的销毁</p><h2 id="罗罗·汤马西"><a href="#罗罗·汤马西" class="headerlink" title="罗罗·汤马西"></a>罗罗·汤马西</h2><h3 id="iOS原生二维码，条形码识别问题"><a href="#iOS原生二维码，条形码识别问题" class="headerlink" title="iOS原生二维码，条形码识别问题"></a>iOS原生二维码，条形码识别问题</h3><ul><li>AVFoundation使用多译码器扫描的时候。不管有没有设置扫描区域（setRectOfInterest:）,二维码可以在扫描区域的任意位置响应扫描成功，但是条形码却不行，只能在扫码区域的中间位置响应。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">官网文档解释如下</span><br><span class="line"></span><br><span class="line">按照ISO标准解碼，实际上是，按照1:1:3:1:1去寻找那三个寻像图形，就是标志性的</span><br><span class="line">大方块。然后圈出二维码大小再去解碼的。也就是说，再没设定边界的情况下全屏都可</span><br><span class="line">以。</span><br><span class="line"></span><br><span class="line">而条形码完全不同，他是在Detect Center那个点，画一个无限延伸的米字型，然后</span><br><span class="line">去判断每一条在线能否解析出条形码所需要的0101010序列。而iOS默认的Center是</span><br><span class="line">Layer 的 Center。所以条形码扫描仪上往往会有一条红线，这并不是为了拟物化，</span><br><span class="line">而是告诉用户一定要用这条线对准条形码，否则会有扫不上的可能性</span><br></pre></td></tr></table></figure><ul><li>有时候会遇到，当AVFoundation使用多译码器扫描的时候。二维码是秒杀，但是条形码却经常扫不上。如果去掉二维码的话，条形码扫描又秒杀的问题。如果是二维码和条形码一起，条形码扫描中心线就只有center。但是如果只有条形码，扫描中心线是center+additional。additional的存在的意义是用更加优秀且稍微耗时的算法去优化扫描精准度，也就是牺牲效率换精确度。</li></ul><h3 id="进入后台播放音频文件时提示错误"><a href="#进入后台播放音频文件时提示错误" class="headerlink" title="进入后台播放音频文件时提示错误"></a>进入后台播放音频文件时提示错误</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">     [[<span class="built_in">UIApplication</span> sharedApplication] beginReceivingRemoteControlEvents];</span><br><span class="line">    <span class="built_in">AVAudioSession</span>* session=[<span class="built_in">AVAudioSession</span> sharedInstance];</span><br><span class="line">    [session setActive:<span class="literal">YES</span> error:<span class="literal">nil</span>];</span><br><span class="line">    [session setCategory:<span class="built_in">AVAudioSessionCategoryPlayback</span> error:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)beginTask</span><br><span class="line">&#123;</span><br><span class="line">    bgTaskIdentifier= [[<span class="built_in">UIApplication</span> sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        <span class="comment">//如果在系统规定时间3分钟内任务还没有完成，在时间到之前会调用到这个方法</span></span><br><span class="line">        [<span class="keyword">self</span> endBack];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结束后台运行，让app挂起</span></span><br><span class="line">- (<span class="type">void</span>)endBack</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//切记endBackgroundTask要和beginBackgroundTaskWithExpirationHandler成对出现</span></span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] endBackgroundTask:bgTaskIdentifier];</span><br><span class="line">    bgTaskIdentifier = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">      [<span class="keyword">self</span> beginTask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Can<span class="string">&#x27;t end BackgroundTask: no background task exists with identifier 2 (0x2), or it may have already been </span></span><br><span class="line"><span class="string">ended. Break in UIApplicationEndBackgroundTaskError() to debug.</span></span><br></pre></td></tr></table></figure><p>遇到这种问题，当时是一脸懵逼的，除了谷歌之外，一点思路都没有，在我契而不舍的搜索之下，结果发现stackoverflow上有人提出这是iOS13特有的系统Bug。然后我拿模拟器iOS12的系统测试，还真是没有报错….</p><h3 id="新机第一次安装、第一次启动的时候，app没数据。kill掉重新打开就好了"><a href="#新机第一次安装、第一次启动的时候，app没数据。kill掉重新打开就好了" class="headerlink" title="新机第一次安装、第一次启动的时候，app没数据。kill掉重新打开就好了"></a>新机第一次安装、第一次启动的时候，app没数据。kill掉重新打开就好了</h3><p>开发App的时候，有个别用户反应，第一次安装，第一次启动App的时候，用户隐私页面是空白的，而且会一直卡在那里，退出App，再重新进入就可以了。刚开始还以为是用户的网络故障，让她切换wifi试试，然后她说又好了，所以当时也没在意，后来自己一不小心复现了。。。。</p><p>症状: iOS 10之后   国行手机</p><p>原因:</p><blockquote><p>2015年底工信部起草的一份《移动智能终端应用软件（APP）预置和分发管理暂行规定》有关，规定中要求设备生产企业「未经明示且经用户同意，不得实施擅自收集使用用户个人信息、强制开启应用软件……等侵害用户合法权益和危害网络安全的行为」</p></blockquote><p>在 iOS 10 中，苹果为国行 iPhone 制定了一个「联网权限」功能，「允许 XXX 使用数据？」<br>只有当你选择「允许」后，应用才能够开始联网。如果你没有允许，那么这个 App 将无法做任何与联网相关的动作，不管是在前台还是后台。</p><p>解决：加一个重新加载的按钮呗！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.jianshu.com/p/6cbde1b8b922">iOS 10 的坑：新机首次安装 app，请求网络权限“是否允许使用数据”</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Objective-C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UIView 几个重要的方法</title>
      <link href="/2018/07/02/UIView%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/07/02/UIView%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><h3 id="layoutSubviews在以下情况下回被调用"><a href="#layoutSubviews在以下情况下回被调用" class="headerlink" title="layoutSubviews在以下情况下回被调用"></a>layoutSubviews在以下情况下回被调用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、init初始化不会触发layoutSubviews</span><br><span class="line">但是是用initWithFrame 进行初始化时，当rect的值不为CGRectZero时,也会触发</span><br><span class="line"></span><br><span class="line">2、addSubview会触发layoutSubviews</span><br><span class="line"></span><br><span class="line">3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化</span><br><span class="line"></span><br><span class="line">4、滚动一个UIScrollView会触发layoutSubviews</span><br><span class="line"></span><br><span class="line">5、旋转Screen会触发父UIView上的layoutSubviews事件</span><br><span class="line"></span><br><span class="line">6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件</span><br></pre></td></tr></table></figure><p>注意</p><span id="more"></span><p>苹果官方文档强调</p><p>You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.</p><p>也就是说layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。</p><p>反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。</p><h3 id="setNeedsLayout"><a href="#setNeedsLayout" class="headerlink" title="setNeedsLayout"></a>setNeedsLayout</h3><ol><li><p>标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用 </p></li><li><p>setNeedsLayout在receiver标上一个需要被重新布局的标记，在系统runloop的下一个周期自动调用layoutSubviews</p></li></ol><h3 id="layoutIfNeeded"><a href="#layoutIfNeeded" class="headerlink" title="layoutIfNeeded"></a>layoutIfNeeded</h3><ol><li>如果有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）</li><li>layoutIfNeeded方法如其名，UIKit会判断该receiver是否需要layout.根据Apple官方文档,layoutIfNeeded方法应该是这样的，layoutIfNeeded遍历的不是superview链，应该是subviews链</li></ol><h3 id="立刻刷新"><a href="#立刻刷新" class="headerlink" title="立刻刷新"></a>立刻刷新</h3><p>先调用[view setNeedsLayout]，把标记设为需要布局，然后马上调用[view layoutIfNeeded]，实现布局</p><h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><h3 id="drawRect在以下情况下会被调用"><a href="#drawRect在以下情况下会被调用" class="headerlink" title="drawRect在以下情况下会被调用"></a>drawRect在以下情况下会被调用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect调用是在Controller-&gt;loadView,Controller-&gt;viewDidLoad 两方法之后掉用的.所以不用担心在控制器中,这些View的drawRect就开始画了.</span><br><span class="line">这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量值).</span><br><span class="line">2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。</span><br><span class="line">3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。</span><br><span class="line">4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。</span><br><span class="line">以上1,2推荐；而3,4不提倡</span><br></pre></td></tr></table></figure><h3 id="drawRect方法使用注意点"><a href="#drawRect方法使用注意点" class="headerlink" title="drawRect方法使用注意点"></a>drawRect方法使用注意点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或者 setNeedsDisplayInRect，让系统自动调该方法。</span><br><span class="line">2、若使用calayer绘图，只能在drawInContext: 中（类似于drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法</span><br><span class="line">3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕</span><br></pre></td></tr></table></figure><h3 id="drawRect-CGRect-rect"><a href="#drawRect-CGRect-rect" class="headerlink" title="drawRect:(CGRect)rect"></a>drawRect:(CGRect)rect</h3><p>重写此方法，执行重绘任务 </p><h3 id="setNeedsDisplay"><a href="#setNeedsDisplay" class="headerlink" title="setNeedsDisplay"></a>setNeedsDisplay</h3><ol><li>标记为需要重绘，异步调用drawRect </li><li>setNeedDisplay在receiver标上一个需要被重新绘图的标记，在下一个draw周期自动重绘，iphone device的刷新频率是60hz，也就是1&#x2F;60秒后重绘</li></ol><h3 id="setNeedsDisplayInRect-CGRect-invalidRect"><a href="#setNeedsDisplayInRect-CGRect-invalidRect" class="headerlink" title="setNeedsDisplayInRect:(CGRect)invalidRect"></a>setNeedsDisplayInRect:(CGRect)invalidRect</h3><p>标记为需要局部重绘</p><h2 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h2><h3 id="sizeToFit"><a href="#sizeToFit" class="headerlink" title="sizeToFit"></a>sizeToFit</h3><p>sizeToFit会自动调用sizeThatFits方法；</p><p>sizeToFit不应该在子类中被重写，应该重写sizeThatFits</p><p>sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>layoutSubviews方法调用先于drawRect</p><h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h2><ol><li><a href="https://blog.csdn.net/timtian008/article/details/57084670">UIView 刷新</a></li><li><a href="http://blog.sina.com.cn/s/blog_a573f7990101cdpe.html">UIView常用的一些方法小记</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> UI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事件传递和响应机制</title>
      <link href="/2018/07/02/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/07/02/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<img src="/2018/07/02/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6/xmind.png" class=""><span id="more"></span><h3 id="响应者对象（UIResponder）"><a href="#响应者对象（UIResponder）" class="headerlink" title="响应者对象（UIResponder）"></a>响应者对象（UIResponder）</h3><p>继承了UIResponder的对象才能接受并处理事件，我们称之为“响应者对象”。以下都是继承UIResponder的，所以都能接收并处理事件。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIApplication</span></span><br><span class="line"><span class="built_in">UIViewController</span></span><br><span class="line"><span class="built_in">UIView</span></span><br></pre></td></tr></table></figure><p>为什么继承了UIResponder的类就能够接收并处理事件呢？<br>因为UIResponder中提供了以下4个对象方法来处理触摸事件</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UIResponder内部提供了以下方法来处理事件触摸事件</span></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="type">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="type">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="type">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line"><span class="comment">//加速计事件</span></span><br><span class="line">- (<span class="type">void</span>)motionBegan:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="type">void</span>)motionEnded:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="type">void</span>)motionCancelled:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line"><span class="comment">//远程控制事件</span></span><br><span class="line">- (<span class="type">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure><h2 id="事件的产生和传递"><a href="#事件的产生和传递" class="headerlink" title="事件的产生和传递"></a>事件的产生和传递</h2><h3 id="事件的产生"><a href="#事件的产生" class="headerlink" title="事件的产生"></a>事件的产生</h3><ol><li>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中</li><li>UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常先发送事件给应用程序的主窗口（keywindow）。</li><li>keywindow会在视图层次结构中找到一个最合适的视图来处理触摸事件。</li></ol><h3 id="寻找处理事件最合适的view"><a href="#寻找处理事件最合适的view" class="headerlink" title="寻找处理事件最合适的view"></a>寻找处理事件最合适的view</h3><ol><li>首先判断主窗口（keyWindow）自己是否能接受触摸事件</li><li>判断触摸点是否在自己身上</li><li>子控件数组中从后往前遍历子控件，重复前面的两个步骤（所谓从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后执行1、2步骤）</li><li>view，比如叫做hitView，那么会把这个事件交给这个hitView，再遍历这个hitView的子控件，直至没有更合适的view为止。</li><li>如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。</li></ol><h4 id="UIView不能接收触摸事件的三种情况："><a href="#UIView不能接收触摸事件的三种情况：" class="headerlink" title="UIView不能接收触摸事件的三种情况："></a>UIView不能接收触摸事件的三种情况：</h4><ol><li>不允许交互：userInteractionEnabled &#x3D; NO</li><li>隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件</li><li>透明度：如果设置一个控件的透明度&lt;0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明</li></ol><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.判断自己能否接收事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.userInteractionEnabled == <span class="literal">NO</span> || <span class="keyword">self</span>.hidden == <span class="literal">YES</span> || <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.判断点在不在当前控件上面</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> pointInside:point withEvent:event]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.去找有没有比自己更合适的view</span></span><br><span class="line">    <span class="comment">// 从后往前遍历自己的子控件</span></span><br><span class="line">    <span class="type">int</span> count = <span class="keyword">self</span>.subviews.count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 获取子控件</span></span><br><span class="line">        <span class="built_in">UIView</span> *childView = <span class="keyword">self</span>.subviews[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换坐标系</span></span><br><span class="line">        <span class="comment">// 把自己坐标系上的点转换成子控件做坐标系上的点</span></span><br><span class="line">        <span class="built_in">CGPoint</span> childPoint = [<span class="keyword">self</span> convertPoint:point toView:childView];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UIView</span> *fitView = [childView hitTest:childPoint withEvent:event];</span><br><span class="line">        <span class="comment">// 找到最合适的view</span></span><br><span class="line">        <span class="keyword">if</span> (fitView) &#123;</span><br><span class="line">            <span class="keyword">return</span> fitView;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有找到比自己更合适的view</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2018/07/02/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6/responder.png" class=""><h3 id="拦截事件的处理"><a href="#拦截事件的处理" class="headerlink" title="拦截事件的处理"></a>拦截事件的处理</h3><p>通过重写hitTest：withEvent：就可以拦截事件的传递过程，想让谁处理事件谁就处理事件。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果hitTest:withEvent:方法中返回nil，那么调用该方法的控件本身和其子控件都不是最合适的view，也就是在自己身上没有找到更合适的view。那么最合适的view就是该控件的父控件。</p><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><p>想让谁成为最合适的view就重写谁自己的父控件的hitTest:withEvent:方法返回指定的子控件，或者重写自己的hitTest:withEvent:方法 return self。但是，建议在父控件的hitTest:withEvent:中返回子控件作为最合适的view！</p><p>原因是子控件在遍历时会根据addsuview的逆序遍历。</p><h3 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h3><ol><li><a href="https://www.jianshu.com/p/2e074db792ba">iOS之事件的传递和响应机制</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> UI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AutoreleasePool总结</title>
      <link href="/2018/06/28/AutoreleasePool%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/28/AutoreleasePool%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为什么已经有了 ARC ,但还是需要 @autoreleasePool 的存在？<br>避免内存峰值，及时释放不需要的内存空间</p></blockquote><span id="more"></span><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="一个很经典的面试题"><a href="#一个很经典的面试题" class="headerlink" title="一个很经典的面试题"></a>一个很经典的面试题</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXFLOAT; i++) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *string = <span class="string">@&quot;stdy&quot;</span>;</span><br><span class="line">        string = [string lowercaseString];</span><br><span class="line">        string = [string stringByAppendingString:<span class="string">@&quot;123&quot;</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;--%@&quot;</span>, string);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述的这种写法，会使内存慢慢增加，如何解决呢？自动释放池</p><!--more--><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXFLOAT; i++) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *string = <span class="string">@&quot;stdy&quot;</span>;</span><br><span class="line">            string = [string lowercaseString];</span><br><span class="line">            string = [string stringByAppendingString:<span class="string">@&quot;123&quot;</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;--%@&quot;</span>, string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="AutoreleasePool爆栈的问题"><a href="#AutoreleasePool爆栈的问题" class="headerlink" title="AutoreleasePool爆栈的问题"></a>AutoreleasePool爆栈的问题</h3><p>autoreleasePool 的自动 drain是靠runLoop进入空闲来触发的。那么如果你在执行一个很重的任务（如一个很多次数的循环）导致runLoop一直不能进入空闲。 那么autoreleasePool 里面对象会越来越多。导致内存爆掉。因此建议如果是循环次数很大的循环，要么循环里面不要产生autorelease的对象，要么就要手动 添加 @autorelease {}来避免内存爆掉。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用容器的block版本的枚举容器时，内部会自动添加一个AutoreleasePool</span></span><br><span class="line">[array enumerateObjectsUsingBlock:^(<span class="type">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">    <span class="comment">// 这里被一个局部@autoreleasepool包围着</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="什么时间会创建自动释放池？"><a href="#什么时间会创建自动释放池？" class="headerlink" title="什么时间会创建自动释放池？"></a>什么时间会创建自动释放池？</h3><p> 从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件，运行循环检测到事件并启动后，就会创建自动释放池。 子线程的 runloop 默认是不工作，无法主动创建，必须手动创建。 自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如：自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。</p><p>但对于 blockOperation 和 invocationOperation 这种默认的Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。</p><p>@autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。</p><p>如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。</p><h3 id="访问-weak-修饰的变量，是否已经被注册在了-autoreleasePool-中？为什么？"><a href="#访问-weak-修饰的变量，是否已经被注册在了-autoreleasePool-中？为什么？" class="headerlink" title="访问 __weak 修饰的变量，是否已经被注册在了 @autoreleasePool 中？为什么？"></a>访问 __weak 修饰的变量，是否已经被注册在了 @autoreleasePool 中？为什么？</h3><p>肯定的，__weak修饰的变量属于弱引用，如果没有被注册到 @autoreleasePool 中，创建之后也就会随之销毁，为了延长它的生命周期，必须注册到 @autoreleasePool 中，以延缓释放。</p><h3 id="函数返回一个对象时，会对对象-autorelease-么？为什么？"><a href="#函数返回一个对象时，会对对象-autorelease-么？为什么？" class="headerlink" title="函数返回一个对象时，会对对象 autorelease 么？为什么？"></a>函数返回一个对象时，会对对象 autorelease 么？为什么？</h3><p>会 ，为了延长返回对象的生命周期，给其他使用者留足调用的时间</p><h3 id="简要说一下-autoreleasePool-的数据结构？"><a href="#简要说一下-autoreleasePool-的数据结构？" class="headerlink" title="简要说一下 @autoreleasePool 的数据结构？"></a>简要说一下 @autoreleasePool 的数据结构？</h3><p>一个双向链表组成的栈</p><img src="/2018/06/28/AutoreleasePool%E6%80%BB%E7%BB%93/autorelease.jpg" class=""><ol><li>AutoreleasePoolPage 组成了一个双向链表，每个page里面都有一个一页的大小的数组，如iOS上一页 0x4000。 每个AutoreleasePoolPage都有个next指针指向下一个可以存储的位置。当next是结尾的时候，这个page就full了。再压入对象就要创建新的page了。</li><li>一般情况下链表最尾端的一个page是 hotPage. 一般autorelease时对象指针会压入这个page。</li><li>objc_autoreleasePoolPush 会返回当前page的 next的地址作为 token. 然后objc_autoreleasePoolPop 会一直倾倒到这个token的地址。</li><li>push和pop一般出现的地方就是： ① @autorelease {} 所包围的代码的前后； ② runLoop 进入和退出时；③ runLoop进入kCFRunLoopBeforeWaiting状态时，也就是常常说的idle时，会先pop, 再 push.</li></ol><h3 id="autoreleasrPool-的释放时机？"><a href="#autoreleasrPool-的释放时机？" class="headerlink" title="@autoreleasrPool 的释放时机？"></a>@autoreleasrPool 的释放时机？</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p><p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p><p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p><p><code>Autorelease对象是在当前runloop迭代结束时释放</code></p><h2 id="Autorelease原理"><a href="#Autorelease原理" class="headerlink" title="Autorelease原理"></a>Autorelease原理</h2><h3 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h3><p>ARC下使用<code>@autoreleasepool&#123;&#125;</code>来使用一个AutoreleasePool，随后编译器会将其改写成下面的样子</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *context = objc_autoreleasePoolPush();</span><br><span class="line"><span class="comment">// &#123;&#125;中的代码</span></span><br><span class="line">objc_autoreleasePoolPop(context);</span><br></pre></td></tr></table></figure><h3 id="AutoreleasePoolPage结构—-C-实现的类"><a href="#AutoreleasePoolPage结构—-C-实现的类" class="headerlink" title="AutoreleasePoolPage结构—-C++实现的类"></a>AutoreleasePoolPage结构—-C++实现的类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">magic_t</span> <span class="type">const</span> magic;</span><br><span class="line">id*next;<span class="comment">//作为游标指向栈顶最新add进来的autorelease对象的地址</span></span><br><span class="line">pthread <span class="type">const</span> thread;</span><br><span class="line">AutoreleasePoolPage* <span class="type">const</span> parent;</span><br><span class="line">AutoreleasePoolPage* child;</span><br><span class="line"><span class="type">uint32_t</span> <span class="type">const</span> depth;</span><br><span class="line"><span class="type">unit32_t</span> hiwat;</span><br></pre></td></tr></table></figure><ul><li>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小）</li><li>一个AutoreleasePoolPage空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</li></ul><h3 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush"></a>objc_autoreleasePoolPush</h3><ul><li>当前线程只有一个AutoreleasePoolPage对象时的内存结构<img src="/2018/06/28/AutoreleasePool%E6%80%BB%E7%BB%93/autorelease01.jpg" class="">上图中，这一页再加入一个autorelease对象就要满了，也就是next指针马上指向栈顶，这时就要建立下一页page对象，与这一页链表连接完成后，新page的next指针被初始化在栈底（begin的位置），然后继续向栈里添加新对象。</li></ul><p><code>向一个对象发送--autorelease消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置</code></p><h3 id="objc-autoreleasePoolPop"><a href="#objc-autoreleasePoolPop" class="headerlink" title="objc_autoreleasePoolPop"></a>objc_autoreleasePoolPop</h3><p>每当进行一次objc_autoreleasePoolPush调用时，runtime会向当前的AutoreleasePoolPage中add进一个哨兵对象，值为0（也就是nil），那么page就变成下面的样子</p><img src="/2018/06/28/AutoreleasePool%E6%80%BB%E7%BB%93/autorelease02.jpg" class=""><p>objc_autoreleasePoolPush的返回值就是这个哨兵对象的地址，objc_autoreleasePoolPop（哨兵对象）作为入参</p><ul><li>释放过程</li></ul><ol><li>根据传入的哨兵对象地址找到哨兵对象所处的page</li><li>在当前page中，将晚于哨兵对象（可根据parent跨越page）插入的所有autorelease对象都发送一次release消息，并向回移动next指针到正确位置</li></ol><p>上面Pop之后的内存状态如下</p><img src="/2018/06/28/AutoreleasePool%E6%80%BB%E7%BB%93/autorelease03.jpg" class=""><h3 id="嵌套的AutoreleasePool"><a href="#嵌套的AutoreleasePool" class="headerlink" title="嵌套的AutoreleasePool"></a>嵌套的AutoreleasePool</h3><p>pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已</p><h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h2><p>1.<a href="https://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> AutoreleasePool </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS性能优化</title>
      <link href="/2018/06/24/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2018/06/24/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>以前喜欢在写代码的时候，注重每个细节的性能，后来发现这样效率很低，常常在细枝末节上浪费过多时间，印证了那句过早的优化是万恶之源，所以现在更倾向于用性能检测手段检查出问题所在，有目的的优化。</p><span id="more"></span><h3 id="1-内存泄漏"><a href="#1-内存泄漏" class="headerlink" title="1.内存泄漏"></a>1.内存泄漏</h3><p>iOS使用引用计数来来管理对象的释放，借鉴的C++的智能指针的机制，但这种机制本身也有问题，常见的有循环引用导致对象不能被释放。</p><h4 id="1-1循环引用"><a href="#1-1循环引用" class="headerlink" title="1.1循环引用"></a>1.1循环引用</h4><p>可以使用腾讯开源的 MLeaksFinder 控件来实现监测。</p><p>原理</p><p>为基类NSObject添加一个方法 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-willDealloc</span><br></pre></td></tr></table></figure><p>方法的作用是，先用一个弱指针指向 self，并在一小段时间(3秒)后，通过这个弱指针调用 -assertNotDealloc，而 -assertNotDealloc 主要作用是直接中断言。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="type">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [weakSelf assertNotDealloc];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)assertNotDealloc &#123;</span><br><span class="line">     <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, @“”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-主线程流畅性监控"><a href="#2-主线程流畅性监控" class="headerlink" title="2.主线程流畅性监控"></a>2.主线程流畅性监控</h3><p>由于UIkit是线程不安全的，所以苹果规定把UI相关的刷新操纵放在主线程里执行，所以监控主线程的流畅度就能测量出App是否流畅，而App流畅，一般是监测FPS值，FPS达到60&#x2F;s是理想状态，小于这个值就会失帧</p><p>原理：开启一个线程，监控runloop的状态 kCFRunLoopBeforeSources kCFRunLoopBeforeWaiting，计算出两个状态之间的差值，如果时间差大于15ms 即存在失帧。这个时候可以利用第三方不会线程栈，找出耗时的函数。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>1.<a href="http://wereadteam.github.io/2016/02/22/MLeaksFinder/">MLeadksFinder简介</a></p><p>2.<a href="http://www.tanhao.me/code/151113.html/">iOS实时卡顿监控</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> Objective-C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo安装遇坑笔记</title>
      <link href="/2018/06/01/Hexo%E5%AE%89%E8%A3%85%E9%81%87%E5%9D%91/"/>
      <url>/2018/06/01/Hexo%E5%AE%89%E8%A3%85%E9%81%87%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页.</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a></p><h2 id="安装完后Hexo-s-运行报错"><a href="#安装完后Hexo-s-运行报错" class="headerlink" title="安装完后Hexo s 运行报错"></a>安装完后Hexo s 运行报错</h2><p>1.提示你 执行  npm install hexo –save<br>执行后会报warning<br>npm WARN engine <a href="mailto:&#x68;&#x65;&#120;&#x6f;&#x40;&#51;&#46;&#x37;&#46;&#x31;">&#x68;&#x65;&#120;&#x6f;&#x40;&#51;&#46;&#x37;&#46;&#x31;</a>: wanted: {“node”:”&gt;&#x3D;6.9.0”} (current: {“node”:”4.8.7”,”npm”:”2.15.11”})<br>这个时候需要更新下node版本<br>2.升级方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm cache clean -f</span><br><span class="line">  sudo npm install -g n</span><br><span class="line">  sudo n stable</span><br></pre></td></tr></table></figure><p>重启终端后 查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br></pre></td></tr></table></figure><h2 id="Hexo-s运行-yml脚本报错"><a href="#Hexo-s运行-yml脚本报错" class="headerlink" title="Hexo s运行 *.yml脚本报错"></a>Hexo s运行 *.yml脚本报错</h2><p>编辑yml文件后，运行报某行的值不能为空的错，这里要吐槽下hexo的脚本解析能力真是太弱了。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo s  <span class="comment">#启动服务器 本地调试使用</span></span><br><span class="line">hexo clean <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常见错误："><a href="#常见错误：" class="headerlink" title="常见错误："></a>常见错误：</h2><p>1.key:后面没有空格<br>2.缩进问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ deploy: </span><br><span class="line">    <span class="built_in">type</span>: git</span><br><span class="line">    repo: https://github.com/JackWchen2015/JackWchen2015.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="Hexo-报TypeError-Cannot-read-property-‘utcOffset’-of-null"><a href="#Hexo-报TypeError-Cannot-read-property-‘utcOffset’-of-null" class="headerlink" title="Hexo 报TypeError: Cannot read property ‘utcOffset’ of null"></a>Hexo 报TypeError: Cannot read property ‘utcOffset’ of null</h2><p>解决方法：编辑yml文件</p><p>1.timezone: Asia&#x2F;Shanghai</p><h2 id="部署后大小写更改造成的路径问题"><a href="#部署后大小写更改造成的路径问题" class="headerlink" title="部署后大小写更改造成的路径问题"></a>部署后大小写更改造成的路径问题</h2><p>有时候经常会出现文章部署后又修改了Tag或Categories，而恰好修改的内容涉及到英文字母大写改小写或小写改大写，譬如news改为News，字母N修改后确发现部署到Github上无法生效，而此时你若在本地预览确一切正常</p><p>由于在发布的文章中出现的Tag或Categories会对应在tag或categories页面中显示，因此当点击对应的Tag或Categories时会出现路径无法找到从而跳转到404页面。</p><p>原因：<br><code>由于git命令默认的配置中忽略了文件名的大小写</code></p><p>解决：</p><ol><li><p>进入.deploy_git文件夹<br>打开.git目录下的config文件并修改ignorecase &#x3D; true 为 ignorecase &#x3D; false</p></li><li><p>删除 .deploy_git文件夹内的所有文件，并push到Github仓库</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -rf *</span><br><span class="line">git commit -m ‘clean all file’</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><ol start="3"><li>重新生成文件并部署到Github上</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="部署失败"><a href="#部署失败" class="headerlink" title="部署失败"></a>部署失败</h2><p><a href="https://www.alankeene.com/2020/1207/hexo-g-d-failed.html">hexo g -d 突然部署失败</a> ChildProcess. hexo&#x2F;node_modules&#x2F;hexo-util&#x2F;lib&#x2F;spawn.js:37:17</p><blockquote><p>repo 仓库的地址访问失败 导致的部署失败</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.jianshu.com/p/0d76298700b6">Mac下node升级</a></li><li><a href="https://trifond.github.io/2018/12/05/hexo-folder-ignore-case/">Hexo部署到Github后文件夹名大小写引起的问题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>指数基金 （平均20%收益）</title>
      <link href="/2018/04/28/%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91/"/>
      <url>/2018/04/28/%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是指数？"><a href="#什么是指数？" class="headerlink" title="什么是指数？"></a>什么是指数？</h3><p>指数就是根据样本股票的价格统计出来的数据，用来衡量整个股票市场的价格波动情形。</p><span id="more"></span><h3 id="什么是指数基金？"><a href="#什么是指数基金？" class="headerlink" title="什么是指数基金？"></a>什么是指数基金？</h3><p>指数基金就是以指数成分股为投资对象的基金，目标是取得与指数大致相同的收益率。简单地说，它买的不是某一只股票，而是买的一揽子股票来跟踪对应的指数。</p><h4 id="被动指数型基金"><a href="#被动指数型基金" class="headerlink" title="被动指数型基金"></a>被动指数型基金</h4><p>买指数里面的全部股票，希望获得和指数一样的收益。</p><h4 id="增强型指数基金"><a href="#增强型指数基金" class="headerlink" title="增强型指数基金"></a>增强型指数基金</h4><p>买指数里的大部分股票，同时挑选一些其它的股票搭配，希望获得比指数更高的收益。</p><h3 id="运作"><a href="#运作" class="headerlink" title="运作"></a>运作</h3><p>根据每一种证券在指数中所占的比例购买响应比例的证券，长期持有即可。</p><h3 id="如何挑选"><a href="#如何挑选" class="headerlink" title="如何挑选"></a>如何挑选</h3><ol><li>看它跟踪的是什么指数<br>1.1 大盘、中小盘指数基金<br>1.2 行业型指数基金<br>1.3 主题型指数基金。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 韭菜的救赎 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络模型和常见协议</title>
      <link href="/2018/03/14/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%92%8CARP,DNS/"/>
      <url>/2018/03/14/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%92%8CARP,DNS/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-x2F-IP五层模型-VS-OSI参考模型"><a href="#TCP-x2F-IP五层模型-VS-OSI参考模型" class="headerlink" title="TCP&#x2F;IP五层模型 VS OSI参考模型"></a>TCP&#x2F;IP五层模型 VS OSI参考模型</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</span><br><span class="line">表示层 数据格式化，代码转换，数据加密 没有协议</span><br><span class="line">会话层 解除或建立与别的接点的联系 没有协议</span><br><span class="line">传输层 提供端对端的接口 TCP，UDP</span><br><span class="line">网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP</span><br><span class="line">数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU</span><br><span class="line">物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2</span><br></pre></td></tr></table></figure><img src="/2018/03/14/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%92%8CARP,DNS/%E7%BD%91%E7%BB%9C%E5%B1%82.png" class=""><span id="more"></span><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><h4 id="IP地址和MAC地址"><a href="#IP地址和MAC地址" class="headerlink" title="IP地址和MAC地址"></a>IP地址和MAC地址</h4><p>MAC地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址</p><img src="/2018/03/14/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%92%8CARP,DNS/macAddr.png" class=""><p>使用IP地址的IP数据报一旦交给了数据链路层，就被封装成了MAC帧，MAC帧在传送时使用的原地址和目的地址都是硬件地址，连接在通信链路上的设备（主机或者路由器）在接收MAC帧时，根据是MAC帧首部的硬件地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP地址本质上是终点地址，它在跳过路由器的时候不会变（NAT（Network address translation）例外）</span><br><span class="line">MAC地址则是下一跳的地址，每跳过一次路由都会改变。</span><br></pre></td></tr></table></figure><h4 id="ARP地址解析协议"><a href="#ARP地址解析协议" class="headerlink" title="ARP地址解析协议"></a>ARP地址解析协议</h4><p>地址解析协议，基本功能是透过目标设备的IP地址，查询目标设备的MAC地址</p><p>每台安装有TCP&#x2F;IP协议的主机里都有一个ARP缓存表，表里的IP地址与MAC地址是一一对应的</p><img src="/2018/03/14/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%92%8CARP,DNS/adr.png" class=""><p>当主机A要向主机B发送IP数据报时，就先在其ARP高速缓存中查找有无主机B的IP地址，如果有，就把硬件地址写入MAC帧，然后通过局域网把该MAC帧发往此硬件地址。</p><p>没有就会按照如下步骤找出主机B的硬件地址</p><ol><li><p>主机A，B在同一个局域网的时候，ARP广播发送一个ARP请求分组</p><img src="/2018/03/14/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%92%8CARP,DNS/arpSend.png" class=""><p>主机B在ARP分组中见到自己的IP地址，就会响应分组，并写入自己的硬件地址</p></li><li><p>主机A，B不在同一个局域网的时候，此时发送主机通过ARP协议获得的将不是目的主机的真实MAC地址，而是当前路由器的MAC地址 这种情况称为委托ARP或ARP代理。</p></li></ol><h4 id="同网段和不同网段设备通信原理"><a href="#同网段和不同网段设备通信原理" class="headerlink" title="同网段和不同网段设备通信原理"></a>同网段和不同网段设备通信原理</h4><p>通信实现的前提是拥有双方的IP地址和MAC地址</p><p><code>主机A与主机B通信，已知A的IP地址，MAC地址，B的IP地址，通过ARP获取主机B的MAC地址</code></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>IP协议并不提供可靠传输，如果丢包了，IP协议并不能通知传输层是否丢包，以及丢包原因。ICMP可以完成这样的功能</p><ol><li>确认IP包是否成功到达目标地址。</li><li>通知在发送过程中IP包被废弃的具体原因。</li></ol><p><code>IP通信中如果某个IP包因为某种原因未能到达目标地址，那么这个具体原因将由ICMP负责通知</code></p><img src="/2018/03/14/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%92%8CARP,DNS/11.png" class=""><ul><li>ICMP消息类型<img src="/2018/03/14/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%92%8CARP,DNS/12.png" class=""></li></ul><h4 id="ICMP超时消息"><a href="#ICMP超时消息" class="headerlink" title="ICMP超时消息"></a>ICMP超时消息</h4><p>IP包中有一个字段TTL（Time To Live，生存周期），它的值随着每经过一次路由器就会减1，直到0时该IP包就会被丢弃，此时IP路由器将会发送一个ICMP超时的消息给发送端主机，并通知该包已被丢弃。</p><ul><li>traceroute<br>可以显示出由执行程序的主机到达特定主机之前历经多少路由器。原理就是利用IP包的TTL从1开始按照顺序递增的同时发送UDP包，强制接收ICMP超时消息的一种方法，这样可以将所有路由器的IP地址逐一呈现。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Jack-Mac-mini:~ Jack$ traceroute www.baidu.com</span><br><span class="line">traceroute to www.baidu.com (14.215.177.39), 64 hops max, 52 byte packets</span><br><span class="line"> 1  xiaoqiang (192.168.31.1)  2.367 ms  1.271 ms  1.048 ms</span><br><span class="line"> 2  192.168.1.1 (192.168.1.1)  1.821 ms  1.886 ms  1.760 ms</span><br><span class="line"> 3  100.64.0.1 (100.64.0.1)  4.640 ms  4.539 ms  5.622 ms</span><br><span class="line"> 4  202.105.158.97 (202.105.158.97)  30.972 ms</span><br><span class="line">    53.187.37.59.broad.dg.gd.dynamic.163data.com.cn (59.37.187.53)  4.616 ms</span><br><span class="line">    202.105.154.165 (202.105.154.165)  3.564 ms</span><br><span class="line"> 5  119.145.47.85 (119.145.47.85)  4.626 ms</span><br><span class="line">    202.105.106.37 (202.105.106.37)  7.971 ms *</span><br><span class="line"> 6  113.96.5.38 (113.96.5.38)  16.189 ms</span><br><span class="line">    113.96.4.246 (113.96.4.246)  8.064 ms</span><br><span class="line">    113.96.0.18 (113.96.0.18)  11.310 ms</span><br><span class="line"> 7  113.96.11.74 (113.96.11.74)  8.232 ms  6.788 ms  9.168 ms</span><br><span class="line"> 8  121.14.67.130 (121.14.67.130)  9.790 ms</span><br><span class="line">    14.215.32.90 (14.215.32.90)  10.042 ms  8.760 ms</span><br><span class="line"> 9  * * *</span><br></pre></td></tr></table></figure><h4 id="ICMP回送消息"><a href="#ICMP回送消息" class="headerlink" title="ICMP回送消息"></a>ICMP回送消息</h4><p>用于通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，网络上常用的ping命令就是利用这个消息实现的。</p><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><h4 id="IP分割与重组"><a href="#IP分割与重组" class="headerlink" title="IP分割与重组"></a>IP分割与重组</h4><p>在数据链路层，每一条数据链路都有它的最大传输单元MTU，所以如果你传输的数据包大于数据链路层的最大传输单元，就需要对它进行分割。</p><img src="/2018/03/14/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%92%8CARP,DNS/10.png" class=""><p>如图，由于以太网的默认MTU是1500字节，因此4342字节的IP数据报无法在一个帧当中发送完成，这时路由器将此IP数据报划分成了3个分片进行发送。</p><p><code>经过分片之后的IP数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。因为无法保证IP数据报是否经由同一个路径传送</code></p><h4 id="路径MTU发现"><a href="#路径MTU发现" class="headerlink" title="路径MTU发现"></a>路径MTU发现</h4><p>分片机制的不足：</p><ol><li>加重路由器的负荷</li><li>一旦某个分片丢失，则会导致整个IP数据报作废</li></ol><p>路径MTU：是指从发送端主机到接收端主机之间不需要分片时最大MTU的大小，即路径中存在的所有数据链中最小的MTU，就可以避免在中途的路由器上进行分片处理。</p><ul><li>路径MTU发现的原理<img src="/2018/03/14/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%92%8CARP,DNS/13.png" class="">1.首先发送端发送IP数据报时将其首部的分片禁止标志位设置1，根据这个标志位，路由器遇到需要分片才能处理的大包，也不会去分片，而是将包丢弃。</li></ul><ol start="2"><li>丢弃的时候，ICMP会回送一个不可达消息将数据链路上的MTU的值发送主机</li><li>发送给同一个目标主机的IP数据报会设置步骤2获取到的MTU为当前MTU，发送主机会根据这个MTU对数据报进行分片处理。如此反复，直到数据报被发送到目标主机为止，没有再收到任何ICMP，就认为最后一次ICMP所通知的MTU即是一个合适MTU。一般会缓存10分钟</li></ol><h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><p>DNS 是域名到 IP 地址的映射，DNS 解析使用 UDP 数据报，端口号53，并且采用明文传输的方式<br>客户端在向服务端发送请求时，会先将 域名 到 DNS 服务器映射出 IP 地址，然后再访问。</p><img src="/2018/03/14/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%92%8CARP,DNS/dns.png" class=""><p>Mac系统下更改host文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/hosts</span><br></pre></td></tr></table></figure><h4 id="DNS-解析的两种方式"><a href="#DNS-解析的两种方式" class="headerlink" title="DNS 解析的两种方式"></a>DNS 解析的两种方式</h4><ul><li>递归查询    （用户向本地 DNS 服务器发起请求）</li></ul><p>不断地自下而上遍历解析，“我去给你问一下”的方式</p><p><code>主机向本地域名服务器的查询采用递归查询</code>,如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向根域名服务器继续发出查询请求报文，而不是让主机自己进行下一步查询。因此，递归查询返回的结果或者是要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p><ul><li>迭代查询  （本地 DNS 服务器向各级域名服务器发起请求）</li></ul><p>迭代查询 是 “我告诉你谁可能知道”的方式</p><p><code>本地域名服务器向根域名服务器的查询通常采用迭代查询</code>,当根域名服务器收到本地域名服务器发出的迭代查询请求报文是，要么给出所要查询的IP地址，要么告诉域名服务器下一步要向哪个域名服务器进行查询。然后本地域名服务器继续进行下一步查询。</p><img src="/2018/03/14/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%92%8CARP,DNS/die.png" class=""><h4 id="DNS优化与应用"><a href="#DNS优化与应用" class="headerlink" title="DNS优化与应用"></a>DNS优化与应用</h4><ol><li><p>DNS缓存<br>  DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</p></li><li><p>DNS负载均衡(DNS重定向) DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时， DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问 引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS</span><br><span class="line">服务器会返回一个跟 用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的</span><br><span class="line">请求，提供所需的内容。</span><br></pre></td></tr></table></figure><ol start="3"><li>dns-prefetch DNS Prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。</li></ol><h4 id="DNS-解析存在的问题"><a href="#DNS-解析存在的问题" class="headerlink" title="DNS 解析存在的问题"></a>DNS 解析存在的问题</h4><p>DNS 劫持</p><p>被钓鱼网站劫持，有可能返回错误的 IP，浏览的不是目标浏览器</p><p>DNS 解析转发</p><p>小的运营商可能将 DNS 解析请求转发，解析的比较慢，效率低</p><h4 id="DNS-劫持解决办法"><a href="#DNS-劫持解决办法" class="headerlink" title="DNS 劫持解决办法"></a>DNS 劫持解决办法</h4><ul><li><a href="http://www.ttlsa.com/web/httpdns-detailed-service/">httpDNS</a></li></ul><p>使用 http 协议向 DNS 服务器 80 端口进行请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpDNS是使用HTTP协议向DNS服务器的80端口进行请求，代替传统的DNS协议向DNS服务器的53端口进行请求,绕开了运营商的Local DNS，从而避免了使用运营商Local DNS造成的劫持和跨网问题。</span><br><span class="line"></span><br><span class="line">HTTPDNS使用HTTP协议进行域名解析，代替现有基于UDP的DNS协议，域名解析请求直接发送到HTTPDNS服务器，从而绕过运营商的Local DNS，能够避免Local DNS造成的域名劫持问题和调度不精准问题</span><br></pre></td></tr></table></figure><ul><li>长连接</li></ul><p>找一个中间的长连 server ,在内网专线进行 Http 请求。客户端和这个长连 server通信即可。</p><h4 id="DNS为什么使用UDP协议作为传输层协议？"><a href="#DNS为什么使用UDP协议作为传输层协议？" class="headerlink" title="DNS为什么使用UDP协议作为传输层协议？"></a>DNS为什么使用UDP协议作为传输层协议？</h4><p>主要是为了避免使用TCP协议时照成的连接时延，因为为了得到一个域名的IP地址，往往会向多个域名服务器查询，如果使用TCP协议，那么每次请求都会存在连接时延，这样使DNS服务变得很慢，因为大多数的地址查询请求，都是浏览器请求页面时发出的，这样会照成网页的等待时间过长。</p><h4 id="使用UDP作为DNS协议的问题？"><a href="#使用UDP作为DNS协议的问题？" class="headerlink" title="使用UDP作为DNS协议的问题？"></a>使用UDP作为DNS协议的问题？</h4><ol><li>由于物理链路的最小MTU（最大传输单元，大于这个值会导致IP分片，IP包每次最大为1500）&#x3D;576，所以为了限制报文长度不超过576，UDP的报文长度被限制在512个字节以内，这样一旦DNS的查询或者应答报文，超过了512字节，那么基于UDP的DNS协议，就会被截断为512字节，那么有可能用户得到的DNS应答就是不完整的，为了解决这个问题，可以使用TCP协议去请求报文。</li><li>安全问题，无法确定得到的应答一定是一个安全的应答。所以现在有了DNS over HTTPS来解决这个问题。</li></ol><h3 id="如何在测试过程中-MOCK-各种网络环境？"><a href="#如何在测试过程中-MOCK-各种网络环境？" class="headerlink" title="如何在测试过程中 MOCK 各种网络环境？"></a>如何在测试过程中 MOCK 各种网络环境？</h3><p><a href="https://blog.csdn.net/u010828718/article/details/46986795">模拟iOS网络环境</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/u013309870/article/details/77427112">计算机网络–ARP地址解析协议详解</a></li><li><a href="https://www.cnblogs.com/duan2/p/9128765.html">同网段和不同网段设备通信原理详解</a></li><li><a href="">图解TCP&#x2F;IP</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【读书笔记】OC高级编程多线程和内存管理</title>
      <link href="/2017/11/14/OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2017/11/14/OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>GCD几个重要的函数</p><span id="more"></span><h2 id="Serial-Dispatch-Queue"><a href="#Serial-Dispatch-Queue" class="headerlink" title="Serial Dispatch Queue"></a>Serial Dispatch Queue</h2><p>系统对于一个<code>Serial Dispatch Queue</code>就只生成并使用一个线程。（所以4个SerialDispatchQueue 性能比一个concurrent queue里的4个block任务 更消耗内存，会引起大量上下文切换，大幅度降低系统的响应性能）。</p><blockquote><p>使用场景：<br>多个线程更新相同资源导致数据竞争时使用 Serial Dispatch Queue</p></blockquote><img src="/2017/11/14/OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/serialdisque.png" class="&#x3D;"><h2 id="Concurrent-dispatch-queue"><a href="#Concurrent-dispatch-queue" class="headerlink" title="Concurrent dispatch queue"></a>Concurrent dispatch queue</h2><p>当想并行执行不发生数据竞争等问题处理时，使用<code>concurrent dispatch queue</code></p><blockquote><p>注意：<br>通过dispatch_queue_create的 dispatch_queue_t对象需要自己管理内存，dispatch_release</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg    YYWebImage</span></span><br><span class="line">+ (<span class="built_in">dispatch_queue_t</span>)setterQueue &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> queue;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        queue = dispatch_queue_create(<span class="string">&quot;com.ibireme.webimage.setter&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        dispatch_set_target_queue(queue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Global-Dispatch-Queue-4种优先级"><a href="#Global-Dispatch-Queue-4种优先级" class="headerlink" title="Global Dispatch Queue 4种优先级"></a>Global Dispatch Queue 4种优先级</h2><p><code>High &gt; Default &gt; Low &gt; Background</code></p><h2 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h2><p><code>dispatch_queue_create</code>函数生成的<code>Dispatch_queue</code>不管是<code>Serial</code>还是<code>concurrent</code>都使用与默认优先级<code>Global dispatch queue</code>相同执行优先级的线程。而变更生成的<code>dispatch queue</code>的执行优先级要使用<code>dispatch_set_target_queue</code>函数。</p><h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//e.g. </span></span><br><span class="line">dispatch_time_t time=dispatch_time(DISPATCH_TIME_NOW,<span class="number">3</span>ull* <span class="built_in">NSEC_PEC_SEC</span>);</span><br><span class="line">dispatch_after(time,dispatch_get_main_queue(),^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(@“waited at least three seconds.”);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>dispatch_after</code>并不是在指定时间后执行，而只是在指定时间追加处理到<code>Dispatch Queue</code>,上面代码与在3秒后用dispatch_async函数追加Block到main Dispatch Queue的相同。</p><blockquote><p>因为Main Dispatch Queue在线程的Runloop中执行，所以在比如每隔1&#x2F;60秒执行的Runloop中，Block最快在3秒后执行，最慢在3秒+1&#x2F;60秒后执行。</p></blockquote><p><code>DISPATCH_TIME_NOW</code> 表示现在的时间</p><h2 id="dispatch-group-wait-group-time"><a href="#dispatch-group-wait-group-time" class="headerlink" title="dispatch_group_wait(group,time);"></a>dispatch_group_wait(group,time);</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//e.g.</span></span><br><span class="line">dispatch_time_t time=dispatch_time(DISPATCH_TIME_NOW,<span class="number">1</span>null*<span class="built_in">NSEC_PEC_SEC</span>);</span><br><span class="line"><span class="type">long</span> result=dispatch_group_wait(group,time);</span><br><span class="line"><span class="keyword">if</span>(result==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//属于dispatch group的全部处理执行结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//属于Dispatch Group的某一个处理还在执行中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的等待会卡住当前线程，直到 指定的时间到了或者<code>dispatch group</code>的处理全部执行结束后。</p><h2 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h2><p>该函数同<code>dispatch_queue_create</code> 函数生成的 <code>Concurrent Dispatch Queue</code>一起使用。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span>  queue=dispatch_queue_create(“com.example.gcd.ForBarrier”,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue,blk0_for_reading);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue,blk1_for_reading);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue,blk2_for_reading);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue,blk3_for_reading);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue,blk4_for_reading);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue,blk_for_writing);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue,blk5_for_reading);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue,blk6_for_reading);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue,blk7_for_reading);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue,blk8_for_reading);</span><br><span class="line">dispatch_release(queue);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用concurrent dispatch queue和 dispatch_barrier_async函数可实现高效率的数据库访问和文件访问。</p><img src="/2017/11/14/OC%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/disbarrier.png" class="&#x3D;"><h2 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h2><p><code>Dispatch Semaphore</code>是持有计数的信号，该计数是多线程编程中的技术类型信号。技术为0时等待，计数为1或大于1时，减去1而不等待。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//创建一个信号量，初始值为1</span></span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line"><span class="comment">//这里会一直等待，直到信号量大于等于1，对改计数进行减法，并返回</span></span><br><span class="line">            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER) ;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            [array addObject:[<span class="built_in">NSNumber</span> numberWithInt:i]];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里增加一个信号量</span></span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>dispatch_semaphore_t 信号量本质上是一种锁</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
