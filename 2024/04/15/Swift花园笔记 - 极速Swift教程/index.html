<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="简单类型Playground是一个可以供你输入Swift代码并立即看到结果的沙盒环境">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift花园笔记 -  极速Swift教程">
<meta property="og:url" content="https://github.com/JackWchen2015/JackWchen2015.github.io.git/2024/04/15/Swift%E8%8A%B1%E5%9B%AD%E7%AC%94%E8%AE%B0%20-%20%E6%9E%81%E9%80%9FSwift%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="学计算机的那个">
<meta property="og:description" content="简单类型Playground是一个可以供你输入Swift代码并立即看到结果的沙盒环境">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-14T16:00:00.000Z">
<meta property="article:modified_time" content="2024-05-27T09:50:15.694Z">
<meta property="article:author" content="Jack Chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/JackWchen2015/JackWchen2015.github.io.git/2024/04/15/Swift%E8%8A%B1%E5%9B%AD%E7%AC%94%E8%AE%B0%20-%20%E6%9E%81%E9%80%9FSwift%E6%95%99%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Swift花园笔记 -  极速Swift教程 | 学计算机的那个</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">学计算机的那个</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">不是我觉到、悟到，你给不了我，给了也拿不住;只有我觉到、悟到，才有可能做到，能做到的才是我的.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/JackWchen2015/JackWchen2015.github.io.git/2024/04/15/Swift%E8%8A%B1%E5%9B%AD%E7%AC%94%E8%AE%B0%20-%20%E6%9E%81%E9%80%9FSwift%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学计算机的那个">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Swift花园笔记 -  极速Swift教程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-04-15T00:00:00+08:00">2024-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-27 17:50:15" itemprop="dateModified" datetime="2024-05-27T17:50:15+08:00">2024-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="简单类型"><a href="#简单类型" class="headerlink" title="简单类型"></a>简单类型</h1><p><code>Playground</code>是一个可以供你输入<code>Swift</code>代码并立即看到结果的沙盒环境</p>
<span id="more"></span>

<h2 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h2><p>表示多行的字符串，需要使用将双引号首尾的引号个数由一个改成三个，就像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 <span class="operator">=</span> <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">这个字符串</span></span><br><span class="line"><span class="string">跨越了</span></span><br><span class="line"><span class="string">多行</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>Swift</code>对于书写这些引号有着特别的规定：<br>开始的三个引号和结束的三个引号都必须独占一行，但它们占的那两行都不会算进最终的字符串里。<br>假如你只是想利用多行字符串来使代码看起来更整洁，你可以通过在每行的行尾添加一个<code>\</code>来确保换行不会进入最终的字符串， 就像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str2 <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这个字符串 <span class="subst">\</span></span></span><br><span class="line"><span class="subst"><span class="string"></span>看起来跨越了多行， <span class="subst">\</span></span></span><br><span class="line"><span class="subst"><span class="string"></span>实际上没有</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>当你通过一个分数创建一个变量时，Swift都会自动赋予这个变量<code>Double</code>类型。</p>
<p><code>var pi = 3.141</code></p>
<h2 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h2><p>这个特性允许你在字符串值里插入变量，从而动态地给一个<code>String</code>类型的变量赋值。在字符串内部，你可以放置任意类型，任意数量的变量。 要放置这些变量，你需要以一个反斜杠开始，即<code>\</code>，然后<code>跟上用圆括号包起来的变量名</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score <span class="operator">=</span> <span class="number">85</span> <span class="keyword">var</span> str <span class="operator">=</span> <span class="string">&quot;你的分数是<span class="subst">\(score)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组允许你通过一个值来存储几个值。</p>
<p>听起来跟数组很像，但元组有所不同：你不能往元组中添加或者删除元素 —— <strong>元组的长度是固定的</strong>。你不能改变元组中元素的类型 —— 元组创建时<strong>内部的元素类型必须是一致的</strong>。</p>
<h2 id="字典默认值"><a href="#字典默认值" class="headerlink" title="字典默认值"></a>字典默认值</h2><p>如果你试图通过一个不存在于字典中的键读取字典中的值时，Swift会返回给你一个<code>nil</code>，</p>
<p>当给定的键对应的值不存在时，我们可以指定一个默认的值返回给访问者。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteIceCream <span class="operator">=</span> [</span><br><span class="line">  <span class="string">&quot;小明&quot;</span>: <span class="string">&quot;巧克力&quot;</span>,</span><br><span class="line">  <span class="string">&quot;小红&quot;</span>: <span class="string">&quot;香草&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">favoriteIceCream[<span class="string">&quot;小华&quot;</span>, <span class="keyword">default</span>: <span class="string">&quot;未知&quot;</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当Swift没有从字典中找到小华最喜欢的冰淇淋时，我们得到的不再是一个nil，而是一个“未知”字符串。</p>
</blockquote>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举，通常简称<code>enums</code>，是一种定义一组高度关联的值的方式。它使得这组关联的值使用起来更方便。</p>
<p>有了枚举，我们可以定义一个叫做Result的类型，它既可以是success，也可以是failure，就像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> success</span><br><span class="line">  <span class="keyword">case</span> failure</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举关联值"><a href="#枚举关联值" class="headerlink" title="枚举关联值"></a>枚举关联值</h3><p>枚举还可以存储附属于每个<code>case</code>的关联值。这个特性使得你可以为枚举附加额外的数据，从而让它们传达更多细微的信息。</p>
<p>定义一个枚举，它存放了各种各样的活动类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> bored</span><br><span class="line">  <span class="keyword">case</span> running</span><br><span class="line">  <span class="keyword">case</span> talking</span><br><span class="line">  <span class="keyword">case</span> singing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的枚举类型存储的信息，可以让我们知道有人在讲话，但我们不知道讲话的内容，或者可以让我们知道有人在跑步，但我们不知道他们将跑去哪里。</p>
<p>通过枚举的关联值，我们添加额外的细节：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> bored</span><br><span class="line">  <span class="keyword">case</span> running(destination: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> talking(topic: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> singing(volume: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们有了更精确的信息。我们可以说某人正在谈论足球：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> talking <span class="operator">=</span> <span class="type">Activity</span>.talking(topic: <span class="string">&quot;football&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="枚举原始值"><a href="#枚举原始值" class="headerlink" title="枚举原始值"></a>枚举原始值</h3><p>给枚举赋予一些原始值从而让它们可以表达某种含义。这么做可以让你动态地创建枚举，并且以不一样的方式来使用它们。</p>
<p>创建一个名叫<code>Planet</code>的枚举，然后让它的每条case存储一个整数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Planet</span>: <span class="title class_">Int</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> mercury</span><br><span class="line">  <span class="keyword">case</span> venus</span><br><span class="line">  <span class="keyword">case</span> earth</span><br><span class="line">  <span class="keyword">case</span> mars</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift会为这些case自动分配一个数字，同样的，是从0开始。你可以利用这些数字创建枚举的case。举个例子，earth会被分配到数字2，于是你可以这么创建一个earth的case：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> earth <span class="operator">=</span> <span class="type">Planet</span>(rawValue: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h1 id="操作符与条件"><a href="#操作符与条件" class="headerlink" title="操作符与条件"></a>操作符与条件</h1><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>Swift只会运行某一个case里的代码。如果你希望继续执行下一个case的代码，你需要用到 fallthrough 关键字，就像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> weather &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;rain&quot;</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;记得带伞&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;snow&quot;</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;记得保暖&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;sunny&quot;</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;记得戴墨镜&quot;</span>)</span><br><span class="line">  <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;天气不错！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="范围操作符"><a href="#范围操作符" class="headerlink" title="范围操作符"></a>范围操作符</h2><p>Swift提供了两种方式给我们创建范围： 它们是<code>..&lt;</code>和 <code>...</code> 操作符。</p>
<p>半开放范围操作符 <code>..&lt;</code> ，创建的范围不包含右边的值。<br>而闭合范围操作符<code> ...</code> ，创建的范围包含右边的值。</p>
<p>范围 1..&lt;5 包含数字1，2，3和4， 而范围 1…5 包含数字1，2，3，4和5。</p>
<p>对于switch语句块来说，范围非常有用。因为你可以把它们用于你的每条case。举个例子，假设我们根据某人的考试成绩打印不同的消息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> score <span class="operator">=</span> <span class="number">85</span></span><br><span class="line"><span class="keyword">switch</span> score &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">50</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;你需要加把劲了。&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">50</span><span class="operator">..&lt;</span><span class="number">85</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;做的不错。&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;你真棒！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>最常见的循环是<code>for</code>循环：它在数组和范围上循环，<strong>每次拉出一个值然后把它赋予一个常量</strong>。</p>
<h2 id="退出多重循环"><a href="#退出多重循环" class="headerlink" title="退出多重循环"></a>退出多重循环</h2><p>用嵌套循环实现一个从 1 到 10 的乘法表：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> product <span class="operator">=</span> i <span class="operator">*</span> j</span><br><span class="line">    print (<span class="string">&quot;<span class="subst">\(i)</span> * <span class="subst">\(j)</span> 等于 <span class="subst">\(product)</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想退出循环，我们需要做两件事。首先，给外层循环加一个标签，像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">outerLoop: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> product <span class="operator">=</span> i <span class="operator">*</span> j</span><br><span class="line">    print (<span class="string">&quot;<span class="subst">\(i)</span> * <span class="subst">\(j)</span> 等于 <span class="subst">\(product)</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在内层循环里添加条件，在条件满足时用 <code>break outerLoop</code> 同时退出内外层循环：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">outerLoop: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> product <span class="operator">=</span> i <span class="operator">*</span> j</span><br><span class="line">    print (<span class="string">&quot;<span class="subst">\(i)</span> * <span class="subst">\(j)</span> 等于 <span class="subst">\(product)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> product <span class="operator">==</span> <span class="number">50</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;这是一个靶心。&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span> outerLoop</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只使用<code>break</code>，就只能退出内层循环，外层循环会继续运行。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>如果你需要返回多个值，可以使用元组作为返回值的类型。</p>
<h2 id="省略参数标签"><a href="#省略参数标签" class="headerlink" title="省略参数标签"></a>省略参数标签</h2><p>在使用 <code>print() </code>函数时并没有传入任何参数标签。我们会写作 <code>print(&quot;Hello&quot;)</code> ，而不是 <code>print(message: &quot;Hello&quot;)</code>。</p>
<p>通过使用下划线<code>_</code>作为外部参数标签，你可以在自己的函数里实现一样的效果，就像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="keyword">_</span> <span class="params">person</span>: <span class="type">String</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(person)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写的话，调用 <code>greet() </code>函数时，你就不必传入参数标签了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">greet(<span class="string">&quot;Taylor&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p><code>print() </code>函数打印文本到屏幕，并且不论你传什么内容给它，它都会在最后添加一个换行。所以多次调用 <code>print() </code>的话，那些文本是不会显示在同一行的。</p>
<p>你可以改变 <code>print() </code>函数的这个行为：你可以用其他符号，例如空格来取代换行。<code>print() </code>有一个叫 <code>terminator</code> 的参数，它的<strong>默认值是换行符</strong>。</p>
<p>通过在参数后面加上一个 <code>= </code>然后写上一个值，你可以为你自己的函数提供默认参数。 </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="keyword">_</span> <span class="params">person</span>: <span class="type">String</span>, <span class="params">nicely</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> nicely <span class="operator">==</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好， <span class="subst">\(person)</span>!&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;不是吧，又是 <span class="subst">\(person)</span>你小子。&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h2><p>有一些函数是 可变 的，可变是指函数可以接收任意多个同类型的参数。例如，<code>print()</code> 函数实际上就是可变的：如果你传入多个参数，它们会被以空格相连打印在同一行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Haters&quot;</span>, <span class="string">&quot;gonna&quot;</span>, <span class="string">&quot;hate&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>你可以通过在参数类型之后添加 <code>... </code>，将一个参数声明成可变参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">square</span>(<span class="params">numbers</span>: <span class="type">Int</span>...) &#123;</span><br><span class="line">  <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(number)</span> 的平方等于 <span class="subst">\(number <span class="operator">*</span> number)</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square(numbers: <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h2 id="书写会抛出错误的函数"><a href="#书写会抛出错误的函数" class="headerlink" title="书写会抛出错误的函数"></a>书写会抛出错误的函数</h2><p>Swift允许我们从函数中抛出错误。实现的方法是在返回值前写一个 <code>throws</code> ，然后在函数出错时使用 <code>throw</code> 关键字抛出错误。</p>
<p>需要定义一个 <code>enum</code> ，用于描述我们可能抛出的错误。这些错误必须基于Swift已经存在的 <code>Error</code> 类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">PasswordError</span>: <span class="title class_">Error</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> obvious</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们来实现一个函数 <code>checkPassword()</code>，这个函数检测传入的密码是否合理，当密码过于简单时，我们抛出一个错误提醒用户。具体来说，当密码被设置成 “password” 时，执行 <code>throw PasswordError.obvious</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">checkPassword</span>(<span class="keyword">_</span> <span class="params">password</span>: <span class="type">String</span>) <span class="keyword">throws</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> password <span class="operator">==</span> <span class="string">&quot;password&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">PasswordError</span>.obvious</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行可能会抛出错误的函数"><a href="#运行可能会抛出错误的函数" class="headerlink" title="运行可能会抛出错误的函数"></a>运行可能会抛出错误的函数</h2><p>Swift并不期望你在程序运行时遭遇错误，因此它不会让你直接运行可能抛出错误的函数。</p>
<p>需要用到三个关键字来运行会抛出错误的函数：<code>do </code>开启一段可能会遭遇问题的代码，<code>try</code> 放在每一个可能抛出错误的函数前面，最后的 <code>catch</code> 让你可以优雅地处理错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> checkPassword(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;这个密码很棒！&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;你不能用这个密码。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="inout-参数"><a href="#inout-参数" class="headerlink" title="inout 参数"></a>inout 参数</h2><p>所有传入Swift函数的参数默认都是 <strong>常量</strong>，所以你无法更改它们。假如你就是想要在函数内改变这些参数呢？可以用 <code>inout</code> 修饰它们，所有在函数内对它们做出的改变都会影响到它们在函数外的原始值。</p>
<p>想要让一个数翻倍。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">doubleInPlace</span>(<span class="params">number</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">  number <span class="operator">*=</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使用这个可以修改参数的函数，首先要求传入的参数本身不能是常量, 其次，在传入函数时，还要用一个 <code>&amp; </code>符号，放在参数名前面。它是参数以 inout 方式使用的显式标识。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myNum <span class="operator">=</span> <span class="number">10</span> </span><br><span class="line">doubleInPlace(number: <span class="operator">&amp;</span>myNum)</span><br></pre></td></tr></table></figure>

<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>Swift允许我们像字符串和整数一样使用函数。具体来说，你可以创建一个函数然后把它赋给一个变量，利用那个变量来调用函数。你甚至可以把函数作为参数传给另一个函数。</p>
<p>以打印信息为例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> driving <span class="operator">=</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;我要去开车&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码实际上创建了一个匿名的函数，并将这个函数赋给了 <code>driving</code>。之后你就可以把 <code>driving() </code>当作一个常规的函数来用，就像这样：</p>
<p><code>driving()</code></p>
<h2 id="在闭包中接收参数"><a href="#在闭包中接收参数" class="headerlink" title="在闭包中接收参数"></a>在闭包中接收参数</h2><p>为了让一个闭包接收参数，你需要在花括号之后把这些参数列出来，然后跟上一个 <code>in</code> 关键字。这样就告诉Swift，闭包的主体是从哪里开始的。</p>
<p>创建一个闭包，接收一个叫 place 的字符串作为唯一的参数，就像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> driving <span class="operator">=</span> &#123; (place: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;我要开车去 <span class="subst">\(place)</span>。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数和闭包的一个区别是运行闭包的时候你不会用到参数标签</strong>。因此，调用 <code>driving() </code>的时候，我们是这样写的：</p>
<p><code>driving(&quot;北京&quot;)</code></p>
<h2 id="从闭包中返回值"><a href="#从闭包中返回值" class="headerlink" title="从闭包中返回值"></a>从闭包中返回值</h2><p>闭包也能返回值，写法和闭包的参数类似：写在闭包内部，<code> in</code> 关键字前面。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drivingWithReturn <span class="operator">=</span> &#123; (place: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;我要开车去 <span class="subst">\(place)</span>。&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> message <span class="operator">=</span> drivingWithReturn(<span class="string">&quot;北京&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>

<h2 id="闭包作为参数"><a href="#闭包作为参数" class="headerlink" title="闭包作为参数"></a>闭包作为参数</h2><p>如果我们打算把这个闭包传入一个函数，以便函数内部可以运行这个闭包。我们需要把函数的参数类型指定为 <code>() -&gt; Void</code>。 它的意思是“不接收参数，并且返回 Void”。在Swift中，<code>Void</code>是什么也没有的意思。</p>
<p>写一个<code>travel()</code>函数，接收不同类型的 <code>traveling</code> 动作， 并且在动作前后分别打印信息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">travel</span>(<span class="params">action</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;我准备出发了。&quot;</span>)</span><br><span class="line">  action()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;我到达目的地了。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以用上 driving 闭包了，就像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">travel(action: driving)</span><br></pre></td></tr></table></figure>

<h2 id="拖尾闭包语法"><a href="#拖尾闭包语法" class="headerlink" title="拖尾闭包语法"></a>拖尾闭包语法</h2><p>如果一个函数的最后一个参数是闭包，Swift允许你采用一种被称为 “拖尾闭包语法” 的方式来调用这个闭包。你可以把闭包传入函数之后的花括号里，而不必像传入参数那样。</p>
<p> travel() 函数,它接收一个 action 闭包。闭包在两个 print() 调用之间执行:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">func</span> <span class="title function_">travel</span>(<span class="params">action</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;我准备出发了。&quot;</span>)</span><br><span class="line">  action()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;我到达目的地了。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 由于函数的最后一个参数是闭包，我们可以用拖尾闭包语法来调用 travel() 函数，就像这样：</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> travel() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;我正在开车。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 实际上，由于函数没有别的参数了，我们还可以将圆括号完全移除：</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> travel &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;我正在开车。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="可变方法"><a href="#可变方法" class="headerlink" title="可变方法"></a>可变方法</h2><p> 如果一个结构体拥有一个变量属性，但是这个结构体的实例是以常量的方式创建的，那么在实例中，这个变量属性是不能修改的。这是因为结构体本身已经是常量了，所以它的所有属性也是常量。</p>
<p> Swift无从得知你将以常量还是变量的方式使用结构体。所以安全起见，Swift的默认策略是：不允许你在方法里修改属性，除非你显式地要求这一点。</p>
<p> 当你想要改变属性值时,，需要在方法前使用 mutating 关键字，就像这样：</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">makeAnonymous</span>() &#123;</span><br><span class="line">    name <span class="operator">=</span> <span class="string">&quot;Anonymous&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 由于这个方法改变了属性值，所以Swift只会允许这个方法在变量型的 Person 实例上调用。</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Ed&quot;</span>)</span><br><span class="line">person.makeAnonymous()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>String 类型是一个结构体类型,数组同样也是结构体</p>
</blockquote>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p> 类和结构体的第一个区别是类没有逐一成员构造器。这意味着只要你的类里有属性，你就必须自行创建构造器。</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> breed: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">breed</span>: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    <span class="keyword">self</span>.breed <span class="operator">=</span> breed</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h2><p> 如果你有一个常量结构体，它有一个变量属性，那么这个变量属性是无法修改的。</p>
<p> 如果它是一个常量类，也有一个变量属性，那么这个变量属性是可以被修改的。类的方法在改变属性时，并不需要 <code>mutating</code> 关键字，而结构体则需要。</p>
<p> 这个区别意味着你可以修改类中的任何变量属性，即便类的实例本身被声明为常量。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Singer</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> name <span class="operator">=</span> <span class="string">&quot;Taylor Swift&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> taylor <span class="operator">=</span> <span class="type">Singer</span>()</span><br><span class="line">taylor.name <span class="operator">=</span> <span class="string">&quot;Ed Sheeran&quot;</span></span><br><span class="line"><span class="built_in">print</span>(taylor.name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 如果你不想属性被修改，那么你必须直接将属性声明为常量。</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Singer</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name <span class="operator">=</span> <span class="string">&quot;Taylor Swift&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>协议是一种描述某个类型必须有某些属性和方法的方式。你告知Swift某个类型将使用某个协议，这个过程称为协议适配或者协议遵循。</p>
<p>举个例子，我们可以写一个函数接收 <code>id</code> 属性，但我们并不精确地关心用的是哪一种数据类型。让我们从 <code>Identifiable</code> 协议开始，这个协议要求所有遵循协议的类型必须有一个 <code>id</code> 字符串属性，并且这个字符串可读写。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Identifiable</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们无法创建协议的实例，因为协议只是一种描述，它本身并非一种类型。</p>
<h2 id="协议继承"><a href="#协议继承" class="headerlink" title="协议继承"></a>协议继承</h2><p>一个协议可以继承另一个协议，这个过程称为协议继承。跟类不一样的是，你可<strong>以同一时间继承多个协议</strong>。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>扩展使得你可以为已经存在的类型添加方法，实现它们设计时没有做的事情。</p>
<p>举个例子，我们可以为 Int 类型添加一个扩展方法 squared()，用来返回当前数的平方。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">squared</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift不允许你通过扩展添加存储属性，但可以用扩展添加计算属性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> isEven: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">%</span> <span class="number">2</span> <span class="operator">==</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h2><p>协议可以描述某个类型应当有某种方法，但并没有提供方法的代码。扩展实现有具体代码的方法，但一次只能作用于一个数据类型，你没办法同时给多个类型添加相同的代码。</p>
<p>协议扩展同时解决了这两个问题：它们就像常规扩展一样，差异只在于你并不是只扩展一个特定的类型，比如 <code>Int</code>，你扩展是的一个协议，因而所有遵循这个协议的类型都会发生改变。</p>
<p>举个例子，下面有一个包含了一些名字的数组和一个同样包含了一些名字的集合：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pythons <span class="operator">=</span> [<span class="string">&quot;Eric&quot;</span>, <span class="string">&quot;Graham&quot;</span>, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Michael&quot;</span>, <span class="string">&quot;Terry&quot;</span>, <span class="string">&quot;Terry&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> beatles <span class="operator">=</span> <span class="type">Set</span>([<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Paul&quot;</span>, <span class="string">&quot;George&quot;</span>, <span class="string">&quot;Ringo&quot;</span>])</span><br></pre></td></tr></table></figure>
<p>Swift的数组和集合都遵循一个叫 <code>Collection</code> 的协议，因此我们可以给 <code>Collection</code> 协议扩展一个叫 <code>summarize()</code> 的方法，这个方法逐一打印<code>collection</code>里的元素。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">summarize</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;There are <span class="subst">\(count)</span> of us:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Array 和 Set 都将获得这个方法。让我们来尝试一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pythons.summarize()</span><br><span class="line">beatles.summarize()</span><br></pre></td></tr></table></figure>
<h2 id="面向协议编程"><a href="#面向协议编程" class="headerlink" title="面向协议编程"></a>面向协议编程</h2><p>协议扩展可以为我们自己的协议方法提供默认实现。这使得类型遵循协议变得更加容易，并且允许我们“面向协议编程”——这是一种<strong>利用协议和协议扩展来加工代码</strong>的方式。</p>
<p>这里有一个叫 <code>Identifiable</code> 的协议，它要求所有遵循协议的类型都有一个叫 <code>id</code> 的属性和叫一个叫 <code>identify()</code> 的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Identifiable</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">identify</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然我们可以让每个遵循这个协议的类型书写它们自己的 <code>identify()</code> 方法，但协议扩展允许我们可以提供一个默认实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Identifiable</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">identify</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My ID is <span class="subst">\(id)</span>.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在当我们再声明一个遵循 <code>Identifiable</code> 协议的类型时，它会自动获得<code> identify()</code> 方法的实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_">Identifiable</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> paul <span class="operator">=</span> <span class="type">User</span>(id: <span class="string">&quot;Paul&quot;</span>)</span><br><span class="line">paul.identify()</span><br></pre></td></tr></table></figure>

<h1 id="可选型"><a href="#可选型" class="headerlink" title="可选型"></a>可选型</h1><h2 id="解包可选型"><a href="#解包可选型" class="headerlink" title="解包可选型"></a>解包可选型</h2><p>if let 和 guard let 的主要区别在于 guard let 之后可选型还可以继续使用。</p>
<p>让我们尝试一下 <code>greet()</code> 函数。它将接收一个可选字符串作为唯一的参数，当它解包发现这个参数是<code>nil</code>时会打印消息并且退出函数。因为可选型 <code>unwrapped</code> 在 <code>guard let</code> 的语句块结束之后作用，我们可以在函数最后打印这个解包后的字符串。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="keyword">_</span> <span class="params">name</span>: <span class="type">String</span>?) &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> unwrapped <span class="operator">=</span> name <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You didn&#x27;t provide a name!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(unwrapped)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空合运算符"><a href="#空合运算符" class="headerlink" title="空合运算符"></a>空合运算符</h2><p>空合运算符解包一个可选型，如果可选型包含值则返回这个值，如果可选型不包含值，即可选型的值是 nil，那么返回某个默认值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">username</span>(<span class="params">for</span> <span class="params">id</span>: <span class="type">Int</span>) -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">  <span class="keyword">if</span> id <span class="operator">==</span> <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Taylor Swift&quot;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user <span class="operator">=</span> username(for: <span class="number">15</span>) <span class="operator">??</span> <span class="string">&quot;Anonymous&quot;</span></span><br></pre></td></tr></table></figure>
<p>它将检查 username() 函数返回的值：如果是一个字符串，它将被解包并放入 user，如果是 nil，则使用 “Anonymous” 替代。</p>
<h2 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h2><p>假如你试图访问形如 <code>a.b.c</code> 这样的代码并且 b 是可选型，你可以在 b 后面写一个问号来启用 可选链： <code>a.b?.c</code>。</p>
<p>当代码运行时，Swift会检查 b 是否有值，如果它是 nil，那么这行代码剩下的部分将被忽略。Swift会立即返回 nil。但是如果 b 有值，它将被解包，代码执行将继续。</p>
<h2 id="可选型-try"><a href="#可选型-try" class="headerlink" title="可选型 try"></a>可选型 try</h2><p>让我们回忆一下可能抛出错误的函数那一节的知识，看下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">PasswordError</span>: <span class="title class_">Error</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> obvious</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">checkPassword</span>(<span class="keyword">_</span> <span class="params">password</span>: <span class="type">String</span>) <span class="keyword">throws</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> password <span class="operator">==</span> <span class="string">&quot;password&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">PasswordError</span>.obvious</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> checkPassword(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;That password is good!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t use that password.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 try 写法其实有另外两种选择，这两种选项都能加深你对可选型和强制解包的理解。</p>
<p>第一个是 <code>try?</code>，它将可能抛出错误的函数转换成返回可选型的函数。如果函数抛出错误，那你就会得到 nil 作为函数的执行结果，否则你会得到将返回值包装之后的可选型。</p>
<p>尝试使用 try? 来执行 checkPassword()，像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">try?</span> checkPassword(<span class="string">&quot;password&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Result was <span class="subst">\(result)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;D&#x27;oh.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一种选择是 <code>try!</code>，当你确信函数一定不会失败时你可以采用它。如果函数实际抛出了错误，你的代码将崩溃。</p>
<p>使用 try! 来重写前面的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try!</span> checkPassword(<span class="string">&quot;sekrit&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;OK!&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="失败构造器"><a href="#失败构造器" class="headerlink" title="失败构造器"></a>失败构造器</h2><p>它是一种可能成功也可能失败的构造器。你在结构体或者类里面用<code>init?()</code>来实现失败构造器。如果某些东西出错，它将返回 <code>nil</code>。因此这种构造器返回的是某种类型的可选型，你用之前需要解包。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str <span class="operator">=</span> <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="keyword">let</span> num <span class="operator">=</span> <span class="type">Int</span>(str)</span><br></pre></td></tr></table></figure>

<p>举个例子，我们现在要求 Person 结构体必须通过一个9字符的ID字符串来构造。只要不是9个字符，都会返回 nil。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init?</span>(<span class="params">id</span>: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> id.count <span class="operator">==</span> <span class="number">9</span> &#123;</span><br><span class="line">      <span class="keyword">self</span>.id <span class="operator">=</span> id</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span>: <span class="title class_">Animal</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">makeNoise</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Woof!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pets <span class="operator">=</span> [<span class="type">Fish</span>(), <span class="type">Dog</span>(), <span class="type">Fish</span>(), <span class="type">Dog</span>()]</span><br></pre></td></tr></table></figure>
<p>Swift 知道 Fish 和 Dog 都继承自 Animal 类，因此它通过类型推断将 pets 创建为一个 Animal 类型的数组。</p>
<p>如果我们想遍历 pets 数组，让所有的狗发出叫声，我们需要执行一次类型转换：Swift将检查每个pet是否 Dog 对象，以便我们调用 makeNoise() 方法。</p>
<p>这里用到了一个关键字 as?，它将返回一个可选型：类型转换失败时返回 nil，成功则返回转换后的类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> pet <span class="keyword">in</span> pets &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> dog <span class="operator">=</span> pet <span class="keyword">as?</span> <span class="type">Dog</span> &#123;</span><br><span class="line">    dog.makeNoise()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1175164920580198400">Swift花园</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/03/03/Building%20a%20Custom%20Combine%20Operator%20for%20Exponential%20Backoff%5B%E8%AF%91%5D/" rel="prev" title="Building a Custom Combine Operator for Exponential Backoff[译]">
      <i class="fa fa-chevron-left"></i> Building a Custom Combine Operator for Exponential Backoff[译]
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/04/17/Swift%E8%8A%B1%E5%9B%AD%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="next" title="Swift花园之设计模式 上">
      Swift花园之设计模式 上 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">简单类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.1.</span> <span class="nav-text">多行字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC"><span class="nav-number">1.2.</span> <span class="nav-text">字符串插值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">复合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E7%BB%84"><span class="nav-number">2.1.</span> <span class="nav-text">元组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">2.2.</span> <span class="nav-text">字典默认值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">2.3.</span> <span class="nav-text">枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E5%85%B3%E8%81%94%E5%80%BC"><span class="nav-number">2.3.1.</span> <span class="nav-text">枚举关联值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E5%8E%9F%E5%A7%8B%E5%80%BC"><span class="nav-number">2.3.2.</span> <span class="nav-text">枚举原始值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E6%9D%A1%E4%BB%B6"><span class="nav-number">3.</span> <span class="nav-text">操作符与条件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.1.</span> <span class="nav-text">switch语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.2.</span> <span class="nav-text">范围操作符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.</span> <span class="nav-text">循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%80%E5%87%BA%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.1.</span> <span class="nav-text">退出多重循环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9C%81%E7%95%A5%E5%8F%82%E6%95%B0%E6%A0%87%E7%AD%BE"><span class="nav-number">5.1.</span> <span class="nav-text">省略参数标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">默认参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">可变函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%A6%E5%86%99%E4%BC%9A%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.</span> <span class="nav-text">书写会抛出错误的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">5.5.</span> <span class="nav-text">运行可能会抛出错误的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inout-%E5%8F%82%E6%95%B0"><span class="nav-number">5.6.</span> <span class="nav-text">inout 参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">6.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E9%97%AD%E5%8C%85%E4%B8%AD%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0"><span class="nav-number">6.1.</span> <span class="nav-text">在闭包中接收参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E9%97%AD%E5%8C%85%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">6.2.</span> <span class="nav-text">从闭包中返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="nav-number">6.3.</span> <span class="nav-text">闭包作为参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%96%E5%B0%BE%E9%97%AD%E5%8C%85%E8%AF%AD%E6%B3%95"><span class="nav-number">6.4.</span> <span class="nav-text">拖尾闭包语法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">7.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E6%96%B9%E6%B3%95"><span class="nav-number">7.1.</span> <span class="nav-text">可变方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">8.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="nav-number">8.1.</span> <span class="nav-text">可变性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE"><span class="nav-number">9.</span> <span class="nav-text">协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E7%BB%A7%E6%89%BF"><span class="nav-number">9.1.</span> <span class="nav-text">协议继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95"><span class="nav-number">9.2.</span> <span class="nav-text">扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E6%89%A9%E5%B1%95"><span class="nav-number">9.3.</span> <span class="nav-text">协议扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B"><span class="nav-number">9.4.</span> <span class="nav-text">面向协议编程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E5%9E%8B"><span class="nav-number">10.</span> <span class="nav-text">可选型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%8C%85%E5%8F%AF%E9%80%89%E5%9E%8B"><span class="nav-number">10.1.</span> <span class="nav-text">解包可选型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">10.2.</span> <span class="nav-text">空合运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E9%93%BE"><span class="nav-number">10.3.</span> <span class="nav-text">可选链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E5%9E%8B-try"><span class="nav-number">10.4.</span> <span class="nav-text">可选型 try</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%B1%E8%B4%A5%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">10.5.</span> <span class="nav-text">失败构造器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">10.6.</span> <span class="nav-text">类型转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">11.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jack Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">175</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jack Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
